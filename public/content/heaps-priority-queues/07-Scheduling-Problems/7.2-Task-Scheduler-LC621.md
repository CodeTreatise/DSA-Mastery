# 7.2 Task Scheduler (LC 621)

## Problem Statement

Given a characters array `tasks` representing tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.

However, there is a non-negative integer `n` that represents the cooldown period between two same tasks (same letter). There must be at least `n` units of time between any two same tasks.

Return the least number of units of time the CPU will take to finish all the given tasks.

```
Example 1:
Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation: A -> B -> idle -> A -> B -> idle -> A -> B

Example 2:
Input: tasks = ["A","A","A","B","B","B"], n = 0
Output: 6
Explanation: Any permutation works (no cooldown)

Example 3:
Input: tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
Output: 16
Explanation: A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A
```

**Constraints:**
- 1 ‚â§ tasks.length ‚â§ 10‚Å¥
- tasks[i] is uppercase English letter
- 0 ‚â§ n ‚â§ 100

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Problem Type</strong></summary>

**Key signals:**
- "Cooldown period between same items"
- "Minimum time to complete all"
- "Schedule with constraints"
- "Idle time when forced to wait"

**Pattern:** Greedy + Max-Heap (or Math formula)

**Why greedy works:**
- Always process most frequent task first
- This minimizes idle gaps
- Less frequent tasks fill cooldown gaps

</details>

---

## ‚úÖ When to Use This Approach

- Tasks with cooldown constraints
- Need to minimize total time (including idle)
- Greedy choice: most frequent task first

## ‚ùå When NOT to Use

| Scenario | Alternative |
|----------|-------------|
| No cooldown (n=0) | Just return len(tasks) |
| Dependencies between tasks | Topological sort |
| Exact schedule needed | Simulation with tracking |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this:**
- [Heap Fundamentals](../01-Heap-Fundamentals/1.1-What-Is-Heap.md)
- [Priority Queue](../03-Priority-Queue/3.1-PQ-Basics.md)
- Greedy algorithm basics

**Related problems:**
- [Reorganize String (LC 767)](./7.4-Reorganize-String-LC767.md) - Similar greedy + heap
- [Distant Barcodes (LC 1054)](https://leetcode.com/problems/distant-barcodes/)

</details>

---

## üìê Solution Approaches

### Approach 1: Math Formula (Optimal)

**Intuition:**
The answer is determined by the most frequent task(s).

```
tasks = [A,A,A,B,B,B], n = 2

Layout with A (most frequent, count=3):
A _ _ A _ _ A
  ‚Üë ‚Üë   ‚Üë ‚Üë
  cooldown slots

Slots between A's: (count_A - 1) * (n + 1) = 2 * 3 = 6
Plus final A: 6 + 1 = 7

But B also has count 3, so:
A B _ A B _ A B  ‚Üí  length = 8

Formula: (max_count - 1) * (n + 1) + num_tasks_with_max_count
         But at least len(tasks) if no idle needed!
```

**Python:**
```python
from collections import Counter

def leastInterval(tasks: list[str], n: int) -> int:
    """
    Math formula approach.
    Time: O(n), Space: O(1) - at most 26 unique tasks
    """
    count = Counter(tasks)
    max_count = max(count.values())
    
    # How many tasks have the maximum count?
    num_max = sum(1 for c in count.values() if c == max_count)
    
    # Formula: (max_count - 1) gaps, each of size (n + 1), plus final batch
    result = (max_count - 1) * (n + 1) + num_max
    
    # At minimum, we need len(tasks) time (when no idle needed)
    return max(result, len(tasks))
```

**JavaScript:**
```javascript
function leastInterval(tasks, n) {
    const count = new Map();
    for (const task of tasks) {
        count.set(task, (count.get(task) || 0) + 1);
    }
    
    const maxCount = Math.max(...count.values());
    let numMax = 0;
    for (const c of count.values()) {
        if (c === maxCount) numMax++;
    }
    
    const result = (maxCount - 1) * (n + 1) + numMax;
    return Math.max(result, tasks.length);
}
```

### Approach 2: Max-Heap Simulation

**When to use:** When you need the actual schedule (not just time).

**Python:**
```python
import heapq
from collections import Counter, deque

def leastInterval_heap(tasks: list[str], n: int) -> int:
    """
    Max-heap simulation approach.
    Time: O(n * m) where m = number of unique tasks
    Space: O(m)
    """
    count = Counter(tasks)
    # Max-heap of remaining counts
    max_heap = [-c for c in count.values()]
    heapq.heapify(max_heap)
    
    time = 0
    # Queue of (available_time, remaining_count)
    cooling = deque()
    
    while max_heap or cooling:
        time += 1
        
        if max_heap:
            remaining = -heapq.heappop(max_heap) - 1
            if remaining > 0:
                cooling.append((time + n, remaining))
        
        # Check if any task finished cooling
        if cooling and cooling[0][0] == time:
            _, count = cooling.popleft()
            heapq.heappush(max_heap, -count)
    
    return time
```

**JavaScript:**
```javascript
function leastIntervalHeap(tasks, n) {
    const count = new Map();
    for (const task of tasks) {
        count.set(task, (count.get(task) || 0) + 1);
    }
    
    // Max-heap (use negative values)
    const heap = [];
    for (const c of count.values()) {
        heap.push(-c);
    }
    heap.sort((a, b) => a - b);  // Min-heap of negatives = max-heap
    
    let time = 0;
    const cooling = [];  // [available_time, remaining_count]
    
    while (heap.length > 0 || cooling.length > 0) {
        time++;
        
        if (heap.length > 0) {
            // Sort to maintain heap property (simulating heappop)
            heap.sort((a, b) => a - b);
            const remaining = -heap.shift() - 1;
            if (remaining > 0) {
                cooling.push([time + n, remaining]);
            }
        }
        
        // Check cooling queue
        if (cooling.length > 0 && cooling[0][0] === time) {
            const [, cnt] = cooling.shift();
            heap.push(-cnt);
        }
    }
    
    return time;
}
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Math Formula |" O(n) "| O(1) | Best, constant 26 chars |
| Heap Simulation |" O(n * 26) "| O(26) | Needed for actual schedule |

**Why O(n) for math:**
- Count frequencies: O(n)
- Find max: O(26) = O(1)
- Calculate formula: O(1)

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Get actual schedule | Need simulation, not just time | Modified LC 621 |
| K different tasks between same | More complex cooldown | Distant Barcodes |
| With deadlines | Constraint satisfaction | Course Schedule III |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting the max() with len(tasks)

```python
# ‚ùå Wrong: May return less than tasks length
return (max_count - 1) * (n + 1) + num_max

# ‚úÖ Correct: At minimum, need len(tasks)
return max((max_count - 1) * (n + 1) + num_max, len(tasks))
```

**Example:** tasks = ["A","B","C","D"], n = 2
- Formula gives: (1-1) * 3 + 4 = 4
- Correct answer: 4 (no idle needed)
- But if formula gave 2, we'd need max(2, 4) = 4

### 2. Wrong Cooling Queue Check

```python
# ‚ùå Wrong: Checking <=, might add back too early
if cooling and cooling[0][0] <= time:

# ‚úÖ Correct: Exactly when cooldown expires
if cooling and cooling[0][0] == time:
```

### 3. Misunderstanding Cooldown

```
n = 2 means 2 units BETWEEN same tasks, not including the task itself

A _ _ A  ‚Üê 2 gaps between A's, total 4 time units for 2 A's
  1 2
```

---

## üìù Practice Problems

### This Problem
- [ ] [Task Scheduler (LC 621)](https://leetcode.com/problems/task-scheduler/) ‚≠ê

### Similar Problems
- [ ] [Reorganize String (LC 767)](https://leetcode.com/problems/reorganize-string/)
- [ ] [Distant Barcodes (LC 1054)](https://leetcode.com/problems/distant-barcodes/)
- [ ] [Task Scheduler II (LC 2365)](https://leetcode.com/problems/task-scheduler-ii/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve with both approaches
- **Day 3:** Explain the math formula intuitively
- **Day 7:** Solve Reorganize String
- **Day 14:** Solve without looking at notes

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This Solution</strong></summary>

**Opening:**
"I see this is a scheduling problem with cooldowns. My greedy intuition is to always process the most frequent task to minimize idle time."

**Approach discussion:**
"I can solve this two ways:
1. **Math formula** - O(1) space, just calculates total time
2. **Heap simulation** - Actually builds the schedule

For just the time, the math approach is elegant..."

**Walk through formula:**
"The most frequent task determines the structure. If 'A' appears 3 times with n=2:
- I have 2 gaps between A's, each of size 3 (n+1)
- So 2 * 3 = 6, plus the final A = 7
- But if B also appears 3 times, the final batch has 2 tasks"

**Edge case:**
"If I have more tasks than idle slots, I don't need idle time at all, so I return max(formula, len(tasks))."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Real-world relevance |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Common |
| Google | ‚≠ê‚≠ê‚≠ê | Sometimes with variations |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand problem | 3-5 min |
| Math solution | 10-15 min |
| Heap simulation | 15-20 min |
| Edge cases | 5 min |

---

## üí° Key Insight

> **The most frequent task creates the "frame" of the schedule.** Everything else fills in the gaps. If there are more tasks than gap slots, no idle time is needed. The formula `(max_count - 1) * (n + 1) + num_max` captures this structure perfectly.

---

## üîó Related

- **Previous:** [Scheduling Overview](./7.1-Task-Scheduler-Overview.md)
- **Next:** [Meeting Rooms II](./7.3-Meeting-Rooms-II-LC253.md)
- **Similar:** [Reorganize String](./7.4-Reorganize-String-LC767.md)
