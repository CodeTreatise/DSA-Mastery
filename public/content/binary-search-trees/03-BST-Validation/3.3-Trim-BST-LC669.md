# 3.3 Trim a Binary Search Tree (LC 669)

## Problem Statement

[LeetCode 669 - Trim a Binary Search Tree](https://leetcode.com/problems/trim-a-binary-search-tree/)

Given the root of a BST and bounds `[low, high]`, trim the tree so that all values are within the range. Return the root of the trimmed BST.

```
Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3
        3
       / \
      0   4
       \
        2
       /
      1

Output: [3,2,null,1]
      3
     /
    2
   /
  1

Nodes 0 and 4 are outside [1,3], so they're removed.
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a Range-Based BST Modification problem:**
- Use BST property to prune subtrees
- If node < low ‚Üí entire left subtree is also < low
- If node > high ‚Üí entire right subtree is also > high

**Keywords:**
- "trim", "prune" BST
- "within range", "bounds"
- "remove nodes outside"

**Pattern:** Range-guided pruning with BST property.

</details>

---

## ‚úÖ When to Use

- Filtering BST by value range
- Removing nodes outside bounds
- Conditional subtree removal

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| General tree | No BST property to exploit | Full traversal |
| Need to keep structure | Trim changes structure | Different operation |
| Count only | Trim is overkill | Range count |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Validate BST (LC 98)](./3.1-Validate-BST-LC98.md) - Range concept
- [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
- [BST Delete](../02-BST-Operations/2.3-BST-Delete-LC450.md) - Node removal

**After mastering this:**
- [Range Sum BST](../05-BST-Range-Problems/5.2-Range-Sum-BST-LC938.md)
- Complex tree modifications

**Combines with:**
- Range DFS technique
- Recursive tree transformation

</details>

---

## üìê How It Works

### The Key Insight: BST Pruning

```
If current node value < low:
  - Current node must be removed
  - Entire LEFT subtree has values < current < low ‚Üí remove all
  - RIGHT subtree might have valid values ‚Üí trim and return

If current node value > high:
  - Current node must be removed
  - Entire RIGHT subtree has values > current > high ‚Üí remove all
  - LEFT subtree might have valid values ‚Üí trim and return

If low <= current <= high:
  - Keep current node
  - Trim both subtrees recursively
```

### Visualization

```
Trim [3,0,4,null,2,null,null,1] with range [1, 3]:

Step 1: At node 3 (in range [1,3]) ‚Üí Keep
        Trim left subtree (0) and right subtree (4)

Step 2: At node 0 (< 1, below range)
        Discard 0, but its right subtree (2) might be valid
        Return trimBST(0.right)

Step 3: At node 4 (> 3, above range)
        Discard 4, return trimBST(4.left) = null

Step 4: At node 2 (in range) ‚Üí Keep
        Trim left (1) and right (null)

Step 5: At node 1 (in range) ‚Üí Keep

Result:
      3
     /
    2
   /
  1
```

---

## üíª Code Implementation

### Recursive (Clean and Elegant)

**Python:**
```python
def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
    """
    Trim BST to only include values in [low, high].
    
    Time: O(n) - might visit all nodes
    Space: O(h) - recursion stack
    
    Key insight: Use BST property to prune entire subtrees.
    """
    if not root:
        return None
    
    # If current value is too small, entire left subtree is invalid
    # Only right subtree might have valid values
    if root.val < low:
        return self.trimBST(root.right, low, high)
    
    # If current value is too large, entire right subtree is invalid
    # Only left subtree might have valid values
    if root.val > high:
        return self.trimBST(root.left, low, high)
    
    # Current value is in range, trim both subtrees
    root.left = self.trimBST(root.left, low, high)
    root.right = self.trimBST(root.right, low, high)
    
    return root
```

**JavaScript:**
```javascript
var trimBST = function(root, low, high) {
    // Trim BST to [low, high] range
    if (!root) return null;
    
    // Value too small ‚Üí skip to right subtree
    if (root.val < low) {
        return trimBST(root.right, low, high);
    }
    
    // Value too large ‚Üí skip to left subtree
    if (root.val > high) {
        return trimBST(root.left, low, high);
    }
    
    // Value in range ‚Üí keep node, trim children
    root.left = trimBST(root.left, low, high);
    root.right = trimBST(root.right, low, high);
    
    return root;
};
```

### Iterative (More Complex)

**Python:**
```python
def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
    """
    Iterative trimming - O(1) extra space (not counting output).
    
    Step 1: Find new root (first node in range)
    Step 2: Trim left subtree
    Step 3: Trim right subtree
    """
    # Step 1: Find root in valid range
    while root and (root.val < low or root.val > high):
        if root.val < low:
            root = root.right
        else:
            root = root.left
    
    if not root:
        return None
    
    # Step 2: Trim nodes < low from left subtree
    node = root
    while node.left:
        if node.left.val < low:
            node.left = node.left.right  # Skip left child
        else:
            node = node.left
    
    # Step 3: Trim nodes > high from right subtree
    node = root
    while node.right:
        if node.right.val > high:
            node.right = node.right.left  # Skip right child
        else:
            node = node.right
    
    return root
```

**JavaScript:**
```javascript
var trimBST = function(root, low, high) {
    // Find new root
    while (root && (root.val < low || root.val > high)) {
        root = root.val < low ? root.right : root.left;
    }
    
    if (!root) return null;
    
    // Trim left side
    let node = root;
    while (node.left) {
        if (node.left.val < low) {
            node.left = node.left.right;
        } else {
            node = node.left;
        }
    }
    
    // Trim right side
    node = root;
    while (node.right) {
        if (node.right.val > high) {
            node.right = node.right.left;
        } else {
            node = node.right;
        }
    }
    
    return root;
};
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Recursive |" O(n) "| O(h) | Clean, preferred |
| Iterative |" O(n) "| O(1) | More complex |

**Why O(n) time:**
- In worst case, we visit all nodes
- Each node is processed at most once

**Why O(h) space recursive:**
- Recursion depth equals tree height
- O(log n) balanced, O(n) skewed

---

## üîÑ Variations

| Variation | Modification | Use Case |
|-----------|--------------|----------|
| **Trim and count** | Return count of removed | Statistics |
| **Trim with callback** | Call function on removed | Logging |
| **Inclusive vs exclusive** | `<=` vs `<` | Problem-specific |
| **Single bound** | Only low or only high | Simpler case |

### Single Bound Trim (Only Remove Below Threshold)

```python
def trimBelow(root: TreeNode, threshold: int) -> TreeNode:
    """Remove all nodes with value < threshold."""
    if not root:
        return None
    
    if root.val < threshold:
        return trimBelow(root.right, threshold)
    
    root.left = trimBelow(root.left, threshold)
    return root
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Return the Result

```python
# ‚ùå Wrong: Not returning when skipping node
if root.val < low:
    self.trimBST(root.right, low, high)  # Lost return!

# ‚úÖ Correct: Return the trimmed subtree
if root.val < low:
    return self.trimBST(root.right, low, high)
```

### 2. Not Updating Children

```python
# ‚ùå Wrong: Not reassigning children
if low <= root.val <= high:
    self.trimBST(root.left, low, high)  # Left child not updated!
    self.trimBST(root.right, low, high)
    return root

# ‚úÖ Correct: Reassign trimmed children
if low <= root.val <= high:
    root.left = self.trimBST(root.left, low, high)
    root.right = self.trimBST(root.right, low, high)
    return root
```

### 3. Confusing Inclusive/Exclusive Bounds

```python
# ‚ùå Wrong if bounds are inclusive
if root.val < low:  # Should be root.val <= low for exclusive

# ‚úÖ Correct for inclusive bounds [low, high]
if root.val < low:
    return self.trimBST(root.right, low, high)
if root.val > high:
    return self.trimBST(root.left, low, high)
```

---

## üìù Practice Problems (Progressive)

### Easy (Build up)
- [ ] [Range Sum of BST (LC 938)](https://leetcode.com/problems/range-sum-of-bst/) - Range without modification
- [ ] [Search in BST (LC 700)](https://leetcode.com/problems/search-in-a-binary-search-tree/) - BST navigation

### Medium (Apply pattern)
- [ ] [Trim BST (LC 669)](https://leetcode.com/problems/trim-a-binary-search-tree/) - This problem
- [ ] [Delete Node in BST (LC 450)](https://leetcode.com/problems/delete-node-in-a-bst/) - Related modification

### Hard (Master)
- [ ] [Remove BST keys outside range](https://www.geeksforgeeks.org/remove-bst-keys-outside-the-given-range/) - Similar
- [ ] Complex tree modifications

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand the pruning logic
- **Day 3:** Implement recursive solution
- **Day 7:** Trace through example by hand
- **Day 14:** Implement iterative version
- **Day 30:** Apply to similar range problems

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"I'll use the BST property to prune efficiently. If a node is below the range, its entire left subtree is also below, so I can skip to the right subtree. Similarly for nodes above the range. For nodes in range, I keep them and recursively trim both subtrees."

**Key points:**
1. "BST property allows skipping entire subtrees"
2. "The trick is returning the trimmed subtree to reconnect"
3. "Time is O(n), space is O(h) for recursion"

**Edge cases to mention:**
- Empty tree
- All nodes outside range
- Root outside range

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê | Tree modification |
| Google | ‚≠ê‚≠ê‚≠ê | Clean recursion |
| Microsoft | ‚≠ê‚≠ê | BST operations |
| Meta | ‚≠ê‚≠ê | Less common |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 3-4 min | Clear specification |
| Code recursive | 8-10 min | Clean solution |
| Code iterative | 15-18 min | More edge cases |
| Trace example | 3-4 min | Walk through |
| Total interview time | 18-25 min | Medium difficulty |

---

## üí° Key Insight

> **The BST property turns range filtering from O(n) checking into O(n) pruning with O(log n) best case.** We don't just skip individual nodes ‚Äî we skip entire subtrees because we know all their values are on one side of the boundary.

---

## üîó Related

- **Previous:** [Recover BST (LC 99)](./3.2-Recover-BST-LC99.md)
- **Similar:** [Range Sum BST (LC 938)](../05-BST-Range-Problems/5.2-Range-Sum-BST-LC938.md)
- **Related:** [BST Delete (LC 450)](../02-BST-Operations/2.3-BST-Delete-LC450.md)
- **Concept:** [Validate BST](./3.1-Validate-BST-LC98.md) - Range logic
