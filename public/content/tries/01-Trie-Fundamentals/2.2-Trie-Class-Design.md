# Trie Class Design

> **A complete Trie class combines the TrieNode structure with Insert, Search, StartsWith, and optionally Delete operations into a cohesive data structure.**

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Build a Complete Trie Class</strong></summary>

**You need a full Trie class when:**
- Problem requires multiple operations (insert + search)
- Building autocomplete or dictionary system
- Need to store and query string collections
- Any "Implement Trie" problem

**Design choices to make:**
- HashMap vs Array for children
- What metadata to track
- Which operations to support

</details>

---

## ‚úÖ When to Use Each Design

| Problem Type | Recommended Design |
|--------------|-------------------|
| **Basic Trie (LC 208)** | Minimal: HashMap, is_end only |
| **Add/Search Words (LC 211)** | HashMap + is_end (for wildcards) |
| **Word Search II (LC 212)** | Extended: word storage + prefix_count |
| **Autocomplete** | Extended: suggestions + ranking |

---

## ‚ùå Design Anti-Patterns

| Anti-Pattern | Problem | Solution |
|--------------|---------|----------|
| **Monolithic class** | Hard to test/extend | Separate TrieNode |
| **No helper methods** | Duplicated traversal code | Add _traverse() |
| **Mutable global state** | Thread-unsafe | Proper encapsulation |
| **Over-engineering** | Too complex for need | Start minimal |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Trie](./1.1-What-Is-Trie.md) - Concept
- [TrieNode Structure](./2.1-TrieNode-Structure.md) - Node design
- All operations: [Insert](../02-Trie-Operations/3.1-Insert-Operation.md), [Search](../02-Trie-Operations/3.2-Search-Operation.md), [StartsWith](../02-Trie-Operations/3.3-StartsWith-Prefix.md)

**After mastering this:**
- [Wildcard Search](../03-Trie-Patterns/4.1-Wildcard-Search.md) - Pattern matching
- [Trie + Backtracking](../03-Trie-Patterns/4.2-Trie-Plus-Backtracking.md) - Grid search

**Full class enables:**
- Any Trie-based problem
- System design interviews
- Building real autocomplete

</details>

---

## üìê Design Overview

### Class Structure

```
Trie
‚îú‚îÄ‚îÄ root: TrieNode
‚îú‚îÄ‚îÄ insert(word)      ‚îÄ‚îÄ Core operations
‚îú‚îÄ‚îÄ search(word)
‚îú‚îÄ‚îÄ startsWith(prefix)
‚îú‚îÄ‚îÄ delete(word)      ‚îÄ‚îÄ Optional
‚îÇ
‚îú‚îÄ‚îÄ _traverse(s)      ‚îÄ‚îÄ Helper methods
‚îú‚îÄ‚îÄ _collect_words()
‚îÇ
‚îî‚îÄ‚îÄ get_words_with_prefix()  ‚îÄ‚îÄ Extended operations
    get_all_words()
    count_words()
```

---

## üíª Complete Implementations

### Implementation 1: Minimal (Interview Standard)

This is the standard implementation for LC 208 and most interviews:

**Python:**
```python
class TrieNode:
    """Minimal node with HashMap children."""
    def __init__(self):
        self.children = {}  # char -> TrieNode
        self.is_end = False


class Trie:
    """
    Standard Trie implementation.
    
    Operations:
    - insert(word): O(m) time, O(m) space
    - search(word): O(m) time, O(1) space  
    - startsWith(prefix): O(m) time, O(1) space
    
    Where m = length of word/prefix
    """
    
    def __init__(self):
        """Initialize empty trie with root node."""
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        """Insert word into trie."""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def search(self, word: str) -> bool:
        """Check if exact word exists in trie."""
        node = self._traverse(word)
        return node is not None and node.is_end
    
    def startsWith(self, prefix: str) -> bool:
        """Check if any word starts with prefix."""
        return self._traverse(prefix) is not None
    
    def _traverse(self, s: str) -> TrieNode:
        """
        Navigate trie following string s.
        Returns final node or None if path doesn't exist.
        """
        node = self.root
        for char in s:
            if char not in node.children:
                return None
            node = node.children[char]
        return node


# Usage:
# trie = Trie()
# trie.insert("apple")
# trie.search("apple")    # True
# trie.search("app")      # False
# trie.startsWith("app")  # True
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = new Map();
        this.isEnd = false;
    }
}

class Trie {
    constructor() {
        this.root = new TrieNode();
    }
    
    insert(word) {
        let node = this.root;
        for (const char of word) {
            if (!node.children.has(char)) {
                node.children.set(char, new TrieNode());
            }
            node = node.children.get(char);
        }
        node.isEnd = true;
    }
    
    search(word) {
        const node = this._traverse(word);
        return node !== null && node.isEnd;
    }
    
    startsWith(prefix) {
        return this._traverse(prefix) !== null;
    }
    
    _traverse(s) {
        let node = this.root;
        for (const char of s) {
            if (!node.children.has(char)) {
                return null;
            }
            node = node.children.get(char);
        }
        return node;
    }
}
```

---

### Implementation 2: Array-Optimized (Lowercase Only)

For problems that specify lowercase English letters:

**Python:**
```python
class TrieNode:
    """Array-based node for lowercase letters only."""
    def __init__(self):
        self.children = [None] * 26
        self.is_end = False


class Trie:
    """Optimized Trie for lowercase English letters."""
    
    def __init__(self):
        self.root = TrieNode()
    
    def _char_index(self, char: str) -> int:
        """Convert character to array index (0-25)."""
        return ord(char) - ord('a')
    
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            index = self._char_index(char)
            if node.children[index] is None:
                node.children[index] = TrieNode()
            node = node.children[index]
        node.is_end = True
    
    def search(self, word: str) -> bool:
        node = self._traverse(word)
        return node is not None and node.is_end
    
    def startsWith(self, prefix: str) -> bool:
        return self._traverse(prefix) is not None
    
    def _traverse(self, s: str) -> TrieNode:
        node = self.root
        for char in s:
            index = self._char_index(char)
            if node.children[index] is None:
                return None
            node = node.children[index]
        return node
```

---

### Implementation 3: Extended (Full Features)

For complex problems requiring word storage, counts, and delete:

**Python:**
```python
class TrieNode:
    """Extended node with full metadata."""
    def __init__(self):
        self.children = {}
        self.is_end = False
        self.word = None        # Store complete word
        self.end_count = 0      # Times word inserted (duplicates)
        self.prefix_count = 0   # Words passing through


class Trie:
    """
    Full-featured Trie with extended operations.
    
    Additional features:
    - Duplicate word handling
    - Word storage (for Word Search II)
    - Prefix counting
    - Delete support
    - Get all words with prefix
    """
    
    def __init__(self):
        self.root = TrieNode()
        self.word_count = 0
    
    def insert(self, word: str) -> None:
        """Insert word with metadata tracking."""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
            node.prefix_count += 1
        
        node.is_end = True
        node.end_count += 1
        node.word = word
        self.word_count += 1
    
    def search(self, word: str) -> bool:
        """Check if exact word exists."""
        node = self._traverse(word)
        return node is not None and node.is_end
    
    def startsWith(self, prefix: str) -> bool:
        """Check if any word starts with prefix."""
        return self._traverse(prefix) is not None
    
    def delete(self, word: str) -> bool:
        """Delete word from trie."""
        node = self._traverse(word)
        if node is None or node.end_count == 0:
            return False
        
        # Decrement counts
        node.end_count -= 1
        if node.end_count == 0:
            node.is_end = False
            node.word = None
        
        self.word_count -= 1
        
        # Decrement prefix counts and cleanup
        node = self.root
        for char in word:
            child = node.children[char]
            child.prefix_count -= 1
            if child.prefix_count == 0:
                del node.children[char]
                break
            node = child
        
        return True
    
    def count_words_with_prefix(self, prefix: str) -> int:
        """Count words starting with prefix."""
        node = self._traverse(prefix)
        return node.prefix_count if node else 0
    
    def get_words_with_prefix(self, prefix: str) -> list[str]:
        """Get all words starting with prefix."""
        node = self._traverse(prefix)
        if node is None:
            return []
        
        results = []
        self._collect_words(node, results)
        return results
    
    def get_all_words(self) -> list[str]:
        """Get all words in trie."""
        results = []
        self._collect_words(self.root, results)
        return results
    
    def _traverse(self, s: str) -> TrieNode:
        """Navigate to node for string s."""
        node = self.root
        for char in s:
            if char not in node.children:
                return None
            node = node.children[char]
        return node
    
    def _collect_words(self, node: TrieNode, results: list) -> None:
        """DFS to collect all words below node."""
        if node.is_end:
            results.append(node.word)
        for child in node.children.values():
            self._collect_words(child, results)
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| **insert** | O(m) | O(m) | Per word |
| **search** | O(m) | O(1) | - |
| **startsWith** | O(m) | O(1) | - |
| **delete** | O(m) | O(1) | With count tracking |
| **get_words_with_prefix** | O(m + k) | O(k) | k = result chars |
| **Build n words** | O(n √ó m) | O(n √ó m) | Total |

---

## üîÑ When to Use Which Implementation

| Implementation | Use When |
|----------------|----------|
| **Minimal (HashMap)** | Standard interview, LC 208 |
| **Array[26]** | Lowercase only, need speed |
| **Extended** | Word Search II, autocomplete |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting _traverse Helper

**‚ùå Wrong:**
```python
def search(self, word):
    node = self.root
    for char in word:
        if char not in node.children:
            return False
        node = node.children[char]
    return node.is_end

def startsWith(self, prefix):
    node = self.root  # Duplicated code!
    for char in prefix:
        if char not in node.children:
            return False
        node = node.children[char]
    return True
```

**‚úÖ Correct:**
```python
def _traverse(self, s):
    # Shared traversal logic
    node = self.root
    for char in s:
        if char not in node.children:
            return None
        node = node.children[char]
    return node

def search(self, word):
    node = self._traverse(word)
    return node is not None and node.is_end

def startsWith(self, prefix):
    return self._traverse(prefix) is not None
```

### 2. Modifying Root Reference

**‚ùå Wrong:**
```python
def insert(self, word):
    for char in word:
        if char not in self.root.children:
            self.root.children[char] = TrieNode()
        self.root = self.root.children[char]  # Lost root!
```

**‚úÖ Correct:**
```python
def insert(self, word):
    node = self.root  # Use local variable!
    for char in word:
        if char not in node.children:
            node.children[char] = TrieNode()
        node = node.children[char]
```

---

## üìù Practice Problems

### Easy (Implement basic class)
- [ ] [Implement Trie](https://leetcode.com/problems/implement-trie-prefix-tree/) - LC 208 ‚≠ê

### Medium (Extend class)
- [ ] [Design Add and Search Words](https://leetcode.com/problems/design-add-and-search-words-data-structure/) - LC 211
- [ ] [Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/) - LC 677

### Hard (Use in complex algorithms)
- [ ] [Word Search II](https://leetcode.com/problems/word-search-ii/) - LC 212

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement minimal Trie from scratch
- **Day 3:** Add delete operation
- **Day 7:** Implement extended version with all features
- **Day 14:** Use in Word Search II
- **Day 30:** Write complete Trie from memory

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Interview Implementation Tips</strong></summary>

**Starting the problem:**
> "I'll implement a Trie with insert, search, and startsWith. I'll use a TrieNode class with a HashMap for children - this handles any character set. If the problem specifies lowercase only, I could optimize with Array[26]."

**Code organization:**
> "I'll add a _traverse helper to avoid code duplication between search and startsWith. The only difference is search checks is_end, startsWith doesn't."

**Time/space discussion:**
> "All operations are O(m) where m is the word length. Insert creates at most m nodes in the worst case. Search and startsWith don't use extra space."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Implement minimal class | 10-15 min | Interview pace |
| Add delete | 10-15 min | Extension |
| Full extended class | 25-30 min | All features |
| Debug and test | 5-10 min | Edge cases |

---

> **üí° Key Insight:** Start with the minimal implementation (HashMap + is_end), add a _traverse helper to keep code DRY, then extend as the problem requires. Over-engineering wastes interview time.

> **üîó Related:** [TrieNode Structure](./2.1-TrieNode-Structure.md) | [Insert](../02-Trie-Operations/3.1-Insert-Operation.md) | [Search](../02-Trie-Operations/3.2-Search-Operation.md) | [StartsWith](../02-Trie-Operations/3.3-StartsWith-Prefix.md)
