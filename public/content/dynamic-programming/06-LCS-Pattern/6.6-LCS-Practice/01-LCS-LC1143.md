# Longest Common Subsequence (LC 1143)

> **The canonical LCS problem.** This is the foundation for understanding how to compare two sequences character by character. Every string DP problem that compares two strings borrows ideas from LCS.

---

## ðŸ“‹ Problem Statement

**LeetCode:** [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)

Given two strings `text1` and `text2`, return the length of their longest common subsequence. If there is no common subsequence, return 0.

A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

**Examples:**
```
Input: text1 = "abcde", text2 = "ace" 
Output: 3
Explanation: The longest common subsequence is "ace"

Input: text1 = "abc", text2 = "abc"
Output: 3

Input: text1 = "abc", text2 = "def"
Output: 0
```

**Constraints:**
- 1 â‰¤ text1.length, text2.length â‰¤ 1000
- text1 and text2 consist of only lowercase English characters

---

## ðŸŽ¯ Pattern Recognition

**This is LCS pattern because:**
- Two sequences to compare
- Looking for common elements
- Order matters (subsequence, not subset)
- Optimal substructure: LCS of longer strings built from LCS of shorter strings

**Key insight:**
```
If s1[i] == s2[j]:
    Include it in LCS, solve for remaining
Else:
    Try skipping s1[i] OR s2[j], take better result
```

---

## ðŸ“ Approach Analysis

### DP State Definition

```
dp[i][j] = length of LCS for s1[0:i] and s2[0:j]

Base: dp[0][j] = 0, dp[i][0] = 0 (empty string has no LCS)

Recurrence:
  if s1[i-1] == s2[j-1]:
      dp[i][j] = dp[i-1][j-1] + 1    (match! extend LCS)
  else:
      dp[i][j] = max(dp[i-1][j], dp[i][j-1])  (skip one char)
```

### 2D Grid Visualization

```
         ""   a    c    e
    ""    0   0    0    0
    a     0   1    1    1     â† 'a' matches at (1,1)
    b     0   1    1    1
    c     0   1    2    2     â† 'c' matches at (3,2)
    d     0   1    2    2
    e     0   1    2    3     â† 'e' matches at (5,3)

Answer: 3 (diagonal path: aâ†’câ†’e)
```

---

## ðŸ’» Solutions

### Solution 1: Standard 2D DP

```python
def longest_common_subsequence(text1: str, text2: str) -> int:
    """
    Classic LCS using 2D DP.
    Time: O(m Ã— n), Space: O(m Ã— n)
    """
    m, n = len(text1), len(text2)
    
    # dp[i][j] = LCS length for text1[0:i] and text2[0:j]
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                # Characters match: extend LCS from diagonal
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                # No match: best of skipping either character
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]
```

```javascript
function longestCommonSubsequence(text1, text2) {
    const m = text1.length, n = text2.length;
    const dp = Array.from({length: m + 1}, 
                          () => new Array(n + 1).fill(0));
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (text1[i-1] === text2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    
    return dp[m][n];
}
```

### Solution 2: Space-Optimized (Two Rows)

```python
def longest_common_subsequence_optimized(text1: str, text2: str) -> int:
    """
    Space-optimized: only keep two rows.
    Time: O(m Ã— n), Space: O(min(m, n))
    """
    # Use shorter string for columns
    if len(text1) < len(text2):
        text1, text2 = text2, text1
    
    m, n = len(text1), len(text2)
    prev = [0] * (n + 1)
    curr = [0] * (n + 1)
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                curr[j] = prev[j-1] + 1
            else:
                curr[j] = max(prev[j], curr[j-1])
        prev, curr = curr, prev
    
    return prev[n]
```

### Solution 3: One Row (Diagonal Tracking)

```python
def longest_common_subsequence_one_row(text1: str, text2: str) -> int:
    """
    Single row with diagonal variable.
    Time: O(m Ã— n), Space: O(min(m, n))
    """
    if len(text1) < len(text2):
        text1, text2 = text2, text1
    
    n = len(text2)
    dp = [0] * (n + 1)
    
    for i in range(len(text1)):
        prev_diag = 0  # This is dp[i-1][j-1]
        for j in range(1, n + 1):
            temp = dp[j]  # Save before overwriting
            if text1[i] == text2[j-1]:
                dp[j] = prev_diag + 1
            else:
                dp[j] = max(dp[j], dp[j-1])
            prev_diag = temp
    
    return dp[n]
```

### Solution 4: Top-Down with Memoization

```python
def longest_common_subsequence_memo(text1: str, text2: str) -> int:
    """
    Recursive with memoization.
    """
    from functools import lru_cache
    
    @lru_cache(maxsize=None)
    def helper(i, j):
        # Base case: one string exhausted
        if i == len(text1) or j == len(text2):
            return 0
        
        if text1[i] == text2[j]:
            return 1 + helper(i + 1, j + 1)
        else:
            return max(helper(i + 1, j), helper(i, j + 1))
    
    return helper(0, 0)
```

---

## âš¡ Complexity Analysis

| Approach | Time | Space |
|----------|------|-------|
| 2D DP | O(m Ã— n) | O(m Ã— n) |
| Two Rows | O(m Ã— n) | O(min(m, n)) |
| One Row | O(m Ã— n) | O(min(m, n)) |
| Memoization | O(m Ã— n) | O(m Ã— n) |

---

## âš ï¸ Common Mistakes

### 1. Off-by-One Error

**âŒ Wrong:**
```python
if text1[i] == text2[j]:  # When i,j go from 1 to len
    dp[i][j] = dp[i-1][j-1] + 1
```

**âœ… Correct:**
```python
if text1[i-1] == text2[j-1]:  # i,j are 1-indexed in DP
    dp[i][j] = dp[i-1][j-1] + 1
```

### 2. Confusing Subsequence with Substring

**Subsequence:** Order matters, gaps allowed
- "ace" IS a subsequence of "abcde" âœ…

**Substring:** Order matters, MUST be contiguous
- "ace" is NOT a substring of "abcde" âŒ

### 3. Wrong Max Logic

**âŒ Wrong:**
```python
dp[i][j] = max(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])
# This is wrong! Diagonal only for matches
```

**âœ… Correct:**
```python
if text1[i-1] == text2[j-1]:
    dp[i][j] = dp[i-1][j-1] + 1  # ONLY diagonal + 1 on match
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])  # No diagonal here
```

### 4. Forgetting Base Cases

```python
# Base cases are implicitly 0 from initialization
# But explicitly: LCS of any string with empty string is 0
```

---

## ðŸ“Š Trace Through Example

```
text1 = "abcde", text2 = "ace"

         ""   a    c    e
    ""    0   0    0    0
    a     ?   ?    ?    ?
    b     ?   ?    ?    ?
    c     ?   ?    ?    ?
    d     ?   ?    ?    ?
    e     ?   ?    ?    ?

Step-by-step for row 'a' (i=1):
  j=1: 'a'=='a' â†’ dp[1][1] = dp[0][0]+1 = 1
  j=2: 'a'â‰ 'c' â†’ dp[1][2] = max(dp[0][2], dp[1][1]) = 1
  j=3: 'a'â‰ 'e' â†’ dp[1][3] = max(dp[0][3], dp[1][2]) = 1

Step-by-step for row 'c' (i=3):
  j=1: 'c'â‰ 'a' â†’ dp[3][1] = max(dp[2][1], dp[3][0]) = 1
  j=2: 'c'=='c' â†’ dp[3][2] = dp[2][1]+1 = 2 â­
  j=3: 'c'â‰ 'e' â†’ dp[3][3] = max(dp[2][3], dp[3][2]) = 2

Final row 'e' (i=5):
  j=3: 'e'=='e' â†’ dp[5][3] = dp[4][2]+1 = 3 â­

Answer: dp[5][3] = 3
```

---

## ðŸ”„ Recovering the LCS String

```python
def lcs_with_string(text1: str, text2: str) -> tuple[int, str]:
    """Return both length and actual LCS string."""
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Fill DP table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    # Backtrack to find LCS
    lcs = []
    i, j = m, n
    while i > 0 and j > 0:
        if text1[i-1] == text2[j-1]:
            lcs.append(text1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1
    
    return dp[m][n], ''.join(reversed(lcs))
```

---

## ðŸ”— LCS Transformations

### LCS â†’ Delete Operations

```python
def min_delete_operations(word1: str, word2: str) -> int:
    """LC 583: Min deletions to make strings equal."""
    lcs = longest_common_subsequence(word1, word2)
    return len(word1) + len(word2) - 2 * lcs
```

### LCS â†’ Longest Palindromic Subsequence

```python
def longest_palindrome_subseq(s: str) -> int:
    """LC 516: LPS = LCS(s, reverse(s))"""
    return longest_common_subsequence(s, s[::-1])
```

### LCS â†’ Shortest Common Supersequence

```python
def shortest_supersequence_length(str1: str, str2: str) -> int:
    """SCS length = m + n - LCS"""
    lcs = longest_common_subsequence(str1, str2)
    return len(str1) + len(str2) - lcs
```

---

## ðŸ“ Related Problems

| Problem | Difficulty | Relationship |
|---------|------------|--------------|
| [583. Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/) | Medium | m + n - 2Ã—LCS |
| [1092. Shortest Common Supersequence](https://leetcode.com/problems/shortest-common-supersequence/) | Hard | m + n - LCS |
| [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/) | Medium | LCS(s, rev(s)) |
| [72. Edit Distance](https://leetcode.com/problems/edit-distance/) | Medium | Similar grid DP |

---

## ðŸŽ¤ Interview Tips

**Time to solve:** 15-20 minutes

**Communication template:**
> "I'll use dp[i][j] for the LCS length of the first i characters of text1 and first j of text2. When characters match, I extend the LCS from the diagonal: dp[i-1][j-1] + 1. When they don't match, I take the max of skipping either character."

**Key points:**
1. Explain the grid structure
2. Draw out a small example
3. Mention the diagonal for matches

**Follow-up questions:**
- "Can you recover the actual string?" â†’ Backtracking
- "Can you optimize space?" â†’ Two rows or one row
- "What about multiple LCS strings?" â†’ Need to track all paths

**Company frequency:**
| Company | Frequency |
|---------|-----------|
| Amazon | â­â­â­â­ |
| Google | â­â­â­â­ |
| Microsoft | â­â­â­ |
| Meta | â­â­â­ |

---

> **ðŸ’¡ Key Insight:** When characters match, we MUST include them and look diagonally (dp[i-1][j-1]). When they don't match, we try skipping each character and take the best (max of left and above). This creates a beautiful grid where the answer "flows" from top-left to bottom-right.

> **ðŸ”— Related:** [LCS Pattern Fundamentals](../6.5-LCS-Fundamentals.md) | [Edit Distance](./02-Edit-Distance-LC72.md) | [Longest Palindromic Subsequence](./03-Longest-Palindromic-Subseq-LC516.md)
