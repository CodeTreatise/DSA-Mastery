# IP Routing Table (Longest Prefix Match)

> **Trie application in networking: Efficiently find the longest matching prefix for IP address routing using a Binary Trie.**

---

## üìã Problem Statement

Design an IP routing table that:
1. Stores routes with IP prefixes (CIDR notation)
2. For a given IP address, finds the longest matching prefix
3. Returns the next hop for that route

**Example:**
```
Routes:
  192.168.0.0/16  ‚Üí Gateway A
  192.168.1.0/24  ‚Üí Gateway B
  192.168.1.128/25 ‚Üí Gateway C

Lookup:
  192.168.1.130 ‚Üí Gateway C (matches /25, most specific)
  192.168.1.1   ‚Üí Gateway B (matches /24)
  192.168.2.1   ‚Üí Gateway A (matches /16)
  10.0.0.1      ‚Üí Default (no match)
```

---

## üéØ Pattern Recognition

**Pattern:** Binary Trie for Bit-Level Prefix Matching

**Key insight:** 
- IP addresses are 32 bits
- CIDR prefix = first N bits must match
- Longest prefix = deepest match in Trie

**Why Trie?**
- Linear scan through routes: O(n) per lookup
- Trie: O(32) = O(1) per lookup

---

## üìê How It Works

### IP Address as Binary

```
IP: 192.168.1.128

Decimal: 192     . 168     . 1       . 128
Binary:  11000000.10101000.00000001.10000000

As 32-bit: 11000000101010000000000110000000
```

### CIDR to Trie Path

```
Route: 192.168.0.0/16 (first 16 bits)
Binary prefix: 1100000010101000 (16 bits)

Route: 192.168.1.0/24 (first 24 bits)
Binary prefix: 110000001010100000000001 (24 bits)

Trie structure:
       root
        |
        1
        |
        1
        |
        0
        ...
       (16 bits: 192.168.x.x ‚Üí Gateway A)
        |
       ... (24 bits: 192.168.1.x ‚Üí Gateway B)
```

---

## üíª Implementation

### IPv4 Routing Table

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = [None, None]  # [0-bit, 1-bit]
        self.gateway = None  # Next hop if this is end of route


class IPRoutingTable:
    """
    IP routing using Binary Trie.
    
    Insert: O(prefix_length) ‚â§ O(32)
    Lookup: O(32)
    """
    
    def __init__(self, default_gateway: str = None):
        self.root = TrieNode()
        self.default_gateway = default_gateway
    
    def add_route(self, cidr: str, gateway: str) -> None:
        """
        Add a route.
        cidr format: "192.168.1.0/24"
        """
        ip, prefix_len = self._parse_cidr(cidr)
        ip_binary = self._ip_to_binary(ip)
        
        node = self.root
        for i in range(prefix_len):
            bit = int(ip_binary[i])
            if node.children[bit] is None:
                node.children[bit] = TrieNode()
            node = node.children[bit]
        
        node.gateway = gateway
    
    def lookup(self, ip: str) -> str:
        """
        Find longest prefix match for IP.
        Returns gateway or default.
        """
        ip_binary = self._ip_to_binary(ip)
        
        node = self.root
        best_match = self.default_gateway
        
        for bit_char in ip_binary:
            bit = int(bit_char)
            
            if node.children[bit] is None:
                break  # No further match
            
            node = node.children[bit]
            
            # Update best match if this node has a gateway
            if node.gateway is not None:
                best_match = node.gateway
        
        return best_match
    
    def delete_route(self, cidr: str) -> bool:
        """Remove a route."""
        ip, prefix_len = self._parse_cidr(cidr)
        ip_binary = self._ip_to_binary(ip)
        
        node = self.root
        for i in range(prefix_len):
            bit = int(ip_binary[i])
            if node.children[bit] is None:
                return False  # Route doesn't exist
            node = node.children[bit]
        
        if node.gateway is None:
            return False
        
        node.gateway = None
        return True
    
    def _parse_cidr(self, cidr: str) -> tuple:
        """Parse CIDR notation: "192.168.1.0/24" ‚Üí ("192.168.1.0", 24)"""
        parts = cidr.split('/')
        ip = parts[0]
        prefix_len = int(parts[1]) if len(parts) > 1 else 32
        return ip, prefix_len
    
    def _ip_to_binary(self, ip: str) -> str:
        """Convert IP to 32-bit binary string."""
        octets = ip.split('.')
        binary = ''
        for octet in octets:
            binary += format(int(octet), '08b')
        return binary
    
    def _binary_to_ip(self, binary: str) -> str:
        """Convert 32-bit binary to IP address."""
        octets = []
        for i in range(0, 32, 8):
            octets.append(str(int(binary[i:i+8], 2)))
        return '.'.join(octets)


# Usage
router = IPRoutingTable(default_gateway="Default")

# Add routes
router.add_route("192.168.0.0/16", "Gateway A")   # 192.168.x.x
router.add_route("192.168.1.0/24", "Gateway B")   # 192.168.1.x
router.add_route("192.168.1.128/25", "Gateway C") # 192.168.1.128-255

# Lookups
print(router.lookup("192.168.1.130"))  # Gateway C (matches /25)
print(router.lookup("192.168.1.1"))    # Gateway B (matches /24)
print(router.lookup("192.168.2.1"))    # Gateway A (matches /16)
print(router.lookup("10.0.0.1"))       # Default (no match)
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = [null, null];
        this.gateway = null;
    }
}

class IPRoutingTable {
    constructor(defaultGateway = null) {
        this.root = new TrieNode();
        this.defaultGateway = defaultGateway;
    }
    
    addRoute(cidr, gateway) {
        const [ip, prefixLen] = this._parseCidr(cidr);
        const ipBinary = this._ipToBinary(ip);
        
        let node = this.root;
        for (let i = 0; i < prefixLen; i++) {
            const bit = parseInt(ipBinary[i]);
            if (node.children[bit] === null) {
                node.children[bit] = new TrieNode();
            }
            node = node.children[bit];
        }
        node.gateway = gateway;
    }
    
    lookup(ip) {
        const ipBinary = this._ipToBinary(ip);
        
        let node = this.root;
        let bestMatch = this.defaultGateway;
        
        for (const bitChar of ipBinary) {
            const bit = parseInt(bitChar);
            
            if (node.children[bit] === null) break;
            
            node = node.children[bit];
            
            if (node.gateway !== null) {
                bestMatch = node.gateway;
            }
        }
        
        return bestMatch;
    }
    
    _parseCidr(cidr) {
        const parts = cidr.split('/');
        const ip = parts[0];
        const prefixLen = parts.length > 1 ? parseInt(parts[1]) : 32;
        return [ip, prefixLen];
    }
    
    _ipToBinary(ip) {
        return ip.split('.')
            .map(octet => parseInt(octet).toString(2).padStart(8, '0'))
            .join('');
    }
}
```

---

### IPv6 Support

**Python:**
```python
class IPv6RoutingTable:
    """
    IPv6 routing table (128-bit addresses).
    """
    
    def __init__(self):
        self.root = TrieNode()
    
    def _ipv6_to_binary(self, ipv6: str) -> str:
        """Convert IPv6 to 128-bit binary."""
        # Expand shorthand notation
        if '::' in ipv6:
            parts = ipv6.split('::')
            left = parts[0].split(':') if parts[0] else []
            right = parts[1].split(':') if parts[1] else []
            missing = 8 - len(left) - len(right)
            groups = left + ['0000'] * missing + right
        else:
            groups = ipv6.split(':')
        
        binary = ''
        for group in groups:
            binary += format(int(group or '0', 16), '016b')
        
        return binary
    
    # Same add_route and lookup logic, just with 128 bits
```

---

## üîç Walkthrough

```
Routes:
  192.168.0.0/16  ‚Üí A
  192.168.1.0/24  ‚Üí B
  192.168.1.128/25 ‚Üí C

Binary prefixes:
  /16: 11000000.10101000 (16 bits)
  /24: 11000000.10101000.00000001 (24 bits)
  /25: 11000000.10101000.00000001.1 (25 bits)

Trie:
                  root
                    |
                    1
                    |
                    1
                   ...
               (at bit 16: gateway=A)
                   ...
               (at bit 24: gateway=B)
                    |
                    1
               (at bit 25: gateway=C)

Lookup 192.168.1.130:
Binary: 11000000.10101000.00000001.10000010

Traverse:
  Bit 0-15: Match /16 ‚Üí best=A
  Bit 16-23: Match /24 ‚Üí best=B
  Bit 24: Match /25 (bit=1) ‚Üí best=C
  Bit 25-31: Continue but no new gateways

Result: Gateway C
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| Add route | O(prefix_len) ‚â§ O(32) | O(prefix_len) |
| Lookup | O(32) = O(1) | O(1) |
| Delete | O(prefix_len) | O(1) |
| Build n routes | O(n √ó avg_prefix) | O(n √ó avg_prefix) |

**Comparison with linear scan:**

| Method | Lookup Time | Space |
|--------|-------------|-------|
| Linear scan | O(n) | O(n) |
| Binary Trie | O(32) = O(1) | O(n √ó 32) |

For routing tables with thousands of entries, Trie is essential.

---

## üîÑ Optimizations

### 1. Path Compression (Radix Tree)

Merge nodes with single children:

```python
class CompressedIPTrie:
    """
    Store multiple bits per node when no branching.
    Reduces node count significantly for sparse tables.
    """
    
    def __init__(self):
        self.root = {
            'prefix': '',      # Bits stored at this edge
            'children': {},    # 0 or 1 as keys
            'gateway': None
        }
```

### 2. Multi-Bit Trie

Process multiple bits at once:

```python
class MultiBitTrie:
    """
    4-bit Trie: Only 8 levels instead of 32.
    Each node has 16 children (0-15).
    Trade-off: More memory per node, fewer lookups.
    """
    
    STRIDE = 4  # Bits per level
    
    def __init__(self):
        self.root = {'children': [None] * 16, 'gateway': None}
    
    def lookup(self, ip: str) -> str:
        binary = self._ip_to_binary(ip)
        node = self.root
        best = None
        
        for i in range(0, 32, self.STRIDE):
            if node is None:
                break
            
            # Get 4-bit index
            nibble = int(binary[i:i+self.STRIDE], 2)
            
            if node['gateway'] is not None:
                best = node['gateway']
            
            node = node['children'][nibble]
        
        return best
```

### 3. Level-Compressed Trie (LC-Trie)

Used in Linux kernel routing:
- Combines path compression + multi-bit
- Adapts stride based on density

---

## ‚ö†Ô∏è Edge Cases

| Case | Handling |
|------|----------|
| Default route (0.0.0.0/0) | Matches all, lowest priority |
| /32 prefix | Exact IP match |
| Overlapping prefixes | Longest wins |
| No match, no default | Return None |

---

## üé§ Interview Tips

**Opening statement:**
"IP routing requires longest prefix matching, which is a perfect use case for a Binary Trie. Each bit of the IP address determines the path, and we track the best match seen so far."

**Key points:**
1. "CIDR prefix length determines how deep we insert into the Trie"
2. "During lookup, we update best_match whenever we hit a gateway"
3. "Even if we can go deeper, we return the last matched gateway"

**Follow-ups:**
- "How to handle updates?" ‚Üí Add/remove routes dynamically
- "Performance for large tables?" ‚Üí Multi-bit Trie, LC-Trie
- "IPv6?" ‚Üí Same concept, 128 bits

---

## üìù Real-World Context

**Where this is used:**
- Linux kernel (fib_trie)
- Cisco routers (TCAM + software Trie)
- Software-defined networking (SDN)
- Cloud load balancers

**Scale considerations:**
- Internet backbone: ~900K routes (2024)
- Per-lookup must be O(1) for line-rate forwarding
- Hardware implementations use TCAM (Ternary CAM)

---

## üìù Practice Checklist

- [ ] Implement basic IP routing table
- [ ] Handle CIDR notation parsing
- [ ] Correctly return longest prefix match
- [ ] Handle default routes
- [ ] Understand optimization trade-offs

<details>
<summary><strong>üß† Spaced Repetition</strong></summary>

- **Day 1:** Implement basic IPv4 routing
- **Day 3:** Trace through with overlapping prefixes
- **Day 7:** Implement delete operation
- **Day 14:** Research Linux kernel implementation

</details>

---

> **üí° Key Insight:** Longest prefix matching means we don't stop at the first match - we continue traversing and update best_match each time we hit a route endpoint. The deepest match wins.

> **üîó Related:** [Bit Trie](../04-Bit-Trie/5.1-Bit-Trie-Fundamentals.md) | [Prefix Matching](../03-Trie-Patterns/4.4-Prefix-Matching.md)
