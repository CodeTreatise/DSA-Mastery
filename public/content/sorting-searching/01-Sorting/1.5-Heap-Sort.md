# 1.5 - Heap Sort

> **The Guaranteed O(n log n) In-Place Sort**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê - Know for completeness  
> **Characteristics:** O(n log n) worst case, O(1) space, Not stable

---

## Overview

**Heap Sort** leverages the heap data structure to sort in-place with guaranteed O(n log n) time complexity. Unlike Quick Sort, it has no O(n¬≤) worst case. Unlike Merge Sort, it needs no extra space.

**Trade-off:** Slower in practice than Quick Sort due to poor cache locality.

```
Build max-heap ‚Üí Extract max repeatedly ‚Üí Sorted!

[4, 10, 3, 5, 1] ‚Üí Max-Heap ‚Üí [10, 5, 3, 4, 1]
                              ‚Üì
Extract 10: [5, 4, 3, 1] [10]
Extract 5:  [4, 1, 3] [5, 10]
Extract 4:  [3, 1] [4, 5, 10]
Extract 3:  [1] [3, 4, 5, 10]
Result: [1, 3, 4, 5, 10]
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Identify Heap Sort</strong></summary>

**Keywords:**
- "Sort with O(1) extra space"
- "Guaranteed O(n log n)"
- "In-place sorting"
- "Priority queue operations"

**The pattern:**
```
Heap property: Parent ‚â• Children (max-heap)

      10           Array: [10, 5, 3, 4, 1]
     /  \          Index:   0  1  2  3  4
    5    3
   / \             Parent at i ‚Üí Children at 2i+1, 2i+2
  4   1            Child at i ‚Üí Parent at (i-1)/2
```

**Decision flow:**
```
Need sorting with:
‚îú‚îÄ‚îÄ Guaranteed O(n log n)? ‚Üí Heap Sort or Merge Sort
‚îú‚îÄ‚îÄ O(1) space required? ‚Üí Heap Sort (not Merge Sort)
‚îú‚îÄ‚îÄ Stability required? ‚Üí NOT Heap Sort
‚îî‚îÄ‚îÄ Best practical speed? ‚Üí Quick Sort (not Heap Sort)
```

</details>

---

## ‚úÖ When to Use

- **Memory constrained** - Only O(1) extra space
- **Need worst-case guarantee** - Always O(n log n)
- **Building priority queues** - Heapify operation
- **Finding K largest/smallest** - Partial heap sort
- **Embedded systems** - Predictable performance

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Need stability | Merge Sort | Heap Sort not stable |
| Best average performance | Quick Sort | Better cache locality |
| Nearly sorted data | Insertion Sort |" O(n) for nearly sorted "|
| Linked lists | Merge Sort | Heap needs random access |
| Small arrays | Insertion Sort | Lower overhead |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Array Basics](../../01-Arrays-Strings/01-Arrays/1.1-Array-Basics.md)
- [Recursion](../../02-Recursion-Backtracking/01-Recursion/1.1-Recursion-Basics.md)
- [Binary Trees](../../06-Trees.md) - Heap is a complete binary tree

**After mastering this:**
- [Heaps & Priority Queues](../../08-Heaps-Priority-Queues.md)
- [Top K Elements Pattern](../../08-Heaps-Priority-Queues.md)
- [Merge K Sorted Lists](link)

**Combines with:**
- Binary Search for optimization problems
- Greedy algorithms using priority queues

**Related problems:**
- Kth Largest Element (LC 215)
- Top K Frequent Elements (LC 347)
- Merge K Sorted Lists (LC 23)

</details>

---

## üìê How It Works

### Step 1: Understanding Heaps

A **max-heap** is a complete binary tree where each parent ‚â• its children.

```
Max-Heap Property:
        10              Array representation:
       /  \             [10, 5, 3, 4, 1]
      5    3              0  1  2  3  4
     / \
    4   1               Index formulas:
                        - Parent of i: (i-1) // 2
                        - Left child: 2*i + 1
                        - Right child: 2*i + 2
```

### Step 2: Heapify (Sift Down)

Fix a single violation by moving element down:

```
Heapify at index 0:
    [4, 10, 3, 5, 1]     4 < 10, swap with larger child
         ‚Üì
    [10, 4, 3, 5, 1]     4 < 5, swap with larger child
         ‚Üì
    [10, 5, 3, 4, 1]     Heap property restored!
```

### Step 3: Build Max-Heap

Start from last non-leaf node, heapify backwards:

```
Array: [4, 10, 3, 5, 1]
Last non-leaf: index 1 (parent of index 3 or 4)

Heapify index 1: [4, 10, 3, 5, 1] ‚Üí [4, 10, 3, 5, 1] (already valid)
Heapify index 0: [4, 10, 3, 5, 1] ‚Üí [10, 5, 3, 4, 1] (swap 4‚Üî10, 4‚Üî5)

Result: Max-heap [10, 5, 3, 4, 1]
```

### Step 4: Extract and Sort

Repeatedly swap root with last, reduce heap size, heapify:

```
[10, 5, 3, 4, 1]  Swap 10‚Üî1, heapify [0..3]
[1, 5, 3, 4 | 10] ‚Üí [5, 4, 3, 1 | 10]

[5, 4, 3, 1 | 10] Swap 5‚Üî1, heapify [0..2]
[1, 4, 3 | 5, 10] ‚Üí [4, 1, 3 | 5, 10]

[4, 1, 3 | 5, 10] Swap 4‚Üî3, heapify [0..1]
[3, 1 | 4, 5, 10] ‚Üí [3, 1 | 4, 5, 10]

[3, 1 | 4, 5, 10] Swap 3‚Üî1
[1 | 3, 4, 5, 10]

Result: [1, 3, 4, 5, 10] ‚úì
```

---

## üíª Code Implementation

### Heap Sort (Iterative)

**Python:**
```python
def heap_sort(arr: list[int]) -> list[int]:
    """
    Heap Sort - In-place, O(n log n) guaranteed.
    
    Time: O(n log n), Space: O(1)
    Not stable.
    """
    n = len(arr)
    
    def heapify(size: int, root: int) -> None:
        """Maintain max-heap property at root."""
        largest = root
        left = 2 * root + 1
        right = 2 * root + 2
        
        # Check if left child is larger
        if left < size and arr[left] > arr[largest]:
            largest = left
        
        # Check if right child is larger
        if right < size and arr[right] > arr[largest]:
            largest = right
        
        # Swap and continue if root is not largest
        if largest != root:
            arr[root], arr[largest] = arr[largest], arr[root]
            heapify(size, largest)
    
    # Step 1: Build max-heap (bottom-up)
    # Start from last non-leaf node
    for i in range(n // 2 - 1, -1, -1):
        heapify(n, i)
    
    # Step 2: Extract elements one by one
    for i in range(n - 1, 0, -1):
        # Move current root (max) to end
        arr[0], arr[i] = arr[i], arr[0]
        # Heapify reduced heap
        heapify(i, 0)
    
    return arr


# Example
arr = [4, 10, 3, 5, 1]
print(heap_sort(arr))  # [1, 3, 4, 5, 10]
```

**JavaScript:**
```javascript
function heapSort(arr) {
    const n = arr.length;
    
    function heapify(size, root) {
        let largest = root;
        const left = 2 * root + 1;
        const right = 2 * root + 2;
        
        if (left < size && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < size && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest !== root) {
            [arr[root], arr[largest]] = [arr[largest], arr[root]];
            heapify(size, largest);
        }
    }
    
    // Build max-heap
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(n, i);
    }
    
    // Extract elements
    for (let i = n - 1; i > 0; i--) {
        [arr[0], arr[i]] = [arr[i], arr[0]];
        heapify(i, 0);
    }
    
    return arr;
}

console.log(heapSort([4, 10, 3, 5, 1]));  // [1, 3, 4, 5, 10]
```

---

### Iterative Heapify (Avoid Stack Overflow)

```python
def heapify_iterative(arr: list[int], size: int, root: int) -> None:
    """Iterative heapify - better for large arrays."""
    while True:
        largest = root
        left = 2 * root + 1
        right = 2 * root + 2
        
        if left < size and arr[left] > arr[largest]:
            largest = left
        
        if right < size and arr[right] > arr[largest]:
            largest = right
        
        if largest == root:
            break
        
        arr[root], arr[largest] = arr[largest], arr[root]
        root = largest
```

---

### Using Python's heapq (Min-Heap)

```python
import heapq

def heap_sort_builtin(arr: list[int]) -> list[int]:
    """
    Using Python's heapq (min-heap).
    
    Note: heapq is a min-heap, so this naturally sorts ascending.
    Time: O(n log n), Space: O(n) - not in-place
    """
    heapq.heapify(arr)  # O(n)
    return [heapq.heappop(arr) for _ in range(len(arr))]


# For in-place with heapq, negate values
def heap_sort_inplace_minheap(arr: list[int]) -> list[int]:
    """In-place using negation trick."""
    # Negate to simulate max-heap
    for i in range(len(arr)):
        arr[i] = -arr[i]
    
    heapq.heapify(arr)
    
    result = []
    while arr:
        result.append(-heapq.heappop(arr))
    
    return result
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Best |" O(n log n) "| O(1) | Always same |
| Average |" O(n log n) "| O(1) | Always same |
| Worst |" O(n log n) "| O(1) | **Guaranteed!** |

**Why this complexity:**

- **Build heap:** O(n) - tighter analysis shows linear time
- **Extract all:** n * O(log n) = O(n log n)
- **Total:** O(n) + O(n log n) = O(n log n)

**Space:** O(1) - only swaps, no extra arrays

**Why O(n) for build heap?**
```
Most nodes are near the bottom (many leaves, few internal nodes).
Leaves need 0 work, nodes near root need O(log n).
Sum: O(n) total work (geometric series).
```

---

## üîÑ Variations

| Variation | Difference | Use Case |
|-----------|------------|----------|
| Min-Heap Sort | Use min-heap, extract min | Descending order |
| Partial Heap Sort | Stop after K extractions | Top K elements |
| D-ary Heap Sort | d children per node | Reduce tree height |
| Bottom-up Heap Sort | Optimize extract phase | Slightly faster |

### Partial Heap Sort for Top K

```python
def top_k_largest(arr: list[int], k: int) -> list[int]:
    """Get K largest elements using partial heap sort."""
    n = len(arr)
    
    def heapify(size, root):
        largest = root
        left, right = 2*root + 1, 2*root + 2
        if left < size and arr[left] > arr[largest]:
            largest = left
        if right < size and arr[right] > arr[largest]:
            largest = right
        if largest != root:
            arr[root], arr[largest] = arr[largest], arr[root]
            heapify(size, largest)
    
    # Build max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(n, i)
    
    # Extract only K elements
    result = []
    for i in range(n - 1, n - 1 - k, -1):
        result.append(arr[0])
        arr[0], arr[i] = arr[i], arr[0]
        heapify(i, 0)
    
    return result


# Example
print(top_k_largest([3, 1, 4, 1, 5, 9, 2, 6], 3))  # [9, 6, 5]
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Index Calculation

‚ùå **Wrong:**
```python
left = 2 * root      # Off by one!
right = 2 * root + 1
```

‚úÖ **Correct:**
```python
left = 2 * root + 1   # For 0-indexed arrays
right = 2 * root + 2
```

### 2. Heapifying in Wrong Direction

‚ùå **Wrong:**
```python
# Building heap top-down
for i in range(n):  # Wrong direction!
    heapify(n, i)
```

‚úÖ **Correct:**
```python
# Building heap bottom-up (more efficient)
for i in range(n // 2 - 1, -1, -1):
    heapify(n, i)
```

### 3. Not Reducing Heap Size During Extraction

‚ùå **Wrong:**
```python
for i in range(n - 1, 0, -1):
    arr[0], arr[i] = arr[i], arr[0]
    heapify(n, 0)  # Wrong! Should be i, not n
```

‚úÖ **Correct:**
```python
for i in range(n - 1, 0, -1):
    arr[0], arr[i] = arr[i], arr[0]
    heapify(i, 0)  # Heap size is i, not n
```

### 4. Confusing Min-Heap vs Max-Heap

‚ùå **Wrong (for ascending sort):**
```python
# Using min-heap logic but expecting ascending sort
if arr[left] < arr[largest]:  # Min-heap!
```

‚úÖ **Correct:**
```python
# Max-heap for ascending sort
if arr[left] > arr[largest]:  # Max-heap
```

---

## üìù Practice Problems

### Easy

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Kth Largest Element | Heap basics | [LC 215](https://leetcode.com/problems/kth-largest-element-in-an-array/) |
| Last Stone Weight | Max-heap simulation | [LC 1046](https://leetcode.com/problems/last-stone-weight/) |

### Medium

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Top K Frequent Elements | Heap + frequency | [LC 347](https://leetcode.com/problems/top-k-frequent-elements/) |
| K Closest Points | Min-heap with distance | [LC 973](https://leetcode.com/problems/k-closest-points-to-origin/) |
| Sort Characters By Frequency | Heap + counting | [LC 451](https://leetcode.com/problems/sort-characters-by-frequency/) |

### Hard

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Merge K Sorted Lists | K-way merge with heap | [LC 23](https://leetcode.com/problems/merge-k-sorted-lists/) |
| Find Median from Data Stream | Two heaps | [LC 295](https://leetcode.com/problems/find-median-from-data-stream/) |
| Sliding Window Median | Two heaps + sliding | [LC 480](https://leetcode.com/problems/sliding-window-median/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement heapify from scratch
**Day 3:** Implement full heap sort
**Day 7:** LC 215 Kth Largest Element
**Day 14:** LC 347 Top K Frequent
**Day 21:** LC 23 Merge K Sorted Lists

**Key insight to remember:**
"Build heap bottom-up, extract top-down"

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate</strong></summary>

**When to mention Heap Sort:**
> "If we need guaranteed O(n log n) with O(1) space, Heap Sort is ideal. But for best average performance, I'd use Quick Sort."

**Explaining the approach:**
> "I'll use a max-heap. First, I'll build the heap in O(n) time by heapifying from the last non-leaf node upward. Then I'll repeatedly extract the maximum and place it at the end."

**Trade-off discussion:**
> "Heap Sort has worse cache locality than Quick Sort because we jump around the array. That's why Quick Sort is faster in practice despite same Big-O."

**Company Focus:**

| Company | Heap Sort Focus |
|---------|-----------------|
| Google | Understand heap operations |
| Amazon | Top K problems (partial heap) |
| Meta | Priority queue applications |
| Microsoft | Comparison with other sorts |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand heap structure | 20 min | Array as tree |
| Implement heapify | 15 min | Key operation |
| Implement full heap sort | 20 min | Build + extract |
| LC 215 Kth Largest | 15 min | Direct application |
| LC 347 Top K Frequent | 25 min | Heap + map |

---

## üí° Key Insight

> **Heap Sort = Build Max-Heap + Repeated Extraction**
>
> 1. Build max-heap: O(n) - bottom-up heapify
> 2. Extract max n times: O(n log n) - swap root to end, heapify
>
> **Memory tip:** "Build bottom-up, extract top-down"
>
> **Trade-off:** Guaranteed O(n log n) but slower than Quick Sort in practice due to poor cache locality.

---

## üîó Related

- [Quick Sort](./1.4-Quick-Sort.md) - Faster in practice, O(n¬≤) worst
- [Merge Sort](./1.3-Merge-Sort.md) - Stable, O(n) space
- [Heaps & Priority Queues](../../08-Heaps-Priority-Queues.md) - Deep dive
- [Top K Elements Pattern](../../08-Heaps-Priority-Queues.md) - Common interview pattern
