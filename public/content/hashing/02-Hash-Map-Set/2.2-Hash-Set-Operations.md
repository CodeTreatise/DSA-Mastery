# Hash Set Operations

> **Hash sets store unique elements with O(1) membership testing - perfect for deduplication and existence checks.**

Hash sets are specialized hash tables that only store keys (no values). They excel at tracking unique elements, checking membership, and performing set operations like union and intersection.

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>When to Use Hash Sets</strong></summary>

**Problem signals:**
- "Check if X exists" â†’ O(1) membership
- "Remove duplicates" â†’ set only keeps unique
- "Find unique elements" â†’ set = unique
- "Intersection of two lists" â†’ set intersection
- "Find missing element" â†’ set difference
- Track visited nodes in graph/tree traversal

**Built-in implementations:**
- Python: `set`, `frozenset`
- JavaScript: `Set`
- Java: `HashSet`, `LinkedHashSet`
- C++: `unordered_set`

</details>

---

## âœ… Core Operations

| Operation | Python | JavaScript | Time |
|-----------|--------|------------|------|
| Create | `s = set()` | `s = new Set()` | O(1) |
| Add | `s.add(x)` | `s.add(x)` | O(1)* |
| Remove | `s.remove(x)` | `s.delete(x)` | O(1)* |
| Check exists | `x in s` | `s.has(x)` | O(1)* |
| Get size | `len(s)` | `s.size` | O(1) |
| Clear | `s.clear()` | `s.clear()` | O(1) or O(n) |
| Union | `s1 \| s2` | - | O(n+m) |
| Intersection | `s1 & s2` | - | O(min(n,m)) |
| Difference | `s1 - s2` | - | O(n) |

*Average case

## âŒ When NOT to Use Hash Sets

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need to count occurrences | Sets don't store counts | Hash map/Counter |
| Need sorted unique values | Sets are unordered | TreeSet, sorted list |
| Need key-value pairs | Sets only store keys | Hash map |
| Need to store mutable objects | Only immutable hashable | List with custom handling |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- [What Is Hashing](../01-Hash-Fundamentals/1.1-What-Is-Hashing.md)
- [Hash Map Operations](./2.1-Hash-Map-Operations.md)

**After this, learn:**
- [Contains Duplicate (LC 217)](https://leetcode.com/problems/contains-duplicate/)
- [Intersection of Two Arrays (LC 349)](https://leetcode.com/problems/intersection-of-two-arrays/)
- [Longest Consecutive Sequence (LC 128)](../04-Two-Sum-Pattern/4.4-Longest-Consecutive-LC128.md)

**Used in:**
- Removing duplicates
- Cycle detection (tracking visited)
- Graph traversal (BFS/DFS visited set)
- Sliding window problems

</details>

---

## ğŸ“ How It Works

### Basic Operations Visualization

```
Set: {3, 7, 1, 9}

ADD s.add(5):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Before: {3, 7, 1, 9}               â”‚
â”‚ After:  {3, 7, 1, 9, 5}            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ADD s.add(3):  (duplicate)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Before: {3, 7, 1, 9, 5}            â”‚
â”‚ After:  {3, 7, 1, 9, 5}  â† No change â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CHECK 7 in s:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ hash(7) â†’ bucket index â†’ found!   â”‚
â”‚ Return: True                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

REMOVE s.remove(1):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Before: {3, 7, 1, 9, 5}            â”‚
â”‚ After:  {3, 7, 9, 5}               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Set Operations Visualization

```
Set A: {1, 2, 3, 4, 5}
Set B: {4, 5, 6, 7, 8}

UNION (A âˆª B):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ All elements from both sets             â”‚
â”‚ {1, 2, 3, 4, 5, 6, 7, 8}                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

INTERSECTION (A âˆ© B):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Elements in BOTH sets                   â”‚
â”‚ {4, 5}                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

DIFFERENCE (A - B):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Elements in A but NOT in B              â”‚
â”‚ {1, 2, 3}                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SYMMETRIC DIFFERENCE (A â–³ B):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Elements in either but NOT both         â”‚
â”‚ {1, 2, 3, 6, 7, 8}                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’» Code Implementation

### Python - Essential Set Operations

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CREATING SETS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Empty set (NOT {} - that's an empty dict!)
s = set()

# With initial values
s = {1, 2, 3, 4, 5}

# From list (removes duplicates)
s = set([1, 2, 2, 3, 3, 3])  # {1, 2, 3}

# From string (each char is element)
s = set("hello")  # {'h', 'e', 'l', 'o'}

# Set comprehension
s = {x**2 for x in range(5)}  # {0, 1, 4, 9, 16}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ADD / REMOVE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

s = {1, 2, 3}

# Add element (duplicates ignored)
s.add(4)      # {1, 2, 3, 4}
s.add(1)      # {1, 2, 3, 4} - no change

# Add multiple elements
s.update([5, 6, 7])  # {1, 2, 3, 4, 5, 6, 7}

# Remove (raises KeyError if missing)
s.remove(7)   # {1, 2, 3, 4, 5, 6}

# Discard (no error if missing)
s.discard(10)  # No error, set unchanged
s.discard(6)   # {1, 2, 3, 4, 5}

# Pop (remove and return arbitrary element)
elem = s.pop()  # Removes and returns some element

# Clear all
s.clear()  # set()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MEMBERSHIP TESTING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

s = {1, 2, 3, 4, 5}

# Check if element exists - O(1)!
1 in s      # True
10 in s     # False
10 not in s # True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SET OPERATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

a = {1, 2, 3, 4}
b = {3, 4, 5, 6}

# Union (elements in either)
a | b                    # {1, 2, 3, 4, 5, 6}
a.union(b)               # Same

# Intersection (elements in both)
a & b                    # {3, 4}
a.intersection(b)        # Same

# Difference (elements in a but not b)
a - b                    # {1, 2}
a.difference(b)          # Same

# Symmetric difference (elements in either but not both)
a ^ b                    # {1, 2, 5, 6}
a.symmetric_difference(b)  # Same

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SET COMPARISONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

a = {1, 2, 3}
b = {1, 2, 3, 4, 5}
c = {1, 2, 3}

# Subset
a <= b           # True (a is subset of b)
a.issubset(b)    # True
a <= c           # True (equal sets are subsets)
a < c            # False (not proper subset)

# Superset
b >= a           # True (b is superset of a)
b.issuperset(a)  # True

# Disjoint (no common elements)
{1, 2}.isdisjoint({3, 4})  # True
{1, 2}.isdisjoint({2, 3})  # False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ITERATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

s = {3, 1, 4, 1, 5}  # Stored as {1, 3, 4, 5}

for elem in s:
    print(elem)

# Convert to list
list(s)  # Order not guaranteed

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FROZEN SET (Immutable, can be dict key or set element)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fs = frozenset([1, 2, 3])
# fs.add(4)  # AttributeError - immutable!

# Can use as dict key
d = {fs: "value"}

# Can add to another set
s = {frozenset([1, 2]), frozenset([3, 4])}
```

### Python - Common Set Patterns

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATTERN 1: Remove Duplicates
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

nums = [1, 2, 2, 3, 3, 3, 4]
unique = list(set(nums))  # [1, 2, 3, 4] (order not preserved)

# Preserve order (Python 3.7+)
unique_ordered = list(dict.fromkeys(nums))  # [1, 2, 2, 3, 3, 3, 4] â†’ [1, 2, 3, 4]

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATTERN 2: Find Duplicates
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def find_duplicates(nums):
    seen = set()
    duplicates = set()
    for num in nums:
        if num in seen:
            duplicates.add(num)
        seen.add(num)
    return list(duplicates)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATTERN 3: Check for Duplicates (Contains Duplicate LC 217)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def contains_duplicate(nums):
    return len(nums) != len(set(nums))

# OR more efficient (early exit)
def contains_duplicate_v2(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    return False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATTERN 4: Find Intersection (LC 349)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def intersection(nums1, nums2):
    return list(set(nums1) & set(nums2))

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATTERN 5: Find Missing Numbers
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def find_missing(nums, n):
    """Find numbers from 1 to n missing in nums."""
    all_nums = set(range(1, n + 1))
    present = set(nums)
    return list(all_nums - present)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATTERN 6: Visited Set (Graph/Tree Traversal)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def bfs(graph, start):
    visited = set()
    queue = [start]
    
    while queue:
        node = queue.pop(0)
        if node in visited:
            continue
        
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                queue.append(neighbor)
    
    return visited
```

### JavaScript - Set Operations

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CREATING SETS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Empty set
const s = new Set();

// With initial values
const s2 = new Set([1, 2, 3, 4, 5]);

// From array (removes duplicates)
const arr = [1, 2, 2, 3, 3, 3];
const unique = new Set(arr);  // Set {1, 2, 3}

// From string
const chars = new Set("hello");  // Set {'h', 'e', 'l', 'o'}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ADD / REMOVE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const s = new Set([1, 2, 3]);

// Add (returns the set, allows chaining)
s.add(4);           // Set {1, 2, 3, 4}
s.add(1);           // Set {1, 2, 3, 4} - no change
s.add(5).add(6);    // Chaining

// Delete (returns boolean)
s.delete(6);        // true
s.delete(100);      // false (didn't exist)

// Clear all
s.clear();          // Set {}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MEMBERSHIP TESTING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const s = new Set([1, 2, 3, 4, 5]);

s.has(3);   // true
s.has(10);  // false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SET OPERATIONS (Manual - JS doesn't have built-in)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const a = new Set([1, 2, 3, 4]);
const b = new Set([3, 4, 5, 6]);

// Union
const union = new Set([...a, ...b]);
// Set {1, 2, 3, 4, 5, 6}

// Intersection
const intersection = new Set([...a].filter(x => b.has(x)));
// Set {3, 4}

// Difference (a - b)
const difference = new Set([...a].filter(x => !b.has(x)));
// Set {1, 2}

// Symmetric difference
const symDiff = new Set([...a].filter(x => !b.has(x))
                    .concat([...b].filter(x => !a.has(x))));
// Set {1, 2, 5, 6}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ITERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const s = new Set([1, 2, 3]);

// for...of
for (const elem of s) {
    console.log(elem);
}

// forEach
s.forEach(elem => console.log(elem));

// Convert to array
const arr = [...s];
const arr2 = Array.from(s);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROPERTIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

s.size;  // 3 (not length!)
```

### JavaScript - Common Set Patterns

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PATTERN 1: Remove Duplicates
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const nums = [1, 2, 2, 3, 3, 3, 4];
const unique = [...new Set(nums)];  // [1, 2, 3, 4]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PATTERN 2: Check for Duplicates
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function containsDuplicate(nums) {
    return nums.length !== new Set(nums).size;
}

// Early exit version
function containsDuplicateV2(nums) {
    const seen = new Set();
    for (const num of nums) {
        if (seen.has(num)) return true;
        seen.add(num);
    }
    return false;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PATTERN 3: Find Intersection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function intersection(nums1, nums2) {
    const set1 = new Set(nums1);
    return [...new Set(nums2.filter(n => set1.has(n)))];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PATTERN 4: Visited Set for Graph Traversal
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function bfs(graph, start) {
    const visited = new Set();
    const queue = [start];
    
    while (queue.length > 0) {
        const node = queue.shift();
        if (visited.has(node)) continue;
        
        visited.add(node);
        for (const neighbor of (graph[node] || [])) {
            if (!visited.has(neighbor)) {
                queue.push(neighbor);
            }
        }
    }
    
    return [...visited];
}
```

---

## âš¡ Complexity Analysis

| Operation | Average | Worst | Notes |
|-----------|---------|-------|-------|
| Add | O(1) | O(n) | Amortized with resizing |
| Remove | O(1) | O(n) | Hash collision |
| Contains | O(1) | O(n) | Hash collision |
| Size | O(1) | O(1) | Stored counter |
| Union | O(n+m) | O(n+m) | All elements |
| Intersection | O(min(n,m)) | O(n*m) | Check smaller set |
| Difference | O(n) | O(n) | Check first set |

**Space:** O(n) where n is number of elements

---

## ğŸ”„ Common Patterns

| Pattern | Description | Example |
|---------|-------------|---------|
| Deduplication | Remove duplicate elements | Unique values from list |
| Membership | O(1) existence check | Check if visited |
| Set Operations | Union, intersection, diff | Find common elements |
| Tracking Seen | Record processed items | Graph traversal visited |
| Complement | Find what's missing | Missing numbers |

---

## âš ï¸ Common Mistakes

### 1. Creating Empty Set Wrong in Python

```python
# âŒ WRONG: This is an empty dict!
s = {}
type(s)  # <class 'dict'>

# âœ… CORRECT: Use set()
s = set()
type(s)  # <class 'set'>
```

### 2. Adding Mutable Types

```python
# âŒ WRONG: Lists are not hashable
s = set()
s.add([1, 2, 3])  # TypeError!

# âœ… CORRECT: Use tuple (immutable)
s.add((1, 2, 3))  # Works!
```

### 3. Assuming Order is Preserved

```python
# âŒ WRONG assumption
s = {3, 1, 4, 1, 5}
list(s)  # Could be [1, 3, 4, 5] or any order

# âœ… If you need order, sort explicitly
sorted(s)  # [1, 3, 4, 5]
```

### 4. remove() vs discard()

```python
s = {1, 2, 3}

# âŒ Using remove for potentially missing keys
s.remove(10)  # KeyError!

# âœ… Use discard for safe removal
s.discard(10)  # No error
```

---

## ğŸ“ Practice Problems (Progressive)

| Problem | Difficulty | Focus | Link |
|---------|------------|-------|------|
| Contains Duplicate | ğŸŸ¢ Easy | Basic membership | [LC 217](https://leetcode.com/problems/contains-duplicate/) |
| Intersection of Two Arrays | ğŸŸ¢ Easy | Set intersection | [LC 349](https://leetcode.com/problems/intersection-of-two-arrays/) |
| Set Mismatch | ğŸŸ¢ Easy | Find dup & missing | [LC 645](https://leetcode.com/problems/set-mismatch/) |
| Happy Number | ğŸŸ¢ Easy | Cycle detection | [LC 202](https://leetcode.com/problems/happy-number/) |
| Longest Consecutive | ğŸŸ¡ Medium | Set for O(1) lookup | [LC 128](https://leetcode.com/problems/longest-consecutive-sequence/) |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Practice add, remove, contains
- **Day 3:** Solve 3 membership problems
- **Day 7:** Practice set operations (union, intersection)
- **Day 14:** Solve LC 128 (tricky set usage)
- **Day 30:** Mix of patterns

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>Hash Sets in Interviews</strong></summary>

**When to propose sets:**
> "I need to check if elements exist in O(1), so I'll use a hash set."

**For deduplication:**
> "I'll convert to a set to remove duplicates in O(n) time."

**Trade-off to mention:**
> "Using a set gives O(1) lookup but uses O(n) extra space."

**When interviewers ask about order:**
> "Sets are unordered. If I need order, I can use a list and track seen elements separately, or sort afterward."

</details>

**Company Focus:**

| Company | Set Problems | Notes |
|---------|-------------|-------|
| All | â­â­â­â­â­ | Fundamental |
| Graph problems | Very common | Visited tracking |
| Meta | Common | Combined patterns |

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Master basic operations | 20 min |
| Learn set operations | 15 min |
| Solve 5 basic problems | 1 hour |
| Master patterns | 1-2 hours |

---

> **ğŸ’¡ Key Insight:** Sets are optimized for membership testing and uniqueness. Whenever you need to ask "have I seen this before?" or "is this unique?", think sets.

> **ğŸ”— Related:** [Hash Map Operations](./2.1-Hash-Map-Operations.md) | [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) | [Longest Consecutive](../04-Two-Sum-Pattern/4.4-Longest-Consecutive-LC128.md)
