# 5.2 Complexity Constraints Guide

> **How to read LeetCode's constraints and immediately know which algorithm family to use â€” before you even think about the problem.**
>
> â±ï¸ *Estimated reading: 10 minutes*

---

## ğŸ¯ The Core Idea

LeetCode always tells you the input size in the "Constraints" section. This **single number** eliminates entire families of algorithms:

```
Constraints:
  1 â‰¤ n â‰¤ 10âµ
```

This means: "Your solution MUST be O(n log n) or better. O(nÂ²) will TLE."

How do you know? Because modern judges handle ~10â¸ operations per second, and:
- nÂ² = (10âµ)Â² = 10Â¹â° â†’ **100 seconds** â†’ âŒ TLE
- n log n = 10âµ Ã— 17 â‰ˆ 10â¶Â·Â² â†’ **instant** â†’ âœ… AC

---

## ğŸ“ The Constraints Table

**Memorize this table. It's the most valuable 30 seconds of any problem.**

| Constraint | Max Complexity | Algorithm Families |
|-----------|---------------|-------------------|
| n â‰¤ **10-12** | O(n!) or O(2â¿) | Brute force, permutations, backtracking with no pruning |
| n â‰¤ **20-25** | O(2â¿) | Bitmask DP, subset enumeration, meet-in-the-middle |
| n â‰¤ **100** | O(nÂ³) or O(nâ´) | Triple/quadruple nested loops, Floyd-Warshall, matrix DP |
| n â‰¤ **500** | O(nÂ³) | DP with 3 dimensions, all-pairs shortest path |
| n â‰¤ **5,000** | O(nÂ²) | Quadratic DP (LCS, Edit Distance), nested Two Pointers |
| n â‰¤ **10âµ** | O(n log n) | Sorting + scan, merge sort, segment trees, balanced BST |
| n â‰¤ **10â¶** | O(n) | Linear scan, two pointers, sliding window, hash map, BFS/DFS |
| n â‰¤ **10â·** | O(n) | Linear only â€” even O(n log n) is borderline |
| n â‰¤ **10â¹** | O(âˆšn) or O(log n) | Binary search, math formulas, sqrt decomposition |
| n â‰¤ **10Â¹â¸** | O(log n) | Binary search on answer, fast exponentiation, math |

---

## ğŸ“ How to Use This in Practice

### Step 1: Read the Constraints FIRST

Before understanding the problem deeply, glance at constraints:

```
n â‰¤ 10âµ â†’ "I need O(n log n) or better"
n â‰¤ 5000 â†’ "O(nÂ²) is fine"
n â‰¤ 20 â†’ "I can brute-force with bitmask"
```

### Step 2: Eliminate Impossible Approaches

```
n = 10âµ
âŒ O(nÂ²) â€” 10Â¹â° operations â€” impossible
âŒ O(nÂ² log n) â€” even worse
âœ… O(n log n) â€” ~1.7M operations â€” great
âœ… O(n) â€” ~100K operations â€” even better
```

### Step 3: Match Remaining Approaches to the Problem

Now you know the FAMILY of solutions. Match with the problem type:

```
n â‰¤ 10âµ + "find pair" â†’ Two Pointers O(n) or Hash Map O(n)
n â‰¤ 10âµ + "contiguous subarray" â†’ Sliding Window O(n)
n â‰¤ 10âµ + "sorted" â†’ Binary Search O(log n) or Two Pointers O(n)
n â‰¤ 5000 + "transform A to B" â†’ DP O(nÂ²) (Edit Distance, LCS)
```

---

## ğŸ’» Real Examples

### Example 1: Two Sum (LC 1)

```
Constraints: 2 â‰¤ n â‰¤ 10â´
```

- n â‰¤ 10â´ â†’ O(nÂ²) is borderline, O(n) preferred
- O(nÂ²) brute force: check all pairs â†’ works but slow
- O(n) hash map: store complements â†’ optimal âœ…

### Example 2: Longest Common Subsequence (LC 1143)

```
Constraints: 1 â‰¤ m, n â‰¤ 1000
```

- m Ã— n â‰¤ 10â¶ â†’ O(m Ã— n) DP is fine âœ…
- That's why the classic 2D DP table works here

### Example 3: Koko Eating Bananas (LC 875)

```
Constraints: 1 â‰¤ piles.length â‰¤ 10â´, 1 â‰¤ piles[i] â‰¤ 10â¹
```

- Notice: piles[i] up to 10â¹ â†’ can't iterate over all speeds 1 to max
- But we can **binary search** on speed: O(n Ã— log(max)) â‰ˆ 10â´ Ã— 30 â‰ˆ 300K âœ…

### Example 4: Subsets (LC 78)

```
Constraints: 1 â‰¤ nums.length â‰¤ 10
```

- n â‰¤ 10 â†’ O(2â¿) = 1024 â†’ trivially fast
- Backtracking/bitmask: generate all 2Â¹â° subsets âœ…
- If n were 10âµ, this approach would be impossible (2^100000 is infinite)

### Example 5: Trapping Rain Water (LC 42)

```
Constraints: n â‰¤ 2 Ã— 10â´
```

- n â‰¤ 20,000 â†’ O(nÂ²) works (400M â€” tight but passable)
- But O(n) two-pointer solution exists â†’ preferred âœ…

---

## ğŸ“ Decision Flowchart

```
Read n from constraints
â”‚
â”œâ”€â”€ n â‰¤ 20?
â”‚   â””â”€â”€ Try ALL possibilities (2â¿, n!, bitmask DP)
â”‚
â”œâ”€â”€ n â‰¤ 5000?
â”‚   â””â”€â”€ O(nÂ²) is fine â†’ nested loops, quadratic DP
â”‚
â”œâ”€â”€ n â‰¤ 10âµ?
â”‚   â”œâ”€â”€ Need sorting? â†’ sort + O(n) scan = O(n log n) âœ…
â”‚   â”œâ”€â”€ Pattern-based? â†’ Two Pointers, Sliding Window O(n)
â”‚   â””â”€â”€ Tree/Graph? â†’ DFS/BFS O(V+E) âœ…
â”‚
â”œâ”€â”€ n â‰¤ 10â¶?
â”‚   â””â”€â”€ O(n) only â€” hash map, counting sort, linear scan
â”‚
â””â”€â”€ n â‰¤ 10â¹ or 10Â¹â¸?
    â””â”€â”€ O(log n) â€” binary search on answer, math formula
```

---

## âš ï¸ Common Mistakes

| Mistake | Reality |
|---------|---------|
| "O(nÂ²) always TLEs" | Fine when n â‰¤ 5000 |
| "Brute force is never acceptable" | When n â‰¤ 15, brute force IS the expected solution |
| "I should optimize first" | Start with the approach the constraints allow, then optimize if time permits |
| Ignoring the constraint on VALUES | n â‰¤ 100 items but values up to 10â¹ â†’ can't create value-indexed array |
| Ignoring multiple constraints | n â‰¤ 10âµ AND m â‰¤ 10âµ â†’ O(n Ã— m) = 10Â¹â° âŒ, need O(n + m) or O(n log m) |

---

## ğŸ“ Two-Dimensional Constraints

When there are two input sizes:

```
Constraints: 1 â‰¤ m â‰¤ 100, 1 â‰¤ n â‰¤ 100
```

Check the PRODUCT:
- m Ã— n â‰¤ 10,000 â†’ O(m Ã— n) fine
- m Ã— n Ã— max(m,n) â‰¤ 10â¶ â†’ O(m Ã— n Ã— min) fine
- m Ã— n > 10â¸ â†’ need sub-quadratic approach

| Grid Size | Allowed | Example |
|-----------|---------|---------|
| 100 Ã— 100 | O(m Ã— n Ã— (m+n)) | Floyd-Warshall on small graph |
| 1000 Ã— 1000 | O(m Ã— n) | Standard 2D DP |
| 10âµ Ã— 10âµ | O(m + n) | Can't even store the grid! |

---

## ğŸ“ Quick Reference Card

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘       CONSTRAINTS â†’ ALGORITHM GUIDE          â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                              â•‘
â•‘  n â‰¤ 12    â†’ Brute force / Backtrack (n!)    â•‘
â•‘  n â‰¤ 25    â†’ Bitmask DP (2â¿)                â•‘
â•‘  n â‰¤ 100   â†’ O(nÂ³) OK                       â•‘
â•‘  n â‰¤ 5000  â†’ O(nÂ²) OK                       â•‘
â•‘  n â‰¤ 10âµ   â†’ O(n log n) needed              â•‘
â•‘  n â‰¤ 10â¶   â†’ O(n) needed                    â•‘
â•‘  n â‰¤ 10â¹   â†’ O(âˆšn) or O(log n) needed       â•‘
â•‘  n â‰¤ 10Â¹â¸  â†’ O(log n) needed                â•‘
â•‘                                              â•‘
â•‘  RULE: ~10â¸ operations â‰ˆ 1 second            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

> **ğŸ’¡ Key Insight:** Reading constraints is the highest-ROI skill in competitive programming. It takes 5 seconds and eliminates 80% of wrong approaches. ALWAYS read constraints before thinking about the algorithm.

---

â† [5.1 UMPIRE Method](./5.1-UMPIRE-Method.md) | **Back to:** [Prerequisites Index](../00-Prerequisites.md)
