# Hash Map Operations

> **Hash maps store key-value pairs with O(1) average access time for insert, lookup, and delete.**

Hash maps (also called dictionaries, associative arrays, or hash tables) are one of the most versatile data structures. Mastering their operations is essential for solving a wide range of interview problems.

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>When to Use Hash Maps</strong></summary>

**Problem signals:**
- "Find if X exists" â†’ O(1) lookup
- "Count occurrences" â†’ value = count
- "Find complement" â†’ store seen elements
- "Group by property" â†’ key = property
- "Cache results" â†’ memoization
- "Map A to B" â†’ transformation tracking

**Built-in implementations:**
- Python: `dict`, `defaultdict`, `Counter`
- JavaScript: `Map`, `Object`, `{}`
- Java: `HashMap`, `LinkedHashMap`
- C++: `unordered_map`

</details>

---

## âœ… Core Operations

| Operation | Python | JavaScript | Time |
|-----------|--------|------------|------|
| Create | `d = {}` | `m = new Map()` | O(1) |
| Insert | `d[key] = val` | `m.set(key, val)` | O(1)* |
| Lookup | `d[key]` or `d.get(key)` | `m.get(key)` | O(1)* |
| Delete | `del d[key]` | `m.delete(key)` | O(1)* |
| Check exists | `key in d` | `m.has(key)` | O(1)* |
| Get size | `len(d)` | `m.size` | O(1) |
| Iterate | `for k, v in d.items()` | `for [k, v] of m` | O(n) |

*Average case - worst case is O(n) due to collisions

## âŒ When NOT to Use Hash Maps

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need sorted keys | Hash maps unordered | TreeMap, sorted array |
| Range queries | Can't find [a, b] efficiently | Segment tree, BST |
| Memory-constrained | Extra space overhead | In-place algorithms |
| Small fixed key range | Array is faster | Direct indexing |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- [What Is Hashing](../01-Hash-Fundamentals/1.1-What-Is-Hashing.md)
- Basic array operations

**After this, learn:**
- [Hash Set Operations](./2.2-Hash-Set-Operations.md)
- [Two Sum Pattern](../04-Two-Sum-Pattern/4.1-Two-Sum-Overview.md)
- [Frequency Pattern](../03-Frequency-Pattern/3.1-Frequency-Overview.md)
- [Grouping Pattern](../06-Grouping-Pattern/6.1-Grouping-Overview.md)

**Combines with:**
- Arrays for indexing
- Linked lists for chaining
- Trees for ordered maps

</details>

---

## ğŸ“ How It Works

### Basic Operations Visualization

```
Hash Map: {"apple": 5, "banana": 3, "cherry": 7}

INSERT d["date"] = 2:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Before: {apple:5, banana:3, cherry:7}       â”‚
â”‚ After:  {apple:5, banana:3, cherry:7, date:2} â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

LOOKUP d["banana"]:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ hash("banana") â†’ bucket index               â”‚
â”‚ Search bucket â†’ found ("banana", 3)         â”‚
â”‚ Return: 3                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

DELETE del d["apple"]:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Before: {apple:5, banana:3, cherry:7, date:2} â”‚
â”‚ After:  {banana:3, cherry:7, date:2}        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Common Operation Patterns

```
Pattern 1: Counting
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
counts = {}
for item in items:
    counts[item] = counts.get(item, 0) + 1

Pattern 2: Grouping
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
groups = {}
for item in items:
    key = get_key(item)
    if key not in groups:
        groups[key] = []
    groups[key].append(item)

Pattern 3: Two Sum / Complement
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
seen = {}
for i, num in enumerate(nums):
    complement = target - num
    if complement in seen:
        return [seen[complement], i]
    seen[num] = i
```

---

## ğŸ’» Code Implementation

### Python - Essential Operations

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CREATING HASH MAPS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Empty dict
d = {}
d = dict()

# With initial values
d = {"apple": 5, "banana": 3}
d = dict(apple=5, banana=3)  # Only works for string keys

# From list of tuples
d = dict([("a", 1), ("b", 2)])

# Dict comprehension
d = {x: x**2 for x in range(5)}  # {0:0, 1:1, 2:4, 3:9, 4:16}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INSERT / UPDATE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

d = {}

# Simple insert
d["key"] = "value"

# Update multiple
d.update({"key2": "val2", "key3": "val3"})

# Conditional insert (only if not exists)
d.setdefault("key", "default_value")  # Returns existing or sets default

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LOOKUP / ACCESS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

d = {"apple": 5, "banana": 3}

# Direct access (raises KeyError if missing)
value = d["apple"]  # 5

# Safe access with default
value = d.get("orange", 0)  # 0 (key not found)
value = d.get("apple", 0)   # 5 (key found)

# Check existence
if "apple" in d:
    print(d["apple"])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DELETE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

d = {"a": 1, "b": 2, "c": 3}

# Remove specific key (raises KeyError if missing)
del d["a"]

# Remove and return value
value = d.pop("b")  # Returns 2, removes key

# Safe remove (no error if missing)
value = d.pop("z", None)  # Returns None if missing

# Remove and return last inserted (Python 3.7+)
key, value = d.popitem()

# Clear all
d.clear()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ITERATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

d = {"a": 1, "b": 2, "c": 3}

# Keys only
for key in d:
    print(key)

for key in d.keys():
    print(key)

# Values only
for value in d.values():
    print(value)

# Both key and value
for key, value in d.items():
    print(f"{key}: {value}")

# Get all as lists
keys_list = list(d.keys())
values_list = list(d.values())
items_list = list(d.items())

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# USEFUL METHODS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

d = {"a": 1, "b": 2}

len(d)          # 2 - number of keys
"a" in d        # True - key exists
"z" not in d    # True - key doesn't exist
list(d)         # ["a", "b"] - list of keys
```

### Python - defaultdict and Counter

```python
from collections import defaultdict, Counter

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# defaultdict - Auto-initializes missing keys
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# For counting (default to 0)
counts = defaultdict(int)
for item in ["a", "b", "a", "c"]:
    counts[item] += 1  # No KeyError!
# {"a": 2, "b": 1, "c": 1}

# For grouping (default to empty list)
groups = defaultdict(list)
for word in ["apple", "ant", "banana", "bat"]:
    groups[word[0]].append(word)  # No need to check if key exists!
# {"a": ["apple", "ant"], "b": ["banana", "bat"]}

# For nested dicts
nested = defaultdict(dict)
nested["outer"]["inner"] = "value"

# For sets
unique_per_key = defaultdict(set)
unique_per_key["category"].add("item1")
unique_per_key["category"].add("item1")  # Duplicate, set ignores
# {"category": {"item1"}}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Counter - Specialized for counting
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Count elements
c = Counter(["a", "b", "a", "c", "a", "b"])
# Counter({"a": 3, "b": 2, "c": 1})

# From string
c = Counter("mississippi")
# Counter({"i": 4, "s": 4, "p": 2, "m": 1})

# Most common elements
c.most_common(2)  # [("i", 4), ("s", 4)]

# Arithmetic with Counters
c1 = Counter(["a", "b", "a"])
c2 = Counter(["a", "c"])
c1 + c2  # Counter({"a": 3, "b": 1, "c": 1})
c1 - c2  # Counter({"a": 1, "b": 1}) - removes 0/negative

# Access count (0 for missing, no KeyError)
c = Counter(["a", "a"])
c["a"]  # 2
c["z"]  # 0 (not KeyError!)

# Update counts
c.update(["a", "b"])  # Add more
c.subtract(["a"])     # Subtract counts
```

### JavaScript - Map Operations

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CREATING MAPS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Empty Map
const m = new Map();

// With initial values
const m2 = new Map([
    ["apple", 5],
    ["banana", 3]
]);

// From object
const obj = { a: 1, b: 2 };
const m3 = new Map(Object.entries(obj));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INSERT / UPDATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const m = new Map();

// Insert
m.set("key", "value");

// Chained inserts
m.set("a", 1).set("b", 2).set("c", 3);

// Update (same as insert)
m.set("key", "new_value");

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOOKUP / ACCESS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const m = new Map([["apple", 5], ["banana", 3]]);

// Get value (returns undefined if missing)
m.get("apple");  // 5
m.get("orange"); // undefined

// Check existence
m.has("apple");  // true
m.has("orange"); // false

// Get with default
const value = m.get("orange") ?? 0;  // 0 (default)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DELETE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const m = new Map([["a", 1], ["b", 2], ["c", 3]]);

// Remove specific key
m.delete("a");  // true if existed, false otherwise

// Clear all
m.clear();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ITERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const m = new Map([["a", 1], ["b", 2], ["c", 3]]);

// Keys
for (const key of m.keys()) {
    console.log(key);
}

// Values
for (const value of m.values()) {
    console.log(value);
}

// Entries (key-value pairs)
for (const [key, value] of m.entries()) {
    console.log(`${key}: ${value}`);
}

// Same as entries (default iterator)
for (const [key, value] of m) {
    console.log(`${key}: ${value}`);
}

// forEach
m.forEach((value, key) => {
    console.log(`${key}: ${value}`);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USEFUL PROPERTIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

m.size;  // Number of entries
```

### JavaScript - Object as Hash Map

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAIN OBJECTS (for string keys only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Create
const obj = {};
const obj2 = { apple: 5, banana: 3 };

// Insert / Update
obj["key"] = "value";
obj.key2 = "value2";

// Lookup
obj["key"];     // "value"
obj.key2;       // "value2"
obj["missing"]; // undefined

// Check existence
"key" in obj;           // true
obj.hasOwnProperty("key"); // true (preferred)

// Delete
delete obj["key"];

// Iterate
for (const key in obj) {
    if (obj.hasOwnProperty(key)) {  // Avoid inherited properties
        console.log(`${key}: ${obj[key]}`);
    }
}

Object.keys(obj);    // ["key2"]
Object.values(obj);  // ["value2"]
Object.entries(obj); // [["key2", "value2"]]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Map vs Object
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Use Map when:
// - Keys are not strings
// - Need to maintain insertion order (< ES6)
// - Frequent additions/deletions
// - Need .size property

// Use Object when:
// - Keys are strings
// - Need JSON serialization
// - Simple key-value storage
// - Working with object literals
```

---

## âš¡ Complexity Analysis

| Operation | Average | Worst | Notes |
|-----------|---------|-------|-------|
| Insert | O(1) | O(n) | Amortized with resizing |
| Lookup | O(1) | O(n) | O(n) only with all collisions |
| Delete | O(1) | O(n) | Same as lookup |
| Iterate | O(n) | O(n) | Must visit all entries |
| Clear | O(1)* | O(n) | Implementation dependent |
| Keys/Values/Items | O(n) | O(n) | Creates new list |

**Space:** O(n) where n is number of stored entries

---

## ğŸ”„ Common Patterns with Hash Maps

| Pattern | Description | Example |
|---------|-------------|---------|
| Counting | Value = count | Word frequency |
| Two Sum | Store complement | Find pairs |
| Grouping | Key = property | Anagrams |
| Caching | Memoization | Fibonacci |
| Mapping | A â†’ B relationship | Isomorphic strings |
| Deduplication | Track seen items | Unique elements |

---

## âš ï¸ Common Mistakes

### 1. Not Handling Missing Keys

```python
# âŒ WRONG: KeyError if missing
d = {}
value = d["missing"]  # KeyError!

# âœ… CORRECT: Use get() or check first
value = d.get("missing", 0)
# OR
if "missing" in d:
    value = d["missing"]
```

### 2. Modifying Dict While Iterating

```python
# âŒ WRONG: RuntimeError in Python
d = {"a": 1, "b": 2, "c": 3}
for key in d:
    if d[key] == 2:
        del d[key]  # RuntimeError!

# âœ… CORRECT: Iterate over copy
for key in list(d.keys()):
    if d[key] == 2:
        del d[key]
```

### 3. Using Mutable Types as Keys

```python
# âŒ WRONG: Lists are mutable, not hashable
d = {[1, 2]: "value"}  # TypeError!

# âœ… CORRECT: Use immutable tuple
d = {(1, 2): "value"}  # Works!
```

### 4. JavaScript Object Key Coercion

```javascript
// âŒ WRONG: Object keys are always strings
const obj = {};
obj[1] = "one";
obj["1"] = "string one";
console.log(obj[1]);  // "string one" - overwritten!

// âœ… CORRECT: Use Map for non-string keys
const m = new Map();
m.set(1, "one");
m.set("1", "string one");
console.log(m.get(1));   // "one"
console.log(m.get("1")); // "string one"
```

---

## ğŸ“ Practice Problems (Progressive)

| Problem | Difficulty | Pattern | Link |
|---------|------------|---------|------|
| Two Sum | ğŸŸ¢ Easy | Complement lookup | [LC 1](https://leetcode.com/problems/two-sum/) |
| Valid Anagram | ğŸŸ¢ Easy | Frequency counting | [LC 242](https://leetcode.com/problems/valid-anagram/) |
| Group Anagrams | ğŸŸ¡ Medium | Grouping | [LC 49](https://leetcode.com/problems/group-anagrams/) |
| Subarray Sum K | ğŸŸ¡ Medium | Prefix + hash | [LC 560](https://leetcode.com/problems/subarray-sum-equals-k/) |
| LRU Cache | ğŸŸ¡ Medium | Map + linked list | [LC 146](https://leetcode.com/problems/lru-cache/) |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Practice basic operations (insert, get, delete)
- **Day 3:** Solve 3 counting problems
- **Day 7:** Solve 3 grouping problems
- **Day 14:** Mix of patterns
- **Day 30:** Timed practice

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>Hash Maps in Interviews</strong></summary>

**First instinct for many problems:**
> "I'll use a hash map for O(1) lookup."

**Trade-off to mention:**
> "This gives O(n) space complexity, trading space for time."

**When explaining:**
> "I'm storing [what] as keys and [what] as values because..."

**Follow-up readiness:**
- What if memory is limited?
- What's the worst-case time complexity?
- Can you do it in O(1) space?

</details>

**Company Focus:**

| Company | Hash Map Problems | Notes |
|---------|------------------|-------|
| All | â­â­â­â­â­ | Fundamental |
| Meta | Very common | Often combined |
| Google | Very common | May ask implementation |
| Amazon | Very common | Practical problems |

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Master basic operations | 30 min |
| Learn defaultdict/Counter | 20 min |
| Solve 5 basic problems | 1 hour |
| Master patterns | 2-3 hours |

---

> **ğŸ’¡ Key Insight:** Hash maps are the "Swiss Army knife" of data structures. When you need fast lookup, counting, grouping, or finding complements, hash maps should be your first consideration.

> **ğŸ”— Related:** [Hash Set Operations](./2.2-Hash-Set-Operations.md) | [Two Sum Pattern](../04-Two-Sum-Pattern/4.1-Two-Sum-Overview.md) | [Frequency Pattern](../03-Frequency-Pattern/3.1-Frequency-Overview.md)
