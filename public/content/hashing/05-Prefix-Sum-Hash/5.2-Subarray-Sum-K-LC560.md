# Subarray Sum Equals K (LeetCode 560)

> **Count subarrays with a target sum using prefix sums and hash maps.**

Given an array of integers `nums` and an integer `k`, return the total number of subarrays whose sum equals to `k`.

A subarray is a contiguous non-empty sequence of elements within an array.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem signals:**
- "Count subarrays" (not subsequences)
- "Sum equals k"
- Contiguous elements
- Need to count, not just find one

**Pattern identification:**
```
This is the classic Prefix Sum + Hash Map problem.

Insight: sum(arr[i:j]) = prefix[j] - prefix[i-1]
If we want sum = k:
    prefix[j] - prefix[i-1] = k
    prefix[i-1] = prefix[j] - k

So for each position, count how many previous prefixes
equal (current_prefix - k).
```

</details>

---

## ‚úÖ When to Use

- Counting ALL subarrays with sum k
- Array contains negative numbers (so sliding window won't work)
- Need O(n) time solution
- Subarray, not subsequence

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Positive numbers only + find shortest | Sliding window works | Sliding window |
| Find indices of one subarray | Simpler variation | Store index not count |
| Maximum subarray sum | Different objective | Kadane's algorithm |
| Subsequence not subarray | Not contiguous | DP |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- [Prefix Sum Basics](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/03-Prefix-Sum.md)
- [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
- [Two Sum Pattern](../04-Two-Sum-Pattern/4.1-Two-Sum-Overview.md)

**After mastering:**
- [Continuous Subarray Sum (LC 523)](./5.3-Continuous-Subarray-LC523.md)
- Subarray Sums Divisible by K (LC 974)
- Binary Subarrays With Sum (LC 930)

**Combines with:**
- Prefix sum for efficient range sums
- Hash map for O(1) complement lookup

</details>

---

## üìê How It Works

### Problem Examples

```
Example 1:
Input: nums = [1,1,1], k = 2
Output: 2
Explanation: [1,1] (indices 0-1) and [1,1] (indices 1-2)

Example 2:
Input: nums = [1,2,3], k = 3
Output: 2
Explanation: [1,2] and [3]

Example 3 (with negatives):
Input: nums = [1,-1,0], k = 0
Output: 3
Explanation: [1,-1], [-1,0,1... wait, that's wrong], [0], [1,-1,0]
Actually: [1,-1], [0], [1,-1,0]
```

### Why Brute Force is Too Slow

```python
# O(n¬≤) or O(n¬≥) - TLE for large inputs
count = 0
for i in range(n):
    for j in range(i, n):
        if sum(nums[i:j+1]) == k:  # O(n) per check
            count += 1
```

### The Optimal Approach

```
nums = [1, 2, 3], k = 3

Step by step:
prefix_count = {0: 1}  # Initialize with 0

i=0: num=1
     prefix = 1
     complement = 1 - 3 = -2 (not in map)
     count = 0
     prefix_count = {0:1, 1:1}

i=1: num=2
     prefix = 3
     complement = 3 - 3 = 0 (in map, count=1!)
     count = 1  ‚Üê Found subarray [0:2] = [1,2]
     prefix_count = {0:1, 1:1, 3:1}

i=2: num=3
     prefix = 6
     complement = 6 - 3 = 3 (in map, count=1!)
     count = 2  ‚Üê Found subarray [2:3] = [3]
     prefix_count = {0:1, 1:1, 3:1, 6:1}

Result: 2
```

### Visualization

```
nums:    [  1,    2,    3  ]
index:      0     1     2

prefix:  [  1,    3,    6  ]

For each prefix, look for (prefix - k):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Index   ‚îÇ Prefix ‚îÇ Need      ‚îÇ Found?      ‚îÇ Count +=  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 0       ‚îÇ 1      ‚îÇ 1-3 = -2  ‚îÇ No          ‚îÇ 0         ‚îÇ
‚îÇ 1       ‚îÇ 3      ‚îÇ 3-3 = 0   ‚îÇ Yes (init)  ‚îÇ 1         ‚îÇ
‚îÇ 2       ‚îÇ 6      ‚îÇ 6-3 = 3   ‚îÇ Yes (idx 1) ‚îÇ 1         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Total count = 2
```

---

## üíª Code Implementation

### Python Solution

```python
from collections import defaultdict
from typing import List

class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        """
        Count subarrays with sum equal to k.
        
        Pattern: Prefix Sum + Hash Map
        
        Key insight: If prefix[j] - prefix[i] = k,
        then subarray from i+1 to j sums to k.
        
        Time: O(n) - single pass
        Space: O(n) - hash map stores at most n prefixes
        """
        count = 0
        prefix = 0
        # Map: prefix_sum -> how many times we've seen it
        prefix_count = defaultdict(int)
        prefix_count[0] = 1  # Empty prefix (for subarrays starting at 0)
        
        for num in nums:
            # Update running prefix sum
            prefix += num
            
            # How many previous prefixes give us sum k?
            # If prefix - k exists, we found subarray(s)
            complement = prefix - k
            count += prefix_count[complement]
            
            # Record this prefix sum
            prefix_count[prefix] += 1
        
        return count
```

### Python - With Detailed Comments

```python
def subarraySum(nums: List[int], k: int) -> int:
    """Verbose version with detailed explanation."""
    count = 0
    prefix = 0
    prefix_count = {0: 1}  # Why 0:1? See below.
    
    # Why initialize with {0: 1}?
    # If nums[0:i] sums to exactly k, then prefix = k
    # We need prefix - k = 0 to exist in our map
    # Without it, we'd miss subarrays starting at index 0
    
    for num in nums:
        prefix += num
        
        # The key insight:
        # sum(nums[i:j+1]) = prefix[j] - prefix[i-1]
        # If this sum = k, then:
        #   prefix[j] - prefix[i-1] = k
        #   prefix[i-1] = prefix[j] - k
        #
        # So we check: how many times have we seen prefix - k?
        # Each occurrence gives us a valid subarray!
        
        complement = prefix - k
        if complement in prefix_count:
            count += prefix_count[complement]
        
        # Add current prefix to map
        prefix_count[prefix] = prefix_count.get(prefix, 0) + 1
    
    return count
```

### JavaScript Solution

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function(nums, k) {
    let count = 0;
    let prefix = 0;
    const prefixCount = new Map([[0, 1]]);  // Initialize with 0
    
    for (const num of nums) {
        prefix += num;
        
        // Check for complement
        const complement = prefix - k;
        if (prefixCount.has(complement)) {
            count += prefixCount.get(complement);
        }
        
        // Record this prefix
        prefixCount.set(prefix, (prefixCount.get(prefix) || 0) + 1);
    }
    
    return count;
};
```

### JavaScript - Alternative with Object

```javascript
var subarraySum = function(nums, k) {
    let count = 0;
    let prefix = 0;
    const prefixCount = { 0: 1 };  // Plain object
    
    for (const num of nums) {
        prefix += num;
        
        // Check complement
        if (prefixCount[prefix - k] !== undefined) {
            count += prefixCount[prefix - k];
        }
        
        // Record prefix
        prefixCount[prefix] = (prefixCount[prefix] || 0) + 1;
    }
    
    return count;
};
```

---

## ‚ö° Complexity Analysis

| Aspect | Complexity | Explanation |
|--------|------------|-------------|
| Time | O(n) | Single pass through array |
| Space | O(n) | Hash map with at most n unique prefixes |

**Detailed breakdown:**
- Each element visited once: O(n)
- Hash map lookup/insert: O(1) average
- Total: O(n)

**Space usage:**
- In worst case, all prefix sums are unique ‚Üí O(n) entries
- Best case: Many repeated prefixes ‚Üí fewer entries

**Comparison with brute force:**

| Approach | Time | Space |
|----------|------|-------|
| Brute force (nested loops + sum) | O(n¬≥) | O(1) |
| Brute force (with prefix array) | O(n¬≤) | O(n) |
| Prefix + Hash Map | O(n) | O(n) |

---

## üîÑ Variations

| Variation | Key Change | Problem |
|-----------|------------|---------|
| Find indices of one subarray | Store index, not count | Interview variant |
| Longest subarray with sum k | Store first index only | LC 325 |
| Shortest subarray with sum k | Store last index | Variation |
| Sum divisible by k | Use modular arithmetic | LC 974 |
| Binary array sum equals k | Simpler (only 0s and 1s) | LC 930 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Initialize {0: 1}

```python
# ‚ùå WRONG
prefix_count = {}  # Missing!

# Example: nums = [3], k = 3
# prefix = 3, complement = 0
# 0 not in empty map ‚Üí misses this valid subarray!

# ‚úÖ CORRECT
prefix_count = {0: 1}
```

### 2. Adding to Map Before Checking

```python
# ‚ùå WRONG ORDER
prefix_count[prefix] += 1  # Added first
count += prefix_count[prefix - k]  # Checked after

# ‚úÖ CORRECT ORDER
count += prefix_count[prefix - k]  # Check first
prefix_count[prefix] += 1  # Then add
```

**Why it matters:** If k = 0, we'd count the current prefix as a valid "previous" prefix!

### 3. Not Handling Negative Numbers

```python
# Note: This solution WORKS with negatives
# That's why we can't use sliding window here

nums = [1, -1, 1, -1], k = 0
# Multiple valid subarrays: [1,-1], [-1,1], [1,-1,1,-1], etc.
```

### 4. Confusing with Two Sum

```python
# Two Sum: find TWO elements summing to target
# This problem: find SUBARRAY (contiguous) summing to target

# Two Sum:      nums[i] + nums[j] = k
# Subarray Sum: sum(nums[i:j+1]) = k
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Key Insight | Link |
|---------|------------|-------------|------|
| Subarray Sum Equals K | üü° Medium | Classic prefix + hash | [LC 560](https://leetcode.com/problems/subarray-sum-equals-k/) |
| Binary Subarrays With Sum | üü° Medium | Only 0s and 1s | [LC 930](https://leetcode.com/problems/binary-subarrays-with-sum/) |
| Continuous Subarray Sum | üü° Medium | Multiple of k | [LC 523](https://leetcode.com/problems/continuous-subarray-sum/) |
| Max Size Subarray Sum K | üü° Medium | Store first index | [LC 325](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/) |
| Subarray Sums Divisible by K | üü° Medium | Modular arithmetic | [LC 974](https://leetcode.com/problems/subarray-sums-divisible-by-k/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve LC 560, understand prefix insight
- **Day 3:** Solve without looking, explain why {0:1}
- **Day 7:** Solve LC 930 (binary version)
- **Day 14:** Solve LC 974 (divisible by k)
- **Day 30:** < 8 min for LC 560

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interview</strong></summary>

**Start with clarification:**
> "Just to confirm - we want contiguous subarrays, and I should count all of them, not just find one?"

**Explain brute force first:**
> "Brute force would check all O(n¬≤) subarrays, which is too slow. I'll use a prefix sum optimization."

**Key insight to verbalize:**
> "The sum of any subarray equals the difference of two prefix sums. So instead of checking all pairs, I'll use a hash map to find complements in O(1)."

**Walk through example:**
> "Let me trace through [1,2,3] with k=3..."

**Edge cases to mention:**
- Negative numbers (handled naturally)
- k = 0 (need repeated prefix sums)
- Empty subarrays (not valid per problem)

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common, expect follow-ups |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Classic problem |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard interview |
| Bloomberg | ‚≠ê‚≠ê‚≠ê‚≠ê | Frequently asked |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Occasionally asked |

---

## ‚è±Ô∏è Time Estimates

| Activity | Target Time |
|----------|-------------|
| Recognize pattern | 1-2 min |
| Implement solution | 8-10 min |
| Trace through example | 2-3 min |
| Discuss complexity | 1-2 min |
| Total | 12-17 min |

---

> **üí° Key Insight:** The prefix sum transforms "find subarray sum = k" into "find two prefixes with difference k" - a hash map problem we already know how to solve (like Two Sum).

> **üîó Related:** [Prefix Hash Overview](./5.1-Prefix-Hash-Overview.md) | [Two Sum](../04-Two-Sum-Pattern/4.2-Two-Sum-LC1.md) | [Continuous Subarray Sum](./5.3-Continuous-Subarray-LC523.md)
