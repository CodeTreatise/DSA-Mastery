# 8.2 Self-Balancing BST Overview

## Introduction

Standard BSTs can become unbalanced (skewed), degrading O(log n) operations to O(n). Self-balancing BSTs automatically maintain balance after insertions and deletions, guaranteeing O(log n) performance.

---

## üéØ Why Self-Balancing?

```
Unbalanced BST (inserting 1, 2, 3, 4, 5 in order):

1
 \
  2           Height: O(n)
   \          Search: O(n)
    3         Insert: O(n)
     \
      4
       \
        5

Balanced BST (same elements):

      3
     / \       Height: O(log n)
    2   4      Search: O(log n)
   /     \     Insert: O(log n)
  1       5
```

---

## ‚úÖ When to Use Self-Balancing BST

- Frequent insertions/deletions with searches
- Need guaranteed O(log n) worst case
- Dynamic ordered data (can't just sort once)
- Range queries with updates

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Static data | Extra overhead | Sort once + binary search |
| Only insertions (no search) | Balance not needed | Append to list |
|" Need O(1) lookup "| BST is O(log n) | Hash table |
| Very small datasets | Overhead not worth it | Simple array |

---

## üìê Types of Self-Balancing BSTs

### 1. AVL Tree (Adelson-Velsky and Landis)

**Property:** Height of left and right subtrees differ by at most 1.

```
Balance Factor = height(left) - height(right)
Valid values: -1, 0, +1

        10 (BF=0)
       /  \
      5    15 (BF=-1)
     / \      \
    3   7     20
```

**Operations:**
- Maintain balance factor at each node
- Rebalance using rotations when |BF| > 1

**Rotations:**
```
Right Rotation (LL case):    Left Rotation (RR case):
    z                             x
   / \                           / \
  y   T4                       T1   y
 / \       =>                      / \
x   T3                           T2   z
/ \                                  / \
T1 T2                              T3  T4
```

**Python Conceptual:**
```python
class AVLNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1

def get_height(node):
    return node.height if node else 0

def get_balance(node):
    return get_height(node.left) - get_height(node.right) if node else 0

def right_rotate(z):
    y = z.left
    T3 = y.right
    
    y.right = z
    z.left = T3
    
    z.height = 1 + max(get_height(z.left), get_height(z.right))
    y.height = 1 + max(get_height(y.left), get_height(y.right))
    
    return y

def left_rotate(x):
    y = x.right
    T2 = y.left
    
    y.left = x
    x.right = T2
    
    x.height = 1 + max(get_height(x.left), get_height(x.right))
    y.height = 1 + max(get_height(y.left), get_height(y.right))
    
    return y
```

**Pros:** Strictly balanced, faster lookups
**Cons:** More rotations on insert/delete

---

### 2. Red-Black Tree

**Property:** Each node is colored red or black with specific rules.

**Rules:**
1. Every node is red or black
2. Root is black
3. Leaves (NIL) are black
4. Red nodes have black children
5. All paths from node to leaves have same black count

```
        8(B)
       /    \
      4(R)   12(R)
     /  \    /   \
   2(B) 6(B) 10(B) 14(B)
```

**Pros:** Fewer rotations than AVL, good for insertions
**Cons:** Slightly less balanced than AVL

**Used in:**
- Java TreeMap, TreeSet
- C++ std::map, std::set
- Linux kernel

---

### 3. B-Tree / B+ Tree

**Property:** Each node can have multiple keys and children.

```
B-Tree of order 3:
            [10, 20]
           /   |   \
      [5,7]  [15]  [25,30]
```

**Pros:** Fewer disk accesses, good for databases
**Cons:** More complex, overkill for in-memory

**Used in:**
- Database indexes (MySQL, PostgreSQL)
- File systems

---

### 4. Splay Tree

**Property:** Recently accessed elements move to root (self-organizing).

**Pros:** Good for access patterns with locality
**Cons:** Amortized O(log n), not worst-case

---

## ‚ö° Complexity Comparison

| Operation | Unbalanced BST | AVL | Red-Black | Hash Table |
|-----------|---------------|-----|-----------|------------|
| Search |" O(n) worst "| O(log n) |" O(log n) "| O(1) avg |
| Insert |" O(n) worst "| O(log n) |" O(log n) "| O(1) avg |
| Delete |" O(n) worst "| O(log n) |" O(log n) "| O(1) avg |
| Ordered traversal |" O(n) "| O(n) |" O(n) "| O(n log n) |
| Range query |" O(n) "| O(log n + k) |" O(log n + k) "| O(n) |

---

## üíª Using Built-in Balanced Trees

### Python (sortedcontainers)

```python
from sortedcontainers import SortedList, SortedDict, SortedSet

# SortedList - maintains sorted order
sl = SortedList([3, 1, 4, 1, 5])
sl.add(2)           # O(log n) insert
sl.remove(1)        # O(log n) delete
idx = sl.bisect_left(3)  # O(log n) search
print(sl[2])        # O(log n) index access

# SortedDict - ordered dictionary
sd = SortedDict()
sd['b'] = 2
sd['a'] = 1
print(list(sd.keys()))  # ['a', 'b'] - sorted order

# SortedSet - ordered set
ss = SortedSet([3, 1, 4])
ss.add(2)
print(ss[0])  # Smallest element
```

### Java

```java
// TreeMap - Red-Black tree based
TreeMap<Integer, String> map = new TreeMap<>();
map.put(3, "c");
map.put(1, "a");
map.firstKey();     // Smallest key: 1
map.floorKey(2);    // Largest key <= 2: 1
map.ceilingKey(2);  // Smallest key >= 2: 3

// TreeSet - Red-Black tree based
TreeSet<Integer> set = new TreeSet<>();
set.add(3);
set.add(1);
set.first();        // Smallest: 1
set.higher(1);      // Smallest > 1: 3
```

### C++

```cpp
#include <set>
#include <map>

// std::set - Red-Black tree
std::set<int> s;
s.insert(3);
s.insert(1);
auto it = s.lower_bound(2);  // Iterator to first >= 2

// std::map - Red-Black tree
std::map<int, std::string> m;
m[3] = "c";
m[1] = "a";
auto it = m.begin();  // Smallest key
```

### JavaScript (No Built-in, Use Libraries)

```javascript
// Use libraries like:
// - sorted-btree
// - bintrees
// - collections.js

// Example with sorted-btree
const { BTree } = require('sorted-btree');

let tree = new BTree();
tree.set(3, 'c');
tree.set(1, 'a');
tree.get(3);           // 'c'
tree.minKey();         // 1
```

---

## üîÑ Rotation Operations

### Right Rotation

```
Before:          After:
    z              y
   / \            / \
  y   T4   =>   T1   z
 / \                / \
T1  T2            T2  T4
(where T2 was y.right, becomes z.left)
```

### Left Rotation

```
Before:          After:
  x                y
 / \              / \
T1  y     =>    x   T3
   / \         / \
  T2  T3     T1  T2
```

### Four Cases for AVL Rebalancing

| Case | Structure | Fix |
|------|-----------|-----|
| LL | Left child is left-heavy | Right rotate |
| RR | Right child is right-heavy | Left rotate |
| LR | Left child is right-heavy | Left rotate child, then right rotate |
| RL | Right child is left-heavy | Right rotate child, then left rotate |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Implementing From Scratch When Not Needed

```python
# ‚ùå Wrong: Writing 200+ lines of AVL code in interview
class AVLTree:
    def insert(self, val):
        # ... complex rotation logic ...
        pass

# ‚úÖ Correct: Use built-in balanced structures
from sortedcontainers import SortedList
sl = SortedList()  # O(log n) insert/delete, balanced
```

### 2. Using Self-Balancing When Hash Table Suffices

| Need | Wrong Choice | Right Choice |
|------|--------------|---------------|
| Fast lookup only |" TreeMap O(log n) "| HashMap O(1) |
| Count occurrences | TreeSet | dict/Counter |
| Check membership | SortedSet | HashSet |

```python
# ‚ùå Wrong: Using ordered structure for unordered access
from sortedcontainers import SortedDict
sd = SortedDict()  # O(log n) operations

# ‚úÖ Correct: Hash table when order doesn't matter
d = {}  # O(1) operations
```

### 3. Forgetting When You Actually Need Ordering

```python
# ‚ùå Wrong: Using hash for range queries
d = {}  # Can't efficiently find "all keys between 10 and 20"

# ‚úÖ Correct: Use balanced BST for ordered operations
from sortedcontainers import SortedDict
sd = SortedDict()
# Range query: O(log n + k) where k is result size
result = list(sd.irange(10, 20))
```

### 4. Not Understanding Amortized vs Worst-Case

| Structure | Average | Worst Case | Guarantee |
|-----------|---------|------------|------------|
| Hash Table |" O(1) "| O(n) | ‚ùå No |
| Balanced BST |" O(log n) "| O(log n) | ‚úÖ Yes |
| Unbalanced BST |" O(log n) "| O(n) | ‚ùå No |

---

## üéØ When Asked in Interviews

**Most interviews don't require implementing self-balancing BSTs from scratch.** However, you should know:

1. **Why they exist:** Guarantee O(log n) operations
2. **Trade-offs:** AVL vs Red-Black vs Hash Table
3. **When to use:** Ordered operations needed
4. **How to use:** Built-in libraries in your language

**Common interview questions:**
- "How would you maintain a sorted collection with fast insert/delete?"
- "When would you use TreeMap vs HashMap?"
- "Why might BST operations be O(n)? How to fix?"

---

## üìù Practice Problems

| Problem | Concept | Difficulty |
|---------|---------|------------|
| [Balance a BST (LC 1382)](https://leetcode.com/problems/balance-a-binary-search-tree/) | Convert to balanced | Medium |
| [Height-Balanced BST (LC 108)](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/) | Build balanced | Easy |
| [Kth Largest (LC 703)](https://leetcode.com/problems/kth-largest-element-in-a-stream/) | Use SortedList | Easy |
| [My Calendar (LC 729)](https://leetcode.com/problems/my-calendar-i/) | Ordered map | Medium |
| [Data Stream Median (LC 295)](https://leetcode.com/problems/find-median-from-data-stream/) | Two heaps or balanced BST | Hard |

---

## üé§ Interview Context

<details>
<summary><strong>How to Discuss Self-Balancing Trees</strong></summary>

**If asked "How does a balanced BST work?":**
"Balanced BSTs maintain a height of O(log n) by restructuring after insertions and deletions. AVL trees track balance factors and rotate when they exceed ¬±1. Red-Black trees use coloring rules and rotations. Both guarantee O(log n) for all operations."

**If asked "When would you use this?":**
"When I need ordered operations like finding min/max, predecessor/successor, or range queries, AND the data is dynamic. For static data, I'd just sort once. For unordered access, I'd use a hash table."

**If asked to implement:**
"I'd typically use the language's built-in (TreeMap in Java, sortedcontainers in Python). If you'd like, I can walk through the rotation logic conceptually."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 20-30 min | One-time learning |
| Implement AVL | 60-90 min | Complex, rarely needed |
| Use built-in | 5-10 min | Know the API |
| Explain in interview | 3-5 min | Conceptual understanding |

---

## üí° Key Insight

> **Self-balancing is about guarantees, not averages.** Random insertions into a BST usually produce a reasonably balanced tree. But sequential or patterned insertions can create worst-case O(n) height. Self-balancing trees guarantee O(log n) regardless of insertion order.

---

## üîó Related

- **Foundation:** [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
- **Application:** [Balance a BST (LC 1382)](https://leetcode.com/problems/balance-a-binary-search-tree/)
- **Alternative:** [Heaps](../../08-Heaps-Priority-Queues/) for different use cases
- **Previous:** [Unique BSTs (LC 96)](./8.1-Unique-BSTs-LC96.md)
