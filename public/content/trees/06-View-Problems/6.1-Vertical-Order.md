# 6.1 - Vertical Order Traversal (LC 987)

> **Grokking Pattern:** #10 Tree BFS + Sorting
>
> **Difficulty:** Hard | **Frequency:** ‚≠ê‚≠ê‚≠ê Common

---

## Problem Statement

Given the `root` of a binary tree, calculate the **vertical order traversal** of the binary tree.

For each node at position `(row, col)`:
- Its left child is at position `(row + 1, col - 1)`
- Its right child is at position `(row + 1, col + 1)`

The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.

```
Input: root = [3,9,20,null,null,15,7]

        3         ‚Üê col 0
       / \
      9   20      ‚Üê col -1, col +1
         / \
        15  7     ‚Üê col 0, col +2

Output: [[9],[3,15],[20],[7]]

Explanation:
- Column -1: [9]
- Column 0: [3, 15] (sorted if same row, same col)
- Column +1: [20]
- Column +2: [7]
```

```
Input: root = [1,2,3,4,5,6,7]

          1           ‚Üê col 0
        /   \
       2     3        ‚Üê col -1, col +1
      / \   / \
     4   5 6   7      ‚Üê col -2, 0, 0, +2

Output: [[4],[2],[1,5,6],[3],[7]]

Note: 5 and 6 are both at (row=2, col=0), so sorted by value
```

[LeetCode 987 - Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Vertical order" or "column order"
- Need to track position (row, col)
- Sorting within same position

**Key insight:**
This combines:
1. BFS/DFS with position tracking
2. Grouping by column
3. Sorting by (row, value) within each column

</details>

---

## ‚úÖ When to Use

- Vertical/column-based traversal
- Position-aware tree problems
- Need specific ordering rules

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Simple level-order | Overcomplicated | Basic BFS |
| Right side view | Only need rightmost | Simpler approach |
| Just need column values | No row tracking | Basic vertical order |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Level Order Traversal](../03-Tree-Traversals/3.2-BFS-Traversals/01-Level-Order.md)
- Hash maps for grouping

**After mastering this:**
- [Binary Tree Right Side View](../03-Tree-Traversals/3.2-BFS-Traversals/04-Right-Side-View.md)
- Diagonal traversal

</details>

---

## üìê How It Works

### Coordinate System

```
              (0, 0)
             /      \
        (-1, 1)    (1, 1)
        /    \     /    \
    (-2, 2) (0,2)(0, 2) (2, 2)

    (col, row) for each node
```

### Algorithm Steps

1. **Traverse tree** (BFS or DFS), tracking (col, row) for each node
2. **Group nodes** by column
3. **Sort each column** by (row, then value)
4. **Return columns** from left to right

### Visualization

```
Tree:       1
          /   \
         2     3
        / \   / \
       4   5 6   7

Step 1: Collect (col, row, val)
(-2, 2, 4), (-1, 1, 2), (0, 0, 1), (0, 2, 5), (0, 2, 6), (1, 1, 3), (2, 2, 7)

Step 2: Group by column
col -2: [(2, 4)]
col -1: [(1, 2)]
col  0: [(0, 1), (2, 5), (2, 6)]
col +1: [(1, 3)]
col +2: [(2, 7)]

Step 3: Sort by (row, value) and extract values
col -2: [4]
col -1: [2]
col  0: [1, 5, 6]  ‚Üê 5 and 6 at same row, sorted by value
col +1: [3]
col +2: [7]

Output: [[4], [2], [1, 5, 6], [3], [7]]
```

---

## üíª Code Implementation

### Solution 1: BFS with Sorting (Recommended)

**Python:**
```python
from collections import defaultdict, deque
from typing import Optional, List

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def vertical_traversal(root: Optional[TreeNode]) -> List[List[int]]:
    """
    Vertical order traversal with proper sorting.
    
    For each node, track (col, row, val).
    Sort by col, then row, then val.
    
    Time: O(n log n) for sorting
    Space: O(n) for storage
    """
    if not root:
        return []
    
    # Store (col, row, val) for each node
    nodes = []
    
    # BFS with position tracking
    queue = deque([(root, 0, 0)])  # (node, col, row)
    
    while queue:
        node, col, row = queue.popleft()
        nodes.append((col, row, node.val))
        
        if node.left:
            queue.append((node.left, col - 1, row + 1))
        if node.right:
            queue.append((node.right, col + 1, row + 1))
    
    # Sort by (col, row, val)
    nodes.sort()
    
    # Group by column
    result = []
    current_col = None
    
    for col, row, val in nodes:
        if col != current_col:
            result.append([])
            current_col = col
        result[-1].append(val)
    
    return result
```

**JavaScript:**
```javascript
function verticalTraversal(root) {
    if (!root) return [];
    
    const nodes = [];
    const queue = [[root, 0, 0]]; // [node, col, row]
    
    while (queue.length > 0) {
        const [node, col, row] = queue.shift();
        nodes.push([col, row, node.val]);
        
        if (node.left) {
            queue.push([node.left, col - 1, row + 1]);
        }
        if (node.right) {
            queue.push([node.right, col + 1, row + 1]);
        }
    }
    
    // Sort by col, then row, then val
    nodes.sort((a, b) => {
        if (a[0] !== b[0]) return a[0] - b[0];
        if (a[1] !== b[1]) return a[1] - b[1];
        return a[2] - b[2];
    });
    
    // Group by column
    const result = [];
    let currentCol = null;
    
    for (const [col, row, val] of nodes) {
        if (col !== currentCol) {
            result.push([]);
            currentCol = col;
        }
        result[result.length - 1].push(val);
    }
    
    return result;
}
```

### Solution 2: DFS with Hash Map

**Python:**
```python
def vertical_traversal_dfs(root: Optional[TreeNode]) -> List[List[int]]:
    """
    DFS approach using hash map.
    """
    if not root:
        return []
    
    # column -> list of (row, val)
    column_map = defaultdict(list)
    min_col = max_col = 0
    
    def dfs(node, col, row):
        nonlocal min_col, max_col
        
        if not node:
            return
        
        min_col = min(min_col, col)
        max_col = max(max_col, col)
        column_map[col].append((row, node.val))
        
        dfs(node.left, col - 1, row + 1)
        dfs(node.right, col + 1, row + 1)
    
    dfs(root, 0, 0)
    
    # Build result
    result = []
    for col in range(min_col, max_col + 1):
        # Sort by (row, val)
        column_map[col].sort()
        result.append([val for row, val in column_map[col]])
    
    return result
```

### Solution 3: Using SortedDict

**Python:**
```python
from sortedcontainers import SortedDict

def vertical_traversal_sorted(root: Optional[TreeNode]) -> List[List[int]]:
    """
    Using SortedDict to maintain column order automatically.
    """
    if not root:
        return []
    
    column_map = SortedDict()
    queue = deque([(root, 0, 0)])
    
    while queue:
        node, col, row = queue.popleft()
        
        if col not in column_map:
            column_map[col] = []
        column_map[col].append((row, node.val))
        
        if node.left:
            queue.append((node.left, col - 1, row + 1))
        if node.right:
            queue.append((node.right, col + 1, row + 1))
    
    result = []
    for col in column_map:
        column_map[col].sort()
        result.append([val for row, val in column_map[col]])
    
    return result
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| BFS + Sort |" O(n log n) "| O(n) | Sorting dominates |
| DFS + Sort |" O(n log n) "| O(n) | Same complexity |
| SortedDict |" O(n log n) "| O(n) | Automatic ordering |

**Why O(n log n)?**
- Traversal is O(n)
- Sorting all nodes is O(n log n)
- Grouping is O(n)
- Overall: O(n log n)

---

## üîÑ Variations

| Variation | Difference | LeetCode |
|-----------|------------|----------|
| Basic vertical order | No same-position sorting | LC 314 |
| Right side view | Only rightmost per level | LC 199 |
| Left side view | Only leftmost per level | N/A |
| Diagonal traversal | Diagonal grouping | Various |

**Note:** LC 314 (Binary Tree Vertical Order Traversal) is simpler - nodes at same position stay in BFS order, not sorted by value.

---

## ‚ö†Ô∏è Common Mistakes

### 1. Confusing LC 987 vs LC 314

```python
# LC 314: Same position nodes keep BFS order
# LC 987: Same position nodes sorted by VALUE

# LC 987 requires extra sort key for values at same (row, col)
nodes.sort()  # Sorts by (col, row, val)
```

### 2. Wrong Coordinate Updates

```python
# ‚ùå WRONG: Both children same column
if node.left:
    queue.append((node.left, col, row + 1))  # Should be col - 1

# ‚úÖ CORRECT:
if node.left:
    queue.append((node.left, col - 1, row + 1))  # Left goes -1
if node.right:
    queue.append((node.right, col + 1, row + 1))  # Right goes +1
```

### 3. Not Tracking Row for Sorting

```python
# ‚ùå WRONG: Only storing column and value
nodes.append((col, node.val))
# Can't sort by row within column!

# ‚úÖ CORRECT: Store all three
nodes.append((col, row, node.val))
```

### 4. Wrong Column Order in Output

```python
# ‚ùå WRONG: Not sorting columns
for col in column_map:  # Hash map order is arbitrary!

# ‚úÖ CORRECT: Iterate in column order
for col in range(min_col, max_col + 1):
    result.append(column_map[col])
```

---

## üìù Practice Problems

### This Problem
- [ ] [Vertical Order Traversal](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/) - LC 987 (Hard)

### Related View Problems
- [ ] [Binary Tree Vertical Order (Premium)](https://leetcode.com/problems/binary-tree-vertical-order-traversal/) - LC 314
- [ ] [Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/) - LC 199
- [ ] [Average of Levels](https://leetcode.com/problems/average-of-levels-in-binary-tree/) - LC 637

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Understand coordinate system
**Day 3:** Implement with BFS
**Day 7:** Implement with DFS
**Day 14:** Compare to LC 314 (simpler version)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Explaining the approach:**
> "I'll assign coordinates to each node - column and row. Left child goes col-1, right goes col+1, both go row+1. Then I collect all (col, row, val) tuples, sort them, and group by column."

**Clarifying the problem:**
> "When nodes are at the same column AND same row, do we sort by value or keep traversal order? In LC 987, we sort by value."

**Time complexity:**
> "O(n log n) because we need to sort all n nodes. The traversal itself is O(n)."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Common question |
| Amazon | ‚≠ê‚≠ê‚≠ê | Sometimes asked |
| Google | ‚≠ê‚≠ê | Occasionally |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand coordinates | 3-5 min | Key insight |
| Implement solution | 15-20 min | Hard problem |
| Handle sorting edge cases | 5 min | Same position |

---

> **üí° Key Insight:** This problem combines BFS traversal with a coordinate system. The key is tracking (column, row, value) for each node, then sorting first by column (for output order), then by row (for top-to-bottom within column), then by value (for same-position tiebreaker). The coordinate system where left child = col-1 and right child = col+1 is the foundation.

---

## üîó Related

- [Level Order Traversal](../03-Tree-Traversals/3.2-BFS-Traversals/01-Level-Order.md)
- [Right Side View](../03-Tree-Traversals/3.2-BFS-Traversals/04-Right-Side-View.md)
- [BFS Concept](../03-Tree-Traversals/3.2-BFS-Traversals/00-BFS-Concept.md)
