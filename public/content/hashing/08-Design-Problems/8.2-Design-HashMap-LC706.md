# Design HashMap (LeetCode 706)

> **Easy** | Design a HashMap without using any built-in hash table libraries. Implement put, get, and remove operations.

This problem teaches the fundamentals of hash table implementation - understanding collision handling and bucket management.

---

## ðŸŽ¯ Pattern Recognition

<details>
<summary><strong>Problem Signals</strong></summary>

**Keywords indicating this pattern:**
- "Design a hash map"
- "Implement without built-in"
- "Key-value storage"
- "O(1) average operations"

**Core concepts tested:**
- Hash function design
- Collision resolution
- Bucket management

</details>

---

## ðŸ“‹ Problem Statement

**LeetCode 706:** [Design HashMap](https://leetcode.com/problems/design-hashmap/)

```
Design a HashMap without using any built-in hash table libraries.

Implement the MyHashMap class:
- MyHashMap() initializes with empty map
- void put(int key, int value) inserts (key, value) pair
  - If key exists, update the value
- int get(int key) returns value if key exists, else -1
- void remove(int key) removes key and its value if exists

Example:
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1);   // map is now [[1,1]]
myHashMap.put(2, 2);   // map is now [[1,1], [2,2]]
myHashMap.get(1);      // return 1
myHashMap.get(3);      // return -1 (not found)
myHashMap.put(2, 1);   // map is now [[1,1], [2,1]] (updated)
myHashMap.get(2);      // return 1
myHashMap.remove(2);   // map is now [[1,1]]
myHashMap.get(2);      // return -1 (removed)

Constraints:
- 0 <= key, value <= 10^6
- At most 10^4 calls to put, get, remove
```

---

## âœ… Learning Objectives

- Understand hash function basics
- Learn collision handling strategies
- Implement chaining with linked lists
- Understand load factor and bucket sizing

---

## âŒ When NOT to Use This Design

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Small, fixed key range | Overkill | Direct array indexing |
| Need ordered keys | Hash is unordered | TreeMap/BST |
| Memory critical, sparse keys | Wastes bucket space | Sorted array + binary search |
| Need range queries | Hash doesn't support | Balanced BST |

---

## ðŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, understand:**
- [What is Hashing](../01-Hash-Fundamentals/1.1-What-Is-Hashing.md)
- [Hash Functions](../01-Hash-Fundamentals/1.2-Hash-Functions.md)
- [Collision Handling](../01-Hash-Fundamentals/1.3-Collision-Handling.md)

**After mastering this:**
- [Design HashSet (LC 705)](./8.3-Design-HashSet-LC705.md) - Simpler variant
- [LRU Cache (LC 146)](./8.4-LRU-Cache-LC146.md) - Combines HashMap + DLL
- [RandomizedSet (LC 380)](./8.5-RandomizedSet-LC380.md) - HashMap + Array

**Key dependencies:**
- Hash function â†’ bucket selection
- Collision strategy â†’ chaining vs probing
- Load factor â†’ when to resize

</details>

---

## ðŸ“ Solution Approaches

### Approach 1: Chaining with Lists (Recommended)

**Key Insight:** Use an array of buckets. Each bucket is a list of (key, value) pairs. Hash function determines which bucket to use.

```
Hash Map with 10 buckets:

put(1, 100):  hash(1) = 1 % 10 = 1  â†’ bucket[1] = [(1, 100)]
put(11, 200): hash(11) = 11 % 10 = 1 â†’ bucket[1] = [(1, 100), (11, 200)]
put(21, 300): hash(21) = 21 % 10 = 1 â†’ bucket[1] = [(1, 100), (11, 200), (21, 300)]

Bucket Array:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 0 â”‚ []                                                  â”‚
â”‚ 1 â”‚ [(1,100), (11,200), (21,300)]  â† Chained entries    â”‚
â”‚ 2 â”‚ []                                                  â”‚
â”‚ 3 â”‚ [(3, 50)]                                           â”‚
â”‚ ...                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

get(11): 
1. hash(11) = 1
2. Search bucket[1] for key 11
3. Found (11, 200) â†’ return 200
```

### Approach 2: Open Addressing (Linear Probing)

```
Hash Map with 10 slots:

put(1, 100):  hash(1) = 1  â†’ slots[1] = (1, 100)
put(11, 200): hash(11) = 1 â†’ collision! probe next â†’ slots[2] = (11, 200)
put(21, 300): hash(21) = 1 â†’ collision! probe â†’ slots[3] = (21, 300)

Slot Array:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 0 â”‚ None                                                â”‚
â”‚ 1 â”‚ (1, 100)   â† Original position                      â”‚
â”‚ 2 â”‚ (11, 200)  â† Probed position                        â”‚
â”‚ 3 â”‚ (21, 300)  â† Probed position                        â”‚
â”‚ 4 â”‚ None                                                â”‚
â”‚ ...                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸ’» Code Implementation

### Python - Approach 1: Chaining with Lists

```python
class MyHashMap:
    """
    HashMap using chaining (list-based buckets).
    
    Design choices:
    - Size 1000: Good balance for constraints (10^4 operations)
    - Simple modulo hash: key % size
    - List buckets: Easy to implement, good for chaining
    
    Time: O(n/k) average, O(n) worst case per operation
    Space: O(k + n) where k = bucket count, n = stored keys
    """
    
    def __init__(self):
        self.size = 1000  # Number of buckets
        self.buckets = [[] for _ in range(self.size)]
    
    def _hash(self, key: int) -> int:
        """Simple modulo hash function."""
        return key % self.size
    
    def put(self, key: int, value: int) -> None:
        """Insert or update key-value pair."""
        bucket_idx = self._hash(key)
        bucket = self.buckets[bucket_idx]
        
        # Check if key exists, update if so
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)  # Update
                return
        
        # Key doesn't exist, append new pair
        bucket.append((key, value))
    
    def get(self, key: int) -> int:
        """Get value for key, return -1 if not found."""
        bucket_idx = self._hash(key)
        bucket = self.buckets[bucket_idx]
        
        for k, v in bucket:
            if k == key:
                return v
        
        return -1  # Not found
    
    def remove(self, key: int) -> None:
        """Remove key if it exists."""
        bucket_idx = self._hash(key)
        bucket = self.buckets[bucket_idx]
        
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket.pop(i)
                return


# Example usage:
# myHashMap = MyHashMap()
# myHashMap.put(1, 1)    # bucket[1] = [(1, 1)]
# myHashMap.put(2, 2)    # bucket[2] = [(2, 2)]
# myHashMap.get(1)       # â†’ 1
# myHashMap.get(3)       # â†’ -1
# myHashMap.put(2, 1)    # bucket[2] = [(2, 1)]
# myHashMap.remove(2)    # bucket[2] = []
```

### Python - Using Linked List Nodes

```python
class ListNode:
    """Node for chained entries."""
    def __init__(self, key=-1, val=-1, next=None):
        self.key = key
        self.val = val
        self.next = next

class MyHashMap:
    """
    HashMap using linked list chaining.
    
    Each bucket has a dummy head for easier insertion/deletion.
    """
    
    def __init__(self):
        self.size = 1000
        # Each bucket has a dummy head node
        self.buckets = [ListNode() for _ in range(self.size)]
    
    def _hash(self, key: int) -> int:
        return key % self.size
    
    def put(self, key: int, value: int) -> None:
        bucket_idx = self._hash(key)
        curr = self.buckets[bucket_idx]
        
        # Traverse to find key or end of list
        while curr.next:
            if curr.next.key == key:
                curr.next.val = value  # Update existing
                return
            curr = curr.next
        
        # Key not found, append new node
        curr.next = ListNode(key, value)
    
    def get(self, key: int) -> int:
        bucket_idx = self._hash(key)
        curr = self.buckets[bucket_idx].next  # Skip dummy
        
        while curr:
            if curr.key == key:
                return curr.val
            curr = curr.next
        
        return -1
    
    def remove(self, key: int) -> None:
        bucket_idx = self._hash(key)
        curr = self.buckets[bucket_idx]
        
        while curr.next:
            if curr.next.key == key:
                curr.next = curr.next.next  # Remove node
                return
            curr = curr.next
```

### Python - Open Addressing (Linear Probing)

```python
class MyHashMap:
    """
    HashMap using open addressing with linear probing.
    
    Note: More complex due to tombstone handling.
    """
    
    def __init__(self):
        self.size = 10007  # Prime number for better distribution
        self.keys = [None] * self.size
        self.values = [None] * self.size
        self.DELETED = -1  # Tombstone marker
    
    def _hash(self, key: int) -> int:
        return key % self.size
    
    def _probe(self, key: int):
        """Linear probing to find key or empty slot."""
        idx = self._hash(key)
        first_deleted = -1
        
        while self.keys[idx] is not None:
            if self.keys[idx] == key:
                return idx, True  # Found key
            if self.keys[idx] == self.DELETED and first_deleted == -1:
                first_deleted = idx  # Remember first deleted slot
            idx = (idx + 1) % self.size
        
        # Return first deleted slot if found, else current empty slot
        if first_deleted != -1:
            return first_deleted, False
        return idx, False
    
    def put(self, key: int, value: int) -> None:
        idx, found = self._probe(key)
        self.keys[idx] = key
        self.values[idx] = value
    
    def get(self, key: int) -> int:
        idx, found = self._probe(key)
        if found:
            return self.values[idx]
        return -1
    
    def remove(self, key: int) -> None:
        idx, found = self._probe(key)
        if found:
            self.keys[idx] = self.DELETED  # Tombstone
            self.values[idx] = None
```

### JavaScript - Chaining with Arrays

```javascript
class MyHashMap {
    /**
     * Initialize HashMap with bucket array.
     */
    constructor() {
        this.size = 1000;
        this.buckets = Array.from({ length: this.size }, () => []);
    }
    
    /**
     * Simple modulo hash function.
     * @param {number} key
     * @return {number}
     */
    _hash(key) {
        return key % this.size;
    }
    
    /**
     * Insert or update key-value pair.
     * @param {number} key
     * @param {number} value
     * @return {void}
     */
    put(key, value) {
        const bucketIdx = this._hash(key);
        const bucket = this.buckets[bucketIdx];
        
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                bucket[i][1] = value;  // Update
                return;
            }
        }
        
        bucket.push([key, value]);  // Insert new
    }
    
    /**
     * Get value for key.
     * @param {number} key
     * @return {number}
     */
    get(key) {
        const bucketIdx = this._hash(key);
        const bucket = this.buckets[bucketIdx];
        
        for (const [k, v] of bucket) {
            if (k === key) return v;
        }
        
        return -1;
    }
    
    /**
     * Remove key if exists.
     * @param {number} key
     * @return {void}
     */
    remove(key) {
        const bucketIdx = this._hash(key);
        const bucket = this.buckets[bucketIdx];
        
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                bucket.splice(i, 1);
                return;
            }
        }
    }
}
```

---

## âš¡ Complexity Analysis

| Operation | Average | Worst Case | Notes |
|-----------|---------|------------|-------|
| put | O(1) | O(n) | n keys in same bucket |
| get | O(1) | O(n) | Linear search in bucket |
| remove | O(1) | O(n) | Linear search in bucket |
| Space | O(k + n) | O(k + n) | k buckets + n entries |

**Why average O(1)?**
- With good hash function and sufficient buckets
- Each bucket has O(n/k) elements on average
- If k â‰ˆ n, then O(n/k) = O(1)

---

## ðŸ”„ Design Variations

| Variation | Implementation | Trade-off |
|-----------|---------------|-----------|
| Simple array | `arr[key] = val` | O(1) but O(max_key) space |
| Chaining (list) | List of (k,v) pairs | Easy, good average case |
| Chaining (linked list) | Linked list nodes | Slightly more complex |
| Open addressing | Single array + probing | Better cache locality |

---

## âš ï¸ Common Mistakes

### 1. Wrong Hash Function

```python
# âŒ WRONG: Negative modulo issues in some languages
def _hash(self, key):
    return key % self.size  # May be negative for negative keys!

# âœ… CORRECT: Ensure positive
def _hash(self, key):
    return abs(key) % self.size
```

### 2. Not Handling Update vs Insert

```python
# âŒ WRONG: Always appending (creates duplicates)
def put(self, key, value):
    bucket = self.buckets[self._hash(key)]
    bucket.append((key, value))  # Duplicate if key exists!

# âœ… CORRECT: Check for existing key first
def put(self, key, value):
    bucket = self.buckets[self._hash(key)]
    for i, (k, v) in enumerate(bucket):
        if k == key:
            bucket[i] = (key, value)  # Update
            return
    bucket.append((key, value))  # Insert new
```

### 3. Using Too Few Buckets

```python
# âŒ BAD: Too few buckets â†’ long chains â†’ O(n) operations
self.size = 10  # With 10^4 operations, ~1000 entries per bucket!

# âœ… GOOD: More buckets â†’ shorter chains â†’ O(1) average
self.size = 1000  # ~10 entries per bucket on average
```

---

## ðŸ“ Practice Problems (Progressive)

| Problem | Difficulty | Key Focus |
|---------|------------|-----------|
| Design HashSet | ðŸŸ¢ Easy | Simpler (no values) |
| Design HashMap | ðŸŸ¢ Easy | This problem |
| LRU Cache | ðŸŸ¡ Medium | HashMap + Linked List |
| Design Linked List | ðŸŸ¡ Medium | Related structure |

**Related LeetCode:**
- [705. Design HashSet](https://leetcode.com/problems/design-hashset/)
- [146. LRU Cache](https://leetcode.com/problems/lru-cache/)
- [707. Design Linked List](https://leetcode.com/problems/design-linked-list/)

<details>
<summary><strong>ðŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement chaining version
- **Day 3:** Implement linked list version
- **Day 7:** Understand open addressing
- **Day 14:** Explain trade-offs between approaches
- **Day 30:** < 10 min implementation

</details>

---

## ðŸŽ¤ Interview Context

<details>
<summary><strong>Communication Template</strong></summary>

**1. Clarify:**
> "Keys are integers from 0 to 10^6. I need to handle insert, update, get, and remove. Should I handle resizing?"

**2. High-level design:**
> "I'll use chaining with an array of buckets. Each bucket is a list of (key, value) pairs. The hash function will be key % bucket_count."

**3. Trade-off discussion:**
> "I'm using 1000 buckets. With 10^4 operations, that's about 10 entries per bucket on average, giving O(1) amortized time."

**4. Follow-up (resizing):**
> "For dynamic resizing, I'd track load factor and rehash when it exceeds a threshold like 0.75."

</details>

**Company Frequency:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | â­â­â­ | Foundation for other designs |
| Microsoft | â­â­â­ | Understanding hash tables |
| Bloomberg | â­â­â­ | Basics |

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Understand problem | 2 min |
| Design approach | 2 min |
| Implement | 8-10 min |
| Test | 2 min |
| **Total** | **14-16 min** |

---

> **ðŸ’¡ Key Insight:** A hash map is an array of buckets where each bucket handles collisions. The hash function maps keys to bucket indices. Chaining (linked lists or arrays per bucket) is the simplest collision handling strategy.

> **ðŸ”— Related:** [Design HashSet](./8.3-Design-HashSet-LC705.md) | [LRU Cache](./8.4-LRU-Cache-LC146.md) | [Hash Fundamentals](../01-Hash-Fundamentals/1.1-What-Is-Hashing.md)
