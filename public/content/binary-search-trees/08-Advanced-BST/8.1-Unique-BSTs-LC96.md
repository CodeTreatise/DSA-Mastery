# 8.1 Unique Binary Search Trees (LC 96)

## Problem Statement

[LeetCode 96 - Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)

Given an integer `n`, return the number of structurally unique BSTs which have exactly `n` nodes with unique values from 1 to n.

```
Input: n = 3
Output: 5

The 5 unique BSTs with values [1, 2, 3]:

    1         1           2          3        3
     \         \         / \        /        /
      2         3       1   3      1        2
       \       /                    \      /
        3     2                      2    1
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a Catalan Numbers / BST Counting problem:**
- Count structures, not specific values
- Each number can be root
- Left and right subtree combinations multiply

**Keywords:**
- "how many unique BSTs"
- "count structurally unique"
- "number of ways to arrange"

**Pattern:** Dynamic Programming with subproblem multiplication.

</details>

---

## ‚úÖ When to Use

- Counting BST structures
- Catalan number problems
- When subproblems combine multiplicatively

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Generate all BSTs | Need actual trees | LC 95 |
| Specific structure | Not counting | Direct construction |
| Non-BST trees | Different formula | Depends on constraints |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
- [Dynamic Programming basics](../../11-Dynamic-Programming/)
- Recursion with memoization

**After mastering this:**
- [Unique BST II (LC 95)](https://leetcode.com/problems/unique-binary-search-trees-ii/) - Generate all
- Catalan number applications

**Combines with:**
- DP with multiplication principle
- BST structure enumeration

</details>

---

## üìê How It Works

### The Key Insight

```
For n nodes, any node can be root.
If i is root:
- Left subtree has nodes 1 to i-1 (i-1 nodes)
- Right subtree has nodes i+1 to n (n-i nodes)

Total BSTs with root i = (BSTs with i-1 nodes) * (BSTs with n-i nodes)

Sum over all possible roots:
G(n) = Œ£ G(i-1) * G(n-i) for i = 1 to n
```

### Visualization

```
For n = 3:

Root = 1:
    1
     \           Left: G(0) = 1
      [2,3]      Right: G(2) = 2
                 Total: 1 * 2 = 2

Root = 2:
      2
     / \         Left: G(1) = 1
    1   3        Right: G(1) = 1
                 Total: 1 * 1 = 1

Root = 3:
        3
       /         Left: G(2) = 2
    [1,2]        Right: G(0) = 1
                 Total: 2 * 1 = 2

G(3) = 2 + 1 + 2 = 5
```

### Computing G(n) Bottom-Up

```
Base cases:
G(0) = 1  (empty tree)
G(1) = 1  (single node)

G(2) = G(0)*G(1) + G(1)*G(0) = 1*1 + 1*1 = 2
G(3) = G(0)*G(2) + G(1)*G(1) + G(2)*G(0) = 1*2 + 1*1 + 2*1 = 5
G(4) = G(0)*G(3) + G(1)*G(2) + G(2)*G(1) + G(3)*G(0) = 1*5 + 1*2 + 2*1 + 5*1 = 14
```

---

## üíª Code Implementation

### Dynamic Programming (Bottom-Up)

**Python:**
```python
def numTrees(self, n: int) -> int:
    """
    Count unique BST structures with n nodes.
    
    Time: O(n¬≤) - two nested loops
    Space: O(n) - dp array
    
    Pattern: G(n) = Œ£ G(i-1) * G(n-i) (Catalan numbers)
    """
    # G[i] = number of unique BSTs with i nodes
    G = [0] * (n + 1)
    
    # Base cases
    G[0] = 1  # Empty tree
    G[1] = 1  # Single node
    
    # Fill for 2 to n nodes
    for num_nodes in range(2, n + 1):
        for root in range(1, num_nodes + 1):
            left_nodes = root - 1
            right_nodes = num_nodes - root
            G[num_nodes] += G[left_nodes] * G[right_nodes]
    
    return G[n]
```

**JavaScript:**
```javascript
var numTrees = function(n) {
    // DP: G(n) = sum of G(i-1) * G(n-i)
    const G = new Array(n + 1).fill(0);
    
    G[0] = 1;
    G[1] = 1;
    
    for (let numNodes = 2; numNodes <= n; numNodes++) {
        for (let root = 1; root <= numNodes; root++) {
            const leftNodes = root - 1;
            const rightNodes = numNodes - root;
            G[numNodes] += G[leftNodes] * G[rightNodes];
        }
    }
    
    return G[n];
};
```

### Recursive with Memoization

**Python:**
```python
def numTrees(self, n: int) -> int:
    """Recursive approach with memoization."""
    memo = {}
    
    def count(num_nodes):
        if num_nodes <= 1:
            return 1
        
        if num_nodes in memo:
            return memo[num_nodes]
        
        total = 0
        for root in range(1, num_nodes + 1):
            left = count(root - 1)
            right = count(num_nodes - root)
            total += left * right
        
        memo[num_nodes] = total
        return total
    
    return count(n)
```

### Mathematical Formula (Catalan Number)

**Python:**
```python
def numTrees(self, n: int) -> int:
    """
    Direct Catalan number formula.
    
    C(n) = (2n)! / ((n+1)! * n!)
    
    Time: O(n), Space: O(1)
    """
    # Calculate using the product formula to avoid large factorials
    # C(n) = C(n-1) * 2(2n-1) / (n+1)
    
    catalan = 1
    for i in range(n):
        catalan = catalan * 2 * (2 * i + 1) // (i + 2)
    
    return catalan
```

**JavaScript:**
```javascript
var numTrees = function(n) {
    // Catalan number formula
    let catalan = 1;
    for (let i = 0; i < n; i++) {
        catalan = catalan * 2 * (2 * i + 1) / (i + 2);
    }
    return Math.round(catalan);
};
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| DP |" O(n¬≤) "| O(n) | Standard approach |
| Memoization |" O(n¬≤) "| O(n) | Same complexity |
| Catalan Formula |" O(n) "| O(1) | Mathematical |

**Why O(n¬≤) for DP:**
- Outer loop: n iterations
- Inner loop: up to n iterations each
- Total: ~n¬≤/2 iterations

**Catalan Numbers:**
The sequence 1, 1, 2, 5, 14, 42, 132, ... is the Catalan sequence.
- C(0) = C(1) = 1
- C(n) = Œ£ C(i)*C(n-1-i) for i = 0 to n-1

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **Generate all BSTs** | Return actual trees | LC 95 |
| **Binary trees (not BST)** | Different formula | Catalan * n! |
| **Full binary trees** | All nodes have 0 or 2 children | Related counting |
| **With specific height** | Additional constraint | Modified DP |

### Generate All BSTs (LC 95)

```python
def generateTrees(n: int) -> list[TreeNode]:
    """Generate all unique BSTs."""
    if n == 0:
        return []
    
    def generate(start, end):
        if start > end:
            return [None]
        
        all_trees = []
        for root_val in range(start, end + 1):
            left_trees = generate(start, root_val - 1)
            right_trees = generate(root_val + 1, end)
            
            for left in left_trees:
                for right in right_trees:
                    root = TreeNode(root_val)
                    root.left = left
                    root.right = right
                    all_trees.append(root)
        
        return all_trees
    
    return generate(1, n)
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Base Case

```python
# ‚ùå Wrong: Missing G[0] base case
G[0] = 0  # Empty tree should count as 1 structure!

# ‚úÖ Correct: Empty tree is a valid structure
G[0] = 1
G[1] = 1
```

### 2. Off-by-One in Loop

```python
# ‚ùå Wrong: Loop doesn't include n
for num_nodes in range(2, n):  # Misses n!
    ...

# ‚úÖ Correct: Include n
for num_nodes in range(2, n + 1):
    ...
```

### 3. Not Understanding Why Structures Are Same

```python
# Common confusion:
# For n=3: Why does left=[1,2] give same count as left=[2,3]?

# Answer: Structure depends on COUNT, not VALUES.
# 2 nodes always have 2 possible structures (left-heavy or right-heavy).
# The actual values don't matter for counting structures.
```

---

## üìù Practice Problems (Progressive)

### Medium (Learn pattern)
- [ ] [Unique BSTs (LC 96)](https://leetcode.com/problems/unique-binary-search-trees/) - This problem
- [ ] [Unique BSTs II (LC 95)](https://leetcode.com/problems/unique-binary-search-trees-ii/) - Generate all

### Hard (Apply pattern)
- [ ] [Different Ways to Add Parentheses (LC 241)](https://leetcode.com/problems/different-ways-to-add-parentheses/) - Similar counting

### Related (Catalan numbers)
- [ ] Balanced parentheses combinations
- [ ] Dyck paths
- [ ] Polygon triangulation

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand the recurrence relation
- **Day 3:** Implement DP solution
- **Day 7:** Learn Catalan formula
- **Day 14:** Solve LC 95 (generate all)
- **Day 30:** Apply pattern to other counting problems

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"I'll think about what happens when I choose each node as root. If node i is root, then nodes 1 to i-1 go to the left subtree and nodes i+1 to n go to the right. The total unique BSTs with root i is the product of unique left subtrees times unique right subtrees."

**Key points:**
1. "This is a subproblem multiplication pattern"
2. "G(n) depends only on count of nodes, not actual values"
3. "This is the Catalan number sequence"
4. "DP gives O(n¬≤) time, formula gives O(n)"

**Follow-up: Generate all trees?**
"Instead of counting, I'd return a list. For each root choice, I'd generate all left subtrees and all right subtrees, then combine them in all possible ways."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê | Medium frequency |
| Google | ‚≠ê‚≠ê‚≠ê | May ask DP insights |
| Meta | ‚≠ê‚≠ê | Less common |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Occasionally asked |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 3-5 min | Trace examples |
| Derive recurrence | 5-7 min | Key insight |
| Code DP solution | 8-10 min | Implement |
| Discuss Catalan | 3-5 min | If asked |
| Total interview time | 20-25 min | Medium difficulty |

---

## üí° Key Insight

> **Structure depends only on count, not values.** A left subtree with 2 nodes always has 2 possible structures, regardless of which specific values it contains. This is why G(n) depends only on n, leading to the elegant Catalan number formula.

---

## üîó Related

- **Extension:** [Unique BSTs II (LC 95)](https://leetcode.com/problems/unique-binary-search-trees-ii/)
- **Pattern:** Dynamic Programming, Catalan Numbers
- **Foundation:** [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
- **Similar:** Counting parenthesizations, polygon triangulations
