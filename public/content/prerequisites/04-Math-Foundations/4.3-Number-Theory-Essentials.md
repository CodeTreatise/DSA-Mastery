# 4.3 Number Theory Essentials

> **The math that powers GCD problems, modular arithmetic, prime sieves, and counting problems on LeetCode ‚Äî just enough to solve the problems, no more.**
>
> ‚è±Ô∏è *Estimated reading: 15 minutes*

---

## üéØ What You Actually Need

Number theory appears in ~5% of LeetCode problems, but when it does, you either know these concepts or you're stuck. Here's what's actually tested:

| Concept | Frequency | Example Problems |
|---------|-----------|-----------------|
| GCD / LCM | ‚≠ê‚≠ê‚≠ê | LC 1979, LC 365, LC 2344 |
| Prime checking / Sieve | ‚≠ê‚≠ê | LC 204, LC 762, LC 866 |
| Modular arithmetic | ‚≠ê‚≠ê‚≠ê | Almost any DP with "mod 10‚Åπ+7" |
| Factorial / Combinatorics | ‚≠ê‚≠ê | LC 62, LC 96 |

---

## üìê 1. GCD (Greatest Common Divisor)

### What It Is

The largest number that divides both a and b evenly.

```
GCD(12, 8) = 4     because 4 divides both 12 and 8
GCD(15, 25) = 5    because 5 divides both 15 and 25
GCD(7, 13) = 1     (coprime ‚Äî no common factor)
```

### Euclidean Algorithm

```python
# Python ‚Äî built-in (use this!)
import math
math.gcd(12, 8)      # 4
math.gcd(12, 8, 6)   # 2  (Python 3.9+ supports multiple args)

# How it works (Euclidean algorithm):
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# Why it works: GCD(a, b) = GCD(b, a % b)
# GCD(12, 8) ‚Üí GCD(8, 4) ‚Üí GCD(4, 0) ‚Üí 4
```

```javascript
// JavaScript ‚Äî no built-in, implement yourself
function gcd(a, b) {
    while (b) {
        [a, b] = [b, a % b];
    }
    return a;
}

gcd(12, 8);    // 4

// GCD of array
function gcdArray(arr) {
    return arr.reduce((a, b) => gcd(a, b));
}
```

### LCM (Least Common Multiple)

$$\text{LCM}(a, b) = \frac{a \times b}{\text{GCD}(a, b)}$$

```python
import math

def lcm(a, b):
    return a * b // math.gcd(a, b)

# Python 3.9+
math.lcm(4, 6)       # 12
math.lcm(4, 6, 8)    # 24
```

```javascript
function lcm(a, b) {
    return (a * b) / gcd(a, b);
}
```

### DSA Use Cases

| Problem | How GCD Helps |
|---------|--------------|
| **Water and Jug** (LC 365) | Solvable iff target is multiple of GCD(x, y) |
| **Greatest Common Divisor of Strings** (LC 1071) | String GCD via length GCD |
| **Fraction Addition** | Simplify fractions with GCD |
| **Array GCD queries** | Find GCD of subarrays |

---

## üìê 2. Modular Arithmetic

### Why "mod 10‚Åπ + 7"?

Many DP problems say "return answer modulo 10‚Åπ + 7" because:
- Answers can be astronomically large (factorials, combinations)
- 10‚Åπ + 7 is prime (enables modular inverse)
- 10‚Åπ + 7 fits in a 32-bit integer
- Two identical answers have identical mods (almost certainly)

### Rules

```python
MOD = 10**9 + 7

# Addition
(a + b) % MOD

# Subtraction (add MOD to avoid negatives)
(a - b + MOD) % MOD

# Multiplication
(a * b) % MOD

# ‚ö†Ô∏è Division ‚Äî NOT just (a / b) % MOD!
# Division requires modular inverse (see below)
```

### Modular Exponentiation (Fast Power)

```python
# Python ‚Äî built-in pow with modular arithmetic
pow(base, exp, MOD)    # (base^exp) % MOD ‚Äî O(log exp)

# Example: 2^1000 mod (10^9+7)
pow(2, 1000, 10**9 + 7)

# Manual implementation (useful to understand)
def mod_pow(base, exp, mod):
    result = 1
    base %= mod
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % mod
        exp //= 2
        base = (base * base) % mod
    return result
```

```javascript
// JavaScript ‚Äî must implement (no built-in mod pow)
function modPow(base, exp, mod) {
    let result = 1n;  // Use BigInt for large numbers
    base = BigInt(base) % BigInt(mod);
    exp = BigInt(exp);
    mod = BigInt(mod);
    while (exp > 0n) {
        if (exp % 2n === 1n) {
            result = (result * base) % mod;
        }
        exp /= 2n;
        base = (base * base) % mod;
    }
    return Number(result);
}
```

### Modular Inverse (for Division)

```python
# a/b mod p = a √ó b^(-1) mod p
# When p is prime: b^(-1) = b^(p-2) mod p  (Fermat's little theorem)

MOD = 10**9 + 7

def mod_inverse(b, mod=MOD):
    return pow(b, mod - 2, mod)

# Then: (a / b) % MOD = (a * mod_inverse(b)) % MOD
```

---

## üìê 3. Primality & Sieve of Eratosthenes

### Check If Number Is Prime

```python
def is_prime(n):
    if n < 2:
        return False
    if n < 4:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

# Time: O(‚àön)
```

### Sieve of Eratosthenes ‚Äî Find ALL Primes up to n

```python
def sieve(n):
    """Return list of all primes ‚â§ n. LC 204."""
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False
    
    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            # Mark all multiples of i as not prime
            for j in range(i*i, n + 1, i):
                is_prime[j] = False
    
    return [i for i in range(2, n + 1) if is_prime[i]]

sieve(30)  # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
# Time: O(n log log n), Space: O(n)
```

```javascript
function sieve(n) {
    const isPrime = new Array(n + 1).fill(true);
    isPrime[0] = isPrime[1] = false;
    
    for (let i = 2; i * i <= n; i++) {
        if (isPrime[i]) {
            for (let j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    
    return isPrime.reduce((primes, val, idx) => {
        if (val) primes.push(idx);
        return primes;
    }, []);
}
```

### DSA Use Cases

| Problem | Concept |
|---------|---------|
| [Count Primes (LC 204)](https://leetcode.com/problems/count-primes/) | Sieve of Eratosthenes |
| [Ugly Number II (LC 264)](https://leetcode.com/problems/ugly-number-ii/) | Prime factors (2, 3, 5 only) |
| [Perfect Squares (LC 279)](https://leetcode.com/problems/perfect-squares/) | Number theory + DP/BFS |

---

## üìê 4. Combinatorics Basics

### Factorials, Permutations, Combinations

$$n! = n \times (n-1) \times \cdots \times 1$$

$$P(n, k) = \frac{n!}{(n-k)!} \quad \text{(ordered selections)}$$

$$C(n, k) = \binom{n}{k} = \frac{n!}{k!(n-k)!} \quad \text{(unordered selections)}$$

```python
import math

math.factorial(5)      # 120
math.comb(5, 2)        # 10  (Python 3.8+)
math.perm(5, 2)        # 20  (Python 3.8+)

# For large values with mod:
def comb_mod(n, k, mod=10**9+7):
    """C(n, k) mod p using modular inverse."""
    if k > n:
        return 0
    num = 1
    den = 1
    for i in range(k):
        num = (num * (n - i)) % mod
        den = (den * (i + 1)) % mod
    return (num * pow(den, mod - 2, mod)) % mod
```

### Pascal's Triangle (LC 118)

```python
# C(n, k) = C(n-1, k-1) + C(n-1, k)
# This IS Pascal's triangle!

def generate_pascal(numRows):
    triangle = [[1]]
    for i in range(1, numRows):
        row = [1]
        for j in range(1, i):
            row.append(triangle[i-1][j-1] + triangle[i-1][j])
        row.append(1)
        triangle.append(row)
    return triangle
```

### Where Combinatorics Appears

| Problem | Formula |
|---------|---------|
| [Unique Paths (LC 62)](https://leetcode.com/problems/unique-paths/) | C(m+n-2, m-1) |
| [Unique BSTs (LC 96)](https://leetcode.com/problems/unique-binary-search-trees/) | Catalan number |
| [Pascal's Triangle (LC 118)](https://leetcode.com/problems/pascals-triangle/) | Direct application |

### Catalan Numbers

$$C_n = \frac{1}{n+1}\binom{2n}{n} = \frac{(2n)!}{(n+1)! \cdot n!}$$

First few: 1, 1, 2, 5, 14, 42, 132, ...

They count:
- Number of valid parentheses combinations
- Number of unique BSTs with n nodes
- Number of ways to triangulate a polygon

---

## ‚ö° Quick Reference

| Operation | Python | JavaScript | Time |
|-----------|--------|------------|------|
| GCD | `math.gcd(a, b)` | Implement yourself | O(log min(a,b)) |
| LCM | `math.lcm(a, b)` | `a*b / gcd(a,b)` | O(log min(a,b)) |
| Is prime | Check divisors to ‚àön | Same | O(‚àön) |
| All primes ‚â§ n | Sieve | Sieve | O(n log log n) |
| Mod power | `pow(b, e, m)` | Implement yourself | O(log e) |
| nCk | `math.comb(n, k)` | Implement yourself | O(k) |
| Factorial | `math.factorial(n)` | Implement yourself | O(n) |

---

> **üí° Key Insight:** For LeetCode, number theory boils down to: (1) GCD/LCM for divisibility problems, (2) "mod 10‚Åπ+7" for large DP answers, (3) Sieve for prime problems. The rest is rare. Master these three and you're covered.

---

‚Üê [4.2 Series & Summations](./4.2-Series-And-Summations.md) | **Back to:** [Prerequisites Index](../00-Prerequisites.md)
