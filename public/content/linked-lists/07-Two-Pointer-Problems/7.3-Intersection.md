# 7.3 Intersection of Two Linked Lists (LC 160)

> **Grokking Pattern:** Two Pointers with Length Equalization
>
> **Difficulty:** Easy | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very High

---

## Problem Statement

Given the heads of two singly linked lists `headA` and `headB`, return the node at which the two lists **intersect**. If the two linked lists have no intersection, return `null`.

The lists must **retain their original structure** after the function returns.

```
List A:     a1 ‚Üí a2 ‚Üò
                      c1 ‚Üí c2 ‚Üí c3
List B: b1 ‚Üí b2 ‚Üí b3 ‚Üó

Output: Node c1 (where they merge)
```

[LeetCode 160 - Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- Two linked lists that may share a common suffix
- Need to find where they merge/intersect
- O(1) space requirement

**Keywords:**
- "intersection", "merge point", "common node"

**Key Insight:**
- If lists intersect, they share the same tail
- The difference is only in their unique prefixes
- Equalize the "starting distance" to find intersection

</details>

---

## ‚úÖ When to Use This Approach

- Finding intersection of two linked lists
- Detecting if two paths converge
- Finding common suffix point

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Need intersection of VALUES | Different problem | Hash set |
| Arrays | Direct comparison | Two pointers on sorted arrays |
| Multiple intersections | Lists can only merge once | Set intersection |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Linked List Basics](../01-Singly-LL/1.1-Basics.md)
- [Two Pointers concept](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md)

**After mastering this:**
- Find merge point in graphs
- Detect if lists share nodes

**Related:**
- [Cycle Detection](../04-Fast-Slow-Pointer/4.2-Cycle-Problems/01-Cycle-Detection.md) - Similar structure analysis

</details>

---

## üìê Approaches Overview

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Hash Set |" O(n + m) "| O(n) | Simple but extra space |
| Length Difference |" O(n + m) "| O(1) | Two passes |
| **Two Pointers Magic** |" O(n + m) "| O(1) | **Elegant one concept** |

---

## üìê Approach 1: Two Pointers (Elegant Solution)

### The Key Insight

When pointer A reaches the end of List A, redirect it to head of List B.
When pointer B reaches the end of List B, redirect it to head of List A.

**Why this works:**
- Pointer A travels: `lenA + lenB` nodes
- Pointer B travels: `lenB + lenA` nodes
- They travel the **same total distance**!
- If there's an intersection, they meet there
- If no intersection, they both reach null together

### Visualization

```
A: a1 ‚Üí a2 ‚Üí c1 ‚Üí c2 ‚Üí c3 (length 5: 2 unique + 3 common)
B: b1 ‚Üí b2 ‚Üí b3 ‚Üí c1 ‚Üí c2 ‚Üí c3 (length 6: 3 unique + 3 common)

Pointer A path: a1‚Üía2‚Üíc1‚Üíc2‚Üíc3‚Üí(jump to B)‚Üíb1‚Üíb2‚Üíb3‚Üíc1 ‚Üê MEET!
Pointer B path: b1‚Üíb2‚Üíb3‚Üíc1‚Üíc2‚Üíc3‚Üí(jump to A)‚Üía1‚Üía2‚Üíc1 ‚Üê MEET!

Both traveled: 5 + 3 = 8 steps (lenA + unique_B = lenB + unique_A)
```

### Implementation

**Python:**

```python
def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode:
    """
    Find intersection using two pointers.
    
    Pattern: Two Pointers with Cross-Traversal
    Time: O(n + m), Space: O(1)
    """
    if not headA or not headB:
        return None
    
    pA = headA
    pB = headB
    
    # Traverse until they meet (or both become None)
    while pA != pB:
        # If pA reaches end of A, redirect to headB
        pA = pA.next if pA else headB
        # If pB reaches end of B, redirect to headA
        pB = pB.next if pB else headA
    
    # Either intersection node or None (both null)
    return pA
```

**JavaScript:**

```javascript
function getIntersectionNode(headA, headB) {
    if (!headA || !headB) return null;
    
    let pA = headA;
    let pB = headB;
    
    while (pA !== pB) {
        pA = pA ? pA.next : headB;
        pB = pB ? pB.next : headA;
    }
    
    return pA;
}
```

---

## üìê Approach 2: Length Difference

### Core Idea

1. Find the length of both lists
2. Calculate the difference
3. Advance the longer list's pointer by the difference
4. Move both pointers together until they meet

### Implementation

**Python:**

```python
def get_intersection_length_diff(headA: ListNode, headB: ListNode) -> ListNode:
    """
    Find intersection using length difference.
    
    Time: O(n + m), Space: O(1)
    """
    def get_length(head):
        length = 0
        while head:
            length += 1
            head = head.next
        return length
    
    lenA = get_length(headA)
    lenB = get_length(headB)
    
    # Align starting points
    while lenA > lenB:
        headA = headA.next
        lenA -= 1
    while lenB > lenA:
        headB = headB.next
        lenB -= 1
    
    # Move together until intersection
    while headA != headB:
        headA = headA.next
        headB = headB.next
    
    return headA  # None if no intersection
```

---

## üìê Approach 3: Hash Set (Simple but O(n) Space)

```python
def get_intersection_hash(headA: ListNode, headB: ListNode) -> ListNode:
    """
    Hash set approach - simple but uses extra space.
    Time: O(n + m), Space: O(n)
    """
    visited = set()
    
    # Add all nodes from A to set
    current = headA
    while current:
        visited.add(current)  # Store node reference, not value!
        current = current.next
    
    # Find first node from B that's in set
    current = headB
    while current:
        if current in visited:
            return current
        current = current.next
    
    return None
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Two Pointers |" O(n + m) "| O(1) | Most elegant |
| Length Diff |" O(n + m) "| O(1) | Two passes |
| Hash Set |" O(n + m) "| O(n) | Extra space |

**Why Two Pointers works mathematically:**
- List A: unique part (a) + common (c)
- List B: unique part (b) + common (c)
- Pointer A travels: a + c + b (then hits intersection at c start)
- Pointer B travels: b + c + a (then hits intersection at c start)
- Both travel same distance: a + b + c

---

## üîÑ Variations

| Variation | Difference | Approach |
|-----------|------------|----------|
| Find intersection of values | Different problem | Hash set of values |
| Y-shaped linked lists | Same as this | This problem |
| Multiple potential intersections | Not possible in LL | Can only merge once |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Comparing Values Instead of Nodes

```python
# ‚ùå Wrong - same values don't mean same node!
while pA.val != pB.val:  # WRONG!
    ...

# ‚úÖ Correct - compare node references
while pA != pB:  # Correct - reference comparison
    ...
```

### 2. Infinite Loop with Null Check

```python
# ‚ùå Wrong - infinite loop if no intersection
while pA != pB:
    pA = pA.next  # Eventually null, but never equals pB
    pB = pB.next

# ‚úÖ Correct - redirect to other list's head when reaching null
while pA != pB:
    pA = pA.next if pA else headB  # Key: redirect at null
    pB = pB.next if pB else headA
```

### 3. Not Understanding "Intersection"

```python
# Intersection means SAME NODE, not same value!
# The lists physically share nodes from the intersection point

# A: 1 ‚Üí 2 ‚Üí 3
# B: 4 ‚Üí 5 ‚Üí 3  ‚Üê This 3 must be the SAME node as A's 3

# NOT the same as:
# A: 1 ‚Üí 2 ‚Üí 3
# B: 4 ‚Üí 5 ‚Üí 3  ‚Üê Different node that happens to have value 3
```

---

## üìù Practice Problems (Progressive)

### Easy (This problem)
- [ ] [Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/) - LC 160 ‚≠ê

### Related
- [ ] [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) - LC 141
- [ ] [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) - LC 142
- [ ] [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) - LC 21

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement two-pointer solution, understand the math
- **Day 3:** Implement length-difference approach
- **Day 7:** Solve without reference, explain why it works
- **Day 14:** Draw the traversal paths to internalize
- **Day 30:** Review and compare with cycle detection

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
> "I'll use two pointers. When each pointer reaches its list's end, I'll redirect it to the other list's head. This way, both pointers travel the same total distance and meet at the intersection."

**Explain why it works:**
> "If the lists have lengths n and m with a common suffix of length c, pointer A travels n + m - c nodes, and pointer B travels m + n - c nodes. Same distance, so they meet at the intersection."

**Handle no intersection case:**
> "If there's no intersection, both pointers will become null at the same time after traversing both lists, so we'll return null."

**Common follow-ups:**
- "Why not use hash set?" ‚Üí Works, but uses O(n) space
- "Can you modify the lists?" ‚Üí Shouldn't, but could connect tail to head and detect cycle

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê |" Focus on O(1) space "|
| Google | ‚≠ê‚≠ê‚≠ê | May ask for proof |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Classic question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand | 5-7 min | Visualize the traversal |
| Implement | 5-7 min | Simple code |
| Explain math | 3-5 min | Why same distance |
| Interview target | 15-20 min | With explanation |

---

> **üí° Key Insight:** By having each pointer traverse both lists (A‚ÜíB and B‚ÜíA), they travel the same total distance. If there's an intersection, they'll meet there. This is one of the most elegant linked list solutions!

---

## üîó Related

- [Two Pointers Pattern](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md) - General technique
- [Cycle Detection](../04-Fast-Slow-Pointer/4.2-Cycle-Problems/01-Cycle-Detection.md) - Related pointer technique
- [Linked List Basics](../01-Singly-LL/1.1-Basics.md) - Foundation
