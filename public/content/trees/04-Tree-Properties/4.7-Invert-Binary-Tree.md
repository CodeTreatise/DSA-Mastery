# 4.7 - Invert Binary Tree (LC 226)

> **Grokking Pattern:** #11 Tree DFS (Tree Modification)
>
> **Difficulty:** Easy | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very Common (Famous!)

---

## Problem Statement

Given the `root` of a binary tree, invert the tree, and return its root.

Inverting a tree means swapping left and right children at every node.

```
Input: root = [4,2,7,1,3,6,9]
        4                    4
       / \                  / \
      2   7      ‚Üí        7   2
     / \ / \              / \ / \
    1  3 6  9            9  6 3  1

Output: [4,7,2,9,6,3,1]
```

[LeetCode 226 - Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Invert" or "mirror" a tree
- Swap left and right children
- Transform tree structure

**Key insight:**
At each node, swap its left and right children. Do this recursively for all nodes.

**The Famous Tweet:**
> "Google: 90% of our engineers use the software you wrote (Homebrew), but you can't invert a binary tree on a whiteboard so fuck off."
> ‚Äî Max Howell, 2015

This problem became famous after this tweet!

</details>

---

## ‚úÖ When to Use

- Creating mirror image of tree
- Transforming tree structure
- Swapping children at all levels

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Check if symmetric | Don't need to modify | Symmetric Tree |
| Copy a tree | No swapping needed | Clone tree |
| Rotate tree | Different operation | AVL rotations |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [DFS Concept](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
- Any traversal order (pre/in/post)

**After mastering this:**
- [Symmetric Tree](./4.6-Symmetric-Tree.md) - Check without modifying
- More complex tree transformations

**Note:**
Can be solved with preorder, postorder, or level-order. The key is just to swap at each node.

</details>

---

## üìê How It Works

### Simple Swap at Each Node

```
Original:            Inverted:
    4                    4
   / \                  / \
  2   7       ‚Üí       7   2
 / \ / \              / \ / \
1  3 6  9            9  6 3  1

At each node:
- Node 4: swap(2, 7) ‚Üí (7, 2)
- Node 2: swap(1, 3) ‚Üí (3, 1)
- Node 7: swap(6, 9) ‚Üí (9, 6)
- ... and so on
```

### Any Order Works!

```
Preorder (process, then children):
1. Swap 4's children (2‚Üî7)
2. Recurse left (now 7)
3. Recurse right (now 2)

Postorder (children first, then process):
1. Recurse left (2)
2. Recurse right (7)
3. Swap 4's children

Both give the same result!
```

---

## üíª Code Implementation

### Solution 1: Recursive DFS (Preorder)

**Python:**
```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def invert_tree(root: Optional[TreeNode]) -> Optional[TreeNode]:
    """
    Invert binary tree using DFS.
    
    Swap children at each node, then recurse.
    Time: O(n), Space: O(h)
    """
    if not root:
        return None
    
    # Swap children
    root.left, root.right = root.right, root.left
    
    # Recurse (order doesn't matter much)
    invert_tree(root.left)
    invert_tree(root.right)
    
    return root
```

**JavaScript:**
```javascript
function invertTree(root) {
    if (!root) return null;
    
    // Swap children
    [root.left, root.right] = [root.right, root.left];
    
    // Recurse
    invertTree(root.left);
    invertTree(root.right);
    
    return root;
}
```

### Solution 2: Recursive (One-Liner)

**Python:**
```python
def invert_tree_oneliner(root: Optional[TreeNode]) -> Optional[TreeNode]:
    """
    Elegant one-liner using tuple assignment.
    """
    if root:
        root.left, root.right = invert_tree_oneliner(root.right), invert_tree_oneliner(root.left)
    return root
```

**JavaScript:**
```javascript
const invertTree = (root) => {
    if (root) {
        [root.left, root.right] = [invertTree(root.right), invertTree(root.left)];
    }
    return root;
};
```

### Solution 3: Iterative BFS

**Python:**
```python
from collections import deque

def invert_tree_bfs(root: Optional[TreeNode]) -> Optional[TreeNode]:
    """
    Iterative using BFS (level-order).
    
    Time: O(n), Space: O(w)
    """
    if not root:
        return None
    
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        
        # Swap children
        node.left, node.right = node.right, node.left
        
        # Add children to queue
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    
    return root
```

**JavaScript:**
```javascript
function invertTreeBFS(root) {
    if (!root) return null;
    
    const queue = [root];
    
    while (queue.length > 0) {
        const node = queue.shift();
        
        [node.left, node.right] = [node.right, node.left];
        
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
    }
    
    return root;
}
```

### Solution 4: Iterative DFS with Stack

**Python:**
```python
def invert_tree_stack(root: Optional[TreeNode]) -> Optional[TreeNode]:
    """
    Iterative using stack.
    
    Time: O(n), Space: O(h)
    """
    if not root:
        return None
    
    stack = [root]
    
    while stack:
        node = stack.pop()
        
        # Swap children
        node.left, node.right = node.right, node.left
        
        # Add children to stack
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
    
    return root
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Recursive |" O(n) "| O(h) | h = height |
| BFS |" O(n) "| O(w) | w = max width |
| Stack |" O(n) "| O(h) | Similar to recursive |

---

## üîÑ Variations

| Variation | Difference | Notes |
|-----------|------------|-------|
| Invert at specific levels | Only swap at certain depths | Add depth tracking |
| Return new tree | Don't modify original | Clone while inverting |
| Invert N-ary tree | Multiple children | Reverse children list |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Losing Reference During Swap

```python
# ‚ùå WRONG: Loses original right reference
root.left = root.right
root.right = root.left  # Now both are original right!

# ‚úÖ CORRECT: Use tuple unpacking or temp variable
root.left, root.right = root.right, root.left

# Or with temp:
temp = root.left
root.left = root.right
root.right = temp
```

### 2. Not Returning Root

```python
# ‚ùå WRONG: No return value
def invert_tree(root):
    if not root:
        return
    root.left, root.right = root.right, root.left
    invert_tree(root.left)
    invert_tree(root.right)
    # Missing return!

# ‚úÖ CORRECT: Return root
def invert_tree(root):
    if not root:
        return None
    root.left, root.right = root.right, root.left
    invert_tree(root.left)
    invert_tree(root.right)
    return root  # Return the root!
```

### 3. Modifying After Swap References

```python
# ‚ùå TRICKY: After swap, left/right have changed
root.left, root.right = root.right, root.left
invert_tree(root.left)   # This is now original right!
invert_tree(root.right)  # This is now original left!

# This is actually CORRECT - we want to process the new children
# Just be aware of the reference change
```

---

## üìù Practice Problems

### This Problem
- [ ] [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/) - LC 226

### Related Problems
- [ ] [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/) - LC 101
- [ ] [Same Tree](https://leetcode.com/problems/same-tree/) - LC 100
- [ ] [Flip Equivalent Binary Trees](https://leetcode.com/problems/flip-equivalent-binary-trees/) - LC 951

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** All approaches (recursive, BFS, stack)
**Day 3:** One-liner version
**Day 7:** Solve without notes
**Day 14:** Explain trade-offs between approaches

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**The Meme Factor:**
> If they mention the Homebrew story, acknowledge it! "Ah yes, the famous tweet. Let me show you how it's done..."

**Explaining approach:**
> "I'll swap each node's children recursively. The traversal order doesn't matter - preorder, postorder, or level-order all work because every node needs to be visited exactly once."

**Discussing trade-offs:**
> "Recursive is cleanest and uses O(h) space. BFS uses O(w) space which could be O(n/2) for a balanced tree. For very deep trees, iterative might avoid stack overflow."

**Follow-up - Without Modifying:**
> "If we can't modify the original tree, I'd create a new tree where each node's children are swapped copies of the original children."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Basic expectation |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | The famous interview |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Standard question |
| Apple | ‚≠ê‚≠ê‚≠ê‚≠ê | Common warm-up |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Recursive solution | 2-3 min | Should be instant |
| BFS solution | 5 min | If asked |
| All approaches | 10 min | Show versatility |

---

> **üí° Key Insight:** Invert Binary Tree is simpler than it looks - just swap left and right at every node. The traversal order doesn't matter because every node needs exactly one swap. This problem teaches that sometimes the "scary" interview questions have beautifully simple solutions.

---

## üîó Related

- [Symmetric Tree](./4.6-Symmetric-Tree.md)
- [Same Tree](./4.5-Same-Tree.md)
- [DFS Concept](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
