# 2.2 Adjacency List

> **The most common graph representation for interview problems**
>
> â±ï¸ **Time:** 30-40 min | ğŸ“Š **Difficulty:** Beginner | ğŸ¯ **Interview Frequency:** Very High

---

## Overview

An **adjacency list** represents a graph as an array (or dictionary) where each index/key corresponds to a vertex, and the value is a list of that vertex's neighbors. This is the **most common representation** for graph problems in coding interviews.

```
Graph:                    Adjacency List:
    [0] â”€â”€â”€ [1]           0: [1, 2]
     â”‚       â”‚            1: [0, 3]
     â”‚       â”‚            2: [0, 3]
    [2] â”€â”€â”€ [3]           3: [1, 2]
    
Each vertex stores only its neighbors
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>When Adjacency List is the Right Choice</strong></summary>

**Use adjacency list when you see:**
- "Sparse graph" (few edges compared to VÂ²)
- "BFS/DFS traversal" (need to iterate neighbors)
- "Find all neighbors" frequently
- "Add edges dynamically"
- Most interview graph problems!

**Keywords suggesting adjacency list:**
- "graph", "nodes", "edges" (general graph)
- "neighbors", "connected to"
- "traverse", "visit all"
- "path", "reachable"

**Default choice:** If not explicitly told otherwise, use adjacency list.

</details>

---

## âœ… When to Use

| Scenario | Why List is Good |
|----------|-----------------|
| Sparse graphs (E << VÂ²) | Space O(V+E) instead of O(VÂ²) |
| BFS/DFS traversal | O(degree) to get neighbors |
| Most interview problems | Flexible and efficient |
| Unknown edge count | Easy to add edges |
| Large vertex count | No VÂ² memory allocation |
| Iterate through neighbors | Direct access to neighbor list |

---

## âŒ When NOT to Use

| Scenario | Why Not | Better Alternative |
|----------|---------|-------------------|
| Frequent "edge exists?" checks | O(degree) lookup | Adjacency Matrix O(1) |
| Dense graphs (E â‰ˆ VÂ²) | No space benefit | Adjacency Matrix |
| Floyd-Warshall algorithm | Needs matrix form | Adjacency Matrix |
| Need to remove edges frequently | O(degree) removal | Adjacency Matrix |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Graph?](../01-Graph-Fundamentals/1.1-What-Is-Graph.md)
- [Graph Terminology](../01-Graph-Fundamentals/1.2-Graph-Terminology.md)
- [Adjacency Matrix](./2.1-Adjacency-Matrix.md) - For comparison

**After mastering this:**
- [BFS Fundamentals](../03-BFS-Pattern/3.1-BFS-Fundamentals.md)
- [DFS Fundamentals](../04-DFS-Pattern/4.1-DFS-Fundamentals.md)
- [Representation Comparison](./2.4-Representation-Comparison.md)

**Used by nearly all graph algorithms:**
- BFS, DFS, Dijkstra, Bellman-Ford
- Topological Sort, Union-Find
- Connected Components, Cycle Detection

</details>

---

## ğŸ“ How It Works

### Basic Structure

```
Graph Visualization:          Adjacency List:
                              
    [A] â”€â”€â”€ [B]               A: [B, C]
     â”‚       â”‚                B: [A, D]
     â”‚       â”‚                C: [A, D]
    [C] â”€â”€â”€ [D]               D: [B, C]
    
    Using indices:
    0: [1, 2]      (A connects to B, C)
    1: [0, 3]      (B connects to A, D)
    2: [0, 3]      (C connects to A, D)
    3: [1, 2]      (D connects to B, C)
```

### Weighted Graph

```
    [A] â”€â”€5â”€â”€ [B]             A: [(B,5), (C,3)]
     â”‚         â”‚              B: [(A,5), (D,2)]
     3         2              C: [(A,3), (D,4)]
     â”‚         â”‚              D: [(B,2), (C,4)]
    [C] â”€â”€4â”€â”€ [D]
                              Each entry: (neighbor, weight)
```

### Directed Graph

```
    [A] â”€â”€â†’ [B]               A: [B, C]      (A points to B, C)
     â”‚       â”‚                B: [D]         (B points to D)
     â†“       â†“                C: [D]         (C points to D)
    [C] â”€â”€â†’ [D]               D: []          (D points to nothing)
    
Note: Only outgoing edges stored
Aâ†’B means B is in A's list, but A is NOT in B's list
```

### Implementation Approaches

```python
# Approach 1: List of lists (when vertices are 0 to V-1)
graph = [[] for _ in range(V)]
graph[0].append(1)  # Edge 0â†’1

# Approach 2: Dictionary (when vertices have arbitrary labels)
graph = {}
graph['A'] = ['B', 'C']
graph['B'] = ['A', 'D']

# Approach 3: defaultdict (auto-creates empty list)
from collections import defaultdict
graph = defaultdict(list)
graph['A'].append('B')  # No KeyError if 'A' doesn't exist
```

---

## ğŸ’» Code Implementation

**Python:**
```python
from collections import defaultdict

class AdjacencyList:
    """Graph represented as adjacency list (dictionary of lists)."""
    
    def __init__(self, directed=False, weighted=False):
        self.directed = directed
        self.weighted = weighted
        self.graph = defaultdict(list)
        self.vertices = set()
    
    def add_vertex(self, v):
        """Add a vertex to the graph."""
        self.vertices.add(v)
        if v not in self.graph:
            self.graph[v] = []
    
    def add_edge(self, u, v, weight=1):
        """Add edge from u to v."""
        self.vertices.add(u)
        self.vertices.add(v)
        
        if self.weighted:
            self.graph[u].append((v, weight))
            if not self.directed:
                self.graph[v].append((u, weight))
        else:
            self.graph[u].append(v)
            if not self.directed:
                self.graph[v].append(u)
    
    def remove_edge(self, u, v):
        """Remove edge between u and v."""
        if self.weighted:
            self.graph[u] = [(n, w) for n, w in self.graph[u] if n != v]
            if not self.directed:
                self.graph[v] = [(n, w) for n, w in self.graph[v] if n != u]
        else:
            if v in self.graph[u]:
                self.graph[u].remove(v)
            if not self.directed and u in self.graph[v]:
                self.graph[v].remove(u)
    
    def has_edge(self, u, v):
        """Check if edge exists. O(degree(u))"""
        if self.weighted:
            return any(n == v for n, w in self.graph[u])
        return v in self.graph[u]
    
    def get_neighbors(self, v):
        """Get all neighbors of v. O(1)"""
        return self.graph[v]
    
    def degree(self, v):
        """Get degree of vertex v."""
        return len(self.graph[v])
    
    def in_degree(self, v):
        """Get in-degree for directed graph. O(V+E)"""
        count = 0
        for u in self.graph:
            if self.weighted:
                if any(n == v for n, w in self.graph[u]):
                    count += 1
            else:
                if v in self.graph[u]:
                    count += 1
        return count
    
    def out_degree(self, v):
        """Get out-degree for directed graph."""
        return self.degree(v)
    
    def get_all_edges(self):
        """Return list of all edges."""
        edges = []
        for u in self.graph:
            for item in self.graph[u]:
                if self.weighted:
                    v, w = item
                    if self.directed or u < v:  # Avoid duplicates for undirected
                        edges.append((u, v, w))
                else:
                    v = item
                    if self.directed or u < v:
                        edges.append((u, v))
        return edges
    
    def __str__(self):
        """String representation."""
        result = []
        for v in sorted(self.graph.keys()):
            result.append(f"{v}: {self.graph[v]}")
        return "\n".join(result)


# Example usage
print("=== Unweighted Undirected Graph ===")
g = AdjacencyList(directed=False, weighted=False)
g.add_edge('A', 'B')
g.add_edge('A', 'C')
g.add_edge('B', 'D')
g.add_edge('C', 'D')
print(g)
# A: ['B', 'C']
# B: ['A', 'D']
# C: ['A', 'D']
# D: ['B', 'C']

print(f"\nNeighbors of A: {g.get_neighbors('A')}")  # ['B', 'C']
print(f"Degree of B: {g.degree('B')}")  # 2
print(f"Has edge A-B: {g.has_edge('A', 'B')}")  # True
print(f"Has edge A-D: {g.has_edge('A', 'D')}")  # False

print("\n=== Weighted Directed Graph ===")
g2 = AdjacencyList(directed=True, weighted=True)
g2.add_edge('A', 'B', 5)
g2.add_edge('A', 'C', 3)
g2.add_edge('B', 'D', 2)
g2.add_edge('C', 'D', 4)
print(g2)
# A: [('B', 5), ('C', 3)]
# B: [('D', 2)]
# C: [('D', 4)]
# D: []
```

**JavaScript:**
```javascript
class AdjacencyList {
    constructor(directed = false, weighted = false) {
        this.directed = directed;
        this.weighted = weighted;
        this.graph = new Map();
        this.vertices = new Set();
    }
    
    addVertex(v) {
        this.vertices.add(v);
        if (!this.graph.has(v)) {
            this.graph.set(v, []);
        }
    }
    
    addEdge(u, v, weight = 1) {
        this.addVertex(u);
        this.addVertex(v);
        
        if (this.weighted) {
            this.graph.get(u).push([v, weight]);
            if (!this.directed) {
                this.graph.get(v).push([u, weight]);
            }
        } else {
            this.graph.get(u).push(v);
            if (!this.directed) {
                this.graph.get(v).push(u);
            }
        }
    }
    
    removeEdge(u, v) {
        if (this.weighted) {
            this.graph.set(u, this.graph.get(u).filter(([n, w]) => n !== v));
            if (!this.directed) {
                this.graph.set(v, this.graph.get(v).filter(([n, w]) => n !== u));
            }
        } else {
            this.graph.set(u, this.graph.get(u).filter(n => n !== v));
            if (!this.directed) {
                this.graph.set(v, this.graph.get(v).filter(n => n !== u));
            }
        }
    }
    
    hasEdge(u, v) {
        const neighbors = this.graph.get(u) || [];
        if (this.weighted) {
            return neighbors.some(([n, w]) => n === v);
        }
        return neighbors.includes(v);
    }
    
    getNeighbors(v) {
        return this.graph.get(v) || [];
    }
    
    degree(v) {
        return (this.graph.get(v) || []).length;
    }
    
    display() {
        for (const [vertex, neighbors] of this.graph) {
            console.log(`${vertex}: [${neighbors.map(n => 
                this.weighted ? `(${n[0]},${n[1]})` : n
            ).join(', ')}]`);
        }
    }
}

// Example usage
const g = new AdjacencyList(false, false);
g.addEdge('A', 'B');
g.addEdge('A', 'C');
g.addEdge('B', 'D');
g.addEdge('C', 'D');
g.display();
// A: [B, C]
// B: [A, D]
// C: [A, D]
// D: [B, C]

console.log(`Neighbors of A: ${g.getNeighbors('A')}`);  // ['B', 'C']
console.log(`Degree of B: ${g.degree('B')}`);  // 2
```

### Quick Building Patterns

**Python - Common Interview Pattern:**
```python
from collections import defaultdict

def build_graph_from_edges(edges, directed=False):
    """Build adjacency list from edge list.
    
    Args:
        edges: List of [u, v] or [u, v, weight]
        directed: If False, add edges in both directions
    
    Returns:
        defaultdict representing the graph
    """
    graph = defaultdict(list)
    
    for edge in edges:
        if len(edge) == 2:
            u, v = edge
            graph[u].append(v)
            if not directed:
                graph[v].append(u)
        else:
            u, v, w = edge
            graph[u].append((v, w))
            if not directed:
                graph[v].append((u, w))
    
    return graph


# Example: LeetCode-style input
edges = [[0, 1], [0, 2], [1, 3], [2, 3]]
graph = build_graph_from_edges(edges)
print(dict(graph))
# {0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2]}
```

---

## âš¡ Complexity Analysis

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| Add vertex | O(1) | Dictionary/array append |
| Add edge | O(1) | List append |
| Remove edge | O(degree) | Search through neighbors |
| Check edge exists | O(degree) | Search through neighbors |
| Get all neighbors | O(1) | â­ Best feature! |
| Get degree | O(1) | Length of neighbor list |
| Iterate neighbors | O(degree) | Direct list traversal |
| **Space** | O(V + E) | â­ Efficient for sparse! |

**Why these complexities:**
- Neighbors stored directly â†’ O(1) access to list
- Edge check requires linear search through neighbors
- Space proportional to actual edges, not VÂ²

---

## ğŸ”„ Variations

| Variation | Storage | Use Case |
|-----------|---------|----------|
| List of lists | `[[1,2], [0,3], ...]` | Integer vertices 0 to V-1 |
| Dictionary | `{'A': ['B'], ...}` | Arbitrary vertex labels |
| defaultdict | Auto-create lists | Cleaner code |
| Set of neighbors | `{0: {1,2}, ...}` | Fast edge check O(1) |

### Set-Based Adjacency (Hybrid)

```python
from collections import defaultdict

# Use sets instead of lists for O(1) edge check
graph = defaultdict(set)
graph[0].add(1)
graph[0].add(2)

# O(1) edge check!
has_edge = 2 in graph[0]  # True

# But still O(degree) to iterate
for neighbor in graph[0]:
    print(neighbor)
```

---

## âš ï¸ Common Mistakes

### 1. Forgetting to Add Both Directions for Undirected

```python
# âŒ Wrong: Only one direction
graph[u].append(v)

# âœ… Correct: Both directions for undirected
graph[u].append(v)
graph[v].append(u)
```

### 2. KeyError for Missing Vertices

```python
# âŒ Wrong: Will crash if vertex doesn't exist
neighbors = graph[vertex]  # KeyError!

# âœ… Correct: Use defaultdict or check
from collections import defaultdict
graph = defaultdict(list)
neighbors = graph[vertex]  # Returns [] if missing

# Or use get()
neighbors = graph.get(vertex, [])
```

### 3. Modifying List While Iterating

```python
# âŒ Wrong: Modifying during iteration
for neighbor in graph[u]:
    if should_remove(neighbor):
        graph[u].remove(neighbor)  # Dangerous!

# âœ… Correct: Create new list or iterate over copy
graph[u] = [n for n in graph[u] if not should_remove(n)]
# Or
for neighbor in list(graph[u]):  # Iterate over copy
    if should_remove(neighbor):
        graph[u].remove(neighbor)
```

### 4. Duplicate Edges

```python
# âŒ Wrong: Adding same edge multiple times
add_edge(0, 1)
add_edge(0, 1)  # Now 0 has [1, 1] - duplicate!

# âœ… Correct: Check before adding or use set
if v not in graph[u]:
    graph[u].append(v)

# Or use sets
graph = defaultdict(set)
graph[0].add(1)
graph[0].add(1)  # Still just {1}
```

---

## ğŸ“ Practice Problems

### Easy (Basic Usage)
| Problem | Difficulty | Focus |
|---------|------------|-------|
| [Find the Town Judge](https://leetcode.com/problems/find-the-town-judge/) | ğŸŸ¢ Easy | Build and query |
| [Find Center of Star Graph](https://leetcode.com/problems/find-center-of-star-graph/) | ğŸŸ¢ Easy | Structure analysis |

### Medium (Traversal with Adjacency List)
| Problem | Difficulty | Focus |
|---------|------------|-------|
| [Clone Graph](https://leetcode.com/problems/clone-graph/) | ğŸŸ¡ Medium | Graph traversal |
| [Number of Islands](https://leetcode.com/problems/number-of-islands/) | ğŸŸ¡ Medium | Grid as adjacency |
| [Course Schedule](https://leetcode.com/problems/course-schedule/) | ğŸŸ¡ Medium | Build from edges |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement AdjacencyList class from scratch
- **Day 3:** Build graph from edge list (interview pattern)
- **Day 7:** Solve BFS/DFS problem using adjacency list
- **Day 14:** Compare implementations for different problems
- **Day 30:** Build graph without thinking about syntax

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Discuss Adjacency List</strong></summary>

**When explaining your choice:**
> "I'll use an adjacency list since this is a sparse graph and we need to iterate through neighbors efficiently for BFS/DFS."

**Quick build pattern to memorize:**
```python
from collections import defaultdict
graph = defaultdict(list)
for u, v in edges:
    graph[u].append(v)
    graph[v].append(u)  # If undirected
```

**Trade-off discussion:**
> "Adjacency list gives O(1) neighbor access but O(degree) edge check. For this BFS problem, we iterate neighbors much more than we check specific edges, so list is better."

**Red flags to avoid:**
- âŒ Using matrix when edge iteration is the main operation
- âŒ Forgetting about disconnected components
- âŒ Not handling weighted vs unweighted correctly

</details>

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Understand concept | 10-15 min |
| Implement class | 20-25 min |
| Build from edges | 5-10 min |
| Solve traversal problem | 15-20 min |
| **Total to master** | **50-70 min** |

---

> **ğŸ’¡ Key Insight:** Adjacency list is the default choice for most graph problems. It provides O(V+E) space and O(1) neighbor access, making it ideal for BFS/DFS which iterate through neighbors constantly.

> **ğŸ”— Related:** [Adjacency Matrix](./2.1-Adjacency-Matrix.md) | [Edge List](./2.3-Edge-List.md) | [BFS Fundamentals](../03-BFS-Pattern/3.1-BFS-Fundamentals.md)

---

**Previous:** [â† 2.1 Adjacency Matrix](./2.1-Adjacency-Matrix.md)  
**Next:** [2.3 Edge List â†’](./2.3-Edge-List.md)
