# 1.3 Analyzing Loops

> **The systematic approach to finding time complexity of any loop structure.**
>
> â±ï¸ *Estimated reading: 25 minutes*

---

## ğŸ¯ The Universal Loop Formula

Most loop complexity follows this pattern:

```
Total Operations = (Number of Iterations) Ã— (Work per Iteration)
```

Let's build your intuition step by step.

---

## ğŸ“ Single Loops

### Pattern 1: Simple For Loop â€” O(n)

```python
def simple_loop(arr):
    total = 0
    for i in range(len(arr)):    # n iterations
        total += arr[i]          # O(1) work per iteration
    return total
    # Total: n Ã— O(1) = O(n)
```

**Trace:**
```
n = 5
i: 0 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ done
Iterations: 5 = n
```

### Pattern 2: Half Loop â€” Still O(n)

```python
def half_loop(arr):
    for i in range(len(arr) // 2):  # n/2 iterations
        print(arr[i])
    # Total: n/2 Ã— O(1) = O(n/2) = O(n)
```

**Remember:** We drop constants! O(n/2) = O(n)

### Pattern 3: Loop with Step â€” Still O(n)

```python
def step_loop(arr):
    for i in range(0, len(arr), 2):  # n/2 iterations (step of 2)
        print(arr[i])
    # Total: n/2 Ã— O(1) = O(n)

def step_loop_3(arr):
    for i in range(0, len(arr), 3):  # n/3 iterations
        print(arr[i])
    # Total: n/3 Ã— O(1) = O(n)
```

### Pattern 4: Loop Dividing by 2 â€” O(log n)

```python
def divide_loop(n):
    count = 0
    while n > 0:
        print(n)
        n = n // 2    # Divide by 2 each iteration
        count += 1
    return count
```

**Trace:**
```
n = 16:  16 â†’ 8 â†’ 4 â†’ 2 â†’ 1 â†’ 0 (done)
         1    2   3   4   5 = 5 iterations

n = 32:  32 â†’ 16 â†’ 8 â†’ 4 â†’ 2 â†’ 1 â†’ 0 (done)
         1     2   3   4   5   6 = 6 iterations

Pattern: logâ‚‚(n) + 1 iterations = O(log n)
```

### Pattern 5: Loop Multiplying by 2 â€” O(log n)

```python
def multiply_loop(n):
    i = 1
    while i < n:
        print(i)
        i *= 2    # Multiply by 2 each iteration
    # Iterations: logâ‚‚(n)
```

**Trace:**
```
n = 16:  i = 1 â†’ 2 â†’ 4 â†’ 8 â†’ 16 (stop, 16 â‰® 16)
         4 iterations = logâ‚‚(16) = O(log n)
```

### Pattern 6: Loop with Non-Constant Step â€” O(âˆšn)

```python
def sqrt_loop(n):
    i = 0
    while i * i < n:
        print(i)
        i += 1
    # When iÂ² = n, i = âˆšn, so âˆšn iterations
```

**Trace:**
```
n = 16:  i = 0 â†’ 1 â†’ 2 â†’ 3 â†’ 4 (stop, 4Â² = 16)
         4 iterations = âˆš16 = O(âˆšn)
```

---

## ğŸ“ Nested Loops

### Pattern 7: Simple Nested Loops â€” O(nÂ²)

```python
def nested_simple(arr):
    n = len(arr)
    for i in range(n):           # n iterations
        for j in range(n):       # n iterations for EACH i
            print(arr[i], arr[j])
    # Total: n Ã— n = O(nÂ²)
```

**Visualization:**
```
i=0: j runs 0,1,2,...,n-1  â†’ n operations
i=1: j runs 0,1,2,...,n-1  â†’ n operations
i=2: j runs 0,1,2,...,n-1  â†’ n operations
...
i=n-1: j runs 0,1,2,...,n-1  â†’ n operations

Total: n rows Ã— n operations each = nÂ²
```

### Pattern 8: Dependent Inner Loop â€” O(nÂ²)

```python
def nested_dependent(arr):
    n = len(arr)
    for i in range(n):           # n iterations
        for j in range(i):       # i iterations (depends on i)
            print(arr[j])
```

**Trace:**
```
i=0: j runs 0 times       â†’ 0 operations
i=1: j runs 0             â†’ 1 operation
i=2: j runs 0,1           â†’ 2 operations
i=3: j runs 0,1,2         â†’ 3 operations
...
i=n-1: j runs 0,1,...,n-2 â†’ n-1 operations

Total: 0 + 1 + 2 + ... + (n-1) = n(n-1)/2 = (nÂ² - n)/2 = O(nÂ²)
```

**The sum formula:** 1 + 2 + 3 + ... + n = n(n+1)/2 â‰ˆ nÂ²/2 = O(nÂ²)

### Pattern 9: Two Independent Inputs â€” O(n Ã— m)

```python
def two_arrays(arr1, arr2):
    for x in arr1:          # n iterations
        for y in arr2:      # m iterations
            print(x, y)
    # Total: n Ã— m = O(n Ã— m), NOT O(nÂ²)!
```

**Common mistake:** Assuming O(nÂ²) when inputs are different.

### Pattern 10: Inner Loop with Constant â€” O(n)

```python
def constant_inner(arr):
    n = len(arr)
    for i in range(n):           # n iterations
        for j in range(5):       # ALWAYS 5 iterations (constant)
            print(arr[i])
    # Total: n Ã— 5 = O(5n) = O(n)
```

### Pattern 11: Outer + Inner Dividing â€” O(n log n)

```python
def n_logn_nested(n):
    for i in range(n):           # n iterations
        j = n
        while j > 0:             # log n iterations
            print(i, j)
            j //= 2
    # Total: n Ã— log n = O(n log n)
```

### Pattern 12: Three Nested Loops â€” O(nÂ³)

```python
def triple_nested(arr):
    n = len(arr)
    for i in range(n):           # n iterations
        for j in range(n):       # n iterations
            for k in range(n):   # n iterations
                print(arr[i], arr[j], arr[k])
    # Total: n Ã— n Ã— n = O(nÂ³)
```

---

## ğŸ“ Complex Patterns

### Pattern 13: Loop with Multiple Operations

```python
def multiple_ops(arr, target):
    n = len(arr)
    for i in range(n):                    # n iterations
        if arr[i] == target:              # O(1)
            print("Found!")               # O(1)
        for j in range(5):                # O(5) = O(1)
            print(arr[i])
    # Total: n Ã— O(1) = O(n)
```

**Key:** All operations inside are O(1) or constant, so it's O(n).

### Pattern 14: Loop with O(n) Operation Inside

```python
def expensive_inner(arr):
    n = len(arr)
    for i in range(n):                    # n iterations
        if arr[i] in arr:                 # O(n) - linear search!
            print("Duplicate!")
    # Total: n Ã— O(n) = O(nÂ²)
```

**Hidden O(n):** The `in` operator on a list is O(n), not O(1)!

### Pattern 15: Loop with Sorting Inside (Very Bad!)

```python
def terrible_algorithm(matrix):
    n = len(matrix)
    for i in range(n):                    # n iterations
        matrix[i].sort()                  # O(n log n) each row!
    # Total: n Ã— O(n log n) = O(nÂ² log n)
```

### Pattern 16: Geometric Outer Loop

```python
def geometric_outer(n):
    i = 1
    while i < n:             # log n iterations
        for j in range(n):   # n iterations
            print(i, j)
        i *= 2
    # Total: log n Ã— n = O(n log n)
```

### Pattern 17: Two Loops (Sequential)

```python
def sequential_loops(arr):
    n = len(arr)
    
    # First loop: O(n)
    for x in arr:
        print(x)
    
    # Second loop: O(n)
    for x in arr:
        print(x * 2)
    
    # Total: O(n) + O(n) = O(2n) = O(n)
```

### Pattern 18: Two Pointers â€” O(n)

```python
def two_pointers(arr):
    left, right = 0, len(arr) - 1
    
    while left < right:           # At most n/2 iterations
        print(arr[left], arr[right])
        left += 1
        right -= 1
    # Total: O(n/2) = O(n)
```

**Why O(n)?** Each iteration moves pointers closer by 2, so at most n/2 iterations.

### Pattern 19: Sliding Window â€” O(n)

```python
def sliding_window(arr, k):
    n = len(arr)
    window_sum = sum(arr[:k])     # O(k) initial calculation
    max_sum = window_sum
    
    for i in range(k, n):         # n - k iterations
        window_sum += arr[i]       # Add new element O(1)
        window_sum -= arr[i - k]   # Remove old element O(1)
        max_sum = max(max_sum, window_sum)
    
    return max_sum
    # Total: O(k) + O(n-k) = O(n)
```

### Pattern 20: Amortized O(1) Inside Loop â€” Still O(n)

```python
def tricky_nested(arr):
    n = len(arr)
    j = 0
    
    for i in range(n):           # n iterations for outer
        while j < n and arr[j] < arr[i]:
            j += 1               # j increases across ALL iterations
    
    # Key insight: j only moves forward, never resets
    # j goes from 0 to n ONCE across all i iterations
    # Total: O(n) + O(n) = O(n), NOT O(nÂ²)!
```

**This is the Two Pointers pattern in disguise!**

---

## ğŸ§® Mathematical Summation Formulas

These formulas appear often in loop analysis:

### Sum 1: Arithmetic Series

```
1 + 2 + 3 + ... + n = n(n+1)/2 â‰ˆ nÂ²/2 = O(nÂ²)
```

**Appears in:** Dependent inner loop like `for j in range(i)`

### Sum 2: Powers of 2

```
1 + 2 + 4 + 8 + ... + 2^k = 2^(k+1) - 1 â‰ˆ 2^k

If k = log n, then sum = O(n)
```

**Appears in:** Geometric growth patterns

### Sum 3: Harmonic Series

```
1 + 1/2 + 1/3 + ... + 1/n â‰ˆ ln(n) = O(log n)
```

**Appears in:** Algorithms that decrease by 1/n each step

---

## âš¡ Quick Reference: Common Loop Complexities

| Pattern | Example Code | Complexity |
|---------|-------------|------------|
| Simple loop | `for i in range(n)` | O(n) |
| Loop with step | `for i in range(0, n, 2)` | O(n) |
| Divide by constant | `while n > 0: n //= 2` | O(log n) |
| Multiply by constant | `while i < n: i *= 2` | O(log n) |
| Two nested loops | `for i: for j:` | O(nÂ²) |
| Dependent inner loop | `for i: for j in range(i):` | O(nÂ²) |
| Different arrays | `for x in a: for y in b:` | O(n Ã— m) |
| Outer Ã— log n inner | `for i: while j //= 2:` | O(n log n) |
| Three nested loops | `for i: for j: for k:` | O(nÂ³) |
| Two pointers | `while left < right:` | O(n) |
| Sliding window | Move window once through array | O(n) |

---

## âš ï¸ Common Mistakes

### Mistake 1: Ignoring Built-in Function Complexity

```python
def sneaky_quadratic(arr):
    for i in range(len(arr)):    # O(n)
        if arr[i] in arr:        # O(n) - list search!
            pass
    # Total: O(nÂ²), not O(n)!
```

**Fix:** Know your language's complexity for built-in operations.

### Mistake 2: Assuming All Nested Loops Are O(nÂ²)

```python
def not_quadratic(arr):
    for i in range(len(arr)):
        for j in range(10):      # Constant!
            print(arr[i])
    # O(10n) = O(n)
```

### Mistake 3: Missing the Geometric Pattern

```python
def looks_quadratic(n):
    i = 1
    while i < n:
        j = 1
        while j < i:
            print(i, j)
            j *= 2       # Geometric growth!
        i *= 2           # Geometric growth!
    # Each outer: O(log i) inner
    # log n outer iterations Ã— log n inner = O(logÂ² n)
```

### Mistake 4: Not Recognizing Amortized Analysis

```python
def append_many(n):
    arr = []
    for i in range(n):
        arr.append(i)  # Amortized O(1), not O(n)!
    # Total: O(n), not O(nÂ²)
```

---

## ğŸ’» Interactive Examples

### Example 1: What's the complexity?

```python
def mystery1(n):
    for i in range(n):
        for j in range(n, 0, -1):
            print(i, j)
```

<details>
<summary><strong>Answer</strong></summary>

**O(nÂ²)**

- Outer loop: n iterations
- Inner loop: Also n iterations (counting down from n to 1)
- Total: n Ã— n = nÂ²

</details>

### Example 2: What's the complexity?

```python
def mystery2(n):
    for i in range(n):
        j = 1
        while j < n:
            print(i, j)
            j *= 3
```

<details>
<summary><strong>Answer</strong></summary>

**O(n log n)**

- Outer loop: n iterations
- Inner loop: j triples each time â†’ logâ‚ƒ(n) iterations
- Total: n Ã— logâ‚ƒ(n) = O(n log n)

(Remember: All log bases differ by a constant factor, so logâ‚ƒ(n) = O(log n))

</details>

### Example 3: What's the complexity?

```python
def mystery3(arr):
    n = len(arr)
    for i in range(n):
        for j in range(i, n):
            print(arr[i], arr[j])
```

<details>
<summary><strong>Answer</strong></summary>

**O(nÂ²)**

Counting operations:
- i=0: j runs n times
- i=1: j runs n-1 times
- i=2: j runs n-2 times
- ...
- i=n-1: j runs 1 time

Total: n + (n-1) + (n-2) + ... + 1 = n(n+1)/2 = O(nÂ²)

</details>

### Example 4: What's the complexity?

```python
def mystery4(n):
    i = n
    while i > 0:
        j = 0
        while j < i:
            print(i, j)
            j += 1
        i //= 2
```

<details>
<summary><strong>Answer</strong></summary>

**O(n)**

- i takes values: n, n/2, n/4, ..., 1
- For each i, inner loop runs i times
- Total: n + n/2 + n/4 + ... + 1 = 2n - 1 = O(n)

This is a geometric series that sums to ~2n.

</details>

---

## ğŸ¤ Interview Strategy

When analyzing loops in interviews:

### Step 1: Identify Loop Type
> "I see a nested loop structure..."

### Step 2: Count Iterations
> "The outer loop runs n times, the inner loop runs log n times..."

### Step 3: Identify Work Per Iteration
> "Inside, we're doing constant-time operations..."

### Step 4: Combine
> "So total complexity is O(n log n)."

### Step 5: Verify with Examples
> "For n = 8: outer runs 8 times, inner runs 3 times (log 8), so about 24 operations. For n = 16: outer runs 16 times, inner runs 4 times, so 64 operations. That growth pattern confirms O(n log n)."

---

> **ğŸ’¡ Key Insight:** Loop analysis is pattern matching. Once you recognize the 10-15 common patterns, you can analyze any loop structure by breaking it down into known components.

---

**Next:** [1.4 Analyzing Recursion](./1.4-Analyzing-Recursion.md) â†’
