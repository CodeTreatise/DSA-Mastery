# Continuous Subarray Sum (LeetCode 523)

> **Find a subarray of length â‰¥2 whose sum is a multiple of k using prefix sums with modular arithmetic.**

Given an integer array `nums` and an integer `k`, return `true` if `nums` has a continuous subarray of size at least two whose elements sum up to a multiple of `k`, or `false` otherwise.

A multiple of `k` is any integer `n` where `n % k == 0`.

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem signals:**
- "Sum is multiple of k" â†’ modular arithmetic
- "Subarray of size at least two" â†’ need length constraint
- "Continuous subarray" â†’ prefix sum applicable

**Key mathematical insight:**
```
sum(arr[i:j]) is a multiple of k
â†” sum(arr[i:j]) % k == 0
â†” (prefix[j] - prefix[i-1]) % k == 0
â†” prefix[j] % k == prefix[i-1] % k
```

So we look for two prefixes with the **same remainder** when divided by k.

</details>

---

## âœ… When to Use

- Subarray sum divisible by k
- Need contiguous elements
- Length constraint (â‰¥2 in this case)
- O(n) solution required

## âŒ When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Exact sum (not multiple) | Different lookup | Standard prefix + hash |
| No length constraint | Simpler problem | Basic prefix hash |
| Subsequence not subarray | Not contiguous | DP |
| k = 0 | Division undefined | Handle as special case |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- [Prefix Sum + Hash Overview](./5.1-Prefix-Hash-Overview.md)
- [Subarray Sum Equals K](./5.2-Subarray-Sum-K-LC560.md)
- Modular arithmetic basics

**After mastering:**
- Subarray Sums Divisible by K (LC 974) - Count all subarrays
- Make Sum Divisible by P (LC 1590) - Remove minimum subarray
- Check If Array Pairs Are Divisible by k (LC 1497)

**Combines with:**
- Prefix sum for range sums
- Modular arithmetic for divisibility
- Hash map for O(1) remainder lookup

</details>

---

## ğŸ“ How It Works

### Problem Examples

```
Example 1:
Input: nums = [23,2,4,6,7], k = 6
Output: true
Explanation: [2,4] sums to 6, which is 1Ã—6

Example 2:
Input: nums = [23,2,6,4,7], k = 6
Output: true
Explanation: [23,2,6,4,7] sums to 42, which is 7Ã—6

Example 3:
Input: nums = [23,2,6,4,7], k = 13
Output: false
No subarray of length â‰¥2 has sum that's a multiple of 13
```

### The Core Insight

```
If two prefix sums have the same remainder when divided by k,
the subarray between them sums to a multiple of k!

Why? Let's say:
  prefix[i] % k = r
  prefix[j] % k = r  (where j > i)

Then:
  (prefix[j] - prefix[i]) % k = (r - r) % k = 0

So sum(arr[i+1:j+1]) is divisible by k!
```

### Step-by-Step Example

```
nums = [23, 2, 4, 6, 7], k = 6

Prefix sums:     [23, 25, 29, 35, 42]
Prefix % 6:      [ 5,  1,  5,  5,  0]
                   â†‘      â†‘
                  idx 0  idx 2

At index 2: prefix % 6 = 5
Previously at index 0: prefix % 6 = 5
Subarray from index 1 to 2: [2, 4]
Sum = 6, which is 1Ã—6 âœ“

Length check: 2 - 0 = 2 â‰¥ 2 âœ“
Answer: true
```

### Visualization

```
nums:      [  23,    2,    4,    6,    7  ]
index:         0     1     2     3     4

prefix:    [  23,   25,   29,   35,   42  ]
prefix%6:  [   5,    1,    5,    5,    0  ]

remainder_index = {0: -1}  // Initialize for sum=0 case

Step 0: prefix%6 = 5
        5 not in map
        map = {0:-1, 5:0}

Step 1: prefix%6 = 1
        1 not in map  
        map = {0:-1, 5:0, 1:1}

Step 2: prefix%6 = 5
        5 in map at index 0!
        Length = 2 - 0 = 2 â‰¥ 2 âœ“
        Return TRUE!

Subarray [2,4] (indices 1-2) sums to 6, multiple of 6.
```

### Why Store First Occurrence?

We store the **first index** where we see each remainder because:
- We need length â‰¥ 2
- First occurrence maximizes the gap
- If remainder repeats immediately (gap=1), it's too short

---

## ğŸ’» Code Implementation

### Python Solution

```python
from typing import List

class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        """
        Check if subarray of length â‰¥2 has sum that's multiple of k.
        
        Key insight: Two prefix sums with same remainder mod k
        means the subarray between them sums to a multiple of k.
        
        Time: O(n)
        Space: O(min(n, k)) - at most k different remainders
        """
        # Map: remainder -> first index where we saw it
        remainder_index = {0: -1}  # For subarrays starting at 0
        
        prefix = 0
        
        for i, num in enumerate(nums):
            prefix += num
            remainder = prefix % k
            
            if remainder in remainder_index:
                # Found same remainder before
                prev_index = remainder_index[remainder]
                # Check length constraint: need at least 2 elements
                if i - prev_index >= 2:
                    return True
                # Don't update map - keep first occurrence for max length
            else:
                # First time seeing this remainder
                remainder_index[remainder] = i
        
        return False
```

### Python - With Detailed Comments

```python
def checkSubarraySum(nums: List[int], k: int) -> bool:
    """Verbose version with explanation."""
    
    # Why {0: -1}?
    # If subarray nums[0:i+1] sums to a multiple of k,
    # prefix % k = 0, and we need index -1 to get length â‰¥ 2
    remainder_index = {0: -1}
    
    prefix = 0
    
    for i, num in enumerate(nums):
        prefix += num
        remainder = prefix % k
        
        # Mathematical explanation:
        # If prefix[j] % k == prefix[i] % k (where j > i)
        # Then (prefix[j] - prefix[i]) % k == 0
        # Meaning sum(nums[i+1:j+1]) is a multiple of k
        
        if remainder in remainder_index:
            prev_index = remainder_index[remainder]
            
            # Length of subarray: (i) - (prev_index) 
            # This represents elements from prev_index+1 to i (inclusive)
            # Length = i - prev_index
            if i - prev_index >= 2:
                return True
            # Important: DON'T update the map here!
            # We want the FIRST occurrence to maximize potential length
        else:
            remainder_index[remainder] = i
    
    return False
```

### Python - Handle k=0 Edge Case

```python
def checkSubarraySum(nums: List[int], k: int) -> bool:
    """Handle k=0 case (looking for sum=0)."""
    if k == 0:
        # Need consecutive zeros
        for i in range(1, len(nums)):
            if nums[i] == 0 and nums[i-1] == 0:
                return True
        return False
    
    # Standard solution for k != 0
    remainder_index = {0: -1}
    prefix = 0
    
    for i, num in enumerate(nums):
        prefix += num
        remainder = prefix % k
        
        if remainder in remainder_index:
            if i - remainder_index[remainder] >= 2:
                return True
        else:
            remainder_index[remainder] = i
    
    return False
```

### JavaScript Solution

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var checkSubarraySum = function(nums, k) {
    // Map: remainder -> first index where seen
    const remainderIndex = new Map([[0, -1]]);
    
    let prefix = 0;
    
    for (let i = 0; i < nums.length; i++) {
        prefix += nums[i];
        
        // Handle modulo - ensure non-negative
        let remainder = prefix % k;
        // Note: In JavaScript, -5 % 3 = -2, but Python gives 1
        // For this problem, nums are non-negative, so not an issue
        
        if (remainderIndex.has(remainder)) {
            if (i - remainderIndex.get(remainder) >= 2) {
                return true;
            }
            // Don't update - keep first occurrence
        } else {
            remainderIndex.set(remainder, i);
        }
    }
    
    return false;
};
```

### JavaScript - Alternative with Object

```javascript
var checkSubarraySum = function(nums, k) {
    const remainderIndex = { 0: -1 };  // Plain object
    let prefix = 0;
    
    for (let i = 0; i < nums.length; i++) {
        prefix += nums[i];
        const remainder = prefix % k;
        
        if (remainder in remainderIndex) {
            if (i - remainderIndex[remainder] >= 2) {
                return true;
            }
        } else {
            remainderIndex[remainder] = i;
        }
    }
    
    return false;
};
```

---

## âš¡ Complexity Analysis

| Aspect | Complexity | Explanation |
|--------|------------|-------------|
| Time | O(n) | Single pass through array |
| Space | O(min(n, k)) | At most k unique remainders |

**Why O(min(n, k)) space:**
- Remainders mod k are in range [0, k-1]
- At most k distinct remainders possible
- But if n < k, at most n remainders stored

**Comparison:**

| Approach | Time | Space |
|----------|------|-------|
| Brute force | O(nÂ²) | O(1) |
| Prefix + Hash | O(n) | O(min(n,k)) |

---

## ğŸ”„ Variations

| Variation | Key Difference | Problem |
|-----------|----------------|---------|
| Count subarrays (not just find) | Count all pairs | LC 974 |
| Remove minimum to make divisible | Find shortest | LC 1590 |
| No length constraint | Simpler | Interview variant |
| Sum exactly k (not multiple) | Different math | LC 560 |

---

## âš ï¸ Common Mistakes

### 1. Forgetting Length Constraint

```python
# âŒ WRONG: Not checking length
if remainder in remainder_index:
    return True  # Might be length 1!

# âœ… CORRECT: Check length â‰¥ 2
if remainder in remainder_index:
    if i - remainder_index[remainder] >= 2:
        return True
```

### 2. Updating Map on Match

```python
# âŒ WRONG: Updating index when found
if remainder in remainder_index:
    if i - remainder_index[remainder] >= 2:
        return True
    remainder_index[remainder] = i  # WRONG! Keep first

# âœ… CORRECT: Only store first occurrence
if remainder not in remainder_index:
    remainder_index[remainder] = i
```

**Why:** We need maximum gap. Updating to later index reduces potential gap.

### 3. Wrong Initialization

```python
# âŒ WRONG: Empty map or wrong index
remainder_index = {}  # Missing 0
remainder_index = {0: 0}  # Wrong index

# âœ… CORRECT
remainder_index = {0: -1}  # -1 so that length = i - (-1) = i+1 â‰¥ 2
```

### 4. Not Handling k=0 (Old Constraint)

```python
# Old problem version allowed k=0
# Modern LeetCode guarantees k â‰¥ 1
# But good to know: k=0 means we need sum=0
```

---

## ğŸ“ Practice Problems (Progressive)

| Problem | Difficulty | Key Insight | Link |
|---------|------------|-------------|------|
| Continuous Subarray Sum | ğŸŸ¡ Medium | Remainder + length | [LC 523](https://leetcode.com/problems/continuous-subarray-sum/) |
| Subarray Sum Equals K | ğŸŸ¡ Medium | No modulo | [LC 560](https://leetcode.com/problems/subarray-sum-equals-k/) |
| Subarray Sums Divisible by K | ğŸŸ¡ Medium | Count all | [LC 974](https://leetcode.com/problems/subarray-sums-divisible-by-k/) |
| Make Sum Divisible by P | ğŸŸ¡ Medium | Remove minimum | [LC 1590](https://leetcode.com/problems/make-sum-divisible-by-p/) |
| Check If Array Pairs Divisible | ğŸŸ¡ Medium | Pair remainders | [LC 1497](https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/) |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve LC 523, focus on the remainder insight
- **Day 3:** Solve again, explain why store first occurrence
- **Day 7:** Solve LC 974 (count version)
- **Day 14:** Solve LC 1590 (harder variation)
- **Day 30:** Should solve LC 523 in < 10 min

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate in Interview</strong></summary>

**Clarify the problem:**
> "So I need to find a subarray of length at least 2 whose sum is divisible by k. The array elements are non-negative."

**Explain the approach:**
> "I'll use prefix sums with a twist. If two prefix sums have the same remainder when divided by k, the subarray between them sums to a multiple of k."

**Mathematical justification:**
> "This works because (a - b) % k = 0 if and only if a % k = b % k."

**Handle the length constraint:**
> "I store the first index where I see each remainder. This maximizes the gap, ensuring I can find length â‰¥ 2 subarrays."

**Edge case to mention:**
- Initialization with {0: -1} handles subarrays starting at index 0

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Meta | â­â­â­â­â­ | Very common |
| Google | â­â­â­â­ | Often asked |
| Amazon | â­â­â­ | Occasionally |
| Microsoft | â­â­â­ | Standard problem |

---

## â±ï¸ Time Estimates

| Activity | Target Time |
|----------|-------------|
| Recognize pattern | 2-3 min |
| Explain approach | 2-3 min |
| Implement solution | 8-10 min |
| Handle edge cases | 2-3 min |
| Total | 15-19 min |

---

> **ğŸ’¡ Key Insight:** Two prefix sums with the same remainder mod k means their difference is divisible by k. Store the first occurrence of each remainder to maximize potential subarray length.

> **ğŸ”— Related:** [Prefix Hash Overview](./5.1-Prefix-Hash-Overview.md) | [Subarray Sum K](./5.2-Subarray-Sum-K-LC560.md) | [LC 974 - Count Divisible](https://leetcode.com/problems/subarray-sums-divisible-by-k/)
