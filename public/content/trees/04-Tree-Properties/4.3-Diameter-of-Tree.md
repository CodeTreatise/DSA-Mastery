# 4.3 - Diameter of Binary Tree (LC 543)

> **Grokking Pattern:** #11 Tree DFS (Global Variable Pattern)
>
> **Difficulty:** Easy | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very Common

---

## Problem Statement

Given the `root` of a binary tree, return the **length of the diameter** of the tree.

The **diameter** of a binary tree is the length of the **longest path** between any two nodes in a tree. This path may or may not pass through the root.

The length of a path is the **number of edges** between nodes.

```
Input: root = [1,2,3,4,5]
        1
       / \
      2   3
     / \
    4   5

Output: 3
Explanation: The path is [4,2,1,3] or [5,2,1,3]
             3 edges total
```

[LeetCode 543 - Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Longest path between any two nodes"
- "Diameter" or "maximum distance"
- Path may or may not go through root

**Key insight:**
For any node, the longest path **through that node** is:
```
left_height + right_height
```

The answer is the maximum of this value across ALL nodes. This requires a **global variable** to track the maximum.

</details>

---

## ‚úÖ When to Use

- Finding longest path in tree
- Path doesn't have fixed start/end
- Need to compare values across nodes

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Path must go through root | Simpler calculation | Direct height sum |
| Need the actual path | Just counting edges | Path tracking |
| Weighted edges | Different formula | Weighted path algorithms |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Maximum Depth](./4.1-Maximum-Depth.md)
- [DFS Concept - Global Variable Pattern](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)

**After mastering this:**
- [Binary Tree Maximum Path Sum](../05-Path-Problems/5.3-Maximum-Path-Sum.md) - Harder version
- [Longest Path in DAG](../../10-Graphs/path-problems.md)

**Similar pattern:**
- Any problem where you need the maximum across all nodes

</details>

---

## üìê How It Works

### Core Intuition

At each node, the longest path **going through** that node uses:
- The deepest path in left subtree
- The deepest path in right subtree

```
        1               Diameter through node 1:
       / \              = height(left) + height(right)
      2   3             = 2 + 1 = 3 edges
     / \
    4   5

But the diameter might not go through root!
```

### Why Global Variable?

```
        1
       / \
      2   3
     / \   \
    4   5   6
   /       / \
  7       8   9

Diameter = 6 (path: 7-4-2-1-3-6-8 or 7-4-2-1-3-6-9)

This path goes through node 1, but we need to check
EVERY node to find the maximum.
```

### Visualization

```
At each node, we calculate TWO things:

1. Height (returned to parent):
   = 1 + max(left_height, right_height)

2. Diameter through this node (update global):
   = left_height + right_height

        1           height=3, diameter_here=2+1=3 ‚Üê max!
       / \
      2   3         height(2)=2, diameter_here=1+1=2
     / \            height(3)=1
    4   5           height(4)=1, height(5)=1
```

---

## üíª Code Implementation

### Solution 1: Global Variable Pattern

**Python:**
```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def diameter_of_binary_tree(root: Optional[TreeNode]) -> int:
    """
    Diameter using global variable pattern.
    
    Key insight: At each node, diameter = left_height + right_height.
    Track the maximum across all nodes.
    
    Time: O(n), Space: O(h)
    """
    max_diameter = 0
    
    def height(node):
        nonlocal max_diameter
        
        if not node:
            return 0
        
        left_height = height(node.left)
        right_height = height(node.right)
        
        # Update global max with diameter through this node
        max_diameter = max(max_diameter, left_height + right_height)
        
        # Return height to parent
        return 1 + max(left_height, right_height)
    
    height(root)
    return max_diameter
```

**JavaScript:**
```javascript
function diameterOfBinaryTree(root) {
    let maxDiameter = 0;
    
    function height(node) {
        if (!node) return 0;
        
        const leftHeight = height(node.left);
        const rightHeight = height(node.right);
        
        // Update global max
        maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight);
        
        // Return height
        return 1 + Math.max(leftHeight, rightHeight);
    }
    
    height(root);
    return maxDiameter;
}
```

### Solution 2: Using Class Variable (Alternative)

**Python:**
```python
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.max_diameter = 0
        
        def height(node):
            if not node:
                return 0
            
            left = height(node.left)
            right = height(node.right)
            
            self.max_diameter = max(self.max_diameter, left + right)
            
            return 1 + max(left, right)
        
        height(root)
        return self.max_diameter
```

### Solution 3: Return Tuple (No Global)

**Python:**
```python
def diameter_no_global(root: Optional[TreeNode]) -> int:
    """
    Alternative: Return (height, max_diameter) tuple.
    Avoids global variable but more complex.
    """
    def dfs(node):
        """Returns (height, max_diameter_in_subtree)"""
        if not node:
            return (0, 0)
        
        left_height, left_max = dfs(node.left)
        right_height, right_max = dfs(node.right)
        
        # Diameter through this node
        diameter_here = left_height + right_height
        
        # Maximum diameter in entire subtree
        max_diameter = max(diameter_here, left_max, right_max)
        
        # Height of this node
        height = 1 + max(left_height, right_height)
        
        return (height, max_diameter)
    
    _, diameter = dfs(root)
    return diameter
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Global Variable |" O(n) "| O(h) | Single traversal |
| Tuple Return |" O(n) "| O(h) | Same complexity |

**Why O(n)?**
- Visit each node exactly once
- O(1) work at each node

**Why O(h) space?**
- Recursion stack depth = tree height
- Worst case O(n) for skewed tree

---

## üîÑ Variations

| Variation | Difference | LeetCode |
|-----------|------------|----------|
| Binary Tree Maximum Path Sum | Path values, not edges | LC 124 |
| Longest Univalue Path | Same value constraint | LC 687 |
| Diameter in N-ary Tree | Multiple children | - |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Confusing Height vs Diameter

```python
# ‚ùå WRONG: Returning diameter instead of height
def helper(node):
    left = helper(node.left)
    right = helper(node.right)
    return left + right  # This is diameter, not height!

# ‚úÖ CORRECT: Return height, update diameter separately
def height(node):
    left = height(node.left)
    right = height(node.right)
    max_diameter = max(max_diameter, left + right)  # Update global
    return 1 + max(left, right)  # Return height
```

### 2. Only Checking Root

```python
# ‚ùå WRONG: Only checking diameter through root
def diameter(root):
    return height(root.left) + height(root.right)

# The maximum diameter might not go through root!
# Must check every node.

# ‚úÖ CORRECT: Check every node
max_diameter = max(max_diameter, left_height + right_height)
```

### 3. Counting Nodes Instead of Edges

```python
# ‚ùå WRONG: Adding 1 for current node
diameter_here = 1 + left_height + right_height  # Wrong!

# ‚úÖ CORRECT: Edges = heights sum
diameter_here = left_height + right_height  # Correct!

# Path [4,2,1,3] has 4 nodes but 3 edges
```

---

## üìù Practice Problems

### This Problem
- [ ] [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) - LC 543

### Similar Pattern
- [ ] [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/) - LC 124 (Hard)
- [ ] [Longest Univalue Path](https://leetcode.com/problems/longest-univalue-path/) - LC 687
- [ ] [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/) - LC 110

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Global variable pattern
**Day 3:** Draw the height vs diameter distinction
**Day 7:** Solve Longest Univalue Path
**Day 14:** Tackle Maximum Path Sum (harder)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Explaining the approach:**
> "The diameter through any node equals the sum of its left and right heights. I'll compute heights with DFS and track the maximum diameter across all nodes using a global variable."

**Clarifying edges vs nodes:**
> "Just to confirm - we're counting edges, not nodes. So a path of 4 nodes has diameter 3."

**Follow-up - Maximum Path Sum:**
> "This extends to path sum problems. Instead of counting edges, we track the maximum path value, and instead of height, we return the maximum single-branch sum."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Often leads to LC 124 |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask follow-ups |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Classic interview question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Recognize pattern | 2-3 min | Height + global variable |
| Implement | 7-10 min | Watch edge vs node |
| Explain approach | 2-3 min | Draw the tree |

---

> **üí° Key Insight:** The diameter problem teaches a fundamental pattern: sometimes you need to track a "global maximum" while computing something else (height) at each node. The answer isn't what you return from recursion, but what you accumulate across all recursive calls.

---

## üîó Related

- [Maximum Depth](./4.1-Maximum-Depth.md)
- [Maximum Path Sum](../05-Path-Problems/5.3-Maximum-Path-Sum.md)
- [DFS - Global Variable Pattern](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
