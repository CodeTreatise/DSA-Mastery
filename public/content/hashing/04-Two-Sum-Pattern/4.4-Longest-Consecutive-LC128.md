# Longest Consecutive Sequence (LeetCode 128)

> **The clever hash set pattern that achieves O(n) for what seems like a sorting problem.**

Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem signals:**
- Find **consecutive** sequence in unsorted array
- O(n) time constraint (can't sort!)
- Need to detect **sequence boundaries**

**Key insight:**
- Use Hash Set for O(1) lookup
- Only start counting from **sequence start** (no left neighbor)
- This avoids redundant counting

**This pattern appears when:**
- Finding sequences/ranges in unsorted data
- O(n) constraint rules out sorting
- Need to identify starts/boundaries of groups

</details>

---

## ‚úÖ When to Use

- Finding consecutive sequences in unsorted data
- O(n) time constraint is critical
- Don't need to preserve original order
- Detecting boundaries/starts of groups

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| O(n log n) acceptable | Simpler with sorting | Sort + linear scan |
| Need original indices | Set loses positions | Hash map with indices |
| Finding k-length sequences | Different optimization | Sliding window |
| Ordered output needed | Set is unordered | Sort-based approach |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- Hash Set operations (O(1) add/lookup)
- Sequence/consecutive number concept
- [Two Sum](./4.2-Two-Sum-LC1.md) - Hash for lookup

**After mastering:**
- [Longest Consecutive Sequence II](https://leetcode.com/problems/longest-consecutive-sequence-ii/) - Follow-up
- Union Find approach for similar problems

**Combines with:**
- Union Find for connected components
- Frequency counting patterns

</details>

---

## üìê How It Works

### Problem Examples

```
Example 1:
Input: nums = [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: [1, 2, 3, 4] is the longest consecutive sequence

Example 2:
Input: nums = [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]
Output: 9
Explanation: [0, 1, 2, 3, 4, 5, 6, 7, 8]
```

### Why Sorting Won't Work (for O(n))

```
Sort: O(n log n) - violates O(n) constraint
We need a clever O(n) approach!
```

### The Key Insight: Sequence Starts

**Observation:** A number is the START of a sequence if `num - 1` doesn't exist.

```
nums = [100, 4, 200, 1, 3, 2]
Set = {100, 4, 200, 1, 3, 2}

Check each number:
- 100: 99 not in set ‚Üí START of sequence, count: 100 (length 1)
- 4: 3 IS in set ‚Üí NOT a start, skip
- 200: 199 not in set ‚Üí START of sequence, count: 200 (length 1)
- 1: 0 not in set ‚Üí START of sequence, count: 1,2,3,4 (length 4) ‚úì
- 3: 2 IS in set ‚Üí NOT a start, skip
- 2: 1 IS in set ‚Üí NOT a start, skip

Longest = 4
```

### Why Only Counting from Starts is O(n)

```
Key insight: Each element is visited at most twice:
1. Once when checking if it's a start
2. Once when counting (if it's part of a sequence starting elsewhere)

For sequence [1, 2, 3, 4]:
- We only count from 1 (the start)
- 2, 3, 4 are checked but not used as starts
- Total operations: O(n)
```

### Visualization

```
nums = [100, 4, 200, 1, 3, 2]

Step 1: Build Set
        {100, 4, 200, 1, 3, 2}

Step 2: Find sequences by identifying starts

        100: 99 not in set ‚Üí COUNT from 100
             100 in set ‚úì, 101 not in set
             Length: 1

        4: 3 IS in set ‚Üí SKIP (not a start)

        200: 199 not in set ‚Üí COUNT from 200
             200 in set ‚úì, 201 not in set
             Length: 1

        1: 0 not in set ‚Üí COUNT from 1
           1 ‚úì ‚Üí 2 ‚úì ‚Üí 3 ‚úì ‚Üí 4 ‚úì ‚Üí 5 ‚úó
           Length: 4 ‚Üê LONGEST

        3: 2 IS in set ‚Üí SKIP
        2: 1 IS in set ‚Üí SKIP

Answer: 4
```

---

## üíª Code Implementation

### Python

```python
from typing import List

class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        """
        Find longest consecutive sequence in O(n).
        
        Key insight: Only count from sequence STARTS (numbers with no left neighbor).
        
        Time: O(n) - each element checked at most twice
        Space: O(n) - hash set storage
        """
        if not nums:
            return 0
        
        num_set = set(nums)
        longest = 0
        
        for num in num_set:
            # Only start counting if this is the START of a sequence
            # (i.e., num - 1 doesn't exist)
            if num - 1 not in num_set:
                # Count consecutive numbers from this start
                current_num = num
                current_streak = 1
                
                while current_num + 1 in num_set:
                    current_num += 1
                    current_streak += 1
                
                longest = max(longest, current_streak)
        
        return longest
    
    def longestConsecutive_sorting(self, nums: List[int]) -> int:
        """Alternative O(n log n) approach using sorting."""
        if not nums:
            return 0
        
        nums = sorted(set(nums))  # Remove duplicates and sort
        longest = 1
        current = 1
        
        for i in range(1, len(nums)):
            if nums[i] == nums[i-1] + 1:
                current += 1
                longest = max(longest, current)
            else:
                current = 1
        
        return longest
```

### JavaScript

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    if (nums.length === 0) return 0;
    
    const numSet = new Set(nums);
    let longest = 0;
    
    for (const num of numSet) {
        // Only count from sequence starts
        if (!numSet.has(num - 1)) {
            let currentNum = num;
            let currentStreak = 1;
            
            // Count consecutive numbers
            while (numSet.has(currentNum + 1)) {
                currentNum++;
                currentStreak++;
            }
            
            longest = Math.max(longest, currentStreak);
        }
    }
    
    return longest;
};

// Alternative: Union Find approach
var longestConsecutiveUnionFind = function(nums) {
    if (nums.length === 0) return 0;
    
    const parent = new Map();
    const size = new Map();
    
    function find(x) {
        if (!parent.has(x)) {
            parent.set(x, x);
            size.set(x, 1);
        }
        if (parent.get(x) !== x) {
            parent.set(x, find(parent.get(x))); // Path compression
        }
        return parent.get(x);
    }
    
    function union(x, y) {
        const px = find(x), py = find(y);
        if (px !== py) {
            // Union by size
            if (size.get(px) < size.get(py)) {
                parent.set(px, py);
                size.set(py, size.get(py) + size.get(px));
            } else {
                parent.set(py, px);
                size.set(px, size.get(px) + size.get(py));
            }
        }
    }
    
    const numSet = new Set(nums);
    
    for (const num of numSet) {
        find(num); // Initialize
        if (numSet.has(num + 1)) {
            union(num, num + 1);
        }
    }
    
    let longest = 0;
    for (const num of numSet) {
        if (parent.get(num) === num) {
            longest = Math.max(longest, size.get(num));
        }
    }
    
    return longest;
};
```

### Java

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums.length == 0) return 0;
        
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }
        
        int longest = 0;
        
        for (int num : numSet) {
            // Only count from sequence starts
            if (!numSet.contains(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;
                
                while (numSet.contains(currentNum + 1)) {
                    currentNum++;
                    currentStreak++;
                }
                
                longest = Math.max(longest, currentStreak);
            }
        }
        
        return longest;
    }
}
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Average | O(n) | O(n) | Each element checked ‚â§ 2 times |
| Worst | O(n) | O(n) | Still linear |

**Why O(n) Time:**
1. Building set: O(n)
2. Iterating through set: O(n)
3. While loops: **Each element is part of at most one counting sequence**
   - Only sequence starts trigger counting
   - Each element is counted at most once in a while loop
4. Total: O(n) + O(n) = O(n)

**Proof of O(n) for the while loops:**
```
Example: [1, 2, 3, 100, 101]

Starts: 1, 100 (only these trigger while loops)
- From 1: count 1‚Üí2‚Üí3 (3 iterations)
- From 100: count 100‚Üí101 (2 iterations)
Total while iterations: 5 = n

Each element is visited exactly once by while loops!
```

---

## üîÑ Variations

| Variation | Difference | Approach |
|-----------|------------|----------|
| Return the sequence | Need actual elements | Track during counting |
| Allow gaps of 1 | Consecutive = differ by ‚â§2 | Modify check condition |
| Binary consecutive | 0s and 1s only | Simpler counting |
| 2D grid consecutive | Adjacent cells | BFS/DFS instead |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Counting from Every Element (O(n¬≤))

```python
# ‚ùå WRONG: O(n¬≤) - counts from every element
for num in num_set:
    current = 1
    while num + current in num_set:
        current += 1
    longest = max(longest, current)

# ‚úÖ CORRECT: Only count from sequence starts
for num in num_set:
    if num - 1 not in num_set:  # This is a START
        # Count from here
```

### 2. Not Handling Duplicates

```python
# ‚ùå WRONG: Duplicates can cause issues
nums = [1, 2, 0, 1]  # Has duplicate 1

# ‚úÖ CORRECT: Use set which automatically removes duplicates
num_set = set(nums)  # {0, 1, 2}
```

### 3. Not Handling Empty Array

```python
# ‚ùå WRONG: Crashes on empty input
def longestConsecutive(nums):
    num_set = set(nums)
    # ... (fails on empty)

# ‚úÖ CORRECT: Handle empty case
def longestConsecutive(nums):
    if not nums:
        return 0
    # ...
```

### 4. Iterating Over Original List Instead of Set

```python
# ‚ùå WRONG: May process duplicates multiple times
for num in nums:  # [1, 2, 0, 1] - processes 1 twice

# ‚úÖ CORRECT: Iterate over set
for num in num_set:  # {0, 1, 2} - each element once
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Link | Notes |
|---------|------------|------|-------|
| Contains Duplicate | üü¢ Easy | [LC 217](https://leetcode.com/problems/contains-duplicate/) | Basic set usage |
| Longest Consecutive | üü° Medium | [LC 128](https://leetcode.com/problems/longest-consecutive-sequence/) | This problem |
| Longest Arithmetic Subsequence | üü° Medium | [LC 1027](https://leetcode.com/problems/longest-arithmetic-subsequence/) | DP + Hash |
| Maximum Gap | üü° Medium | [LC 164](https://leetcode.com/problems/maximum-gap/) | Related concept |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve LC 128, understand why O(n)
- **Day 3:** Re-solve without looking, explain the "start" insight
- **Day 7:** Implement Union Find approach
- **Day 14:** Solve similar problem (LC 1027)
- **Day 30:** Should be able to explain + code in 10 min

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interview</strong></summary>

**Clarify:**
> "So I need the LENGTH of the longest consecutive sequence, and it must be O(n) time. Does 'consecutive' mean integers differing by 1?"

**Initial thoughts:**
> "The naive approach would be to sort in O(n log n), but we need O(n). I'll use a hash set."

**Key insight to explain:**
> "The trick is to only count from SEQUENCE STARTS. A number is a start if num-1 doesn't exist. This way, each element is only counted once, keeping it O(n)."

**Complexity explanation:**
> "Time is O(n) because although there's a while loop, each element participates in at most one counting sequence. Space is O(n) for the hash set."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Favorite problem! |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Tests O(n) insight |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Common in interviews |
| Microsoft | ‚≠ê‚≠ê‚≠ê | May ask Union Find variant |

---

## ‚è±Ô∏è Time Estimates

| Activity | Target Time |
|----------|-------------|
| Understand problem | 2 min |
| Think of O(n) approach | 3-5 min |
| Code solution | 5-7 min |
| Explain O(n) proof | 2-3 min |

---

> **üí° Key Insight:** The O(n) guarantee comes from only starting counts at sequence boundaries. When `num - 1` doesn't exist, we found a start. This ensures each element is visited at most twice: once in the main loop, once in a while loop.

> **üîó Related:** [Two Sum Overview](./4.1-Two-Sum-Overview.md) | [Union Find](../../14-Advanced-Data-Structures.md) | [Hash Set Basics](../02-Hash-Map-Set/2.2-Hash-Set-Basics.md)
