# 2.2 Insert into BST (LC 701)

## Problem Statement

[LeetCode 701 - Insert into a Binary Search Tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/)

Given the root of a BST and a value to insert, insert the value into the BST and return the root. It's guaranteed that the value doesn't exist in the original BST.

```
Input: root = [4,2,7,1,3], val = 5
        4                     4
       / \                   / \
      2   7       ‚Üí         2   7
     / \                   / \ /
    1   3                 1  3 5

Output: [4,2,7,1,3,5]
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a BST Insertion problem:**
- Need to add a new value maintaining BST property
- Search finds the correct position
- Insert as a new leaf node

**Keywords:**
- "insert", "add" to BST
- "maintain BST property"
- "new node", "new value"

**Pattern:** Search until you find a null position, insert there.

</details>

---

## ‚úÖ When to Use

- Building a BST from values
- Adding new elements dynamically
- Any data structure that needs ordered insertions
- Implementing sets/maps with BST

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Need balanced tree | Standard insert can skew | AVL/Red-Black insert |
| Bulk insertions |" O(n log n) total "| Build from sorted array O(n) |
| Duplicate values | Standard BST assumes unique | Modified BST with counts |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Search (LC 700)](./2.1-BST-Search-LC700.md) - Same navigation logic
- [BST Definition](../01-BST-Fundamentals/1.1-BST-Definition.md)

**After mastering this:**
- [BST Delete (LC 450)](./2.3-BST-Delete-LC450.md) - More complex restructuring
- [Build BST from Sorted Array (LC 108)](../06-BST-Construction/6.1-Sorted-Array-to-BST-LC108.md)
- [Self-Balancing Trees](../08-Advanced-BST/8.2-Self-Balancing-Overview.md)

**Combines with:**
- Build BST from values
- Rebuild balanced from inorder

</details>

---

## üìê How It Works

### Visualization

```
Inserting 5 into BST:

        4               
       / \              Step 1: 5 > 4, go RIGHT
      2   7             Step 2: 5 < 7, go LEFT
     / \                Step 3: Left child is NULL ‚Üí INSERT HERE!
    1   3               

Result:
        4
       / \
      2   7
     / \ /
    1  3 5   ‚Üê New node inserted as leaf
```

### Algorithm Steps

1. **If tree is empty:** Create new node as root
2. **Search for correct position:** Navigate using BST property
3. **Find null child:** Where the value belongs
4. **Create new node:** Attach as leaf

### Key Insight

```
Insert always creates a LEAF node.

Why? To insert in the middle would require restructuring,
but adding as leaf maintains BST property automatically.

Before: [2,7] has no left child of 7
After:  5 becomes left child of 7

        7                7
       /        ‚Üí       /
     null              5
```

---

## üíª Code Implementation

### Iterative (Preferred - O(1) space)

**Python:**
```python
def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    """
    Insert value into BST as new leaf node.
    
    Time: O(h) - traverse from root to leaf
    Space: O(1) - no extra space
    
    Pattern: BST Navigation + Leaf Insertion
    """
    new_node = TreeNode(val)
    
    # Empty tree case
    if not root:
        return new_node
    
    # Find the correct parent for new node
    current = root
    while True:
        if val < current.val:
            if current.left:
                current = current.left
            else:
                current.left = new_node  # Insert as left child
                break
        else:
            if current.right:
                current = current.right
            else:
                current.right = new_node  # Insert as right child
                break
    
    return root
```

**JavaScript:**
```javascript
var insertIntoBST = function(root, val) {
    // Iterative insertion - O(h) time, O(1) space
    const newNode = new TreeNode(val);
    
    if (!root) return newNode;
    
    let current = root;
    while (true) {
        if (val < current.val) {
            if (current.left) {
                current = current.left;
            } else {
                current.left = newNode;
                break;
            }
        } else {
            if (current.right) {
                current = current.right;
            } else {
                current.right = newNode;
                break;
            }
        }
    }
    
    return root;
};
```

### Recursive (Clean and Elegant)

**Python:**
```python
def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    """
    Recursive BST insertion.
    
    Time: O(h)
    Space: O(h) - recursion stack
    
    Key: Return the node to maintain tree structure.
    """
    if not root:
        return TreeNode(val)
    
    if val < root.val:
        root.left = self.insertIntoBST(root.left, val)
    else:
        root.right = self.insertIntoBST(root.right, val)
    
    return root
```

**JavaScript:**
```javascript
var insertIntoBST = function(root, val) {
    // Recursive - elegant but O(h) space
    if (!root) return new TreeNode(val);
    
    if (val < root.val) {
        root.left = insertIntoBST(root.left, val);
    } else {
        root.right = insertIntoBST(root.right, val);
    }
    
    return root;
};
```

### One-Liner (Pythonic)

```python
def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    """Elegant one-liner."""
    if not root:
        return TreeNode(val)
    exec(f"root.{'left' if val < root.val else 'right'} = self.insertIntoBST(root.{'left' if val < root.val else 'right'}, val)")
    return root

# Cleaner version:
def insertIntoBST(self, root, val):
    if not root: return TreeNode(val)
    if val < root.val: root.left = self.insertIntoBST(root.left, val)
    else: root.right = self.insertIntoBST(root.right, val)
    return root
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space (Iterative) | Space (Recursive) |
|------|------|-------------------|-------------------|
| Best |" O(1) "| O(1) |" O(1) "|
| Average |" O(log n) "| O(1) |" O(log n) "|
| Worst |" O(n) "| O(1) |" O(n) "|

**Why these complexities:**

- **Time O(h):** Navigate from root to a leaf position
- **Worst case O(n):** Skewed tree (e.g., inserting sorted values)

**Building entire BST:**
```
Inserting n values one by one:
- Best case (random order): O(n log n) total
- Worst case (sorted order): O(n¬≤) total

For sorted input, use divide & conquer instead: O(n)
```

---

## üîÑ Variations

| Variation | Modification | When to Use |
|-----------|--------------|-------------|
| **Insert with count** | Track occurrence count | Allow duplicates |
| **Insert with balance** | Rebalance after insert | AVL/Red-Black tree |
| **Insert with parent** | Set parent pointer | When needed for successor |
| **Bulk insert** | Build from sorted | More efficient for many values |

### Insert with Duplicate Handling

```python
def insertWithDuplicates(root: TreeNode, val: int) -> TreeNode:
    """Handle duplicates by storing count or going right."""
    if not root:
        return TreeNode(val)
    
    if val < root.val:
        root.left = insertWithDuplicates(root.left, val)
    elif val > root.val:
        root.right = insertWithDuplicates(root.right, val)
    else:
        # Duplicate! Either increment count or add to right
        root.right = insertWithDuplicates(root.right, val)
    
    return root
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Return Root

```python
# ‚ùå Wrong: No return statement
def insertIntoBST(root, val):
    if not root:
        return TreeNode(val)
    if val < root.val:
        root.left = self.insertIntoBST(root.left, val)
    else:
        root.right = self.insertIntoBST(root.right, val)
    # Missing return root!

# ‚úÖ Correct: Always return root
def insertIntoBST(root, val):
    if not root:
        return TreeNode(val)
    if val < root.val:
        root.left = self.insertIntoBST(root.left, val)
    else:
        root.right = self.insertIntoBST(root.right, val)
    return root  # Essential!
```

### 2. Not Handling Empty Tree

```python
# ‚ùå Wrong: Assumes root exists
def insertIntoBST(root, val):
    current = root
    while current.val != val:  # Crashes if root is None!
        ...

# ‚úÖ Correct: Handle empty tree first
def insertIntoBST(root, val):
    if not root:
        return TreeNode(val)
    current = root
    ...
```

### 3. Inserting in Wrong Position

```python
# ‚ùå Wrong: Not using BST property correctly
def insertIntoBST(root, val):
    if val < root.val:
        root.left = TreeNode(val)  # Overwrites existing left child!
    ...

# ‚úÖ Correct: Navigate to null position
def insertIntoBST(root, val):
    if val < root.val:
        if root.left:
            root.left = insertIntoBST(root.left, val)  # Recurse
        else:
            root.left = TreeNode(val)  # Only insert when null
    ...
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)
- [ ] [Insert into BST (LC 701)](https://leetcode.com/problems/insert-into-a-binary-search-tree/) - This problem
- [ ] [Search in BST (LC 700)](https://leetcode.com/problems/search-in-a-binary-search-tree/) - Same navigation

### Medium (Apply variations)
- [ ] [Delete Node in BST (LC 450)](https://leetcode.com/problems/delete-node-in-a-bst/) - Opposite operation
- [ ] [Convert Sorted Array to BST (LC 108)](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/) - Bulk insertion
- [ ] [Balance a BST (LC 1382)](https://leetcode.com/problems/balance-a-binary-search-tree/) - Fix imbalance

### Hard (Master edge cases)
- [ ] Implement AVL tree insertion with rotations

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement both iterative and recursive
- **Day 3:** Build BST from array using insert
- **Day 7:** Trace what happens with sorted input
- **Day 14:** Compare with LC 108 (balanced approach)
- **Day 30:** Implement with balancing (AVL-style)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"I'll use the BST property to find where the new value belongs. I navigate the tree comparing values, and when I reach a null position, that's where I insert the new node as a leaf."

**Key points to mention:**
- "Insert always creates a leaf node"
- "Time is O(h), which is O(log n) for balanced trees"
- "For iterative, space is O(1); for recursive, O(h)"

**Follow-up questions:**
- "What if you insert sorted values?" ‚Üí Tree becomes skewed, O(n) operations
- "How to keep it balanced?" ‚Üí AVL or Red-Black tree rotations
- "Iterative or recursive?" ‚Üí Iterative for O(1) space

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common building block |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Part of BST operation set |
| Google | ‚≠ê‚≠ê‚≠ê | May ask about balancing |
| Meta | ‚≠ê‚≠ê‚≠ê | Foundation for harder problems |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Straightforward |
| Code iterative | 7-10 min | Watch edge cases |
| Code recursive | 5-7 min | Cleaner |
| Discuss complexity | 2-3 min |" O(h) analysis "|
| Total interview time | 12-18 min | Easy problem |

---

## üí° Key Insight

> **BST insert always adds a leaf.** The search determines WHERE, and the insert simply attaches a new node at a null position. This is why unbalanced insertions (sorted data) create skewed trees ‚Äî each new node extends the longest path.

---

## üîó Related

- **Previous:** [BST Search (LC 700)](./2.1-BST-Search-LC700.md)
- **Next:** [BST Delete (LC 450)](./2.3-BST-Delete-LC450.md)
- **Construction:** [Sorted Array to BST (LC 108)](../06-BST-Construction/6.1-Sorted-Array-to-BST-LC108.md)
- **Balance:** [Self-Balancing Overview](../08-Advanced-BST/8.2-Self-Balancing-Overview.md)
