# 4.2 Sort by End Time Pattern

> **Definition:** A greedy strategy for interval problems where sorting by ending time allows us to maximize the number of non-overlapping intervals selected.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Maximum number of non-overlapping intervals"
- "Minimum intervals to remove for non-overlapping"
- Activity selection / scheduling
- "Can attend all meetings?" (variation)

**Key Insight:**
```
Why sort by END time?

The interval that ends earliest leaves the MOST ROOM
for remaining intervals.

Bad: [1,10] takes up space from 1-10
Good: [1,2] finishes quickly, leaves 2-‚àû free
```

**Visual:**
```
Intervals:
A: [1,6]    [======]
B: [2,4]     [==]        ‚Üê Ends earliest!
C: [5,8]        [===]
D: [7,9]          [==]

Sort by end: B(4), A(6), C(8), D(9)
Greedy: Take B ‚Üí Take C ‚Üí Done (D overlaps C)
Result: 2 non-overlapping
```

</details>

---

## ‚úÖ When to Use

- **Activity Selection**: Maximize activities one person can do
- **Non-overlapping Intervals**: Minimize removals to avoid overlap
- **Minimum Arrows**: Minimum groups of overlapping balloons
- **Video Stitching**: (variation with coverage)

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Merge intervals | Need to process in order | Sort by START |
| Count simultaneous | Need overlap tracking | Heap/sweep line |
| Weighted intervals | Value matters, not just count | DP |
| Find intersection | Need ordered processing | Two pointers |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Interval Overview](./4.1-Interval-Greedy-Overview.md)
- Sorting with custom comparators
- Greedy choice property

**After mastering this:**
- [Sort by Start Pattern](./4.3-Sort-By-Start-Pattern.md)
- Weighted Job Scheduling (DP)
- Video Stitching

**Combines with:**
- Two pointers for interval intersections
- Binary search for weighted scheduling

</details>

---

## üìê How It Works

### The Algorithm

```
1. Sort intervals by end time (ascending)
2. Take first interval (ends earliest)
3. For each remaining interval:
   - If it starts >= last taken's end ‚Üí TAKE it
   - Otherwise ‚Üí SKIP it (overlaps)
4. Count taken intervals
```

### Step-by-Step Visualization

```
Input: [[1,4], [2,3], [3,5], [4,6]]

Step 1: Sort by end time
        [[2,3], [1,4], [3,5], [4,6]]
        
Timeline:
[2,3]   [=]
[1,4] [===]
[3,5]    [==]
[4,6]     [==]

Step 2: Greedy selection
        
Pass 1: Take [2,3], last_end = 3
        [2,3]   [=]  ‚úì TAKE (first one)
        
Pass 2: Check [1,4], start=1 < last_end=3
        [1,4] [===]  ‚úó SKIP (overlaps)
        
Pass 3: Check [3,5], start=3 >= last_end=3
        [3,5]    [==]  ‚úì TAKE (non-overlapping!)
        last_end = 5
        
Pass 4: Check [4,6], start=4 < last_end=5
        [4,6]     [==]  ‚úó SKIP (overlaps)

Result: 2 intervals selected ([2,3] and [3,5])
```

---

## üíª Code Implementation

### Maximum Non-Overlapping Intervals

```python
def max_non_overlapping(intervals: list[list[int]]) -> int:
    """
    Find maximum number of non-overlapping intervals.
    
    Classic Activity Selection problem.
    
    Time: O(n log n), Space: O(1)
    
    Args:
        intervals: List of [start, end] pairs
        
    Returns:
        Maximum count of non-overlapping intervals
    """
    if not intervals:
        return 0
    
    # KEY: Sort by END time (greedy criterion)
    intervals.sort(key=lambda x: x[1])
    
    count = 1  # Take first interval
    last_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        start, end = intervals[i]
        
        # Non-overlapping: current starts after last ends
        if start >= last_end:
            count += 1
            last_end = end
    
    return count


# Example usage
intervals = [[1,4], [2,3], [3,5], [4,6]]
print(max_non_overlapping(intervals))  # Output: 2
```

```javascript
/**
 * Find maximum number of non-overlapping intervals.
 * 
 * @param {number[][]} intervals - Array of [start, end] pairs
 * @return {number} Maximum count of non-overlapping intervals
 */
function maxNonOverlapping(intervals) {
    if (intervals.length === 0) return 0;
    
    // Sort by end time
    intervals.sort((a, b) => a[1] - b[1]);
    
    let count = 1;
    let lastEnd = intervals[0][1];
    
    for (let i = 1; i < intervals.length; i++) {
        const [start, end] = intervals[i];
        
        if (start >= lastEnd) {  // Non-overlapping
            count++;
            lastEnd = end;
        }
    }
    
    return count;
}

// Example
console.log(maxNonOverlapping([[1,4], [2,3], [3,5], [4,6]])); // 2
```

---

### Minimum Intervals to Remove (LeetCode 435)

```python
def erase_overlap_intervals(intervals: list[list[int]]) -> int:
    """
    LeetCode 435: Non-overlapping Intervals
    
    Find minimum number of intervals to remove to make
    remaining intervals non-overlapping.
    
    Key insight: min_removed = total - max_kept
    
    Time: O(n log n), Space: O(1)
    """
    if not intervals:
        return 0
    
    # Sort by end time
    intervals.sort(key=lambda x: x[1])
    
    # Count maximum we can KEEP
    keep_count = 1
    last_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] >= last_end:
            keep_count += 1
            last_end = intervals[i][1]
    
    # Removed = Total - Kept
    return len(intervals) - keep_count
```

```javascript
function eraseOverlapIntervals(intervals) {
    if (intervals.length === 0) return 0;
    
    intervals.sort((a, b) => a[1] - b[1]);
    
    let keepCount = 1;
    let lastEnd = intervals[0][1];
    
    for (let i = 1; i < intervals.length; i++) {
        if (intervals[i][0] >= lastEnd) {
            keepCount++;
            lastEnd = intervals[i][1];
        }
    }
    
    return intervals.length - keepCount;
}
```

---

### Minimum Arrows to Burst Balloons (LeetCode 452)

```python
def find_min_arrow_shots(points: list[list[int]]) -> int:
    """
    LeetCode 452: Minimum Number of Arrows to Burst Balloons
    
    Each balloon = interval on x-axis.
    Arrow at position x bursts all balloons where x_start <= x <= x_end.
    
    This is equivalent to: minimum groups of overlapping intervals
    
    Time: O(n log n), Space: O(1)
    """
    if not points:
        return 0
    
    # Sort by end point
    points.sort(key=lambda x: x[1])
    
    arrows = 1
    arrow_pos = points[0][1]  # Shoot at end of first balloon
    
    for i in range(1, len(points)):
        start, end = points[i]
        
        # Current balloon NOT hit by arrow
        if start > arrow_pos:
            arrows += 1
            arrow_pos = end  # New arrow at end of this balloon
    
    return arrows
```

```javascript
function findMinArrowShots(points) {
    if (points.length === 0) return 0;
    
    // Sort by end point
    points.sort((a, b) => a[1] - b[1]);
    
    let arrows = 1;
    let arrowPos = points[0][1];
    
    for (let i = 1; i < points.length; i++) {
        const [start, end] = points[i];
        
        if (start > arrowPos) {  // Need new arrow
            arrows++;
            arrowPos = end;
        }
    }
    
    return arrows;
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| Sorting | O(n log n) | O(1) or O(n)* |
| Linear scan | O(n) | O(1) |
| **Total** | **O(n log n)** | **O(1)** |

*Space depends on sorting implementation

**Why O(n log n) is optimal:**
- We MUST examine each interval at least once: O(n)
- Sorting is necessary (unsorted doesn't help)
- Can't do better than O(n log n) for comparison-based sort

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Count max kept | Basic problem | Activity Selection |
| Count min removed | `total - kept` | LC 435 |
| Min arrows | Count groups | LC 452 |
| Can attend all | Check any overlap | Meeting Rooms |
| Weighted selection | DP needed | Weighted Job Scheduling |

### Variation: "Can Attend All Meetings?"

```python
def can_attend_meetings(intervals: list[list[int]]) -> bool:
    """
    Check if one person can attend all meetings.
    (No overlaps allowed)
    """
    if len(intervals) <= 1:
        return True
    
    intervals.sort(key=lambda x: x[1])
    
    last_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] < last_end:  # Overlap!
            return False
        last_end = intervals[i][1]
    
    return True
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Sorting by Start Instead of End

```python
# ‚ùå WRONG: Sort by start
intervals.sort(key=lambda x: x[0])
# This doesn't maximize non-overlapping!

# Example: [[1,10], [2,3], [3,4]]
# Sort by start: [1,10] picked first ‚Üí blocks [2,3] and [3,4]
# Result: 1

# ‚úÖ CORRECT: Sort by end
intervals.sort(key=lambda x: x[1])
# Sort by end: [2,3] ‚Üí [3,4] ‚Üí skip [1,10]
# Result: 2
```

### 2. Wrong Overlap Condition

```python
# ‚ùå WRONG: Using > instead of >=
if start > last_end:  # Misses touching intervals
    count += 1

# ‚úÖ CORRECT: >= allows touching intervals (usually)
if start >= last_end:  # [1,2] and [2,3] don't overlap
    count += 1

# ‚ö†Ô∏è CLARIFY with interviewer:
# Some problems consider [1,2] and [2,3] as overlapping!
```

### 3. Forgetting to Update last_end

```python
# ‚ùå WRONG: Not updating tracking variable
if start >= last_end:
    count += 1
    # Forgot to update last_end!

# ‚úÖ CORRECT: Always update
if start >= last_end:
    count += 1
    last_end = end  # Critical!
```

### 4. Off-by-One with Indexing

```python
# ‚ùå WRONG: Starting from index 0 in loop
count = 0
for i in range(len(intervals)):  # Counts first twice potentially

# ‚úÖ CORRECT: Take first, then loop from 1
count = 1
last_end = intervals[0][1]
for i in range(1, len(intervals)):
    ...
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)
- [ ] [Meeting Rooms](https://leetcode.com/problems/meeting-rooms/) - Can attend all?
  - Hint: If any overlap, return False

### Medium (Apply the pattern)
- [ ] [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/) - Classic
  - Hint: `removed = total - max_kept`
- [ ] [Minimum Number of Arrows](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)
  - Hint: Count groups of overlapping
- [ ] [Maximum Length of Pair Chain](https://leetcode.com/problems/maximum-length-of-pair-chain/)
  - Hint: Same as activity selection

### Hard (Edge cases + variations)
- [ ] [Course Schedule III](https://leetcode.com/problems/course-schedule-iii/)
  - Hint: Sort by deadline, use heap for swapping
- [ ] [Maximum Profit in Job Scheduling](https://leetcode.com/problems/maximum-profit-in-job-scheduling/)
  - Hint: This is DP (weighted), not pure greedy

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve Non-overlapping Intervals from scratch
- **Day 3:** Solve Min Arrows without looking at template
- **Day 7:** Explain why end time sorting works to someone
- **Day 14:** Solve Maximum Length of Pair Chain
- **Day 30:** Attempt Course Schedule III

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This Pattern</strong></summary>

**The 4-Step Explanation:**

```
"I recognize this as an interval selection problem.

STEP 1 - INSIGHT:
To maximize non-overlapping, I want to pick intervals
that end earliest - they leave the most room.

STEP 2 - APPROACH:
I'll sort by end time, then greedily take each interval
that doesn't overlap with the last one I took.

STEP 3 - COMPLEXITY:
O(n log n) for sorting, O(n) for the scan.
O(1) space since I'm just tracking the last end.

STEP 4 - EDGE CASES:
Empty input, all overlapping, none overlapping, touching
intervals (I'll clarify if [1,2] and [2,3] overlap)."
```

**Company Focus:**
| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Google | ‚≠ê‚≠ê‚≠ê | May add constraints |
| Meta | ‚≠ê‚≠ê‚≠ê | Calendar scheduling |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Standard problems |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Recognize pattern | 30 sec | "Intervals + maximize" |
| Explain approach | 1-2 min | Clarify edge cases |
| Code solution | 5-7 min | Template + edge cases |
| Test & debug | 2-3 min | Trace through example |
| **Total** | **8-12 min** | Interview target |

---

> **üí° Key Insight:** Ending earliest = leaving most room. This is why sort-by-end works for selection problems. It's the greedy choice that provably leads to optimal.

> **üîó Related:** [Sort by Start Pattern](./4.3-Sort-By-Start-Pattern.md) | [Interval Overview](./4.1-Interval-Greedy-Overview.md) | [Greedy Fundamentals](../01-Greedy-Fundamentals/1.1-What-Is-Greedy.md)
