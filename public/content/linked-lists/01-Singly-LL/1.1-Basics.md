# 1.1 Singly Linked List Basics

> **Foundation:** Core data structure for dynamic collections
>
> ‚è±Ô∏è Estimated Learning Time: 30-45 minutes

---

## Overview

A **Singly Linked List** is a linear data structure where each element (node) contains data and a reference (pointer) to the next node. Unlike arrays, linked lists don't require contiguous memory allocation, allowing efficient insertions and deletions.

**Key Characteristics:**
- Each node has `data` and `next` pointer
- First node is called the **head**
- Last node's `next` points to `null`
- No random access (must traverse from head)

---

## üéØ Pattern Recognition

<details>
<summary><strong>When You'll Encounter Linked Lists</strong></summary>

**Look for these signals:**
- "Dynamic size" requirements
- Frequent insertions/deletions
- "No random access needed"
- Problems involving node manipulation

**Common problem types:**
| Type | Example |
|------|---------|
| Traversal | Find middle, detect cycle |
| Modification | Reverse, delete node |
| Merging | Merge sorted lists |
| Comparison | Find intersection |

</details>

---

## ‚úÖ When to Use Linked Lists

- **Unknown or changing size** - Don't need to preallocate
- **Frequent insertions/deletions at beginning** - O(1) vs O(n) for arrays
- **No random access needed** - Sequential access only
- **Memory fragmentation** - Can use non-contiguous memory
- **Building other data structures** - Stacks, queues, hash tables

---

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need random access |" O(n) to access element "| Array |
| Memory efficiency critical | Extra pointer overhead | Array |
| Cache performance matters | Poor locality | Array |
| Frequent access by index | Traversal too slow | Array or Hash Map |
| Small, fixed-size collection | Overhead not worth it | Array |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- Basic programming concepts
- Pointers/references
- Classes/objects
- [Big O notation](../../00-Prerequisites.md)

**After mastering this:**
- [Basic Operations](./1.2-Operations.md) - Insert, delete, search
- [Basic Problems](./1.3-Basic-Problems.md) - Find middle, length, etc.
- [Fast & Slow Pointer](../04-Fast-Slow-Pointer/4.1-Concept.md) - Key pattern
- [In-Place Reversal](../05-In-Place-Reversal/5.1-Reversal-Technique.md) - Key pattern

**Builds to:**
- Doubly Linked List
- Circular Linked List
- Stack/Queue implementation

</details>

---

## üìê How It Works

### Node Structure

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ data: 1     ‚îÇ      ‚îÇ data: 2     ‚îÇ      ‚îÇ data: 3     ‚îÇ
‚îÇ next: ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ next: ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ next: null  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚ñ≤
      ‚îÇ
     HEAD
```

### Memory Comparison with Arrays

```
Array (contiguous memory):
‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1 ‚îÇ 2 ‚îÇ 3 ‚îÇ 4 ‚îÇ 5 ‚îÇ  Memory: 0x100, 0x104, 0x108...
‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò

Linked List (scattered memory):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1 ‚îÇ ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ 2 ‚îÇ ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ 3 ‚îÇ / ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 0x100        0x250        0x180    (non-contiguous)
```

### Terminology

| Term | Description |
|------|-------------|
| **Node** | Element containing data and next pointer |
| **Head** | First node in the list |
| **Tail** | Last node (next = null) |
| **Next** | Pointer to the following node |
| **Null** | Indicates end of list |

---

## üíª Code Implementation

### Node Class

**Python:**
```python
class ListNode:
    """
    A node in a singly linked list.
    
    Attributes:
        val: The value stored in this node
        next: Reference to the next node (or None)
    """
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
    
    def __repr__(self):
        """String representation for debugging."""
        return f"ListNode({self.val})"


# Creating nodes manually
node1 = ListNode(1)
node2 = ListNode(2)
node3 = ListNode(3)

# Linking nodes
node1.next = node2
node2.next = node3

# Now: node1 ‚Üí node2 ‚Üí node3 ‚Üí None
```

**JavaScript:**
```javascript
class ListNode {
    /**
     * A node in a singly linked list.
     * @param {number} val - Value stored in node
     * @param {ListNode|null} next - Next node reference
     */
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
    
    toString() {
        return `ListNode(${this.val})`;
    }
}

// Creating and linking nodes
const node1 = new ListNode(1);
const node2 = new ListNode(2);
const node3 = new ListNode(3);

node1.next = node2;
node2.next = node3;

// node1 ‚Üí node2 ‚Üí node3 ‚Üí null
```

### LinkedList Class (Wrapper)

**Python:**
```python
class LinkedList:
    """
    Singly linked list wrapper class.
    Provides convenient methods for list operations.
    """
    def __init__(self):
        self.head = None
        self.size = 0
    
    def is_empty(self) -> bool:
        """Check if list is empty."""
        return self.head is None
    
    def get_size(self) -> int:
        """Return the number of nodes."""
        return self.size
    
    def print_list(self) -> None:
        """Print all values in the list."""
        current = self.head
        values = []
        while current:
            values.append(str(current.val))
            current = current.next
        print(" ‚Üí ".join(values) + " ‚Üí None")
    
    def to_list(self) -> list:
        """Convert to Python list."""
        result = []
        current = self.head
        while current:
            result.append(current.val)
            current = current.next
        return result
    
    @staticmethod
    def from_list(values: list) -> 'LinkedList':
        """Create LinkedList from Python list."""
        ll = LinkedList()
        if not values:
            return ll
        
        ll.head = ListNode(values[0])
        current = ll.head
        ll.size = 1
        
        for val in values[1:]:
            current.next = ListNode(val)
            current = current.next
            ll.size += 1
        
        return ll


# Usage
ll = LinkedList.from_list([1, 2, 3, 4, 5])
ll.print_list()  # 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí None
print(ll.get_size())  # 5
```

**JavaScript:**
```javascript
class LinkedList {
    constructor() {
        this.head = null;
        this.size = 0;
    }
    
    isEmpty() {
        return this.head === null;
    }
    
    getSize() {
        return this.size;
    }
    
    printList() {
        let current = this.head;
        const values = [];
        while (current) {
            values.push(current.val);
            current = current.next;
        }
        console.log(values.join(' ‚Üí ') + ' ‚Üí null');
    }
    
    toArray() {
        const result = [];
        let current = this.head;
        while (current) {
            result.push(current.val);
            current = current.next;
        }
        return result;
    }
    
    static fromArray(values) {
        const ll = new LinkedList();
        if (!values.length) return ll;
        
        ll.head = new ListNode(values[0]);
        let current = ll.head;
        ll.size = 1;
        
        for (let i = 1; i < values.length; i++) {
            current.next = new ListNode(values[i]);
            current = current.next;
            ll.size++;
        }
        
        return ll;
    }
}

// Usage
const ll = LinkedList.fromArray([1, 2, 3, 4, 5]);
ll.printList(); // 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí null
```

---

## ‚ö° Complexity Analysis

### Time Complexity Comparison

| Operation | Array | Linked List | Notes |
|-----------|-------|-------------|-------|
| Access by index |" O(1) "| O(n) | Must traverse |
| Search |" O(n) "| O(n) | Both linear |
| Insert at beginning |" O(n) "| **O(1)** | LL wins |
| Insert at end |" O(1)* "| O(n)** | *Amortized, **Without tail |
| Insert at middle |" O(n) "| O(n) | Both need to shift/traverse |
| Delete at beginning |" O(n) "| **O(1)** | LL wins |
| Delete at end |" O(1) "| O(n) | Need to find prev |
| Delete at middle |" O(n) "| O(n) | Both need work |

**With tail pointer:** Insert at end becomes O(1) for linked list

### Space Complexity

| Data Structure | Space per Element |
|----------------|-------------------|
| Array (int) | 4-8 bytes |
| Linked List Node | 12-24 bytes (value + pointer + overhead) |

Linked lists use 2-3x more memory due to pointer storage and object overhead.

---

## üîÑ Variations

| Variation | Key Difference | Use Case |
|-----------|----------------|----------|
| With tail pointer |" O(1) append "| Frequent end operations |
| With size tracking |" O(1) length "| Need fast size checks |
| Sorted linked list | Maintain order on insert | Priority operations |
| Skip list | Multiple levels |" Faster search O(log n) "|

---

## ‚ö†Ô∏è Common Mistakes

### 1. Null Pointer Access

```python
# ‚ùå Wrong - crashes if head is None
def get_first_value(head):
    return head.val  # NullPointerException!

# ‚úÖ Correct - check first
def get_first_value(head):
    if not head:
        return None  # Or raise exception
    return head.val
```

### 2. Losing the Head Reference

```python
# ‚ùå Wrong - loses track of list
def print_list(head):
    while head:
        print(head.val)
        head = head.next
    # head is now None! We lost the list.

# ‚úÖ Correct - use a separate pointer
def print_list(head):
    current = head
    while current:
        print(current.val)
        current = current.next
    # head is still intact
```

### 3. Forgetting to Update Links

```python
# When inserting a new node, order matters!

# ‚ùå Wrong - loses rest of list
def insert_after(node, new_val):
    new_node = ListNode(new_val)
    node.next = new_node  # Lost the rest of the list!

# ‚úÖ Correct - save link first
def insert_after(node, new_val):
    new_node = ListNode(new_val)
    new_node.next = node.next  # Save the rest
    node.next = new_node       # Now safe to update
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn basics)
- [ ] [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) - LC 206 - Fundamental operation
- [ ] [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) - LC 21 - Basic merging
- [ ] [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) - LC 141 - Cycle detection

### Medium (Apply concepts)
- [ ] [Remove Nth Node From End](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) - LC 19 - Two pointers
- [ ] [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/) - LC 2 - Node manipulation

### Hard (Master)
- [ ] [Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) - LC 23 - Divide & conquer

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**For basics:**
- **Day 1:** Implement Node class, create list from array
- **Day 3:** Implement basic traversal and printing
- **Day 7:** Solve LC 206 (reverse) - key operation
- **Day 14:** Solve LC 141 (cycle) - fast/slow pattern
- **Day 30:** Review all operations, ensure automatic recall

</details>

---

## üé§ Interview Context

<details>
<summary><strong>What Interviewers Look For</strong></summary>

**Fundamentals they expect:**
1. Know Node structure without hesitation
2. Handle null checks naturally
3. Understand when to use linked list vs array
4. Draw diagrams while solving

**Common questions:**
- "Why use a linked list over an array?"
- "What's the time complexity of X operation?"
- "How would you find the middle element?"

**Red flags:**
- Forgetting null checks
- Losing head reference
- Not understanding pointer manipulation

</details>

**Company Focus:**

| Company | LL Focus | Common Topics |
|---------|----------|---------------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | All operations, cycles |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Reversal, reordering |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Complex manipulations |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Standard operations |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn Node structure | 15-20 min | Core concept |
| Implement basic class | 20-30 min | With helper methods |
| Master traversal | 15-20 min | Foundation for all |
| First problem (LC 206) | 15-25 min | Reversal |
| Full basics mastery | 2-3 hours | All fundamentals |

---

> **üí° Key Insight:** In linked lists, you only have access to the current node and what comes after it. You can never go backward in a singly linked list without additional data structures. This constraint shapes how we solve problems - we often use techniques like fast/slow pointers or reversing to work around it.

---

## üîó Related

- [Basic Operations](./1.2-Operations.md) - Insert, delete, search
- [Basic Problems](./1.3-Basic-Problems.md) - Common interview problems
- [Fast & Slow Pointer](../04-Fast-Slow-Pointer/4.1-Concept.md) - Key pattern
- [In-Place Reversal](../05-In-Place-Reversal/5.1-Reversal-Technique.md) - Key pattern
- [Doubly Linked List](../02-Doubly-LL/2.1-Doubly-LL-Complete.md) - Next level
