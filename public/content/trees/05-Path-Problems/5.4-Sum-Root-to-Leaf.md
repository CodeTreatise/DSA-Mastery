# 5.4 - Sum Root to Leaf Numbers (LC 129)

> **Grokking Pattern:** #11 Tree DFS (Path as Number Pattern)
>
> **Difficulty:** Medium | **Frequency:** ‚≠ê‚≠ê‚≠ê Common

---

## Problem Statement

You are given the `root` of a binary tree containing digits from `0` to `9` only.

Each root-to-leaf path in the tree represents a number.

For example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`.

Return the **total sum** of all root-to-leaf numbers.

```
Input: root = [1,2,3]
      1
     / \
    2   3

Output: 25
Explanation: 
  - Path 1‚Üí2 = 12
  - Path 1‚Üí3 = 13
  - Total = 12 + 13 = 25
```

```
Input: root = [4,9,0,5,1]
        4
       / \
      9   0
     / \
    5   1

Output: 1026
Explanation:
  - Path 4‚Üí9‚Üí5 = 495
  - Path 4‚Üí9‚Üí1 = 491
  - Path 4‚Üí0 = 40
  - Total = 495 + 491 + 40 = 1026
```

[LeetCode 129 - Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Root-to-leaf" path mentioned
- Path represents a number
- Accumulate/sum paths

**Key insight:**
At each level, multiply current number by 10 and add current digit:
```
current_num = current_num * 10 + node.val
```

This builds the number as we traverse down.

</details>

---

## ‚úÖ When to Use

- Path interpreted as digits
- Need to accumulate to leaf
- Sum of all path values

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Binary digits | Use bit operations | Binary to decimal |
| Sum of node values | Don't multiply by 10 | Path Sum I |
| Any path, not root-to-leaf | Different constraint | Max Path Sum |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Path Sum](./5.1-Path-Sum.md) - Basic root-to-leaf
- [DFS Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)

**After mastering this:**
- [Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/)
- [Binary tree paths as strings](https://leetcode.com/problems/binary-tree-paths/)

</details>

---

## üìê How It Works

### Building Numbers During Traversal

```
        4           current_num = 4
       / \
      9   0         left: current_num = 4*10 + 9 = 49
     / \            right: current_num = 4*10 + 0 = 40
    5   1

At 5 (leaf): current_num = 49*10 + 5 = 495 ‚Üí add to sum
At 1 (leaf): current_num = 49*10 + 1 = 491 ‚Üí add to sum
At 0 (leaf): current_num = 40 ‚Üí add to sum

Total: 495 + 491 + 40 = 1026
```

### Key Formula

```
new_num = current_num * 10 + node.val
```

At each level, shift left (multiply by 10) and add new digit.

---

## üíª Code Implementation

### Solution 1: DFS with Number Accumulation (Recommended)

**Python:**
```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def sum_numbers(root: Optional[TreeNode]) -> int:
    """
    Sum of all root-to-leaf numbers.
    
    Build number as we go down: current * 10 + digit
    Add to total only at leaf nodes.
    
    Time: O(n), Space: O(h)
    """
    def dfs(node, current_num):
        if not node:
            return 0
        
        # Build current number
        current_num = current_num * 10 + node.val
        
        # Leaf node: return the complete number
        if not node.left and not node.right:
            return current_num
        
        # Internal node: sum of paths through children
        return dfs(node.left, current_num) + dfs(node.right, current_num)
    
    return dfs(root, 0)
```

**JavaScript:**
```javascript
function sumNumbers(root) {
    function dfs(node, currentNum) {
        if (!node) return 0;
        
        // Build current number
        currentNum = currentNum * 10 + node.val;
        
        // Leaf node
        if (!node.left && !node.right) {
            return currentNum;
        }
        
        // Sum from both children
        return dfs(node.left, currentNum) + dfs(node.right, currentNum);
    }
    
    return dfs(root, 0);
}
```

### Solution 2: BFS with Number Tracking

**Python:**
```python
from collections import deque

def sum_numbers_bfs(root: Optional[TreeNode]) -> int:
    """
    BFS approach: store (node, current_number) in queue.
    """
    if not root:
        return 0
    
    total = 0
    queue = deque([(root, root.val)])
    
    while queue:
        node, current_num = queue.popleft()
        
        # Leaf node
        if not node.left and not node.right:
            total += current_num
            continue
        
        if node.left:
            queue.append((node.left, current_num * 10 + node.left.val))
        if node.right:
            queue.append((node.right, current_num * 10 + node.right.val))
    
    return total
```

**JavaScript:**
```javascript
function sumNumbersBFS(root) {
    if (!root) return 0;
    
    let total = 0;
    const queue = [[root, root.val]];
    
    while (queue.length > 0) {
        const [node, currentNum] = queue.shift();
        
        if (!node.left && !node.right) {
            total += currentNum;
            continue;
        }
        
        if (node.left) {
            queue.push([node.left, currentNum * 10 + node.left.val]);
        }
        if (node.right) {
            queue.push([node.right, currentNum * 10 + node.right.val]);
        }
    }
    
    return total;
}
```

### Solution 3: Iterative DFS

**Python:**
```python
def sum_numbers_iterative(root: Optional[TreeNode]) -> int:
    """
    Iterative DFS using stack.
    """
    if not root:
        return 0
    
    total = 0
    stack = [(root, root.val)]
    
    while stack:
        node, current_num = stack.pop()
        
        if not node.left and not node.right:
            total += current_num
        
        if node.right:
            stack.append((node.right, current_num * 10 + node.right.val))
        if node.left:
            stack.append((node.left, current_num * 10 + node.left.val))
    
    return total
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| DFS Recursive |" O(n) "| O(h) | Cleanest |
| BFS |" O(n) "| O(w) | Queue width |
| Iterative DFS |" O(n) "| O(h) | Stack depth |

**Where:**
- n = number of nodes
- h = tree height
- w = max tree width

---

## üîÑ Variations

| Variation | Difference | LeetCode |
|-----------|------------|----------|
| Binary tree paths | Return path strings | LC 257 |
| Smallest string from leaf | Lexicographic order | LC 988 |
| Path sum equals target | Check equality | LC 112 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Adding at Every Node (Not Just Leaves)

```python
# ‚ùå WRONG: Adding at every node
def dfs(node, current_num):
    if not node:
        return 0
    current_num = current_num * 10 + node.val
    return current_num + dfs(node.left, current_num) + dfs(node.right, current_num)
    # Adds intermediate numbers too!

# ‚úÖ CORRECT: Only add at leaf nodes
def dfs(node, current_num):
    if not node:
        return 0
    current_num = current_num * 10 + node.val
    if not node.left and not node.right:
        return current_num  # Only return at leaf
    return dfs(node.left, current_num) + dfs(node.right, current_num)
```

### 2. Wrong Order of Operations

```python
# ‚ùå WRONG: Adding before multiplying
current_num = current_num + node.val * 10  # Wrong formula!

# ‚úÖ CORRECT: Shift left then add
current_num = current_num * 10 + node.val
```

### 3. Forgetting to Handle None Children

```python
# ‚ùå WRONG: Only checking both None
if node.left is None and node.right is None:
    return current_num
# Then calling dfs on None child

# ‚úÖ CORRECT: Check None at start
if not node:
    return 0
# Now safe to call on any child
```

---

## üìù Practice Problems

### This Problem
- [ ] [Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/) - LC 129

### Similar Pattern
- [ ] [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) - LC 257
- [ ] [Path Sum](https://leetcode.com/problems/path-sum/) - LC 112
- [ ] [Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/) - LC 988

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Understand number building formula
**Day 3:** Implement DFS approach
**Day 7:** Add BFS solution
**Day 14:** Solve Binary Tree Paths for string version

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Explaining approach:**
> "As I traverse down, I build the number by multiplying by 10 and adding the current digit. This is like reading a number left to right. When I hit a leaf, I have a complete number to add to the total."

**Why DFS returns the sum:**
> "At each node, I return the sum of all paths through my subtree. For a leaf, that's just the single number. For internal nodes, it's the sum from both children."

**Edge case:**
> "Single node tree: that node itself is the answer."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê | Common |
| Meta | ‚≠ê‚≠ê‚≠ê | Standard question |
| Microsoft | ‚≠ê‚≠ê | Occasionally asked |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Simple concept |
| Implement solution | 10-12 min | Medium difficulty |
| Handle edge cases | 2-3 min | Single node, etc. |

---

> **üí° Key Insight:** Building a number as you traverse is as simple as `current * 10 + digit`. This same technique works for binary numbers (`current * 2 + bit`) or any base. The key is only collecting the result at leaf nodes.

---

## üîó Related

- [Path Sum](./5.1-Path-Sum.md)
- [Path Sum II](./5.2-Path-Sum-II.md)
- [DFS Traversal Patterns](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
