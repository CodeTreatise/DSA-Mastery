# 3.2 - Missing and Duplicate Number Problems

> **Complete Guide to the Most Common Interview Problems**  
> **Pattern:** Cyclic Sort + Index Mapping  
> **Key Insight:** These problems share ONE core technique

---

## Overview

Missing and duplicate number problems appear frequently in interviews because:
- They test **O(1) space thinking**
- Multiple solutions exist (math, XOR, cyclic sort)
- Edge cases are tricky

This file covers all variations with multiple approaches.

---

## üéØ Problem Classification

| Problem Type | Key Constraint | Example |
|--------------|----------------|---------|
| Single Missing | Range [0,n], n nums | [0,1,3] ‚Üí 2 |
| Single Duplicate | Range [1,n], n+1 nums | [1,3,4,2,2] ‚Üí 2 |
| All Missing | Range [1,n], n nums | [4,3,2,7,8,2,3,1] ‚Üí [5,6] |
| All Duplicates | Range [1,n], n nums | Same array ‚Üí [2,3] |
| Missing + Duplicate | One each | [1,2,2,4] ‚Üí miss:3, dup:2 |
| First Missing Positive | Any integers | [3,4,-1,1] ‚Üí 2 |

---

## ‚úÖ When to Use

- Numbers are in a **contiguous range** [0, n] or [1, n]
- Array size matches the range
- Need to find **anomalies** (missing/duplicates)
- **O(1) space** constraint
- Array **can be modified** (for cyclic sort/marking)

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Numbers not in contiguous range | Hash Set | Can't use index mapping |
| Array is immutable | XOR or Math | Cyclic sort modifies array |
| Need to preserve order | Hash approach | Cyclic sort reorders |
| Range is much larger than array | Hash Map | Can't use index as hash |
| Multiple copies of same duplicate | Counting | Cyclic handles one duplicate |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Related Patterns</strong></summary>

**Before this, you should know:**
- [Cyclic Sort Pattern](./3.1-Cyclic-Sort-Pattern.md)
- Array index manipulation
- XOR properties (a ^ a = 0)

**Related techniques:**
- Counting Sort (index as bucket)
- Hash Set (O(n) space alternative)
- Floyd's Cycle Detection (for duplicate in n+1 array)

**After mastering this:**
- [Bit Manipulation](../../15-Bit-Manipulation.md) - XOR tricks
- [Math Problems](../../16-Math-Number-Theory.md) - Sum/product formulas

</details>

---

## üîÑ Variations

| Problem | Approach | Key Insight | LC |
|---------|----------|-------------|-----|
| Missing Number | XOR or Sum | Pairs cancel | 268 |
| Find Duplicate | Floyd's Cycle | Array as linked list | 287 |
| All Duplicates | Negative Marking | Sign as visited flag | 442 |
| All Missing | Negative Marking | Positive = unvisited | 448 |
| Set Mismatch | Cyclic Sort | Find anomaly position | 645 |
| First Missing Positive | Cyclic Sort | Ignore out of range | 41 |

---

## üìê Solution Approaches

### Three Main Techniques

| Approach | Time | Space | Modifies Array? |
|----------|------|-------|-----------------|
| **Math (Sum/Product)** |" O(n) "| O(1) | ‚ùå No |
| **XOR** |" O(n) "| O(1) | ‚ùå No |
| **Cyclic Sort/Marking** |" O(n) "| O(1) | ‚úÖ Yes |

Choose based on constraints:
- Array immutable ‚Üí Math or XOR
- Array can be modified ‚Üí Cyclic Sort (most versatile)
- Multiple missing/duplicates ‚Üí Cyclic Sort or Marking

---

## üíª Problem Solutions

---

### Problem 1: Missing Number (LC 268)

**Given:** Array of n distinct numbers from [0, n]  
**Find:** The missing number

```
Input: [3, 0, 1]
Output: 2 (since 2 is missing from 0,1,2,3)
```

#### Solution A: Sum Formula

**Python:**
```python
def missing_number_sum(nums: list[int]) -> int:
    """
    Use Gauss formula: sum(0..n) = n*(n+1)/2
    
    Time: O(n), Space: O(1)
    No overflow in Python (arbitrary precision)
    """
    n = len(nums)
    expected = n * (n + 1) // 2
    actual = sum(nums)
    return expected - actual


# Example
print(missing_number_sum([3, 0, 1]))  # 2
print(missing_number_sum([0, 1]))     # 2
print(missing_number_sum([9,6,4,2,3,5,7,0,1]))  # 8
```

**JavaScript:**
```javascript
function missingNumberSum(nums) {
    const n = nums.length;
    const expected = (n * (n + 1)) / 2;
    const actual = nums.reduce((a, b) => a + b, 0);
    return expected - actual;
}
```

#### Solution B: XOR

```python
def missing_number_xor(nums: list[int]) -> int:
    """
    XOR all indices and values.
    Pairs cancel out, missing number remains.
    
    a ^ a = 0, a ^ 0 = a
    
    Time: O(n), Space: O(1)
    """
    result = len(nums)  # Start with n
    
    for i, num in enumerate(nums):
        result ^= i ^ num
    
    return result


# How it works:
# nums = [3, 0, 1], n = 3
# XOR: 3 ^ (0^3) ^ (1^0) ^ (2^1)
#    = 3 ^ 0 ^ 3 ^ 1 ^ 0 ^ 2 ^ 1
#    = (0^0) ^ (1^1) ^ (3^3) ^ 2
#    = 0 ^ 0 ^ 0 ^ 2 = 2
```

#### Solution C: Cyclic Sort

```python
def missing_number_cyclic(nums: list[int]) -> int:
    """
    Place each number at its index, find the gap.
    
    Time: O(n), Space: O(1)
    """
    n = len(nums)
    i = 0
    
    while i < n:
        # nums[i] should be at index nums[i] (for 0-indexed)
        if nums[i] < n and nums[i] != nums[nums[i]]:
            correct = nums[i]
            nums[i], nums[correct] = nums[correct], nums[i]
        else:
            i += 1
    
    for i in range(n):
        if nums[i] != i:
            return i
    
    return n


# Example
print(missing_number_cyclic([3, 0, 1]))  # 2
```

---

### Problem 2: Find the Duplicate Number (LC 287)

**Given:** Array of n+1 integers from [1, n], exactly one duplicate  
**Find:** The duplicate (without modifying array)

```
Input: [1, 3, 4, 2, 2]
Output: 2
```

#### Solution A: Floyd's Cycle Detection (Best)

```python
def find_duplicate(nums: list[int]) -> int:
    """
    Treat array as linked list where nums[i] points to nums[nums[i]].
    The duplicate creates a cycle!
    
    Time: O(n), Space: O(1), No modification
    """
    # Phase 1: Find intersection point
    slow = fast = nums[0]
    
    while True:
        slow = nums[slow]       # Move 1 step
        fast = nums[nums[fast]] # Move 2 steps
        if slow == fast:
            break
    
    # Phase 2: Find cycle entrance (the duplicate)
    slow = nums[0]
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]
    
    return slow


# Example
print(find_duplicate([1, 3, 4, 2, 2]))  # 2
print(find_duplicate([3, 1, 3, 4, 2]))  # 3
```

**Why it works (visualization):**
```
nums = [1, 3, 4, 2, 2]
       0  1  2  3  4

As linked list:
0 ‚Üí 1 ‚Üí 3 ‚Üí 2 ‚Üí 4 ‚Üí 2 ‚Üí 4 ‚Üí 2 ... (cycle at 2!)
            ‚Üë_______‚Üì

The duplicate (2) is where the cycle begins.
```

**JavaScript:**
```javascript
function findDuplicate(nums) {
    let slow = nums[0];
    let fast = nums[0];
    
    // Phase 1: Find intersection
    do {
        slow = nums[slow];
        fast = nums[nums[fast]];
    } while (slow !== fast);
    
    // Phase 2: Find entrance
    slow = nums[0];
    while (slow !== fast) {
        slow = nums[slow];
        fast = nums[fast];
    }
    
    return slow;
}
```

#### Solution B: Binary Search on Value Range

```python
def find_duplicate_binary(nums: list[int]) -> int:
    """
    Binary search on answer space [1, n].
    
    For each mid, count how many nums <= mid.
    If count > mid, duplicate is in [1, mid].
    
    Time: O(n log n), Space: O(1)
    """
    left, right = 1, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        count = sum(1 for num in nums if num <= mid)
        
        if count > mid:
            right = mid  # Duplicate in lower half
        else:
            left = mid + 1  # Duplicate in upper half
    
    return left
```

---

### Problem 3: Find All Duplicates (LC 442)

**Given:** Array of n integers from [1, n], some appear twice  
**Find:** All duplicates in O(n) time and O(1) extra space

```
Input: [4, 3, 2, 7, 8, 2, 3, 1]
Output: [2, 3]
```

#### Solution A: Cyclic Sort

```python
def find_all_duplicates_cyclic(nums: list[int]) -> list[int]:
    """
    Place each number at index num-1.
    Scan for mismatches.
    
    Time: O(n), Space: O(1)
    """
    i = 0
    while i < len(nums):
        correct = nums[i] - 1
        if nums[i] != nums[correct]:
            nums[i], nums[correct] = nums[correct], nums[i]
        else:
            i += 1
    
    return [nums[i] for i in range(len(nums)) if nums[i] != i + 1]


# Example
print(find_all_duplicates_cyclic([4,3,2,7,8,2,3,1]))  # [2, 3]
```

#### Solution B: Negative Marking

```python
def find_all_duplicates_marking(nums: list[int]) -> list[int]:
    """
    Use sign of nums[abs(x)-1] as visited marker.
    
    Time: O(n), Space: O(1)
    """
    result = []
    
    for num in nums:
        idx = abs(num) - 1
        if nums[idx] < 0:
            # Already visited ‚Üí duplicate
            result.append(abs(num))
        else:
            nums[idx] = -nums[idx]
    
    return result


# How it works:
# [4, 3, 2, 7, 8, 2, 3, 1]
# See 4 ‚Üí mark index 3 negative: [4, 3, 2, -7, 8, 2, 3, 1]
# See 3 ‚Üí mark index 2 negative: [4, 3, -2, -7, 8, 2, 3, 1]
# See 2 ‚Üí mark index 1 negative: [4, -3, -2, -7, 8, 2, 3, 1]
# See 7 ‚Üí mark index 6 negative: [4, -3, -2, -7, 8, 2, -3, 1]
# See 8 ‚Üí mark index 7 negative: [4, -3, -2, -7, 8, 2, -3, -1]
# See 2 ‚Üí index 1 already negative ‚Üí 2 is duplicate!
# See 3 ‚Üí index 2 already negative ‚Üí 3 is duplicate!
# See 1 ‚Üí mark index 0 negative: [-4, -3, -2, -7, 8, 2, -3, -1]
```

**JavaScript:**
```javascript
function findDuplicatesMarking(nums) {
    const result = [];
    
    for (const num of nums) {
        const idx = Math.abs(num) - 1;
        if (nums[idx] < 0) {
            result.push(Math.abs(num));
        } else {
            nums[idx] = -nums[idx];
        }
    }
    
    return result;
}
```

---

### Problem 4: Find All Missing Numbers (LC 448)

**Given:** Array of n integers from [1, n], some appear twice  
**Find:** All numbers that don't appear

```
Input: [4, 3, 2, 7, 8, 2, 3, 1]
Output: [5, 6]
```

#### Solution A: Cyclic Sort

```python
def find_disappeared_cyclic(nums: list[int]) -> list[int]:
    """
    Same as find duplicates, but return missing instead.
    
    Time: O(n), Space: O(1)
    """
    i = 0
    while i < len(nums):
        correct = nums[i] - 1
        if nums[i] != nums[correct]:
            nums[i], nums[correct] = nums[correct], nums[i]
        else:
            i += 1
    
    # If nums[i] != i + 1, then i + 1 is missing
    return [i + 1 for i in range(len(nums)) if nums[i] != i + 1]
```

#### Solution B: Negative Marking

```python
def find_disappeared_marking(nums: list[int]) -> list[int]:
    """
    Mark indices as negative. Positive indices = missing numbers.
    
    Time: O(n), Space: O(1)
    """
    for num in nums:
        idx = abs(num) - 1
        nums[idx] = -abs(nums[idx])
    
    # Indices still positive ‚Üí those numbers missing
    return [i + 1 for i in range(len(nums)) if nums[i] > 0]


# Example
print(find_disappeared_marking([4,3,2,7,8,2,3,1]))  # [5, 6]
```

---

### Problem 5: Set Mismatch (LC 645)

**Given:** Array originally contained [1, n], but one number is duplicated and one is missing  
**Find:** [duplicate, missing]

```
Input: [1, 2, 2, 4]
Output: [2, 3]
```

#### Solution A: Cyclic Sort

```python
def find_error_nums_cyclic(nums: list[int]) -> list[int]:
    """
    After cyclic sort, find the position where number != index + 1.
    
    Time: O(n), Space: O(1)
    """
    i = 0
    while i < len(nums):
        correct = nums[i] - 1
        if nums[i] != nums[correct]:
            nums[i], nums[correct] = nums[correct], nums[i]
        else:
            i += 1
    
    for i in range(len(nums)):
        if nums[i] != i + 1:
            return [nums[i], i + 1]  # [duplicate, missing]
    
    return []
```

#### Solution B: Math + XOR

```python
def find_error_nums_math(nums: list[int]) -> list[int]:
    """
    Use sum and sum of squares to find both.
    
    Let x = duplicate, y = missing
    sum(nums) - sum(1..n) = x - y
    sum(nums^2) - sum(1^2..n^2) = x^2 - y^2 = (x+y)(x-y)
    
    Solve for x and y.
    
    Time: O(n), Space: O(1)
    """
    n = len(nums)
    expected_sum = n * (n + 1) // 2
    expected_sq_sum = n * (n + 1) * (2 * n + 1) // 6
    
    actual_sum = sum(nums)
    actual_sq_sum = sum(x * x for x in nums)
    
    diff = actual_sum - expected_sum      # x - y
    sq_diff = actual_sq_sum - expected_sq_sum  # x^2 - y^2
    
    # x + y = (x^2 - y^2) / (x - y)
    sum_xy = sq_diff // diff
    
    x = (diff + sum_xy) // 2  # duplicate
    y = sum_xy - x             # missing
    
    return [x, y]
```

---

### Problem 6: First Missing Positive (LC 41) ‚≠ê HARD

**Given:** Unsorted array of integers (any values)  
**Find:** Smallest missing positive integer

```
Input: [3, 4, -1, 1]
Output: 2

Input: [7, 8, 9, 11, 12]
Output: 1
```

#### Key Insight

The answer is always in range [1, n+1] where n = len(nums).

Why? We have n slots. If 1,2,...,n are all present, answer is n+1.
Otherwise, some number in [1, n] is missing.

#### Solution: Cyclic Sort (Modified)

```python
def first_missing_positive(nums: list[int]) -> int:
    """
    Only consider numbers in [1, n].
    Place each at index num - 1.
    Find first gap.
    
    Time: O(n), Space: O(1)
    """
    n = len(nums)
    i = 0
    
    while i < n:
        num = nums[i]
        correct = num - 1
        
        # Only process if in valid range and not already in place
        if 1 <= num <= n and nums[i] != nums[correct]:
            nums[i], nums[correct] = nums[correct], nums[i]
        else:
            i += 1
    
    # First gap is the answer
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    
    return n + 1


# Examples
print(first_missing_positive([3, 4, -1, 1]))   # 2
print(first_missing_positive([1, 2, 0]))       # 3
print(first_missing_positive([7, 8, 9, 11]))   # 1
print(first_missing_positive([1, 2, 3, 4, 5])) # 6
```

**JavaScript:**
```javascript
function firstMissingPositive(nums) {
    const n = nums.length;
    let i = 0;
    
    while (i < n) {
        const num = nums[i];
        const correct = num - 1;
        
        if (num >= 1 && num <= n && nums[i] !== nums[correct]) {
            [nums[i], nums[correct]] = [nums[correct], nums[i]];
        } else {
            i++;
        }
    }
    
    for (let i = 0; i < n; i++) {
        if (nums[i] !== i + 1) {
            return i + 1;
        }
    }
    
    return n + 1;
}
```

---

## ‚ö° Complexity Summary

| Problem | Approach | Time | Space |
|---------|----------|------|-------|
| Missing Number | Sum/XOR |" O(n) "| O(1) |
| Find Duplicate | Floyd's |" O(n) "| O(1) |
| All Duplicates | Marking |" O(n) "| O(1) |
| All Missing | Marking |" O(n) "| O(1) |
| Set Mismatch | Cyclic |" O(n) "| O(1) |
| First Missing + | Cyclic |" O(n) "| O(1) |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Confusing Index Ranges

‚ùå **Wrong:**
```python
# For [1, n] range
correct = nums[i]  # Wrong for 1-indexed!
```

‚úÖ **Correct:**
```python
# For [1, n] range
correct = nums[i] - 1  # Convert to 0-indexed
```

### 2. Integer Overflow (in other languages)

‚ùå **Wrong (Java/C++):**
```java
int expected = n * (n + 1) / 2;  // Overflow for large n!
```

‚úÖ **Correct:**
```java
long expected = (long) n * (n + 1) / 2;
```

### 3. Floyd's Cycle: Wrong Starting Point

‚ùå **Wrong:**
```python
slow = fast = 0  # Start at index 0
```

‚úÖ **Correct:**
```python
slow = fast = nums[0]  # Start at first element
```

### 4. Not Restoring Array After Marking

If you need to preserve the array after negative marking:
```python
# After algorithm
for i in range(len(nums)):
    nums[i] = abs(nums[i])
```

---

## üìù Practice Problems

### Essential (Must Do)

| Problem | Technique | LeetCode |
|---------|-----------|----------|
| Missing Number | XOR/Sum | [LC 268](https://leetcode.com/problems/missing-number/) |
| Find the Duplicate Number | Floyd's | [LC 287](https://leetcode.com/problems/find-the-duplicate-number/) |
| Find All Duplicates | Marking | [LC 442](https://leetcode.com/problems/find-all-duplicates-in-an-array/) |
| Find All Missing Numbers | Marking | [LC 448](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/) |
| Set Mismatch | Cyclic | [LC 645](https://leetcode.com/problems/set-mismatch/) |
| First Missing Positive | Cyclic | [LC 41](https://leetcode.com/problems/first-missing-positive/) |

### Extended Practice

| Problem | Related Pattern | LeetCode |
|---------|-----------------|----------|
| Single Number | XOR | [LC 136](https://leetcode.com/problems/single-number/) |
| Single Number II | Bit counting | [LC 137](https://leetcode.com/problems/single-number-ii/) |
| Single Number III | XOR + grouping | [LC 260](https://leetcode.com/problems/single-number-iii/) |
| Couples Holding Hands | Cyclic swap | [LC 765](https://leetcode.com/problems/couples-holding-hands/) |

<details>
<summary><strong>üß† Spaced Repetition</strong></summary>

**Week 1:**
- Day 1: LC 268 (Missing Number) - all 3 approaches
- Day 3: LC 448 (All Missing) + LC 442 (All Duplicates)

**Week 2:**
- Day 7: LC 287 (Find Duplicate) - Floyd's algorithm
- Day 10: LC 645 (Set Mismatch)

**Week 3:**
- Day 14: LC 41 (First Missing Positive)
- Day 21: Review all problems

</details>

---

## üé§ Interview Strategy

<details>
<summary><strong>Approach Selection Guide</strong></summary>

**During interview, ask:**
1. "Can I modify the array?" ‚Üí Cyclic sort/marking
2. "Is there overflow concern?" ‚Üí XOR over sum
3. "Need to find ONE value?" ‚Üí Consider Floyd's
4. "Need to find ALL values?" ‚Üí Marking technique

**Communication template:**
> "I notice the numbers are in range [1, n], which means I can use the index as a hash. Let me walk through the cyclic sort approach..."

</details>

| Company | Favorite Problem | Key Focus |
|---------|------------------|-----------|
| Google | First Missing Positive |" Edge cases, O(1) space "|
| Amazon | Find Duplicates | Multiple approaches |
| Meta | Missing Number | Clean code, all approaches |
| Apple | Set Mismatch | Math reasoning |

---

## ‚è±Ô∏è Time Estimates

| Problem | Target Time | Notes |
|---------|-------------|-------|
| Missing Number | 10 min | Know all 3 approaches |
| Find Duplicate | 15 min | Floyd's takes practice |
| All Duplicates | 12 min | Marking is quick |
| All Missing | 12 min | Same as duplicates |
| Set Mismatch | 15 min | Combine techniques |
| First Missing + | 20 min | Edge cases! |

---

## üí° Key Insights

> **Insight 1: Index as Hash**
> When range is [1, n] and size is n, each number has a "home" index.

> **Insight 2: Choose Your Weapon**
> - XOR = pairs cancel out (single anomaly)
> - Sum = total should equal expected (single missing)
> - Cyclic Sort = place and scan (any anomaly type)
> - Floyd = linked list cycle (single duplicate in n+1 array)

> **Insight 3: First Missing Positive**
> Answer is always in [1, n+1]. Ignore everything else!

---

## üîó Related

- [Cyclic Sort Pattern](./3.1-Cyclic-Sort-Pattern.md) - Core technique
- [Bit Manipulation](../../15-Bit-Manipulation.md) - XOR techniques
- [Math Problems](../../16-Math-Number-Theory.md) - Sum formulas
