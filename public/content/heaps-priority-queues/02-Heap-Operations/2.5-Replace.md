# 2.5 Replace Operations

## Definition

**Replace operations** combine extract and insert in a single efficient operation. Instead of pop + push (2 * O(log n)), replace does it in one pass (1 * O(log n)).

```
heapreplace vs pop + push:

heapreplace (pop, then push):
  1. Pop root
  2. Put new element at root
  3. Bubble down once
  Time: O(log n)

heappushpop (push, then pop):
  1. If new > root: return new immediately
  2. Else: swap with root, bubble down
  Time: O(log n)

Both are 2x faster than separate pop + push!
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Replace Operations</strong></summary>

**Key signals:**
- Maintaining fixed-size heap (Top K)
- Sliding window with heap
- Streaming K elements
- Need to swap in new element

**The pattern:**
```python
# Pattern: Keep heap at size K
for element in stream:
    if len(heap) < k:
        heappush(heap, element)
    elif element > heap[0]:  # Better than worst in heap
        heapreplace(heap, element)  # O(log n) instead of 2 * O(log n)
```

</details>

---

## ‚úÖ When to Use

| Scenario | Which Operation? |
|----------|------------------|
| Top K elements | `heapreplace` |
| Sliding window | `heapreplace` |
| Replace smallest with new | `heapreplace` |
| Insert new, get smallest | `heappushpop` |

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|---------------------|
| Just removing | Use `heappop` |
| Just inserting | Use `heappush` |
| No size constraint | Just push |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Insert (push)](./2.1-Insert.md)
- [Extract (pop)](./2.2-Extract.md)
- [Heap Property](../01-Heap-Fundamentals/1.2-Heap-Property.md)

**After mastering this:**
- [Top K Pattern](../04-Top-K-Pattern/4.1-Top-K-Overview.md)
- [Sliding Window Median](../05-Two-Heaps-Pattern/5.3-Sliding-Window-Median-LC480.md)

**Used in:**
- Top K elements (maintain K-size heap)
- K-way merge (replace after extract)
- Stream processing

</details>

---

## üìê How It Works

### heapreplace: Pop First, Push After

```
heapreplace(heap, new_val):
  
Step 1: Save root (return value)
Step 2: Put new value at root
Step 3: Bubble down to restore heap property

Example: heapreplace([1, 3, 2], 5)

Before:     Pop root    Replace     Bubble down    Result
   1           ‚Üì          5            2             2
  / \         / \        / \          / \           / \
 3   2       3   2      3   2        3   5         3   5

Returns: 1 (the old root)
Heap is now: [2, 3, 5]
```

### heappushpop: Push First, Pop After

```
heappushpop(heap, new_val):

Step 1: Compare new value with root
Step 2: If new >= root (min-heap), return new (no heap modification!)
Step 3: Else: swap new with root, bubble down, return old root

Example 1: heappushpop([1, 3, 2], 0)
  0 < 1, so:
  - Replace root 1 with 0
  - Bubble down (0 stays at root since it's smallest)
  - Return 1
  Result: heap = [0, 3, 2], returns 1

Example 2: heappushpop([1, 3, 2], 5)
  5 > 1, so:
  - Return 5 immediately (no heap modification!)
  Result: heap = [1, 3, 2] (unchanged), returns 5
```

### Comparison: heapreplace vs heappushpop

```
heapreplace: "Remove root, add new value"
  - Always removes current root
  - New value goes through bubble down
  - Use when: Processing sliding window, removing old element

heappushpop: "Add new value, remove smallest"
  - New value might not enter heap
  - Optimization: If new is smallest, return immediately
  - Use when: Finding top K, maintaining fixed size
```

---

## üíª Code Implementation

### heapreplace (Python Built-in)

**Python:**
```python
import heapq

def demo_heapreplace():
    """
    heapreplace: Pop smallest, push new value
    
    Equivalent to: pop() then push(), but faster
    Time: O(log n) - single bubble-down
    """
    heap = [1, 3, 2, 4, 5]
    heapq.heapify(heap)
    print(f"Before: {heap}")  # [1, 3, 2, 4, 5]
    
    # Replace smallest with 6
    old = heapq.heapreplace(heap, 6)
    print(f"Removed: {old}")   # 1
    print(f"After: {heap}")    # [2, 3, 6, 4, 5]


def manual_heapreplace(heap: list, new_val) -> any:
    """
    Manual implementation of heapreplace.
    """
    if not heap:
        raise IndexError("heap is empty")
    
    old_val = heap[0]
    heap[0] = new_val
    
    # Bubble down
    i = 0
    n = len(heap)
    while True:
        smallest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and heap[left] < heap[smallest]:
            smallest = left
        if right < n and heap[right] < heap[smallest]:
            smallest = right
        
        if smallest == i:
            break
        
        heap[i], heap[smallest] = heap[smallest], heap[i]
        i = smallest
    
    return old_val
```

**JavaScript:**
```javascript
function heapreplace(heap, newVal) {
    if (heap.length === 0) throw new Error("Heap is empty");
    
    const oldVal = heap[0];
    heap[0] = newVal;
    
    // Bubble down
    let i = 0;
    const n = heap.length;
    
    while (true) {
        let smallest = i;
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        
        if (left < n && heap[left] < heap[smallest]) smallest = left;
        if (right < n && heap[right] < heap[smallest]) smallest = right;
        
        if (smallest === i) break;
        
        [heap[i], heap[smallest]] = [heap[smallest], heap[i]];
        i = smallest;
    }
    
    return oldVal;
}
```

### heappushpop (Python Built-in)

**Python:**
```python
import heapq

def demo_heappushpop():
    """
    heappushpop: Push new value, pop smallest
    
    Optimization: If new value is smallest, just return it!
    Time: O(log n) - but often O(1) if new is smallest
    """
    heap = [1, 3, 2, 4, 5]
    heapq.heapify(heap)
    
    # Case 1: New value is larger than root
    result = heapq.heappushpop(heap, 0)
    print(f"Pushed 0, popped {result}")  # popped 0 (the new value!)
    print(f"Heap: {heap}")  # [1, 3, 2, 4, 5] (unchanged)
    
    # Case 2: New value is larger than root
    result = heapq.heappushpop(heap, 6)
    print(f"Pushed 6, popped {result}")  # popped 1 (old root)
    print(f"Heap: {heap}")  # [2, 3, 6, 4, 5]


def manual_heappushpop(heap: list, new_val) -> any:
    """
    Manual implementation of heappushpop.
    """
    if not heap or new_val <= heap[0]:
        # Optimization: new value is smallest, just return it
        return new_val
    
    # Else: replace root with new value
    old_val = heap[0]
    heap[0] = new_val
    
    # Bubble down
    i = 0
    n = len(heap)
    while True:
        smallest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and heap[left] < heap[smallest]:
            smallest = left
        if right < n and heap[right] < heap[smallest]:
            smallest = right
        
        if smallest == i:
            break
        
        heap[i], heap[smallest] = heap[smallest], heap[i]
        i = smallest
    
    return old_val
```

### Top K Elements Using Replace

**Python:**
```python
import heapq

def top_k_with_replace(nums: list[int], k: int) -> list[int]:
    """
    Find K largest elements using heapreplace.
    
    Strategy: Maintain min-heap of size K
    - If current > heap root, replace (new element is better)
    - Uses O(log K) per replacement
    
    Time: O(n log K)
    Space: O(K)
    """
    if k <= 0:
        return []
    
    # Initialize heap with first K elements
    heap = nums[:k]
    heapq.heapify(heap)  # O(K)
    
    # Process remaining elements
    for num in nums[k:]:
        if num > heap[0]:  # Better than current smallest in top K
            heapq.heapreplace(heap, num)  # O(log K)
    
    return heap


def top_k_with_pushpop(nums: list[int], k: int) -> list[int]:
    """
    Alternative using heappushpop.
    Same complexity, different approach.
    """
    if k <= 0:
        return []
    
    heap = []
    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, num)
        else:
            heapq.heappushpop(heap, num)  # Keep K largest
    
    return heap


# Example:
nums = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
k = 3
print(top_k_with_replace(nums, k))  # [5, 5, 9] or similar (K largest)
```

**JavaScript:**
```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    size() { return this.heap.length; }
    peek() { return this.heap[0]; }
    
    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        if (this.heap.length === 0) return undefined;
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return min;
    }
    
    pushpop(val) {
        if (this.heap.length === 0 || val <= this.heap[0]) {
            return val;
        }
        const old = this.heap[0];
        this.heap[0] = val;
        this._bubbleDown(0);
        return old;
    }
    
    replace(val) {
        const old = this.heap[0];
        this.heap[0] = val;
        this._bubbleDown(0);
        return old;
    }
    
    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.heap[parent] <= this.heap[i]) break;
            [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
            i = parent;
        }
    }
    
    _bubbleDown(i) {
        const n = this.heap.length;
        while (true) {
            let smallest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;
            if (left < n && this.heap[left] < this.heap[smallest]) smallest = left;
            if (right < n && this.heap[right] < this.heap[smallest]) smallest = right;
            if (smallest === i) break;
            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
            i = smallest;
        }
    }
}

function topKWithReplace(nums, k) {
    const heap = new MinHeap();
    
    for (const num of nums) {
        if (heap.size() < k) {
            heap.push(num);
        } else if (num > heap.peek()) {
            heap.replace(num);
        }
    }
    
    return heap.heap;
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| `heapreplace` |" O(log n) "| O(1) | Single bubble-down |
| `heappushpop` |" O(log n) "| O(1) |" May be O(1) if new is smallest "|
| pop + push |" O(2 log n) "| O(1) | Two operations |

**Why replace is faster:**
```
pop + push:
  pop():  bubble down  - O(log n)
  push(): bubble up    - O(log n)
  Total: 2 * O(log n)

heapreplace:
  Replace root, bubble down - O(log n)
  Total: 1 * O(log n)

~2x faster in practice!
```

---

## üîÑ Variations

| Operation | Behavior | Use Case |
|-----------|----------|----------|
| `heapreplace` | Pop first, push after | Remove specific, add new |
| `heappushpop` | Push first, pop after | Maintain size K |
| `nsmallest` | Uses heapreplace internally | Find K smallest |
| `nlargest` | Uses heapreplace internally | Find K largest |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Confusing heapreplace and heappushpop

```python
import heapq

# heapreplace: Always removes root, even if new is smaller
heap = [1, 3, 2]
result = heapq.heapreplace(heap, 0)  
# result = 1, heap = [0, 3, 2] - 0 is now root

# heappushpop: Returns smallest, might be the new value
heap = [1, 3, 2]
result = heapq.heappushpop(heap, 0)
# result = 0, heap = [1, 3, 2] - unchanged!
```

### 2. Using Replace on Empty Heap

```python
import heapq

# ‚ùå Wrong: heapreplace on empty heap raises IndexError
heap = []
heapq.heapreplace(heap, 5)  # IndexError!

# ‚úÖ Correct: Check or use heappush for empty
if not heap:
    heapq.heappush(heap, 5)
else:
    heapq.heapreplace(heap, 5)
```

### 3. Not Checking Size Before Replace

```python
import heapq

# ‚ùå Wrong: Replacing when heap isn't full yet
def top_k_wrong(nums, k):
    heap = []
    for num in nums:
        heapq.heapreplace(heap, num)  # Empty heap error!
    return heap

# ‚úÖ Correct: Build heap to size K first
def top_k_correct(nums, k):
    heap = []
    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, num)
        elif num > heap[0]:
            heapq.heapreplace(heap, num)
    return heap
```

### 4. Using heappushpop for Top K (Subtle Bug)

```python
import heapq

# ‚ö†Ô∏è Subtle: This works but might miss elements
def top_k_pushpop(nums, k):
    heap = []
    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, num)
        else:
            heapq.heappushpop(heap, num)
            # heappushpop returns the smallest
            # If num < heap[0], it returns num (never entered heap)
            # This is correct behavior for top K
    return heap

# Both work for top K, but heapreplace with explicit check is clearer
```

---

## üìù Practice Problems (Progressive)

### Easy (Understand replace)
- [ ] [Kth Largest Element in a Stream (LC 703)](https://leetcode.com/problems/kth-largest-element-in-a-stream/)
- [ ] [Last Stone Weight (LC 1046)](https://leetcode.com/problems/last-stone-weight/)

### Medium (Apply replace)
- [ ] [Kth Largest Element in an Array (LC 215)](https://leetcode.com/problems/kth-largest-element-in-an-array/)
- [ ] [Top K Frequent Elements (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/)
- [ ] [K Closest Points to Origin (LC 973)](https://leetcode.com/problems/k-closest-points-to-origin/)

### Hard (Master replace in sliding window)
- [ ] [Sliding Window Median (LC 480)](https://leetcode.com/problems/sliding-window-median/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement heapreplace manually
- **Day 3:** Implement heappushpop manually
- **Day 7:** Use both in Top K problem
- **Day 14:** Compare performance vs pop+push
- **Day 30:** Apply to sliding window

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Explain This in Interviews</strong></summary>

**Describing replace:**
"Replace operations combine extract and insert into a single O(log n) operation. Instead of pop then push which would be 2 * O(log n), heapreplace does it in one bubble-down."

**When to use which:**
"I use heapreplace when I'm maintaining a fixed-size heap and need to swap out elements - like in Top K problems. heappushpop is similar but the semantics are 'try to insert, get back smallest' which can sometimes short-circuit if the new element is already the smallest."

**Performance benefit:**
"In a streaming Top K problem with n elements, using heapreplace instead of pop+push saves roughly half the time in the replace-heavy phase."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| All | ‚≠ê‚≠ê‚≠ê‚≠ê | Core for Top K |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Many streaming problems |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Performance-focused |
| Google | ‚≠ê‚≠ê‚≠ê | May ask about optimization |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand difference | 10-15 min | heapreplace vs heappushpop |
| Implement manually | 15-20 min | Both operations |
| Apply to Top K | 10-15 min | With size constraint |
| Master | 30-45 min | Edge cases |

---

## üí° Key Insight

> **Replace operations are 2x faster than pop + push** because they only do one bubble operation. For Top K problems maintaining a K-size heap, use `heapreplace(heap, new)` when `new > heap[0]` to efficiently keep the K largest elements.

---

## üîó Related

- **Previous:** [Heapify](./2.4-Heapify.md)
- **Next:** [Priority Queue Basics](../03-Priority-Queue/3.1-PQ-Basics.md)
- **Related:** [Top K Pattern](../04-Top-K-Pattern/4.1-Top-K-Overview.md) | [Insert](./2.1-Insert.md) | [Extract](./2.2-Extract.md)
