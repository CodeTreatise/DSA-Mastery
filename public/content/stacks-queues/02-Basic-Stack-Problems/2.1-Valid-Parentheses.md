# 2.1 Valid Parentheses (LC 20)

> **Grokking Pattern:** #7 Stacks - Matching Pairs
>
> **Difficulty:** Easy | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Must-Know Classic

---

## Problem Statement

Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

A string is valid if:
1. Open brackets are closed by the same type of brackets
2. Open brackets are closed in the correct order
3. Every close bracket has a corresponding open bracket of the same type

```
Example 1:
Input: s = "()"
Output: true

Example 2:
Input: s = "()[]{}"
Output: true

Example 3:
Input: s = "(]"
Output: false

Example 4:
Input: s = "([)]"
Output: false

Example 5:
Input: s = "{[]}"
Output: true
```

[LeetCode 20 - Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Matching pairs" (brackets, tags, etc.)
- "Nested structure" validation
- "LIFO matching" - most recent open must close first

**Key insight:**
When we see a closing bracket, it must match the most recently seen unmatched opening bracket. This is LIFO behavior ‚Üí Stack!

**Why stack works:**
- Push opening brackets
- Pop when closing bracket matches top
- If mismatch or stack state wrong ‚Üí invalid

</details>

---

## ‚úÖ When to Use This Approach

- Matching nested pairs (brackets, HTML tags)
- Validating properly nested structures
- Any LIFO matching problem

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Order doesn't matter | Just count | Counter/Hash |
| Only one type of bracket | Counter sufficient | Increment/decrement |
| Need position of error | Stack tracks but needs enhancement | Stack with indices |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md)
- Basic string iteration

**After mastering this:**
- [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/) - LC 32
- [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) - LC 22
- [Remove Invalid Parentheses](https://leetcode.com/problems/remove-invalid-parentheses/) - LC 301
- [Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/) - LC 921

**This is the foundation for:**
- Expression evaluation
- HTML/XML validation
- Code syntax checking

</details>

---

## üìê How It Works

### Strategy

1. Create mapping: closing ‚Üí opening
2. Iterate through string:
   - Opening bracket ‚Üí push to stack
   - Closing bracket ‚Üí check if matches top of stack
3. Valid if stack empty at end

### Visual Walkthrough

```
Input: "{[]}"

i=0: char='{'
     Opening ‚Üí push
     Stack: ['{']

i=1: char='['
     Opening ‚Üí push
     Stack: ['{', '[']

i=2: char=']'
     Closing ‚Üí check top
     Top='[' matches ']' ‚úì
     Pop
     Stack: ['{']

i=3: char='}'
     Closing ‚Üí check top
     Top='{' matches '}' ‚úì
     Pop
     Stack: []

End: Stack empty ‚Üí VALID ‚úì
```

### Invalid Example

```
Input: "([)]"

i=0: char='('
     Push
     Stack: ['(']

i=1: char='['
     Push
     Stack: ['(', '[']

i=2: char=')'
     Closing ‚Üí check top
     Top='[' does NOT match ')' ‚úó
     Return false immediately

Result: INVALID
```

### Edge Cases

```
Case 1: "(((" 
        Stack: ['(', '(', '(']
        End: Stack not empty ‚Üí INVALID

Case 2: ")))"
        First ')': Stack empty, no match ‚Üí INVALID

Case 3: ""
        Empty string ‚Üí Stack empty ‚Üí VALID
```

---

## üíª Code Implementation

### Solution: Stack with Hash Map

**Python:**
```python
def is_valid(s: str) -> bool:
    """
    Check if parentheses string is valid.
    
    Pattern: Stack for matching pairs
    Time: O(n), Space: O(n)
    
    Key insight: Most recent open must match next close (LIFO)
    """
    # Map closing ‚Üí opening
    matching = {
        ')': '(',
        ']': '[',
        '}': '{'
    }
    
    stack = []
    
    for char in s:
        if char in matching:
            # Closing bracket
            # Check if it matches the most recent opening
            if not stack or stack[-1] != matching[char]:
                return False
            stack.pop()
        else:
            # Opening bracket
            stack.append(char)
    
    # Valid only if all opening brackets were matched
    return len(stack) == 0


def is_valid_verbose(s: str) -> bool:
    """
    More explicit version with detailed logic.
    """
    if not s:
        return True
    
    # Odd length can never be valid
    if len(s) % 2 == 1:
        return False
    
    opening = {'(', '[', '{'}
    matching = {')': '(', ']': '[', '}': '{'}
    
    stack = []
    
    for char in s:
        if char in opening:
            stack.append(char)
        elif char in matching:
            # Must have a matching opening bracket
            if not stack:
                return False  # More closing than opening
            if stack[-1] != matching[char]:
                return False  # Wrong type of bracket
            stack.pop()
    
    return len(stack) == 0  # All opened must be closed
```

**JavaScript:**
```javascript
/**
 * Check if parentheses string is valid.
 * Pattern: Stack for matching pairs
 * Time: O(n), Space: O(n)
 */
function isValid(s) {
    // Map closing to opening
    const matching = {
        ')': '(',
        ']': '[',
        '}': '{'
    };
    
    const stack = [];
    
    for (const char of s) {
        if (char in matching) {
            // Closing bracket
            if (stack.length === 0 || stack[stack.length - 1] !== matching[char]) {
                return false;
            }
            stack.pop();
        } else {
            // Opening bracket
            stack.push(char);
        }
    }
    
    return stack.length === 0;
}

// Alternative: Using switch
function isValidSwitch(s) {
    const stack = [];
    
    for (const char of s) {
        switch (char) {
            case '(':
            case '[':
            case '{':
                stack.push(char);
                break;
            case ')':
                if (stack.pop() !== '(') return false;
                break;
            case ']':
                if (stack.pop() !== '[') return false;
                break;
            case '}':
                if (stack.pop() !== '{') return false;
                break;
        }
    }
    
    return stack.length === 0;
}
```

### Alternative: Early Exit Optimization

**Python:**
```python
def is_valid_optimized(s: str) -> bool:
    """
    With early exit optimizations.
    """
    # Odd length impossible
    if len(s) % 2 == 1:
        return False
    
    # Start with closing bracket impossible
    if s and s[0] in ')]}':
        return False
    
    matching = {')': '(', ']': '[', '}': '{'}
    stack = []
    
    for char in s:
        if char in matching:
            # If more closings than openings
            if not stack:
                return False
            if stack.pop() != matching[char]:
                return False
        else:
            stack.append(char)
    
    return not stack
```

---

## ‚ö° Complexity Analysis

| Aspect | Complexity | Notes |
|--------|------------|-------|
| Time |" O(n) "| Single pass through string |
| Space |" O(n) "| Stack can hold n/2 brackets |

**Why O(n) space?**
- Worst case: all opening brackets like `(((((`
- Stack grows to n/2 (half are opening)
- Still O(n)

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Find longest valid substring | Return length, not bool | LC 32 |
| Minimum removals | Count unmatched | LC 921 |
| Generate all valid | Backtracking | LC 22 |
| With wildcards `*` | Can be any bracket | LC 678 |
| Return positions of invalid | Store indices in stack | Custom |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Checking Stack Empty Before Pop

```python
# ‚ùå WRONG: Crashes on ")"
if stack[-1] != matching[char]:
    return False
stack.pop()

# ‚úÖ CORRECT: Check empty first
if not stack or stack[-1] != matching[char]:
    return False
stack.pop()
```

### 2. Forgetting Final Stack Check

```python
# ‚ùå WRONG: Returns True for "((("
for char in s:
    # ... matching logic
return True

# ‚úÖ CORRECT: Check stack is empty
return len(stack) == 0
```

### 3. Wrong Mapping Direction

```python
# ‚ùå WRONG: Maps opening to closing
matching = {'(': ')', '[': ']', '{': '}'}

# ‚úÖ CORRECT: Maps closing to opening (what we check against stack)
matching = {')': '(', ']': '[', '}': '{'}
```

### 4. Including Non-Bracket Characters

```python
# ‚ùå WRONG: Pushes all characters
stack.append(char)  # Pushes 'a', 'b', etc.

# ‚úÖ CORRECT: Only push opening brackets
if char in '([{':
    stack.append(char)
```

---

## üìù Practice Problems (Progressive)

### This Problem
- [ ] [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/) - LC 20 ‚≠ê

### Related Problems
- [ ] [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) - LC 22
- [ ] [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/) - LC 32 (Hard)
- [ ] [Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/) - LC 678
- [ ] [Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/) - LC 921
- [ ] [Minimum Remove to Make Valid Parentheses](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/) - LC 1249

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement and trace through examples
**Day 3:** Implement without looking at code
**Day 7:** Handle all edge cases
**Day 14:** Solve LC 921 (count minimum adds)
**Day 21:** Solve LC 32 (longest valid substring)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Clarify:**
> "So the string only contains bracket characters, no letters or spaces?"

**Explain key insight:**
> "When I see a closing bracket, it must match the most recently seen unmatched opening bracket. This is LIFO behavior, so I'll use a stack."

**Walk through approach:**
> "I'll iterate through the string. For opening brackets, push to stack. For closing brackets, check if it matches the stack top. If mismatch or empty stack, invalid. At the end, stack must be empty."

**Discuss edge cases:**
> "Empty string is valid. Odd-length string is always invalid. String starting with closing bracket is invalid."

**Handle follow-ups:**
> - "What if we only have `()` ?" ‚Üí Can use counter instead
> - "Return positions of invalid?" ‚Üí Store indices instead of chars
> - "Minimum removals?" ‚Üí Track unmatched count

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Classic warm-up |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Often asked |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Frequently asked |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Common |
| Bloomberg | ‚≠ê‚≠ê‚≠ê‚≠ê | Finance applications |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 1-2 min | Read examples |
| Explain approach | 2-3 min | Stack + matching |
| Implement | 5-7 min | Clean code |
| Test | 2-3 min | Edge cases |
| Interview target | 10-15 min | Including explanation |

---

> **üí° Key Insight:** The stack naturally enforces the LIFO matching requirement. Each closing bracket must match the most recent unmatched opening bracket - exactly what the stack top represents. The stack essentially tracks "what we're waiting to close."

---

## üîó Related

- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md) - Foundation
- [Expression Evaluation](./2.3-Expression-Evaluation.md) - Uses similar matching
- [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) - Related backtracking
