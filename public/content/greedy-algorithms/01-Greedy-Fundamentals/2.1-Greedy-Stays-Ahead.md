# 2.1 Greedy Stays Ahead Proof

> **Definition:** The "Greedy Stays Ahead" proof technique shows that at every step, the greedy solution is at least as good as any other solution. If greedy stays ahead throughout, it must be optimal at the end.

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use This Proof Technique</strong></summary>

**Use Greedy Stays Ahead when:**
- Problem involves selecting items sequentially
- Greedy makes ONE choice at each step
- You can measure "progress" at each step
- Each greedy choice is comparable to alternative choices

**Best for proving:**
- Activity/interval selection problems
- Scheduling problems
- Selection problems with ordering

**Structure of the proof:**
1. Define a measure of "quality" at step i
2. Show greedy's quality ‚â• any other solution's quality at step i
3. Use induction: if true at step i, true at step i+1
4. Conclude: greedy is optimal at final step

</details>

---

## ‚úÖ When to Use

- Proving activity selection (sort by end time) is optimal
- Proving interval covering is optimal
- Any selection problem with measurable progress

## ‚ùå When NOT to Use

| Scenario | Use Instead |
|----------|-------------|
| Exchange argument easier | Exchange Argument |
| No clear step-by-step measure | Try counterexample first |
| Problem doesn't have ordering | Different proof technique |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Connections</strong></summary>

**Before this, you should know:**
- [What Is Greedy](./1.1-What-Is-Greedy.md)
- [When Greedy Works](./1.2-When-Greedy-Works.md)
- Mathematical induction (basic)

**After mastering this:**
- [Exchange Argument](./2.2-Exchange-Argument.md) - Alternative proof
- [Classic Greedy Problems](../05-Classic-Greedy/7.1-Classic-Problems-Overview.md) - Activity selection example

**Related:**
- Used to prove scheduling algorithms optimal
- Foundation for algorithm correctness proofs

</details>

---

## üìê How It Works

### The Core Idea

```
At every step k:
  greedy_progress[k] ‚â• alternative_progress[k]

If greedy stays ahead at every step,
then at the final step: greedy_result ‚â• any_other_result
```

### Proof Structure

```
1. Base Case (step 0 or 1):
   - Show greedy's first choice is at least as good as any alternative

2. Inductive Step:
   - Assume greedy stays ahead through step k
   - Show greedy's choice at step k+1 keeps it ahead

3. Conclusion:
   - By induction, greedy stays ahead through final step
   - Therefore, greedy solution is optimal
```

### Visual Representation

```
Step:        1      2      3      4      5 (final)
             ‚îÇ      ‚îÇ      ‚îÇ      ‚îÇ      ‚îÇ
Greedy:      ‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñà ‚Üê Stays ahead
             ‚îÇ      ‚îÇ      ‚îÇ      ‚îÇ      ‚îÇ
Alternative: ‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄX  ‚Üê Falls behind or equals
             ‚îÇ      ‚îÇ      ‚îÇ      ‚îÇ      ‚îÇ
             ‚ñº      ‚ñº      ‚ñº      ‚ñº      ‚ñº
Progress:    ‚â•      ‚â•      ‚â•      ‚â•      ‚â• (at every step)
```

---

## üíª Code Implementation

**Python - Activity Selection with Proof:**

```python
def activity_selection_with_proof(activities):
    """
    Select maximum non-overlapping activities.
    
    PROOF: Greedy Stays Ahead
    
    Claim: Sorting by end time and greedily selecting non-overlapping
    activities gives the maximum number of activities.
    
    Proof:
    Let G = {g1, g2, ..., gk} be greedy's selection (sorted by end time)
    Let O = {o1, o2, ..., om} be any other valid selection (m ‚â• k?)
    
    We'll show: k ‚â• m (greedy selects at least as many)
    
    Key observation: g_i.end ‚â§ o_i.end for all i ‚â§ min(k,m)
    (Greedy's i-th activity ends no later than any alternative's i-th)
    
    Base case (i=1):
    - g1 is the earliest-ending activity overall
    - o1 ends at or after g1 (since g1 ends earliest)
    - Therefore: g1.end ‚â§ o1.end ‚úì
    
    Inductive step:
    - Assume g_i.end ‚â§ o_i.end for all i ‚â§ j
    - At step j+1:
      - Greedy picks the earliest-ending activity starting after g_j.end
      - Since g_j.end ‚â§ o_j.end, any activity valid after o_j is also valid after g_j
      - So greedy has AT LEAST as many choices as alternative
      - Greedy picks earliest ending among its choices
      - Therefore: g_{j+1}.end ‚â§ o_{j+1}.end ‚úì
    
    Conclusion:
    - If m > k, then o_{k+1} exists and starts after o_k.end
    - But since g_k.end ‚â§ o_k.end, o_{k+1} starts after g_k.end too
    - So greedy could have picked o_{k+1} - contradiction!
    - Therefore: k ‚â• m, greedy is optimal ‚úì
    """
    if not activities:
        return []
    
    # Sort by end time (greedy criterion)
    sorted_acts = sorted(activities, key=lambda x: x[1])
    
    selected = [sorted_acts[0]]
    last_end = sorted_acts[0][1]
    
    for start, end in sorted_acts[1:]:
        if start >= last_end:  # Non-overlapping
            selected.append((start, end))
            last_end = end
    
    return selected


def verify_stays_ahead(greedy_selection, alternative_selection):
    """
    Verify that greedy stays ahead of alternative.
    """
    print("Comparing greedy vs alternative:\n")
    print("Step | Greedy End | Alternative End | Stays Ahead?")
    print("-" * 55)
    
    min_len = min(len(greedy_selection), len(alternative_selection))
    
    for i in range(min_len):
        g_end = greedy_selection[i][1]
        a_end = alternative_selection[i][1]
        ahead = "‚úì" if g_end <= a_end else "‚úó"
        print(f"  {i+1}  |     {g_end}      |       {a_end}        |      {ahead}")
    
    if len(greedy_selection) >= len(alternative_selection):
        print(f"\nGreedy selected {len(greedy_selection)}, Alternative selected {len(alternative_selection)}")
        print("Greedy is optimal! ‚úì")
    else:
        print("\nWARNING: Alternative selected more - check the proof!")


# Example
activities = [(1,3), (2,5), (4,6), (6,8), (5,9), (8,10)]
greedy = activity_selection_with_proof(activities)
print(f"Greedy selection: {greedy}\n")

# Compare with a suboptimal alternative
alternative = [(1,3), (4,6), (8,10)]  # Also valid, but let's verify
verify_stays_ahead(greedy, alternative)
```

**JavaScript:**
```javascript
function activitySelectionWithProof(activities) {
    /**
     * PROOF: Greedy Stays Ahead
     * 
     * At step i, greedy's i-th selection ends no later than
     * any other valid solution's i-th selection.
     * 
     * Since greedy can always continue when alternatives can,
     * greedy selects at least as many activities.
     */
    if (activities.length === 0) return [];
    
    // Sort by end time
    const sorted = [...activities].sort((a, b) => a[1] - b[1]);
    
    const selected = [sorted[0]];
    let lastEnd = sorted[0][1];
    
    for (let i = 1; i < sorted.length; i++) {
        const [start, end] = sorted[i];
        if (start >= lastEnd) {
            selected.push(sorted[i]);
            lastEnd = end;
        }
    }
    
    return selected;
}

function verifyStaysAhead(greedy, alternative) {
    console.log("Step | Greedy End | Alt End | Ahead?");
    console.log("-".repeat(40));
    
    const minLen = Math.min(greedy.length, alternative.length);
    
    for (let i = 0; i < minLen; i++) {
        const gEnd = greedy[i][1];
        const aEnd = alternative[i][1];
        const ahead = gEnd <= aEnd ? "‚úì" : "‚úó";
        console.log(`  ${i+1}  |     ${gEnd}      |    ${aEnd}    |   ${ahead}`);
    }
    
    console.log(`\nGreedy: ${greedy.length}, Alternative: ${alternative.length}`);
}

// Test
const activities = [[1,3], [2,5], [4,6], [6,8], [5,9], [8,10]];
const greedy = activitySelectionWithProof(activities);
console.log("Greedy:", greedy);
```

---

## ‚ö° Complexity Analysis

| Aspect | Complexity | Notes |
|--------|------------|-------|
| Proof itself | O(1) | Mathematical reasoning |
| Algorithm | O(n log n) | Dominated by sorting |
| Verification | O(n) | Compare step by step |

---

## üîÑ Proof Template

### Generic Greedy Stays Ahead Proof

```markdown
**Theorem:** Algorithm A produces an optimal solution.

**Proof by "Greedy Stays Ahead":**

Let G = {g‚ÇÅ, g‚ÇÇ, ..., g‚Çñ} be the solution produced by algorithm A.
Let O = {o‚ÇÅ, o‚ÇÇ, ..., o‚Çò} be any optimal solution.

We will show that k ‚â• m.

**Claim:** For all i ‚â§ min(k, m), [greedy's measure] ‚â§ [optimal's measure]

**Base Case (i = 1):**
[Show g‚ÇÅ is at least as good as o‚ÇÅ by the greedy criterion]

**Inductive Step:**
Assume the claim holds for all j ‚â§ i.
At step i + 1:
- [Show that greedy's choice at step i+1 maintains the property]
- [Key: greedy has at least as many options as alternative]

**Conclusion:**
If m > k, then [derive contradiction using the claim].
Therefore, k ‚â• m, and greedy is optimal. ‚àé
```

---

## ‚ö†Ô∏è Common Mistakes

1. **Not defining "ahead" properly**
   - ‚ùå Vague notion of "better"
   - ‚úÖ Precise measure: "ends no later than"

2. **Skipping the base case**
   - ‚ùå "Obviously true for first step"
   - ‚úÖ Explicitly prove: g‚ÇÅ.end ‚â§ o‚ÇÅ.end because...

3. **Weak inductive step**
   - ‚ùå "Similarly, it holds for step k+1"
   - ‚úÖ Show why greedy has at least as many options

4. **Forgetting to derive contradiction**
   - ‚ùå "So greedy stays ahead, done"
   - ‚úÖ Show: if alternative is longer, greedy could continue too

---

## üìù Practice Problems

### Prove with Greedy Stays Ahead
- [ ] [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/) - Equivalent to activity selection
- [ ] [Meeting Rooms](https://leetcode.com/problems/meeting-rooms/) - Simple overlap check
- [ ] [Minimum Number of Arrows](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/) - Interval covering

### Where This Proof Applies
- Activity Selection (canonical example)
- Interval Scheduling Maximization
- Tape Storage Problem
- Task Scheduling with Deadlines

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Write out full proof for activity selection
- **Day 3:** Prove non-overlapping intervals
- **Day 7:** Explain proof to someone
- **Day 14:** Apply to a new problem
- **Day 30:** Review and prove a variant

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Explaining the Proof in Interviews</strong></summary>

**When interviewer asks "How do you know greedy is optimal?":**

```
"I can prove this using the 'greedy stays ahead' argument.

The key insight is that at every step, greedy's selection 
ends no later than any alternative's selection at that step.

[Draw two timelines]

Since greedy always ends earlier or at the same time, 
it never has fewer options than any alternative. So if 
there's a longer valid selection, greedy would have 
found it too.

This means greedy gives the maximum number of activities."
```

**Shorter version for time pressure:**
```
"Greedy picks the earliest-ending activity. This is safe 
because ending earlier never blocks more activities than 
ending later. By induction, greedy stays ahead and gives 
the optimal count."
```

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand technique | 30 min | With activity selection |
| Write first proof | 45 min | Detailed, careful |
| Apply to new problem | 20 min | After practice |
| Explain verbally | 2-3 min | Interview context |

---

> **üí° Key Insight:** "Greedy stays ahead" works by showing that greedy never falls behind‚Äîat every step, it maintains at least as good a position as any alternative. This cumulative advantage proves optimality.

> **üîó Related:** [Exchange Argument](./2.2-Exchange-Argument.md) | [Classic Greedy](../05-Classic-Greedy/7.1-Classic-Problems-Overview.md) | [When Greedy Works](./1.2-When-Greedy-Works.md)
