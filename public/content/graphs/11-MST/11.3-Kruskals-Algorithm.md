# 11.3 Kruskal's Algorithm

> **Sort edges by weight, greedily add if no cycle - using Union-Find**
>
> ‚è±Ô∏è **Study Time:** 25 min | üìä **Priority:** Medium | üéØ **Pattern:** Greedy + Union-Find

---

## Overview

**Kruskal's Algorithm** builds the MST by processing edges in order of increasing weight, adding each edge if it doesn't create a cycle.

```
Algorithm:
1. Sort all edges by weight (ascending)
2. For each edge in sorted order:
   - If adding it doesn't create a cycle, add to MST
   - Use Union-Find to check connectivity
3. Stop when we have V-1 edges

Key: Union-Find enables O(Œ±(V)) cycle checking!
```

---

## üéØ When to Use Kruskal's

**Choose Kruskal's over Prim's when:**
- Edges given as a list (no need to build adjacency list)
- Sparse graph (fewer edges to sort)
- Already using Union-Find for other purposes
- Want simpler implementation

**Not ideal when:**
- Dense graph (many edges to sort)
- Graph given as adjacency list
- Need to start from specific vertex

---

## üìê How It Works

### Step-by-Step Example

```
Edges: [(0,1,4), (0,2,1), (1,2,2), (1,3,5), (2,3,8)]
Nodes: 0, 1, 2, 3

Step 1: Sort edges
        [(0,2,1), (1,2,2), (0,1,4), (1,3,5), (2,3,8)]

Step 2: Process edges
        Edge (0,2,1): 0 and 2 not connected ‚Üí ADD
                      Union(0,2), MST weight = 1
        
        Edge (1,2,2): 1 and 2 not connected ‚Üí ADD
                      Union(1,2), MST weight = 3
        
        Edge (0,1,4): 0 and 1 already connected (via 2) ‚Üí SKIP
        
        Edge (1,3,5): 1 and 3 not connected ‚Üí ADD
                      Union(1,3), MST weight = 8
        
        We have 3 edges (V-1) ‚Üí DONE!

MST: edges (0,2), (1,2), (1,3) with total weight 8
```

---

## üíª Code Implementation

**Python:**
```python
from typing import List, Tuple

class UnionFind:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x: int, y: int) -> bool:
        root_x, root_y = self.find(x), self.find(y)
        if root_x == root_y:
            return False  # Already connected
        if self.rank[root_x] < self.rank[root_y]:
            root_x, root_y = root_y, root_x
        self.parent[root_y] = root_x
        if self.rank[root_x] == self.rank[root_y]:
            self.rank[root_x] += 1
        return True


def kruskal(n: int, edges: List[Tuple[int, int, int]]) -> int:
    """
    Kruskal's MST algorithm.
    edges = [(u, v, weight), ...]
    
    Time: O(E log E) for sorting
    Space: O(V) for Union-Find
    """
    # Sort by weight
    edges.sort(key=lambda x: x[2])
    
    uf = UnionFind(n)
    mst_weight = 0
    edges_used = 0
    
    for u, v, weight in edges:
        if uf.union(u, v):
            mst_weight += weight
            edges_used += 1
            
            # Early termination: MST complete
            if edges_used == n - 1:
                break
    
    # Check if graph is connected
    return mst_weight if edges_used == n - 1 else -1


def kruskal_with_edges(n: int, edges: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:
    """
    Return the actual MST edges.
    """
    edges.sort(key=lambda x: x[2])
    
    uf = UnionFind(n)
    mst_edges = []
    
    for u, v, weight in edges:
        if uf.union(u, v):
            mst_edges.append((u, v, weight))
            if len(mst_edges) == n - 1:
                break
    
    return mst_edges


# Example
edges = [(0, 1, 4), (0, 2, 1), (1, 2, 2), (1, 3, 5), (2, 3, 8)]
print(f"MST weight: {kruskal(4, edges)}")  # 8
print(f"MST edges: {kruskal_with_edges(4, edges)}")
# [(0, 2, 1), (1, 2, 2), (1, 3, 5)]
```

**JavaScript:**
```javascript
class UnionFind {
    constructor(n) {
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.rank = new Array(n).fill(0);
    }
    
    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
    }
    
    union(x, y) {
        let rootX = this.find(x), rootY = this.find(y);
        if (rootX === rootY) return false;
        
        if (this.rank[rootX] < this.rank[rootY]) {
            [rootX, rootY] = [rootY, rootX];
        }
        this.parent[rootY] = rootX;
        if (this.rank[rootX] === this.rank[rootY]) {
            this.rank[rootX]++;
        }
        return true;
    }
}

function kruskal(n, edges) {
    edges.sort((a, b) => a[2] - b[2]);
    
    const uf = new UnionFind(n);
    let mstWeight = 0;
    let edgesUsed = 0;
    
    for (const [u, v, weight] of edges) {
        if (uf.union(u, v)) {
            mstWeight += weight;
            edgesUsed++;
            if (edgesUsed === n - 1) break;
        }
    }
    
    return edgesUsed === n - 1 ? mstWeight : -1;
}
```

---

## ‚ö° Complexity Analysis

| Aspect | Complexity | Notes |
|--------|------------|-------|
| **Time** | O(E log E) | Dominated by sorting |
| **Space** | O(V) | Union-Find structure |

**Breakdown:**
- Sorting: O(E log E) = O(E log V) since E ‚â§ V¬≤
- Union-Find operations: O(E √ó Œ±(V)) ‚âà O(E)
- Total: O(E log E)

---

## üîÑ Variations

### Min Cost to Connect Points (LC 1584)

```python
def minCostConnectPoints(points: List[List[int]]) -> int:
    """
    Generate all edges (complete graph), then run Kruskal's.
    """
    n = len(points)
    edges = []
    
    # Generate all edges
    for i in range(n):
        for j in range(i + 1, n):
            dist = abs(points[i][0] - points[j][0]) + \
                   abs(points[i][1] - points[j][1])
            edges.append((i, j, dist))
    
    return kruskal(n, edges)
```

### Maximum Spanning Tree

```python
def maxSpanningTree(n: int, edges: List[Tuple[int, int, int]]) -> int:
    """
    Sort in descending order instead.
    """
    edges.sort(key=lambda x: x[2], reverse=True)  # Descending!
    
    uf = UnionFind(n)
    total = 0
    count = 0
    
    for u, v, weight in edges:
        if uf.union(u, v):
            total += weight
            count += 1
            if count == n - 1:
                break
    
    return total if count == n - 1 else -1
```

### Critical and Pseudo-Critical Edges (LC 1489)

Identify which edges must be in MST vs could be in MST:

```python
def findCriticalAndPseudoCriticalEdges(n: int, edges: List[List[int]]) -> List[List[int]]:
    """
    Critical: Removing it increases MST weight
    Pseudo-Critical: Can be in some MST but not all
    """
    # Add original indices
    indexed_edges = [(u, v, w, i) for i, (u, v, w) in enumerate(edges)]
    indexed_edges.sort(key=lambda x: x[2])
    
    def mst_weight(n, edges, force_include=None, exclude=None):
        uf = UnionFind(n)
        weight = 0
        count = 0
        
        if force_include is not None:
            u, v, w, _ = force_include
            uf.union(u, v)
            weight += w
            count += 1
        
        for u, v, w, i in edges:
            if exclude is not None and i == exclude:
                continue
            if uf.union(u, v):
                weight += w
                count += 1
        
        return weight if count == n - 1 else float('inf')
    
    base_weight = mst_weight(n, indexed_edges)
    critical = []
    pseudo_critical = []
    
    for u, v, w, i in indexed_edges:
        # Check if critical: removing increases weight
        if mst_weight(n, indexed_edges, exclude=i) > base_weight:
            critical.append(i)
        # Check if pseudo-critical: forcing doesn't increase weight
        elif mst_weight(n, indexed_edges, force_include=(u, v, w, i)) == base_weight:
            pseudo_critical.append(i)
    
    return [critical, pseudo_critical]
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Sorting Edges

```python
# ‚ùå WRONG: Processing unsorted edges
for u, v, weight in edges:
    if uf.union(u, v):
        total += weight

# ‚úÖ CORRECT: Sort first
edges.sort(key=lambda x: x[2])
```

### 2. Forgetting Connectivity Check

```python
# ‚ùå WRONG: Assuming graph is connected
return total

# ‚úÖ CORRECT: Verify we used V-1 edges
return total if edges_used == n - 1 else -1
```

### 3. Wrong Termination Condition

```python
# ‚ùå WRONG: Processing all edges
for u, v, weight in edges:
    if uf.union(u, v):
        total += weight

# ‚úÖ CORRECT: Stop when MST complete
for u, v, weight in edges:
    if uf.union(u, v):
        total += weight
        count += 1
        if count == n - 1:
            break  # MST complete!
```

---

## üìù Practice Problems

- [ ] [Min Cost to Connect All Points](https://leetcode.com/problems/min-cost-to-connect-all-points/) - Generate edges, run Kruskal's
- [ ] [Connecting Cities With Minimum Cost](https://leetcode.com/problems/connecting-cities-with-minimum-cost/) - Direct application
- [ ] [Critical and Pseudo-Critical Edges](https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/) - Advanced analysis

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate</strong></summary>

**Opening:**
> "I'll use Kruskal's algorithm: sort edges by weight, then greedily add each edge if it doesn't create a cycle. I'll use Union-Find for efficient cycle detection."

**Why it works:**
> "Kruskal's is correct due to the Cut Property: the minimum weight edge crossing any cut is safe to add to the MST. By processing in sorted order, we're always making the greedy-optimal choice."

**Complexity:**
> "Time is O(E log E) for sorting, plus near-linear for Union-Find operations. Space is O(V) for the Union-Find structure."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Implement | 10 min | With Union-Find template |
| Solve basic problem | 15 min | Direct application |
| Critical edges variant | 30 min | More analysis |

---

> **üí° Key Insight:** Kruskal's works because we process edges in sorted order. When we add an edge, it's guaranteed to be the minimum weight edge that could connect those two components.

---

**Back:** [‚Üê Prim's Algorithm](./11.2-Prims-Algorithm.md) | **Next:** [Advanced Topics ‚Üí](../12-Advanced/12.1-Advanced-Overview.md)
