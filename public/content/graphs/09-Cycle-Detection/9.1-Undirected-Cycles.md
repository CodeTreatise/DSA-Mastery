# 9.1 Cycle Detection in Undirected Graphs

> **Detecting cycles with DFS parent tracking or Union-Find**
>
> ‚è±Ô∏è **Study Time:** 30 min | üìä **Priority:** High | üéØ **Pattern:** DFS / Union-Find

---

## Overview

A **cycle** in an undirected graph is a path that starts and ends at the same vertex without repeating edges. Detecting cycles is crucial for:
- Validating tree structure (trees have no cycles)
- Finding redundant edges
- Network reliability analysis

**Two main approaches:**
```
1. DFS with parent tracking
   - When visiting neighbor, if visited AND not parent ‚Üí cycle!
   
2. Union-Find
   - When adding edge, if both endpoints already connected ‚Üí cycle!
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Problem</strong></summary>

**Look for these signals:**
- "Does the graph contain a cycle?"
- "Is this a valid tree?" (tree = connected + no cycles)
- "Find redundant edge" (edge that creates cycle)
- "Can we remove an edge to make a tree?"

**Keywords in problem statement:**
- "cycle", "loop", "circular dependency"
- "valid tree", "connected acyclic graph"
- "redundant connection"

</details>

---

## ‚úÖ When to Use Each Approach

| Approach | Time | Space | Best When |
|----------|------|-------|-----------|
| **DFS** | O(V + E) | O(V) | General detection |
| **Union-Find** | O(E √ó Œ±(V)) | O(V) | Processing edges one by one |

**Choose DFS when:**
- Graph already built as adjacency list
- Need to find the actual cycle
- Part of larger DFS traversal

**Choose Union-Find when:**
- Processing edges incrementally
- Need to find the specific edge that creates cycle
- Already using Union-Find for other purposes

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [DFS Pattern](../04-DFS-Traversal/4.1-DFS-Fundamentals.md)
- [Union-Find](../07-Union-Find/7.1-Union-Find-Basics.md)

**After mastering this:**
- [Directed Graph Cycles](./9.2-Directed-Cycles.md)
- [Finding the Cycle Path](../12-Advanced/12.1-Advanced-Overview.md)
- [Minimum Spanning Tree](../11-MST/11.1-MST-Introduction.md)

**Combines with:**
- Tree validation problems
- Graph connectivity
- Redundant edge finding

</details>

---

## üìê How It Works

### Approach 1: DFS with Parent Tracking

```
Key insight: In DFS, we mark nodes as visited.
If we see a visited neighbor that's NOT our parent ‚Üí cycle!

        1 ‚îÄ‚îÄ‚îÄ 2
        ‚îÇ     ‚îÇ
        4 ‚îÄ‚îÄ‚îÄ 3

DFS from 1:
  Visit 1, mark visited
  ‚Üí Visit 2 (parent=1), mark visited
    ‚Üí Visit 3 (parent=2), mark visited
      ‚Üí See 4: not visited, go there
        Visit 4 (parent=3), mark visited
        ‚Üí See 1: visited AND not parent(3) ‚Üí CYCLE!
```

### Approach 2: Union-Find

```
Process edges one by one:
  Edge (1,2): Union(1,2) ‚Üí connected
  Edge (2,3): Union(2,3) ‚Üí connected
  Edge (3,4): Union(3,4) ‚Üí connected
  Edge (4,1): Find(4)=1, Find(1)=1, SAME! ‚Üí CYCLE!
```

---

## üíª Code Implementation

**Python - DFS Approach:**
```python
from collections import defaultdict
from typing import List

def hasCycleDFS(n: int, edges: List[List[int]]) -> bool:
    """
    Detect cycle using DFS with parent tracking.
    
    Time: O(V + E)
    Space: O(V)
    """
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    visited = [False] * n
    
    def dfs(node: int, parent: int) -> bool:
        visited[node] = True
        
        for neighbor in graph[node]:
            if not visited[neighbor]:
                if dfs(neighbor, node):
                    return True
            elif neighbor != parent:
                # Visited neighbor that's not parent = cycle!
                return True
        
        return False
    
    # Check all components (graph might be disconnected)
    for i in range(n):
        if not visited[i]:
            if dfs(i, -1):
                return True
    
    return False


def findCyclePath(n: int, edges: List[List[int]]) -> List[int]:
    """
    Find and return the actual cycle path.
    """
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    visited = [False] * n
    parent = [-1] * n
    cycle_start = cycle_end = -1
    
    def dfs(node: int, par: int) -> bool:
        nonlocal cycle_start, cycle_end
        visited[node] = True
        parent[node] = par
        
        for neighbor in graph[node]:
            if not visited[neighbor]:
                if dfs(neighbor, node):
                    return True
            elif neighbor != par:
                cycle_start = neighbor
                cycle_end = node
                return True
        
        return False
    
    for i in range(n):
        if not visited[i]:
            if dfs(i, -1):
                break
    
    if cycle_start == -1:
        return []  # No cycle
    
    # Reconstruct cycle path
    path = [cycle_start]
    current = cycle_end
    while current != cycle_start:
        path.append(current)
        current = parent[current]
    path.append(cycle_start)
    
    return path


# Test
print(hasCycleDFS(4, [[0,1], [1,2], [2,3], [3,0]]))  # True
print(hasCycleDFS(4, [[0,1], [1,2], [2,3]]))  # False
```

**Python - Union-Find Approach:**
```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        root_x, root_y = self.find(x), self.find(y)
        if root_x == root_y:
            return False  # Already connected!
        if self.rank[root_x] < self.rank[root_y]:
            root_x, root_y = root_y, root_x
        self.parent[root_y] = root_x
        if self.rank[root_x] == self.rank[root_y]:
            self.rank[root_x] += 1
        return True


def hasCycleUnionFind(n: int, edges: List[List[int]]) -> bool:
    """
    Detect cycle using Union-Find.
    
    Time: O(E √ó Œ±(V)) ‚âà O(E)
    Space: O(V)
    """
    uf = UnionFind(n)
    
    for u, v in edges:
        if not uf.union(u, v):
            return True  # Edge creates cycle!
    
    return False


def findRedundantEdge(n: int, edges: List[List[int]]) -> List[int]:
    """
    Find the edge that creates the cycle (LC 684).
    """
    uf = UnionFind(n)
    
    for u, v in edges:
        if not uf.union(u, v):
            return [u, v]
    
    return []
```

**JavaScript:**
```javascript
// DFS Approach
function hasCycleDFS(n, edges) {
    const graph = Array.from({ length: n }, () => []);
    for (const [u, v] of edges) {
        graph[u].push(v);
        graph[v].push(u);
    }
    
    const visited = new Array(n).fill(false);
    
    function dfs(node, parent) {
        visited[node] = true;
        
        for (const neighbor of graph[node]) {
            if (!visited[neighbor]) {
                if (dfs(neighbor, node)) return true;
            } else if (neighbor !== parent) {
                return true; // Cycle!
            }
        }
        
        return false;
    }
    
    for (let i = 0; i < n; i++) {
        if (!visited[i] && dfs(i, -1)) {
            return true;
        }
    }
    
    return false;
}

// Union-Find Approach
function hasCycleUnionFind(n, edges) {
    const parent = Array.from({ length: n }, (_, i) => i);
    
    function find(x) {
        if (parent[x] !== x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    function union(x, y) {
        const rootX = find(x), rootY = find(y);
        if (rootX === rootY) return false;
        parent[rootY] = rootX;
        return true;
    }
    
    for (const [u, v] of edges) {
        if (!union(u, v)) return true;
    }
    
    return false;
}
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| **DFS** | O(V + E) | O(V) | Visit each vertex/edge once |
| **Union-Find** | O(E √ó Œ±(V)) | O(V) | Nearly O(E) in practice |

**When is Union-Find faster?**
- When processing edges one by one (streaming)
- When you need to stop at the first cycle-creating edge
- When combined with other Union-Find operations

---

## üîÑ Variations

### Valid Tree Check (LC 261)

A graph is a valid tree if:
1. Connected (exactly n-1 edges for n nodes)
2. No cycles

```python
def validTree(n: int, edges: List[List[int]]) -> bool:
    """
    Check if graph is a valid tree.
    Tree = connected + acyclic
    """
    # Quick check: tree has exactly n-1 edges
    if len(edges) != n - 1:
        return False
    
    # Check connectivity using Union-Find
    uf = UnionFind(n)
    for u, v in edges:
        uf.union(u, v)
    
    # Check if all nodes in same component
    root = uf.find(0)
    return all(uf.find(i) == root for i in range(n))
```

### Find All Cycles

DFS with cycle path reconstruction:

```python
def findAllCycles(n: int, edges: List[List[int]]) -> List[List[int]]:
    """
    Find all cycles in the graph.
    More complex - uses modified DFS.
    """
    # This is more complex and typically involves
    # finding a cycle basis using spanning tree
    pass  # Beyond scope of basic cycle detection
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting Parent Check in DFS

```python
# ‚ùå WRONG: Any visited neighbor triggers cycle
if visited[neighbor]:
    return True  # But neighbor could be parent!

# ‚úÖ CORRECT: Skip the parent
if visited[neighbor] and neighbor != parent:
    return True
```

### 2. Not Handling Disconnected Graphs

```python
# ‚ùå WRONG: Only check from node 0
dfs(0, -1)

# ‚úÖ CORRECT: Check all components
for i in range(n):
    if not visited[i]:
        if dfs(i, -1):
            return True
```

### 3. Confusing Directed vs Undirected

```python
# ‚ùå WRONG: Using directed graph logic for undirected
# In undirected, we need parent tracking
# In directed, we use three-color marking

# ‚úÖ CORRECT: Use appropriate algorithm for graph type
```

---

## üìù Practice Problems (Progressive)

### Easy (Basic detection)
- [ ] [Graph Valid Tree](https://leetcode.com/problems/graph-valid-tree/) - Tree = connected + no cycle
- [ ] [Redundant Connection](https://leetcode.com/problems/redundant-connection/) - Find cycle-creating edge

### Medium (Variations)
- [ ] [Course Schedule](https://leetcode.com/problems/course-schedule/) - Directed graph cycle
- [ ] [Detect Cycles in 2D Grid](https://leetcode.com/problems/detect-cycles-in-2d-grid/) - Grid cycle

### Hard (Advanced)
- [ ] [Critical Connections](https://leetcode.com/problems/critical-connections-in-a-network/) - Find bridges

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

| Day | Activity |
|-----|----------|
| 1 | Implement DFS cycle detection |
| 3 | Implement Union-Find cycle detection |
| 7 | Solve Graph Valid Tree |
| 14 | Compare approaches, when to use each |

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening:**
> "For cycle detection in an undirected graph, I have two approaches: DFS with parent tracking, or Union-Find. I'll use [choice] because [reason]."

**Explaining DFS approach:**
> "In DFS, I mark nodes as visited. If I see a visited neighbor that isn't my parent, I've found a cycle - that's a back edge."

**Explaining Union-Find approach:**
> "With Union-Find, I process edges one by one. If an edge connects two nodes already in the same component, adding it would create a cycle."

</details>

**Company Focus:**
| Company | Frequency | Notes |
|---------|-----------|-------|
| **Amazon** | High | Tree validation, redundant edges |
| **Meta** | Medium | DFS approach preferred |
| **Google** | Medium | May ask for cycle path |
| **Microsoft** | High | Graph validation problems |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn DFS approach | 20 min | With parent tracking |
| Learn Union-Find approach | 15 min | After Union-Find basics |
| Solve Valid Tree | 15 min | Direct application |
| Solve Redundant Connection | 15 min | Find cycle-creating edge |

---

> **üí° Key Insight:** In undirected graphs, a "back edge" (to a visited non-parent) means a cycle. Unlike directed graphs, we don't need three-color marking - just parent tracking!

---

> **üîó Related:** [Directed Cycles](./9.2-Directed-Cycles.md) | [Union-Find](../07-Union-Find/7.1-Union-Find-Basics.md) | [DFS Pattern](../04-DFS-Traversal/4.1-DFS-Fundamentals.md)

---

**Next:** [Directed Graph Cycles ‚Üí](./9.2-Directed-Cycles.md)
