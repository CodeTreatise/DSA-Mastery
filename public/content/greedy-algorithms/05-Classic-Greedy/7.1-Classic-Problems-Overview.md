# 7.1 Classic Greedy Problems Overview

> **Definition:** Classic greedy problems are foundational algorithms that demonstrate core greedy principlesâ€”from Huffman coding to fractional knapsack, these algorithms have stood the test of time and interview frequency.

---

## ðŸŽ¯ The Essential Classics

| Problem | Greedy Choice | Interview Frequency |
|---------|---------------|---------------------|
| **Huffman Coding** | Merge smallest frequencies | â­â­ (concepts tested) |
| **Fractional Knapsack** | Highest value/weight ratio | â­â­â­ (vs 0/1 comparison) |
| **Coin Change (Canonical)** | Largest denomination first | â­â­ (understand limitation) |
| **Assign Cookies** | Match smallest to smallest | â­â­â­â­ (easy interview) |
| **Candy Distribution** | Two-pass Lâ†’R, Râ†’L | â­â­â­â­ (common hard) |

---

## ðŸ“ 1. Fractional Knapsack

### Problem

Given weights and values of n items, put these items in a knapsack of capacity W to get maximum total value. You can break items (take fractions).

### Greedy Choice

**Sort by value-to-weight ratio (value/weight) in descending order.**

```python
def fractional_knapsack(values: list[int], weights: list[int], capacity: int) -> float:
    """
    Fractional Knapsack - can take portions of items.
    
    Time: O(n log n), Space: O(n)
    """
    n = len(values)
    
    # Calculate ratio and sort
    items = [(values[i] / weights[i], weights[i], values[i]) for i in range(n)]
    items.sort(reverse=True)  # Highest ratio first
    
    total_value = 0.0
    remaining = capacity
    
    for ratio, weight, value in items:
        if weight <= remaining:
            # Take entire item
            total_value += value
            remaining -= weight
        else:
            # Take fraction
            total_value += ratio * remaining
            break
    
    return total_value
```

```javascript
function fractionalKnapsack(values, weights, capacity) {
    const items = values.map((v, i) => ({
        ratio: v / weights[i],
        weight: weights[i],
        value: v
    }));
    
    items.sort((a, b) => b.ratio - a.ratio);
    
    let totalValue = 0;
    let remaining = capacity;
    
    for (const item of items) {
        if (item.weight <= remaining) {
            totalValue += item.value;
            remaining -= item.weight;
        } else {
            totalValue += item.ratio * remaining;
            break;
        }
    }
    
    return totalValue;
}
```

### Why It Works

```
Taking highest ratio first maximizes "bang for buck".
Since we can take fractions, there's no trade-off decision.

Counterexample for 0/1 Knapsack (where greedy FAILS):
Items: (weight=10, value=60), (weight=20, value=100), (weight=30, value=120)
Capacity: 50

Greedy (by ratio): take (10,60) + (20,100) = 160
Optimal: take (20,100) + (30,120) = 220 âŒ

But for fractional, greedy is always optimal!
```

---

## ðŸ“ 2. Huffman Coding

### Problem

Given character frequencies, build a binary tree for optimal prefix-free encoding.

### Greedy Choice

**Always merge the two smallest frequencies first.**

```python
import heapq
from collections import Counter

def huffman_encoding(text: str) -> dict[str, str]:
    """
    Build Huffman encoding for text.
    
    Time: O(n log n), Space: O(n)
    """
    if not text:
        return {}
    
    freq = Counter(text)
    
    # Handle single character
    if len(freq) == 1:
        char = list(freq.keys())[0]
        return {char: "0"}
    
    # Min-heap of (frequency, unique_id, node)
    # Node: (char, left, right) or just char for leaf
    heap = [[f, i, char] for i, (char, f) in enumerate(freq.items())]
    heapq.heapify(heap)
    
    counter = len(heap)
    
    while len(heap) > 1:
        # Merge two smallest
        lo = heapq.heappop(heap)
        hi = heapq.heappop(heap)
        
        merged_freq = lo[0] + hi[0]
        merged_node = [lo, hi]  # Internal node with children
        
        heapq.heappush(heap, [merged_freq, counter, merged_node])
        counter += 1
    
    # Build codes from tree
    codes = {}
    
    def build_codes(node, code):
        if isinstance(node[2], str):  # Leaf node
            codes[node[2]] = code or "0"
        else:
            build_codes(node[2][0], code + "0")
            build_codes(node[2][1], code + "1")
    
    build_codes(heap[0], "")
    return codes
```

### Why It Works

```
Huffman coding uses:
- Shorter codes for frequent characters
- Longer codes for rare characters

By always merging smallest, we push rare characters deeper in tree.

Property: Optimal prefix-free encoding (no code is prefix of another).
```

---

## ðŸ“ 3. Assign Cookies (LeetCode 455)

### Problem

Assign cookies to children. Each child has greed factor g[i], each cookie has size s[j]. Child i is satisfied if s[j] >= g[i].

### Greedy Choice

**Sort both arrays. Match smallest unsatisfied child with smallest sufficient cookie.**

```python
def findContentChildren(g: list[int], s: list[int]) -> int:
    """
    LeetCode 455: Assign Cookies
    
    Time: O(n log n + m log m), Space: O(1)
    """
    g.sort()  # Children's greed
    s.sort()  # Cookie sizes
    
    child = cookie = 0
    
    while child < len(g) and cookie < len(s):
        if s[cookie] >= g[child]:
            child += 1  # Child satisfied
        cookie += 1  # Try next cookie
    
    return child  # Number of satisfied children
```

```javascript
function findContentChildren(g, s) {
    g.sort((a, b) => a - b);
    s.sort((a, b) => a - b);
    
    let child = 0, cookie = 0;
    
    while (child < g.length && cookie < s.length) {
        if (s[cookie] >= g[child]) child++;
        cookie++;
    }
    
    return child;
}
```

### Why It Works

```
Intuition: Don't waste big cookies on children with small needs.

If cookie s[j] can satisfy child g[i], it can satisfy any child 
with smaller greed. So match with smallest unsatisfied child.
```

---

## ðŸ“ 4. Candy Distribution (LeetCode 135)

### Problem

N children in a line, each with rating. Give candy such that:
1. Each child gets at least 1 candy
2. Higher-rated neighbors get more candy

Minimize total candies.

### Greedy Choice

**Two-pass approach: left-to-right, then right-to-left.**

```python
def candy(ratings: list[int]) -> int:
    """
    LeetCode 135: Candy
    
    Two-pass greedy approach.
    
    Time: O(n), Space: O(n)
    """
    n = len(ratings)
    candies = [1] * n
    
    # Left to right: handle left neighbors
    for i in range(1, n):
        if ratings[i] > ratings[i - 1]:
            candies[i] = candies[i - 1] + 1
    
    # Right to left: handle right neighbors
    for i in range(n - 2, -1, -1):
        if ratings[i] > ratings[i + 1]:
            candies[i] = max(candies[i], candies[i + 1] + 1)
    
    return sum(candies)
```

```javascript
function candy(ratings) {
    const n = ratings.length;
    const candies = new Array(n).fill(1);
    
    // Left to right
    for (let i = 1; i < n; i++) {
        if (ratings[i] > ratings[i - 1]) {
            candies[i] = candies[i - 1] + 1;
        }
    }
    
    // Right to left
    for (let i = n - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1]) {
            candies[i] = Math.max(candies[i], candies[i + 1] + 1);
        }
    }
    
    return candies.reduce((a, b) => a + b, 0);
}
```

### Why It Works

```
Pass 1 (Lâ†’R): Ensure each child has more than LEFT neighbor if rated higher.
Pass 2 (Râ†’L): Ensure each child has more than RIGHT neighbor if rated higher.
              Take MAX to satisfy both constraints.

Example: ratings = [1, 2, 2]
After Lâ†’R: [1, 2, 1]  (second > first, so gets 2)
After Râ†’L: [1, 2, 1]  (second = third, no change needed)
Answer: 4
```

---

## ðŸ“ 5. Coin Change (When Greedy Works)

### Problem

Make change for amount using minimum coins (specific denominations).

### Greedy Limitation

**Greedy only works for "canonical" coin systems (like US coins).**

```python
def coin_change_greedy(coins: list[int], amount: int) -> int:
    """
    Greedy coin change - ONLY works for canonical systems!
    
    Canonical: [1, 5, 10, 25] (US coins)
    Non-canonical: [1, 3, 4] (greedy fails for amount 6)
    """
    coins.sort(reverse=True)  # Largest first
    count = 0
    
    for coin in coins:
        if amount >= coin:
            count += amount // coin
            amount %= coin
    
    return count if amount == 0 else -1  # -1 if impossible


def coin_change_dp(coins: list[int], amount: int) -> int:
    """
    DP solution - works for ALL coin systems.
    Use this in interviews unless specifically told canonical.
    """
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i and dp[i - coin] != float('inf'):
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1
```

### When Greedy Fails

```
Coins: [1, 3, 4], Amount: 6

Greedy: 4 + 1 + 1 = 3 coins
Optimal: 3 + 3 = 2 coins âŒ

Always use DP for coin change in interviews!
```

---

## âš¡ Complexity Summary

| Problem | Time | Space | Key |
|---------|------|-------|-----|
| Fractional Knapsack | O(n log n) | O(n) | Sort by ratio |
| Huffman Coding | O(n log n) | O(n) | Min-heap |
| Assign Cookies | O(n log n) | O(1) | Sort both |
| Candy | O(n) | O(n) | Two-pass |
| Coin Change (greedy) | O(n) | O(1) | Only canonical! |

---

## âš ï¸ Common Interview Traps

### 1. Fractional vs 0/1 Knapsack

```
Interviewer: "Solve the knapsack problem"
You: "Can I take fractions of items?"

If YES â†’ Greedy (sort by ratio)
If NO â†’ DP (this is 0/1 knapsack)
```

### 2. Coin Change System

```
Interviewer: "Make change with minimum coins"
You: "What denominations?"

If canonical (1, 5, 10, 25) â†’ Greedy works
If arbitrary â†’ Use DP
When in doubt â†’ Use DP
```

### 3. Two-Pass Problems

```
If constraints involve BOTH directions:
- Left neighbors AND right neighbors
- Before AND after relationships

â†’ Consider two-pass approach (Lâ†’R then Râ†’L)
```

---

## ðŸ“ Practice Problems

### Classic Implementations
- [ ] [Assign Cookies](https://leetcode.com/problems/assign-cookies/)
- [ ] [Candy](https://leetcode.com/problems/candy/)
- [ ] [Lemonade Change](https://leetcode.com/problems/lemonade-change/)

### Variations
- [ ] [Two City Scheduling](https://leetcode.com/problems/two-city-scheduling/)
- [ ] [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/)
- [ ] [Partition Labels](https://leetcode.com/problems/partition-labels/)

### For Comparison (NOT greedy)
- [ ] [Coin Change](https://leetcode.com/problems/coin-change/) - DP
- [ ] [0/1 Knapsack](https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/) - DP

---

## ðŸŽ¤ Interview Context

<details>
<summary><strong>How to Discuss Classic Greedy in Interviews</strong></summary>

**When asked about Knapsack:**
```
"There are two versions:
1. Fractional - can take portions â†’ Greedy (sort by value/weight ratio)
2. 0/1 - must take whole items â†’ DP (greedy doesn't work)

For fractional, greedy is optimal because taking the highest
ratio first always maximizes value."
```

**When asked about Coin Change:**
```
"Greedy only works for canonical coin systems like US coins.
For arbitrary denominations, I'd use DP because greedy can
give suboptimal results.

For example, with coins [1,3,4] and amount 6:
Greedy: 4+1+1 = 3 coins
DP: 3+3 = 2 coins"
```

</details>

---

> **ðŸ’¡ Key Insight:** Classic greedy problems teach core principles, but also teach us where greedy FAILS. Understanding both sides is crucial for interviews.

> **ðŸ”— Related:** [Greedy vs DP](../01-Greedy-Fundamentals/1.3-Greedy-vs-DP.md) | [Interval Pattern](../02-Interval-Pattern/4.1-Interval-Greedy-Overview.md)
