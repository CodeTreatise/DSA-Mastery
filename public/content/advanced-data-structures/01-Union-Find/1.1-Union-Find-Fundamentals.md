# Union-Find (Disjoint Set Union) Fundamentals

> **The go-to data structure for tracking connected components and grouping relationships.**
>
> Also known as: **DSU** (Disjoint Set Union), **Merge-Find Set**

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Union-Find Problems</strong></summary>

**Look for these signals:**
- "Group", "connect", "merge", "union" in problem statement
- "Are X and Y in the same group/connected?"
- Dynamic connectivity: adding edges over time
- Need to count distinct groups/components
- Equivalence relationships (if a~b and b~c, then a~c)

**Keywords in problem statement:**
- "connected components"
- "same group / same set"
- "merge accounts / union operations"
- "find if path exists"
- "number of islands" (with dynamic additions)

**Problem patterns:**
```
‚úì "Given edges, count connected components"
‚úì "Group elements that share a property"
‚úì "Check if adding edge creates a cycle"
‚úì "Merge accounts with common emails"
‚úì "Can all equations be satisfied?"
```

</details>

---

## ‚úÖ When to Use Union-Find

| Scenario | Why Union-Find Works |
|----------|---------------------|
| **Connected components** | Track which nodes belong together |
| **Cycle detection in undirected graphs** | If two nodes already connected, edge creates cycle |
| **Dynamic connectivity** | Online queries: "are X and Y connected?" |
| **Grouping by equivalence** | Transitive relationships (a~b, b~c ‚Üí a~c) |
| **Kruskal's MST algorithm** | Check if adding edge connects new components |
| **Network connectivity** | Servers, social networks, friend groups |

**Best when:**
- Edges added dynamically (one at a time)
- Need fast "same component?" queries
- Don't need to enumerate all members of a group

---

## ‚ùå When NOT to Use Union-Find

| Scenario | Better Alternative | Why |
|----------|-------------------|-----|
| Need to **remove** edges | Maintain full graph, use DFS/BFS | Union-Find doesn't support "undo" |
| Need **path** between nodes | BFS/DFS | Union-Find only checks connectivity |
| Need to **list all members** of a group | DFS + adjacency list | Union-Find tracks roots, not members |
| **Directed** graph connectivity | Tarjan's SCC algorithm | Union-Find is for undirected only |
| Small static graph | Simple DFS | Overkill for one-time traversal |
| Need **shortest path** | BFS/Dijkstra | Union-Find ignores distances |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Connections</strong></summary>

**Before this, you should know:**
- [Graph Basics](../../10-Graphs/10-Graphs.md) - Nodes, edges, connectivity
- [Trees](../../06-Trees/06-Trees.md) - Parent-child relationships
- [Recursion](../../02-Recursion-Backtracking/02-Recursion-Backtracking.md) - For path compression

**After mastering this:**
- [Kruskal's MST Algorithm](../../10-Graphs/10-Graphs.md#minimum-spanning-tree) - Uses Union-Find
- [Cycle Detection](./1.4-Advanced-Patterns/02-Cycle-Detection.md) - Classic application

**Combines with:**
- **Sorting** for problems like "Smallest String With Swaps"
- **Graphs** for connected component problems
- **Greedy** algorithms (Kruskal's)

</details>

---

## üìê How It Works

### The Core Idea

Union-Find maintains a **forest of trees** where:
- Each tree represents a **set/group**
- Each node points to its **parent**
- The **root** of each tree is the **representative** of that set

```
Initial: Each element is its own set (self-loop)

  0    1    2    3    4    (5 separate sets)
  ‚Ü∫    ‚Ü∫    ‚Ü∫    ‚Ü∫    ‚Ü∫

After union(0,1) and union(2,3):

  0 ‚Üê 1    2 ‚Üê 3    4      (3 sets now)
  ‚Ü∫         ‚Ü∫        ‚Ü∫

After union(0,2):

      0 ‚Üê 1           4    (2 sets now)
     ‚Üó
    2 ‚Üê 3
```

### Two Core Operations

| Operation | Purpose | Question It Answers |
|-----------|---------|---------------------|
| **find(x)** | Get representative (root) of x's set | "Which group is x in?" |
| **union(x, y)** | Merge sets containing x and y | "Make x and y part of same group" |

### Visual Representation

```
parent array: [0, 0, 2, 2, 4]
               ‚Üë  ‚Üë  ‚Üë  ‚Üë  ‚Üë
               0  1  2  3  4

Interpretation:
- parent[0] = 0 ‚Üí 0 is root of its set
- parent[1] = 0 ‚Üí 1's parent is 0
- parent[2] = 2 ‚Üí 2 is root of its set
- parent[3] = 2 ‚Üí 3's parent is 2
- parent[4] = 4 ‚Üí 4 is root of its set

Tree visualization:
    Set 1:  0      Set 2:  2      Set 3:  4
            |              |
            1              3
```

### The Algorithm Flow

```
FUNCTION find(x):
    While parent[x] ‚â† x:
        x = parent[x]
    Return x

FUNCTION union(x, y):
    root_x = find(x)
    root_y = find(y)
    
    If root_x ‚â† root_y:
        parent[root_x] = root_y  (or vice versa)
        Return True  (successfully merged)
    Return False  (already same set)
```

---

## üíª Code Implementation

### Basic Implementation (No Optimizations)

**Python:**
```python
class UnionFind:
    """
    Basic Union-Find without optimizations.
    
    Time Complexity:
        - find(): O(n) worst case (linear chain)
        - union(): O(n) worst case
    
    Space Complexity: O(n)
    """
    
    def __init__(self, n: int):
        """Initialize n elements, each in its own set."""
        # parent[i] = parent of element i
        # Initially, each element is its own parent (self-loop)
        self.parent = list(range(n))
    
    def find(self, x: int) -> int:
        """
        Find the root (representative) of x's set.
        
        Traverse parent pointers until we find a self-loop.
        """
        while self.parent[x] != x:
            x = self.parent[x]
        return x
    
    def union(self, x: int, y: int) -> bool:
        """
        Merge the sets containing x and y.
        
        Returns:
            True if sets were different (merge happened)
            False if x and y were already in same set
        """
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False  # Already in same set
        
        # Make root_x point to root_y (arbitrary choice)
        self.parent[root_x] = root_y
        return True
    
    def connected(self, x: int, y: int) -> bool:
        """Check if x and y are in the same set."""
        return self.find(x) == self.find(y)


# Example usage
uf = UnionFind(5)
print(uf.connected(0, 1))  # False

uf.union(0, 1)
print(uf.connected(0, 1))  # True

uf.union(2, 3)
uf.union(0, 2)
print(uf.connected(1, 3))  # True (transitively connected)
```

**JavaScript:**
```javascript
class UnionFind {
    /**
     * Basic Union-Find without optimizations.
     * @param {number} n - Number of elements
     */
    constructor(n) {
        // Each element starts as its own parent
        this.parent = Array.from({ length: n }, (_, i) => i);
    }
    
    /**
     * Find the root (representative) of x's set.
     * @param {number} x - Element to find root of
     * @returns {number} Root of x's set
     */
    find(x) {
        while (this.parent[x] !== x) {
            x = this.parent[x];
        }
        return x;
    }
    
    /**
     * Merge the sets containing x and y.
     * @param {number} x - First element
     * @param {number} y - Second element
     * @returns {boolean} True if merge happened
     */
    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);
        
        if (rootX === rootY) {
            return false;  // Already same set
        }
        
        this.parent[rootX] = rootY;
        return true;
    }
    
    /**
     * Check if x and y are in the same set.
     * @param {number} x - First element
     * @param {number} y - Second element
     * @returns {boolean} True if connected
     */
    connected(x, y) {
        return this.find(x) === this.find(y);
    }
}

// Example usage
const uf = new UnionFind(5);
console.log(uf.connected(0, 1));  // false

uf.union(0, 1);
console.log(uf.connected(0, 1));  // true

uf.union(2, 3);
uf.union(0, 2);
console.log(uf.connected(1, 3));  // true
```

---

## ‚ö° Complexity Analysis

### Basic Implementation (No Optimizations)

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Initialize | O(n) | O(n) | Create parent array |
| find(x) | O(n) | O(1) | Worst case: linear chain |
| union(x, y) | O(n) | O(1) | Dominated by find() |
| connected(x, y) | O(n) | O(1) | Two find() calls |

**Why O(n) worst case?**

If we always attach the new element as a child:
```
union(0, 1): 0 ‚Üí 1
union(1, 2): 0 ‚Üí 1 ‚Üí 2
union(2, 3): 0 ‚Üí 1 ‚Üí 2 ‚Üí 3
union(3, 4): 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4

find(0) must traverse 4 edges!
```

This creates a **linear chain** (degenerate tree).

### With Optimizations (covered in next file)

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| find(x) | O(Œ±(n)) ‚âà O(1) | O(1) | With path compression |
| union(x, y) | O(Œ±(n)) ‚âà O(1) | O(1) | With union by rank |

Where Œ±(n) is the **inverse Ackermann function** - grows so slowly that Œ±(n) < 5 for any practical n.

---

## üîÑ Variations

| Variation | Difference | Use Case |
|-----------|------------|----------|
| **With Path Compression** | Flatten tree during find | Near O(1) find |
| **With Union by Rank** | Attach smaller to larger | Balanced trees |
| **With Size Tracking** | Track set sizes | "How many in this group?" |
| **Weighted Union-Find** | Store relative values | Potentials, ratios |
| **With Component Count** | Track number of sets | "How many groups?" |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Check if Already Connected

```python
# ‚ùå Wrong: Always decrement count
def union(self, x, y):
    root_x, root_y = self.find(x), self.find(y)
    self.parent[root_x] = root_y
    self.count -= 1  # Wrong if already same set!

# ‚úÖ Correct: Check first
def union(self, x, y):
    root_x, root_y = self.find(x), self.find(y)
    if root_x == root_y:
        return False  # Already same set
    self.parent[root_x] = root_y
    self.count -= 1
    return True
```

### 2. Unioning Elements Instead of Roots

```python
# ‚ùå Wrong: Connecting elements directly
def union(self, x, y):
    self.parent[x] = y  # Wrong! Doesn't merge sets properly

# ‚úÖ Correct: Connect roots
def union(self, x, y):
    root_x, root_y = self.find(x), self.find(y)
    if root_x != root_y:
        self.parent[root_x] = root_y
```

### 3. Not Initializing Parent Array Correctly

```python
# ‚ùå Wrong: All zeros
self.parent = [0] * n  # Element 1, 2, 3... all point to 0

# ‚úÖ Correct: Each element is its own parent
self.parent = list(range(n))  # [0, 1, 2, 3, ...]
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the basics)
| Problem | Pattern | Key Insight |
|---------|---------|-------------|
| [Number of Provinces](https://leetcode.com/problems/number-of-provinces/) | Basic UF | Count components |

### Medium (Apply the pattern)
| Problem | Pattern | Key Insight |
|---------|---------|-------------|
| [Redundant Connection](https://leetcode.com/problems/redundant-connection/) | Cycle Detection | Edge that connects same component |
| [Number of Connected Components](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/) | Count roots | Initialize count = n, decrement on union |
| [Accounts Merge](https://leetcode.com/problems/accounts-merge/) | Grouping | Union emails, group by root |

### Hard (Master edge cases)
| Problem | Pattern | Key Insight |
|---------|---------|-------------|
| [Number of Islands II](https://leetcode.com/problems/number-of-islands-ii/) | Dynamic UF | Add islands one by one, check neighbors |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

After solving each problem:
- **Day 1:** Implement Union-Find from scratch without looking
- **Day 3:** Solve Number of Provinces again
- **Day 7:** Add path compression and union by rank
- **Day 14:** Solve Accounts Merge
- **Day 30:** Explain Union-Find to someone else

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Opening statement:**
> "I notice this is a connectivity/grouping problem. The key insight is that we need to track which elements belong to the same group and merge groups efficiently. Union-Find is perfect for this because it gives us near O(1) operations for both finding which group an element is in and merging two groups."

**Explain the approach:**
> "I'll use a parent array where each element points to its representative. The find operation follows parent pointers to the root, and union connects two roots."

**Mention optimizations (shows depth):**
> "To ensure efficiency, I'll add path compression during find, which flattens the tree, and union by rank, which keeps trees balanced. Together these give O(Œ±(n)) which is effectively O(1)."

**Company Frequency:**
| Company | Frequency | Focus |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Connected components |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Accounts merge pattern |
| Google | ‚≠ê‚≠ê‚≠ê | May combine with other DS |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Graph connectivity |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn basic concept | 20-30 min | Understand parent array |
| Implement basic UF | 10-15 min | find, union, connected |
| Add optimizations | 15-20 min | Path compression, union by rank |
| Solve Easy problem | 15-20 min | Number of Provinces |
| Solve Medium problem | 25-35 min | Accounts Merge |
| Master pattern | 3-4 hours | Multiple problems |

---

> **üí° Key Insight:** Union-Find brilliantly reduces "are X and Y connected?" from O(n) traversal to nearly O(1) by maintaining set representatives. The magic is in the optimizations: path compression makes trees flat, and union by rank keeps them balanced.

> **üîó Related:** [Optimizations](./1.3-Optimizations.md) | [Connected Components](./1.4-Advanced-Patterns/01-Connected-Components.md) | [Graph Traversal](../../10-Graphs/10-Graphs.md)

---

**Next:** [Basic Implementation Details ‚Üí](./1.2-Basic-Implementation.md)
