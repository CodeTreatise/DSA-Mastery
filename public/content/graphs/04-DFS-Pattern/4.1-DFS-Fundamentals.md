# 4.1 DFS Fundamentals

> **Deep exploration before backtracking - the foundation of graph traversal**
>
> â±ï¸ **Time:** 45-60 min | ğŸ“Š **Difficulty:** Core | ğŸ¯ **Interview Frequency:** â­â­â­â­â­ (25%+ of graph problems)

---

## Overview

**Depth-First Search (DFS)** explores as deep as possible along each branch before backtracking. It's the natural way to explore all paths, detect cycles, and traverse connected components.

```
DFS Visualization:

     [0]
    / | \
  [1][2][3]
  /       \
[4]       [5]

DFS from 0: 0 â†’ 1 â†’ 4 (backtrack) â†’ 2 (backtrack) â†’ 3 â†’ 5
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            Goes deep first, then backtracks!

vs BFS:     0 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            Level by level
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>How to Identify DFS Problems</strong></summary>

**Look for these signals:**
- "Find if path exists" (any path, not shortest)
- "Explore all possibilities"
- "Connected components"
- "Cycle detection"
- "Topological ordering"
- "Backtracking" required
- "Count all paths"
- "Island/region problems"

**Keywords in problem statement:**
- "connected", "reachable"
- "all paths", "any path"
- "detect cycle"
- "topological sort"
- "flood fill", "count islands"
- "component", "region"

**When DFS beats BFS:**
- Memory-constrained (stack vs queue)
- Need to explore exhaustively
- Backtracking required
- Topological sort
- Finding ANY path (not shortest)

</details>

---

## âœ… When to Use DFS

| Scenario | Why DFS Works |
|----------|---------------|
| Path existence | Any path works, don't need shortest |
| Cycle detection | Detect back edges during traversal |
| Connected components | Explore entire component before next |
| Topological sort | Finish times give ordering |
| Backtracking problems | Natural recursion fits |
| Tree traversals | Pre/in/post-order are DFS variants |
| Generate all paths | Need exhaustive exploration |

---

## âŒ When NOT to Use DFS

| Scenario | Why Not | Better Alternative |
|----------|---------|-------------------|
| Shortest path (unweighted) | DFS finds A path, not SHORTEST | BFS |
| Level-order traversal | DFS doesn't visit level-by-level | BFS |
| Minimum steps | May find long path first | BFS |
| Very deep graphs | Stack overflow risk | Iterative BFS |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Graph Basics](../01-Graph-Fundamentals/1.1-What-Is-Graph.md)
- [Adjacency List](../02-Graph-Representation/2.2-Adjacency-List.md)
- [Recursion](../../02-Recursion-Backtracking/01-Recursion/1.1-Recursion-Basics.md)

**After mastering this:**
- [DFS Template](./4.2-DFS-Template.md) - Generic patterns
- [DFS Applications](./4.3-DFS-Applications.md) - Cycle detection, topological sort
- [Grid Traversal](../05-Grid-Traversal/5.1-Grid-Introduction.md)
- [Backtracking](../../02-Recursion-Backtracking/02-Backtracking/2.1-Backtracking-Basics.md)

**Combines with:**
- **Topological Sort** = DFS + finish time ordering
- **Cycle Detection** = DFS + tracking visiting state
- **Union-Find** = Alternative for connectivity

**Grokking Pattern:** #15 - Graph DFS

</details>

---

## ğŸ“ How It Works

### Core Concept

DFS uses a **stack** (explicit or recursion) to explore:

1. Start at source node, mark visited
2. For each unvisited neighbor, recursively explore
3. Backtrack when no more unvisited neighbors
4. Continue until all reachable nodes visited

### Recursive vs Iterative

```
RECURSIVE (uses call stack):
def dfs(node):
    visit(node)
    for neighbor in graph[node]:
        if not visited[neighbor]:
            dfs(neighbor)

ITERATIVE (explicit stack):
stack = [start]
while stack:
    node = stack.pop()
    if not visited[node]:
        visit(node)
        for neighbor in graph[node]:
            stack.append(neighbor)
```

### Step-by-Step Visualization

```
Graph:
    0 â”€â”€â”€ 1 â”€â”€â”€ 2
    â”‚     â”‚
    3     4

DFS from 0 (recursive):

Step 1: visit(0), explore neighbors [1, 3]
        â†“ recurse on 1
Step 2: visit(1), explore neighbors [0, 2, 4]
        â†“ 0 visited, recurse on 2
Step 3: visit(2), explore neighbors [1]
        â†“ 1 visited, backtrack
Step 4: back at 1, recurse on 4
Step 5: visit(4), explore neighbors [1]
        â†“ 1 visited, backtrack
Step 6: back at 0, recurse on 3
Step 7: visit(3), explore neighbors [0]
        â†“ 0 visited, backtrack
Step 8: Done!

Visit order: 0 â†’ 1 â†’ 2 â†’ 4 â†’ 3
```

### DFS Tree and Edge Types

```
Original Graph:          DFS Tree from 0:
    0 â”€â”€â”€ 1                   0
    â”‚ â•²   â”‚                  â•± â•²
    â”‚  â•²  â”‚                 1   3
    3    2                 â•± â•²
    â”‚                     2   4
    4

Edge Types:
- Tree edges: edges in DFS tree (0â†’1, 1â†’2, 1â†’4, 0â†’3)
- Back edges: edges to ancestors (used for cycle detection)
- Forward edges: edges to descendants (in directed graphs)
- Cross edges: edges to neither ancestor nor descendant
```

---

## ğŸ’» Code Implementation

### Recursive DFS (Most Common)

**Python:**
```python
from collections import defaultdict

def dfs_recursive(graph, start):
    """
    Basic recursive DFS traversal.
    
    Time: O(V + E) - visit each vertex and edge once
    Space: O(V) - recursion stack + visited set
    """
    visited = set()
    result = []
    
    def dfs(node):
        if node in visited:
            return
        
        visited.add(node)
        result.append(node)  # Process node
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
    
    dfs(start)
    return result


# Example
graph = {
    0: [1, 3],
    1: [0, 2, 4],
    2: [1],
    3: [0],
    4: [1]
}

print(dfs_recursive(graph, 0))  # [0, 1, 2, 4, 3]
```

### Iterative DFS (Explicit Stack)

**Python:**
```python
def dfs_iterative(graph, start):
    """
    Iterative DFS using explicit stack.
    
    Use when:
    - Risk of stack overflow (very deep graphs)
    - Need explicit control over traversal
    - Debugging (easier to trace)
    
    Time: O(V + E)
    Space: O(V)
    """
    visited = set()
    stack = [start]
    result = []
    
    while stack:
        node = stack.pop()  # LIFO - key difference from BFS
        
        if node in visited:
            continue
        
        visited.add(node)
        result.append(node)
        
        # Add neighbors in reverse order for consistent ordering
        for neighbor in reversed(graph[node]):
            if neighbor not in visited:
                stack.append(neighbor)
    
    return result


# Example
print(dfs_iterative(graph, 0))  # [0, 1, 2, 4, 3]
```

### DFS for Path Finding

**Python:**
```python
def has_path(graph, start, end):
    """
    Check if path exists from start to end.
    
    Time: O(V + E)
    Space: O(V)
    """
    if start == end:
        return True
    
    visited = set()
    
    def dfs(node):
        if node == end:
            return True
        
        visited.add(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
        
        return False
    
    return dfs(start)


def find_path(graph, start, end):
    """
    Find actual path from start to end (not necessarily shortest).
    
    Returns path as list, or empty list if no path.
    """
    if start == end:
        return [start]
    
    visited = set()
    
    def dfs(node, path):
        if node == end:
            return path
        
        visited.add(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                result = dfs(neighbor, path + [neighbor])
                if result:
                    return result
        
        return None
    
    return dfs(start, [start]) or []


# Example
print(has_path(graph, 0, 4))  # True
print(find_path(graph, 0, 4))  # [0, 1, 4]
```

### DFS for All Paths

**Python:**
```python
def find_all_paths(graph, start, end):
    """
    Find ALL paths from start to end.
    
    Note: Time can be exponential - O(2^V) paths possible
    """
    all_paths = []
    
    def dfs(node, path):
        if node == end:
            all_paths.append(path[:])  # Copy current path
            return
        
        for neighbor in graph[node]:
            if neighbor not in path:  # Avoid cycles
                path.append(neighbor)
                dfs(neighbor, path)
                path.pop()  # Backtrack
    
    dfs(start, [start])
    return all_paths


# Example with multiple paths
graph2 = {
    0: [1, 2],
    1: [3],
    2: [3],
    3: []
}
print(find_all_paths(graph2, 0, 3))  # [[0, 1, 3], [0, 2, 3]]
```

### DFS for Connected Components

**Python:**
```python
def count_connected_components(graph, n):
    """
    Count number of connected components in undirected graph.
    
    Time: O(V + E)
    Space: O(V)
    """
    visited = set()
    count = 0
    
    def dfs(node):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
    
    for node in range(n):
        if node not in visited:
            dfs(node)
            count += 1
    
    return count


# Example: Graph with 3 components
graph3 = {
    0: [1],    # Component 1
    1: [0],
    2: [3],    # Component 2
    3: [2],
    4: []      # Component 3 (isolated)
}
print(count_connected_components(graph3, 5))  # 3
```

**JavaScript:**
```javascript
// Recursive DFS
function dfsRecursive(graph, start) {
    const visited = new Set();
    const result = [];
    
    function dfs(node) {
        if (visited.has(node)) return;
        
        visited.add(node);
        result.push(node);
        
        for (const neighbor of graph.get(node) || []) {
            dfs(neighbor);
        }
    }
    
    dfs(start);
    return result;
}

// Iterative DFS
function dfsIterative(graph, start) {
    const visited = new Set();
    const stack = [start];
    const result = [];
    
    while (stack.length > 0) {
        const node = stack.pop();
        
        if (visited.has(node)) continue;
        
        visited.add(node);
        result.push(node);
        
        const neighbors = graph.get(node) || [];
        for (let i = neighbors.length - 1; i >= 0; i--) {
            if (!visited.has(neighbors[i])) {
                stack.push(neighbors[i]);
            }
        }
    }
    
    return result;
}

// Has Path
function hasPath(graph, start, end) {
    if (start === end) return true;
    
    const visited = new Set();
    
    function dfs(node) {
        if (node === end) return true;
        
        visited.add(node);
        
        for (const neighbor of graph.get(node) || []) {
            if (!visited.has(neighbor) && dfs(neighbor)) {
                return true;
            }
        }
        
        return false;
    }
    
    return dfs(start);
}

// Connected Components
function countComponents(graph, n) {
    const visited = new Set();
    let count = 0;
    
    function dfs(node) {
        visited.add(node);
        for (const neighbor of graph.get(node) || []) {
            if (!visited.has(neighbor)) {
                dfs(neighbor);
            }
        }
    }
    
    for (let i = 0; i < n; i++) {
        if (!visited.has(i)) {
            dfs(i);
            count++;
        }
    }
    
    return count;
}
```

---

## âš¡ Complexity Analysis

| Aspect | Complexity | Notes |
|--------|------------|-------|
| **Time** | O(V + E) | Visit each vertex, traverse each edge |
| **Space (Recursive)** | O(V) | Call stack depth |
| **Space (Iterative)** | O(V) | Explicit stack |

### Why O(V + E)?

```
For each vertex v:
  - Mark visited: O(1)
  - Process: O(1)
  - Iterate neighbors: O(degree(v))

Sum of all degrees = 2E (undirected) or E (directed)

Total = O(V) + O(E) = O(V + E)
```

### Space Breakdown

```
Recursive:
  - visited set: O(V)
  - call stack: O(V) worst case (linear graph)
  - Total: O(V)

Iterative:
  - visited set: O(V)
  - explicit stack: O(V)
  - Total: O(V)

âš ï¸ Watch out: Recursive can hit stack limit!
   Python default: ~1000 calls
   Increase with: sys.setrecursionlimit(10000)
```

---

## ğŸ”„ DFS vs BFS Comparison

| Aspect | DFS | BFS |
|--------|-----|-----|
| **Data Structure** | Stack (implicit/explicit) | Queue |
| **Exploration** | Deep first, then backtrack | Level by level |
| **Path Found** | Any path | Shortest path (unweighted) |
| **Space** | O(depth) | O(width) |
| **Use Case** | Exhaustive search, cycles | Shortest path, levels |
| **Implementation** | Easier recursive | Typically iterative |

```
Graph shape matters:

Deep tree:          Wide tree:
    0                   0
    |               /||||||\
    1             1 2 3 4 5 6
    |
    2               DFS: O(1) space
    |               BFS: O(6) space
    3
    
DFS: O(4) space
BFS: O(1) space
```

---

## ğŸ”„ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| Pre-order | Process before recursing | Standard DFS |
| Post-order | Process after recursing | Topological sort |
| Iterative deepening | BFS-like space, DFS approach | Memory-limited search |
| Bidirectional DFS | From both ends | Finding connection |

---

## âš ï¸ Common Mistakes

### 1. Stack Overflow on Deep Graphs

```python
# âŒ Wrong: May overflow on large graphs
def dfs(node):
    for neighbor in graph[node]:
        dfs(neighbor)  # Recurses 10000+ times â†’ StackOverflow

# âœ… Correct: Use iterative or increase limit
import sys
sys.setrecursionlimit(10000)

# Or use iterative DFS
def dfs_safe(start):
    stack = [start]
    while stack:
        node = stack.pop()
        # ...
```

### 2. Modifying Visited During Recursion (for backtracking)

```python
# âŒ Wrong: Doesn't allow revisiting for different paths
visited.add(node)
for neighbor in graph[node]:
    dfs(neighbor)
# Never removes from visited - can't find all paths

# âœ… Correct: Remove after recursion for all-paths problems
visited.add(node)
for neighbor in graph[node]:
    dfs(neighbor)
visited.remove(node)  # Backtrack
```

### 3. Forgetting to Handle Disconnected Graphs

```python
# âŒ Wrong: Only explores one component
def traverse(graph):
    dfs(0)  # Misses nodes not connected to 0

# âœ… Correct: Start DFS from each unvisited node
def traverse(graph, n):
    visited = set()
    for node in range(n):
        if node not in visited:
            dfs(node, visited)
```

### 4. Using Wrong Order for Stack

```python
# âš ï¸ Note: Order of adding to stack affects traversal order
stack.append(neighbor)  # Last added = first processed

# To match recursive order exactly:
for neighbor in reversed(graph[node]):
    stack.append(neighbor)
```

---

## ğŸ“ Practice Problems (Progressive)

### Easy (Learn the pattern)
| Problem | Focus | Link |
|---------|-------|------|
| Find if Path Exists | Basic DFS | [LC 1971](https://leetcode.com/problems/find-if-path-exists-in-graph/) |
| Number of Connected Components | DFS for components | [LC 323](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/) |
| Flood Fill | Grid DFS | [LC 733](https://leetcode.com/problems/flood-fill/) |

### Medium (Apply variations)
| Problem | Focus | Link |
|---------|-------|------|
| Number of Islands | Count components | [LC 200](https://leetcode.com/problems/number-of-islands/) |
| Clone Graph | DFS with copying | [LC 133](https://leetcode.com/problems/clone-graph/) |
| All Paths From Source to Target | Find all paths | [LC 797](https://leetcode.com/problems/all-paths-from-source-to-target/) |
| Course Schedule | Cycle detection | [LC 207](https://leetcode.com/problems/course-schedule/) |

### Hard (Master edge cases)
| Problem | Focus | Link |
|---------|-------|------|
| Critical Connections | Find bridges (Tarjan) | [LC 1192](https://leetcode.com/problems/critical-connections-in-a-network/) |
| Longest Increasing Path in Matrix | DFS with memoization | [LC 329](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/) |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement recursive and iterative DFS, solve Flood Fill
**Day 3:** Implement path finding and all paths
**Day 7:** Solve Number of Islands, Clone Graph
**Day 14:** Solve Course Schedule (cycle detection)
**Day 30:** Review advanced applications (Tarjan, bridges)

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate DFS in Interviews</strong></summary>

**Opening statement when identifying DFS:**
> "This problem asks to explore all connected nodes / find any path / detect cycles. I'll use DFS because it naturally explores one path completely before backtracking."

**Explaining the approach:**
> "I'll start at the source, mark it visited, and recursively explore each unvisited neighbor. When all neighbors are visited, I backtrack."

**Complexity discussion:**
> "Time is O(V + E) since each vertex and edge is processed once. Space is O(V) for the recursion stack and visited set."

**Common follow-ups:**

Q: "Why not BFS?"
> "BFS works too, but DFS is more natural here since I don't need shortest path. It's also simpler to implement recursively."

Q: "What about stack overflow?"
> "For very deep graphs, I'd use iterative DFS with an explicit stack, or increase recursion limit."

Q: "Can you detect a cycle?"
> "Yes, by tracking three states: unvisited, visiting (in current path), visited (done). A back edge to a 'visiting' node indicates a cycle."

</details>

**Company Focus:**
| Company | DFS Frequency | Focus Areas |
|---------|---------------|-------------|
| Meta | â­â­â­â­â­ | Islands, Clone Graph |
| Amazon | â­â­â­â­â­ | Connected components |
| Google | â­â­â­â­ | Cycle detection, topological |
| Microsoft | â­â­â­â­ | Grid problems |

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn concept | 30-45 min | Understand recursion vs iteration |
| Basic implementation | 15-20 min | Template memorization |
| Solve Easy problem | 10-15 min | Direct application |
| Solve Medium problem | 20-30 min | Add path tracking |
| **Master DFS pattern** | **3-5 hours** | 5-7 problems |

---

> **ğŸ’¡ Key Insight:** DFS is like exploring a maze by following one path until you hit a dead end, then backtracking to try the next path. It's exhaustive - guaranteed to explore everything reachable, but not guaranteed to find the shortest route.

> **ğŸ”— Related:** [DFS Template](./4.2-DFS-Template.md) | [DFS Applications](./4.3-DFS-Applications.md) | [BFS Fundamentals](../03-BFS-Pattern/3.1-BFS-Fundamentals.md) | [Topological Sort](../06-Topological-Sort/6.1-Topological-Basics.md)

---

**Previous:** [â† Word Ladder](../03-BFS-Pattern/3.4-BFS-Practice/02-Word-Ladder-LC127.md)  
**Next:** [4.2 DFS Template â†’](./4.2-DFS-Template.md)
