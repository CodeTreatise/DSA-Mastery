# 8.3 Bellman-Ford Algorithm

> **Handle negative edges and detect negative cycles**
>
> â±ï¸ **Study Time:** 30 min | ğŸ“Š **Priority:** Medium | ğŸ¯ **Pattern:** Dynamic Programming on Edges

---

## Overview

**Bellman-Ford** finds shortest paths from a single source, handling **negative edge weights** (unlike Dijkstra). It also **detects negative cycles**.

**Core Idea:**
- Relax all edges V-1 times
- After V-1 iterations, all shortest paths are found (if no negative cycle)
- One more iteration detects if a negative cycle exists

```
Why V-1 iterations?
A shortest path visits at most V-1 edges.
Each iteration "fixes" at least one more edge in the path.
After V-1 iterations, all paths are optimal.
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>How to Identify Bellman-Ford Problems</strong></summary>

**Look for these signals:**
- Shortest path with **negative weights**
- "Detect if negative cycle exists"
- Currency exchange arbitrage
- Path that can be improved indefinitely

**Keywords in problem statement:**
- "profit/loss", "exchange rates"
- "detect cycle", "arbitrage"
- "minimum cost" with possible negative values

**Choose Bellman-Ford over Dijkstra when:**
- Edge weights can be negative
- Need to detect negative cycles
- Graph may have arbitrage opportunities

</details>

---

## âœ… When to Use

- Graph has **negative edge weights**
- Need to detect negative cycles
- Currency/price arbitrage problems
- Simpler than Dijkstra (no heap needed)

## âŒ When NOT to Use

| Scenario | Better Choice | Why |
|----------|--------------|-----|
| Non-negative weights | Dijkstra | O(E log V) vs O(V Ã— E) |
| All pairs needed | Floyd-Warshall | More efficient |
| Very sparse graph | Dijkstra | Much faster |
| Need only BFS distance | BFS | O(V + E) |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Dijkstra's Algorithm](./8.2-Dijkstra.md)
- [Graph Representation](../02-Graph-Representation/2.1-Adjacency-List.md)
- Dynamic Programming concepts

**After mastering this:**
- [Floyd-Warshall](./8.4-Floyd-Warshall.md)
- SPFA (Queue-based optimization)
- Johnson's Algorithm (all-pairs with negative)

**Combines with:**
- Arbitrage detection (multiply instead of add)
- K-edge paths (stop after K iterations)
- Cycle detection

</details>

---

## ğŸ“ How It Works

### Why Negative Weights Break Dijkstra

```
Graph:     5        -4
       0 â”€â”€â”€â†’ 1 â”€â”€â”€â†’ 2
       â”‚             â†‘
       â””â”€â”€â”€â”€â”€â”€2â”€â”€â”€â”€â”€â”€â”˜

Edges: 0â†’1 (weight 5), 1â†’2 (weight -4), 0â†’2 (weight 2)

Dijkstra (greedy - always pick smallest distance):
1. Start: dist = [0, âˆ, âˆ]
2. Pop 0 (dist=0): Update dist[1]=5, dist[2]=2
   Heap: [(2, node2), (5, node1)]
3. Pop 2 (dist=2): Node 2 "finalized" with dist=2
   But wait... we haven't explored 0â†’1â†’2 yet!
4. Pop 1 (dist=5): Try to update 2: 5+(-4)=1 < 2
   But node 2 is already "done"! Dijkstra ignores this.

Dijkstra's answer: dist[2] = 2 âŒ
Correct answer:    dist[2] = 1 âœ“ (via path 0â†’1â†’2)

The problem: Dijkstra assumes once a node is popped,
its distance is final. Negative edges violate this!
```

### Bellman-Ford Solution

```
Edge list: [(0,1,5), (0,2,2), (1,2,-4)]
Initial:   dist = [0, âˆ, âˆ]

Iteration 1 (relax all edges):
  Edge (0,1,5): dist[1] = min(âˆ, 0+5) = 5
  Edge (0,2,2): dist[2] = min(âˆ, 0+2) = 2
  Edge (1,2,-4): dist[2] = min(2, 5+(-4)) = 1 âœ“

Iteration 2 (relax all edges):
  Edge (0,1,5): dist[1] = min(5, 0+5) = 5 (no change)
  Edge (0,2,2): dist[2] = min(1, 0+2) = 1 (no change)
  Edge (1,2,-4): dist[2] = min(1, 5+(-4)) = 1 (no change)

No changes â†’ converged!
Final: dist = [0, 5, 1]
```

### Detecting Negative Cycles

```
If after V-1 iterations, we can STILL improve a distance,
there must be a negative cycle!

Graph with negative cycle:
0 â†’(1)â†’ 1
â†‘       â†“
â””â”€â”€(-3)â”€â”˜

After V-1 iterations:
  One more pass: 1 â†’(-3)â†’ 0 still improves!
  This means infinite improvement â†’ negative cycle
```

---

## ğŸ’» Code Implementation

**Python:**
```python
from typing import List, Tuple

def bellman_ford(
    n: int, 
    edges: List[Tuple[int, int, int]], 
    source: int
) -> Tuple[List[float], bool]:
    """
    Bellman-Ford shortest path algorithm.
    
    Args:
        n: Number of nodes (0 to n-1)
        edges: List of (u, v, weight) tuples
        source: Starting node
    
    Returns:
        (distances, has_negative_cycle)
    
    Time: O(V Ã— E)
    Space: O(V)
    """
    dist = [float('inf')] * n
    dist[source] = 0
    
    # Relax all edges V-1 times
    for i in range(n - 1):
        updated = False
        for u, v, weight in edges:
            if dist[u] != float('inf') and dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                updated = True
        
        # Early termination: no updates means we're done
        if not updated:
            break
    
    # Check for negative cycle
    for u, v, weight in edges:
        if dist[u] != float('inf') and dist[u] + weight < dist[v]:
            return dist, True  # Negative cycle detected!
    
    return dist, False


def bellman_ford_with_path(
    n: int, 
    edges: List[Tuple[int, int, int]], 
    source: int, 
    dest: int
) -> Tuple[int, List[int]]:
    """
    Bellman-Ford with path reconstruction.
    """
    dist = [float('inf')] * n
    dist[source] = 0
    parent = [-1] * n
    
    for _ in range(n - 1):
        for u, v, weight in edges:
            if dist[u] != float('inf') and dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                parent[v] = u
    
    # Reconstruct path
    if dist[dest] == float('inf'):
        return -1, []
    
    path = []
    current = dest
    while current != -1:
        path.append(current)
        current = parent[current]
    
    return dist[dest], path[::-1]


# Example usage
edges = [(0, 1, 5), (0, 2, 2), (1, 2, -4)]
dist, has_cycle = bellman_ford(3, edges, 0)
print(f"Distances: {dist}")  # [0, 5, 1]
print(f"Has negative cycle: {has_cycle}")  # False
```

**JavaScript:**
```javascript
function bellmanFord(n, edges, source) {
    const dist = new Array(n).fill(Infinity);
    dist[source] = 0;
    
    // Relax all edges V-1 times
    for (let i = 0; i < n - 1; i++) {
        let updated = false;
        for (const [u, v, weight] of edges) {
            if (dist[u] !== Infinity && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                updated = true;
            }
        }
        if (!updated) break;
    }
    
    // Check for negative cycle
    for (const [u, v, weight] of edges) {
        if (dist[u] !== Infinity && dist[u] + weight < dist[v]) {
            return { dist, hasNegativeCycle: true };
        }
    }
    
    return { dist, hasNegativeCycle: false };
}

// K-edges variant (for "Cheapest Flights Within K Stops")
function bellmanFordKEdges(n, edges, source, dest, k) {
    let dist = new Array(n).fill(Infinity);
    dist[source] = 0;
    
    // Only k+1 iterations (k edges = k+1 nodes)
    for (let i = 0; i <= k; i++) {
        const newDist = [...dist]; // Copy to avoid using updates from same iteration
        for (const [u, v, weight] of edges) {
            if (dist[u] !== Infinity && dist[u] + weight < newDist[v]) {
                newDist[v] = dist[u] + weight;
            }
        }
        dist = newDist;
    }
    
    return dist[dest] === Infinity ? -1 : dist[dest];
}
```

---

## âš¡ Complexity Analysis

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Standard | O(V Ã— E) | O(V) | V-1 passes over E edges |
| Sparse (E â‰ˆ V) | O(VÂ²) | O(V) | Reasonable |
| Dense (E â‰ˆ VÂ²) | O(VÂ³) | O(V) | Consider Floyd-Warshall |
| With early termination | O(V Ã— E) worst | O(V) | Often faster in practice |

**Why O(V Ã— E):**
- Outer loop: V-1 iterations
- Inner loop: E edges to relax
- Total: (V-1) Ã— E â‰ˆ V Ã— E

**Comparison with Dijkstra:**
| Aspect | Dijkstra | Bellman-Ford |
|--------|----------|--------------|
| Time | O(E log V) | O(V Ã— E) |
| Negative weights | âŒ | âœ… |
| Negative cycles | âŒ | âœ… |
| Implementation | Needs heap | Simple loops |

---

## ğŸ”„ Variations

### 1. Cheapest Flights Within K Stops (LC 787)

Limit to at most K edges - stop after K+1 iterations:

```python
def findCheapestPrice(n, flights, src, dst, k):
    """
    Bellman-Ford limited to k+1 iterations.
    Key: Use copy of distances to avoid "cascading" within same iteration.
    """
    dist = [float('inf')] * n
    dist[src] = 0
    
    for _ in range(k + 1):  # At most k+1 edges
        new_dist = dist.copy()  # IMPORTANT: copy!
        for u, v, price in flights:
            if dist[u] != float('inf'):
                new_dist[v] = min(new_dist[v], dist[u] + price)
        dist = new_dist
    
    return dist[dst] if dist[dst] != float('inf') else -1
```

### 2. Currency Arbitrage Detection

Multiply instead of add, check for ratio > 1:

```python
def detectArbitrage(rates, currencies):
    """
    rates[i][j] = exchange rate from currency i to j
    Arbitrage exists if we can profit by cycling back.
    
    Convert to: -log(rate) for each edge
    Negative cycle in this graph = arbitrage!
    """
    import math
    
    n = len(currencies)
    edges = []
    
    # Convert rates to negative logs
    for i in range(n):
        for j in range(n):
            if rates[i][j] > 0:
                edges.append((i, j, -math.log(rates[i][j])))
    
    # Run Bellman-Ford from any node
    dist = [float('inf')] * n
    dist[0] = 0
    
    for _ in range(n - 1):
        for u, v, w in edges:
            if dist[u] != float('inf') and dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
    
    # Check for negative cycle
    for u, v, w in edges:
        if dist[u] != float('inf') and dist[u] + w < dist[v]:
            return True  # Arbitrage exists!
    
    return False
```

### 3. SPFA (Shortest Path Faster Algorithm)

Queue-based optimization - often faster in practice:

```python
from collections import deque

def spfa(n, graph, source):
    """
    SPFA: Queue-based Bellman-Ford optimization.
    Only relax from nodes that were updated.
    
    Average: O(E), Worst: O(V Ã— E)
    """
    dist = [float('inf')] * n
    dist[source] = 0
    in_queue = [False] * n
    count = [0] * n  # For negative cycle detection
    
    queue = deque([source])
    in_queue[source] = True
    
    while queue:
        u = queue.popleft()
        in_queue[u] = False
        
        for v, weight in graph[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                
                if not in_queue[v]:
                    queue.append(v)
                    in_queue[v] = True
                    count[v] += 1
                    
                    # If a node is added more than V times, negative cycle exists
                    if count[v] >= n:
                        return None  # Negative cycle!
    
    return dist
```

---

## âš ï¸ Common Mistakes

### 1. Not Using Distance Copy for K Stops

```python
# âŒ WRONG: Cascading updates in same iteration
for u, v, w in edges:
    dist[v] = min(dist[v], dist[u] + w)
# Problem: An update to dist[u] affects dist[v] in same iteration!

# âœ… CORRECT: Use copy of previous distances
new_dist = dist.copy()
for u, v, w in edges:
    if dist[u] != float('inf'):
        new_dist[v] = min(new_dist[v], dist[u] + w)
dist = new_dist
```

### 2. Checking Source Distance

```python
# âŒ WRONG: Relax even when source distance is infinity
if dist[u] + weight < dist[v]:
    dist[v] = dist[u] + weight  # inf + x is still inf!

# âœ… CORRECT: Check if source is reachable
if dist[u] != float('inf') and dist[u] + weight < dist[v]:
    dist[v] = dist[u] + weight
```

### 3. Confusing Iterations with Edges

```python
# âŒ WRONG: n iterations (should be n-1)
for _ in range(n):  # One too many for shortest path

# âœ… CORRECT: n-1 for shortest path, n-th for cycle detection
for _ in range(n - 1):  # Find shortest paths
    relax_all_edges()

# Optional: One more for cycle detection
if can_still_relax():
    has_negative_cycle = True
```

---

## ğŸ“ Practice Problems (Progressive)

### Easy (Basic implementation)
- [ ] [Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/) - K-limited BF

### Medium (Apply variations)
- [ ] [Network Delay Time](https://leetcode.com/problems/network-delay-time/) - Use BF instead of Dijkstra
- [ ] [Find the City](https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/) - Multiple sources

### Hard (Negative cycles)
- [ ] Currency Arbitrage (no LC, classic interview) - Detect cycle via logs
- [ ] [Shortest Path Visiting All Nodes](https://leetcode.com/problems/shortest-path-visiting-all-nodes/) - BFS/DP alternative

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

| Day | Activity |
|-----|----------|
| 1 | Implement basic Bellman-Ford |
| 3 | Solve K Stops problem |
| 7 | Explain why V-1 iterations are enough |
| 14 | Implement SPFA optimization |
| 30 | Solve arbitrage problem |

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**When to mention Bellman-Ford:**
> "Since the weights can be negative, I can't use Dijkstra. I'll use Bellman-Ford which handles negative weights by relaxing all edges V-1 times."

**Explain the V-1:**
> "A shortest path has at most V-1 edges. Each iteration guarantees we find paths with one more edge. After V-1 iterations, all shortest paths are found."

**Negative cycle detection:**
> "If we can still improve a distance after V-1 iterations, there's a negative cycle - we could keep going around forever and reduce the cost."

</details>

**Company Focus:**
| Company | Frequency | Notes |
|---------|-----------|-------|
| **Google** | Medium | Complex path problems |
| **Meta** | Low | Prefer Dijkstra |
| **Amazon** | Medium | K Stops variant |
| **Trading Firms** | High | Arbitrage detection |

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn algorithm | 25 min | After Dijkstra |
| Implement from scratch | 10 min | Simpler than Dijkstra |
| K Stops variant | 20 min | Key trick: copy distances |
| Arbitrage problem | 30 min | Log transformation |

---

> **ğŸ’¡ Key Insight:** Bellman-Ford is essentially **dynamic programming on edges**. Each iteration allows paths to use one more edge. V-1 iterations cover all possible path lengths.

---

> **ğŸ”— Related:** [Dijkstra](./8.2-Dijkstra.md) | [Floyd-Warshall](./8.4-Floyd-Warshall.md) | [Cycle Detection](../09-Cycle-Detection/9.1-Undirected-Cycles.md)

---

**Back:** [â† Dijkstra](./8.2-Dijkstra.md) | **Next:** [Floyd-Warshall â†’](./8.4-Floyd-Warshall.md)
