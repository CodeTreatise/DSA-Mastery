# 1.2 Recursion Patterns

> **Common Patterns in Recursive Problem Solving**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - Recognize patterns ‚Üí faster solutions  
> **Prerequisites:** [1.1 Recursion Basics](./1.1-Recursion-Basics.md)

---

## Overview

Recursive problems follow common patterns. Recognizing these patterns allows you to quickly identify the solution approach and avoid reinventing the wheel.

The five main recursion patterns are:
1. **Linear Recursion** - Process one element, recurse on rest
2. **Binary Recursion** - Divide into two parts
3. **Tree Recursion** - Multiple recursive calls per step
4. **Tail Recursion** - Recursive call is the last operation
5. **Mutual Recursion** - Functions call each other

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Each Pattern</strong></summary>

| Pattern | Structure | Common Problems |
|---------|-----------|-----------------|
| **Linear** | One recursive call | Array sum, factorial, linked list |
| **Binary** | Two recursive calls | Trees, merge sort, Fibonacci |
| **Tree/Multiple** | 2+ calls in loop | N-ary trees, backtracking |
| **Tail** | Call is last operation | Optimizable to iteration |
| **Mutual** | A calls B, B calls A | Even/odd, complex state machines |

</details>

---

## ‚úÖ When to Use Each Pattern

- **Linear:** Simple list/array processing
- **Binary:** Tree structures, divide-and-conquer
- **Tree:** N-ary trees, generating all combinations
- **Tail:** When you need to optimize for space
- **Mutual:** Alternating states/conditions

---

## ‚ùå When NOT to Use

| Situation | Pattern to Avoid | Use Instead |
|-----------|-----------------|-------------|
| Simple iteration | Any recursion | for/while loop |
| Deep recursion | Non-tail | Tail or iteration |
| Overlapping subproblems | Binary without memo | Add memoization |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Recursion Basics](./1.1-Recursion-Basics.md) - Core concepts

**After mastering this:**
- [Thinking Recursively](./1.3-Thinking-Process.md) - Mental model
- [Divide and Conquer](../03-Divide-Conquer/3.1-DC-Basics.md) - Advanced application
- [Backtracking](../02-Backtracking/2.2-Backtracking-Template.md) - Tree recursion pattern

</details>

---

## üìê Pattern 1: Linear Recursion

**Structure:** Process one element, make one recursive call.

```
f([a, b, c, d])
    ‚îî‚îÄ‚îÄ f([b, c, d])
            ‚îî‚îÄ‚îÄ f([c, d])
                    ‚îî‚îÄ‚îÄ f([d])
                            ‚îî‚îÄ‚îÄ f([]) ‚Üí base case
```

### üíª Code

```python
def array_sum(arr: list[int], index: int = 0) -> int:
    """
    Linear recursion: Sum array elements.
    
    Time: O(n), Space: O(n) stack
    """
    if index == len(arr):
        return 0
    return arr[index] + array_sum(arr, index + 1)


def reverse_list(arr: list, index: int = 0) -> list:
    """Linear recursion: Reverse a list."""
    if index == len(arr):
        return []
    return reverse_list(arr, index + 1) + [arr[index]]


def linked_list_length(head) -> int:
    """Linear recursion on linked list."""
    if head is None:
        return 0
    return 1 + linked_list_length(head.next)
```

```javascript
function arraySum(arr, index = 0) {
    if (index === arr.length) return 0;
    return arr[index] + arraySum(arr, index + 1);
}

function reverseList(arr, index = 0) {
    if (index === arr.length) return [];
    return [...reverseList(arr, index + 1), arr[index]];
}

function linkedListLength(head) {
    if (head === null) return 0;
    return 1 + linkedListLength(head.next);
}
```

---

## üìê Pattern 2: Binary Recursion

**Structure:** Make two recursive calls, combine results.

```
f([a, b, c, d])
     /          \
f([a, b])      f([c, d])
  /    \        /    \
f([a]) f([b]) f([c]) f([d])
```

### üíª Code

```python
def merge_sort(arr: list) -> list:
    """
    Binary recursion: Divide-and-conquer sorting.
    
    Time: O(n log n), Space: O(n)
    """
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])    # First recursive call
    right = merge_sort(arr[mid:])   # Second recursive call
    
    return merge(left, right)

def merge(left: list, right: list) -> list:
    """Merge two sorted arrays."""
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result


def binary_search(arr: list, target: int, lo: int = 0, hi: int = None) -> int:
    """Binary recursion: Search in sorted array."""
    if hi is None:
        hi = len(arr) - 1
    
    if lo > hi:
        return -1
    
    mid = (lo + hi) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search(arr, target, mid + 1, hi)
    else:
        return binary_search(arr, target, lo, mid - 1)
```

```javascript
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result.push(left[i++]);
        } else {
            result.push(right[j++]);
        }
    }
    
    return [...result, ...left.slice(i), ...right.slice(j)];
}

function binarySearch(arr, target, lo = 0, hi = arr.length - 1) {
    if (lo > hi) return -1;
    
    const mid = Math.floor((lo + hi) / 2);
    
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) return binarySearch(arr, target, mid + 1, hi);
    return binarySearch(arr, target, lo, mid - 1);
}
```

### Tree Traversal Example

```python
def tree_height(root) -> int:
    """Binary recursion on tree."""
    if root is None:
        return 0
    
    left_height = tree_height(root.left)    # Binary call 1
    right_height = tree_height(root.right)  # Binary call 2
    
    return 1 + max(left_height, right_height)
```

---

## üìê Pattern 3: Tree/Multiple Recursion

**Structure:** Make multiple (often variable) recursive calls.

```
generate_subsets([1, 2, 3])
            /            \
   include 1           exclude 1
        |                   |
    [1] + f([2,3])      [] + f([2,3])
       /     \            /      \
    [1,2]   [1]        [2]      []
     ...    ...        ...      ...
```

### üíª Code

```python
def generate_subsets(nums: list[int]) -> list[list[int]]:
    """
    Tree recursion: Generate all subsets.
    
    Time: O(2^n * n), Space: O(n)
    """
    result = []
    
    def backtrack(index: int, current: list):
        if index == len(nums):
            result.append(current[:])
            return
        
        # Include current element
        current.append(nums[index])
        backtrack(index + 1, current)
        current.pop()
        
        # Exclude current element
        backtrack(index + 1, current)
    
    backtrack(0, [])
    return result


def nary_tree_traversal(root, visit):
    """Multiple recursion: N-ary tree."""
    if root is None:
        return
    
    visit(root.val)
    
    for child in root.children:
        nary_tree_traversal(child, visit)
```

```javascript
function generateSubsets(nums) {
    const result = [];
    
    function backtrack(index, current) {
        if (index === nums.length) {
            result.push([...current]);
            return;
        }
        
        // Include
        current.push(nums[index]);
        backtrack(index + 1, current);
        current.pop();
        
        // Exclude
        backtrack(index + 1, current);
    }
    
    backtrack(0, []);
    return result;
}

function naryTreeTraversal(root, visit) {
    if (!root) return;
    visit(root.val);
    for (const child of root.children) {
        naryTreeTraversal(child, visit);
    }
}
```

---

## üìê Pattern 4: Tail Recursion

**Structure:** Recursive call is the **last** operation (no work after it).

### üíª Code

```python
# Non-tail recursive (has work after recursive call)
def factorial_non_tail(n: int) -> int:
    if n <= 1:
        return 1
    return n * factorial_non_tail(n - 1)  # Must multiply AFTER call returns


# Tail recursive (call is last, carries result in accumulator)
def factorial_tail(n: int, acc: int = 1) -> int:
    """
    Tail recursion: Accumulator carries the result.
    
    Some languages (not Python) optimize this to O(1) space.
    """
    if n <= 1:
        return acc
    return factorial_tail(n - 1, n * acc)  # No work after this call


# Tail recursive sum
def sum_tail(arr: list[int], index: int = 0, acc: int = 0) -> int:
    if index == len(arr):
        return acc
    return sum_tail(arr, index + 1, acc + arr[index])
```

```javascript
// Tail recursive factorial
function factorialTail(n, acc = 1) {
    if (n <= 1) return acc;
    return factorialTail(n - 1, n * acc);
}

// Tail recursive sum
function sumTail(arr, index = 0, acc = 0) {
    if (index === arr.length) return acc;
    return sumTail(arr, index + 1, acc + arr[index]);
}
```

### Why Tail Recursion Matters

```
Non-tail: Each call must wait for return to complete its work
factorial(4) ‚Üí 4 * factorial(3) ‚Üí waiting...
             ‚Üí 4 * (3 * factorial(2)) ‚Üí waiting...
             ‚Üí 4 * (3 * (2 * factorial(1)))
             ‚Üí 4 * (3 * (2 * 1))  ‚Üê now unwinding
             ‚Üí 4 * (3 * 2)
             ‚Üí 4 * 6
             ‚Üí 24

Tail: Can reuse same stack frame (in optimized languages)
factorial_tail(4, 1) ‚Üí factorial_tail(3, 4)
                     ‚Üí factorial_tail(2, 12)
                     ‚Üí factorial_tail(1, 24)
                     ‚Üí 24  ‚Üê no unwinding needed
```

**Note:** Python does NOT optimize tail recursion, but languages like Scheme, Scala, and some JavaScript engines do.

---

## üìê Pattern 5: Mutual Recursion

**Structure:** Two or more functions call each other.

### üíª Code

```python
def is_even(n: int) -> bool:
    """
    Mutual recursion: Determines if n is even.
    
    is_even(4) ‚Üí is_odd(3) ‚Üí is_even(2) ‚Üí is_odd(1) ‚Üí is_even(0) ‚Üí True
    """
    if n == 0:
        return True
    return is_odd(n - 1)


def is_odd(n: int) -> bool:
    """Mutual recursion: Determines if n is odd."""
    if n == 0:
        return False
    return is_even(n - 1)


# Practical example: Expression parser
def parse_expression(tokens: list, pos: int = 0):
    """Parse expression (calls parse_term)."""
    left, pos = parse_term(tokens, pos)
    
    while pos < len(tokens) and tokens[pos] in ['+', '-']:
        op = tokens[pos]
        right, pos = parse_term(tokens, pos + 1)
        left = (op, left, right)
    
    return left, pos


def parse_term(tokens: list, pos: int = 0):
    """Parse term (may call parse_expression for parentheses)."""
    if tokens[pos] == '(':
        result, pos = parse_expression(tokens, pos + 1)
        return result, pos + 1  # Skip closing paren
    else:
        return int(tokens[pos]), pos + 1
```

```javascript
function isEven(n) {
    if (n === 0) return true;
    return isOdd(n - 1);
}

function isOdd(n) {
    if (n === 0) return false;
    return isEven(n - 1);
}
```

---

## ‚ö° Complexity Analysis

| Pattern | Typical Time | Typical Space | Example |
|---------|--------------|---------------|---------|
| Linear |" O(n) "| O(n) | Array sum |
| Binary |" O(n) or O(log n) "| O(n) or O(log n) | Tree, Binary Search |
| Tree/Multiple |" O(branches^depth) "| O(depth) |" Subsets O(2‚Åø) "|
| Tail |" O(n) "| O(1)* | Factorial with acc |
| Mutual | Varies | Varies | Parser |

*Only with tail call optimization (not in Python)

---

## üîÑ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| With accumulator | Carry result through calls | Tail recursion |
| With memoization | Cache repeated calls | DP, Fibonacci |
| With pruning | Stop early on invalid paths | Backtracking |
| With indices | Avoid array slicing | Efficiency |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Choosing Wrong Pattern

‚ùå **Wrong:** Using binary recursion for linear problem
```python
def array_sum(arr):
    if len(arr) == 0: return 0
    if len(arr) == 1: return arr[0]
    mid = len(arr) // 2
    return array_sum(arr[:mid]) + array_sum(arr[mid:])
# Unnecessary complexity for simple sum
```

‚úÖ **Correct:** Linear recursion for linear problem
```python
def array_sum(arr, i=0):
    if i == len(arr): return 0
    return arr[i] + array_sum(arr, i + 1)
```

### 2. Not Using Accumulator for Tail Recursion

‚ùå **Wrong:** Non-tail when tail is possible
```python
def sum_list(arr, i=0):
    if i == len(arr): return 0
    return arr[i] + sum_list(arr, i + 1)  # Work after call
```

‚úÖ **Correct:** Tail recursive with accumulator
```python
def sum_list(arr, i=0, acc=0):
    if i == len(arr): return acc
    return sum_list(arr, i + 1, acc + arr[i])  # Call is last
```

### 3. Forgetting Memoization for Binary Recursion with Overlap

‚ùå **Wrong:** Exponential Fibonacci
```python
def fib(n):
    if n <= 1: return n
    return fib(n-1) + fib(n-2)  # Recalculates same values
```

‚úÖ **Correct:** Memoized
```python
def fib(n, memo={}):
    if n in memo: return memo[n]
    if n <= 1: return n
    memo[n] = fib(n-1, memo) + fib(n-2, memo)
    return memo[n]
```

---

## üìù Practice Problems

### Easy (Pattern recognition)

| Problem | Pattern | LeetCode |
|---------|---------|----------|
| Reverse String | Linear | [LC 344](https://leetcode.com/problems/reverse-string/) |
| Maximum Depth of Binary Tree | Binary | [LC 104](https://leetcode.com/problems/maximum-depth-of-binary-tree/) |
| Fibonacci Number | Binary + Memo | [LC 509](https://leetcode.com/problems/fibonacci-number/) |

### Medium (Apply patterns)

| Problem | Pattern | LeetCode |
|---------|---------|----------|
| Merge Sort | Binary | - |
| Binary Search | Binary | [LC 704](https://leetcode.com/problems/binary-search/) |
| Subsets | Tree | [LC 78](https://leetcode.com/problems/subsets/) |
| Pow(x, n) | Binary | [LC 50](https://leetcode.com/problems/powx-n/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1: Identify patterns**
- Day 1-2: Linear recursion problems
- Day 3-4: Binary recursion (trees, binary search)
- Day 5-7: Tree recursion (subsets, permutations)

**Week 2: Master patterns**
- Convert between patterns
- Identify tail recursion opportunities
- Add memoization where needed

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate About Patterns</strong></summary>

**When you recognize a pattern, say it:**
> "This looks like a binary recursion pattern, similar to tree traversal. I'll have two recursive calls, one for each subtree."

**When choosing a pattern:**
> "I'm using linear recursion here since we're just processing each element once."

**When optimizing:**
> "I can convert this to tail recursion to make it more efficient."
> "I see overlapping subproblems, so I'll add memoization."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn all 5 patterns | 1-2 hours | With examples |
| Practice linear/binary | 30-45 min | 2-3 problems each |
| Practice tree recursion | 45-60 min | Subsets, permutations |
| Understand tail recursion | 20-30 min | Concept + examples |

---

## üí° Key Insight

> **Pattern recognition is the key to recursive problem solving.**
>
> When you see a new problem, ask:
> 1. Am I processing elements one at a time? ‚Üí **Linear**
> 2. Am I dividing into two parts? ‚Üí **Binary**
> 3. Am I generating all combinations? ‚Üí **Tree/Multiple**
> 4. Can the recursive call be last? ‚Üí **Tail**
> 5. Do states alternate? ‚Üí **Mutual**

---

## üîó Related

- [Recursion Basics](./1.1-Recursion-Basics.md) - Foundation
- [Thinking Recursively](./1.3-Thinking-Process.md) - Mental model
- [Divide and Conquer](../03-Divide-Conquer/3.1-DC-Basics.md) - Binary pattern application
- [Backtracking](../02-Backtracking/2.2-Backtracking-Template.md) - Tree pattern application
