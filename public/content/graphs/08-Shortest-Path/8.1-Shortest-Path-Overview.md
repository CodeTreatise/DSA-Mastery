# 8.1 Shortest Path Overview

> **Finding optimal routes in weighted graphs - the foundation of navigation, routing, and optimization**
>
> â±ï¸ **Study Time:** 45 min | ğŸ“Š **Priority:** High | ğŸ¯ **Interview:** Meta, Google, Amazon

---

## Overview

**Shortest path algorithms** find the minimum-weight path between nodes in a weighted graph. This is one of the most practical graph problems with applications in GPS navigation, network routing, and game AI.

```
Problem Types:
â”œâ”€â”€ Single Source (one start, all destinations)
â”‚   â”œâ”€â”€ Non-negative weights â†’ Dijkstra's O(E log V)
â”‚   â””â”€â”€ Negative weights â†’ Bellman-Ford O(V Ã— E)
â”œâ”€â”€ All Pairs (every node to every node)
â”‚   â””â”€â”€ Any weights â†’ Floyd-Warshall O(VÂ³)
â””â”€â”€ Unweighted (all edges weight 1)
    â””â”€â”€ Use BFS â†’ O(V + E)
```

---

## ğŸ¯ Algorithm Selection

**Decision flowchart for choosing the right algorithm:**

```
Is the graph weighted?
â”œâ”€â”€ No â†’ BFS (O(V + E))
â””â”€â”€ Yes â†“
    Are there negative weights?
    â”œâ”€â”€ No â†’ Dijkstra (O(E log V))
    â””â”€â”€ Yes â†“
        Do you need single source or all pairs?
        â”œâ”€â”€ Single source â†’ Bellman-Ford (O(V Ã— E))
        â””â”€â”€ All pairs â†’ Floyd-Warshall (O(VÂ³))
```

| Algorithm | Graph Type | Time | Space | Use When |
|-----------|-----------|------|-------|----------|
| **BFS** | Unweighted | O(V+E) | O(V) | All edges have same weight |
| **Dijkstra** | Non-negative | O(E log V) | O(V) | Typical shortest path (GPS) |
| **Bellman-Ford** | Any weights | O(V Ã— E) | O(V) | Negative edges, detect neg cycles |
| **Floyd-Warshall** | Any weights | O(VÂ³) | O(VÂ²) | All pairs, small dense graphs |

---

## âœ… When to Use Shortest Path

- Finding minimum cost/time between locations
- Network routing (packets, traffic)
- Cheapest flight with k stops
- Minimum effort paths
- Game AI pathfinding

## âŒ When NOT to Use

| Instead of... | Use... | When... |
|--------------|--------|---------|
| Shortest path | BFS | Unweighted graph |
| Dijkstra | Bellman-Ford | Negative edge weights |
| Bellman-Ford | Dijkstra | No negative weights (faster) |
| Any of these | Greedy/DP | Not actually a graph problem |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Graph Basics](../01-Graph-Fundamentals/1.1-Graph-Terminology.md)
- [BFS Pattern](../03-BFS-Traversal/3.1-BFS-Fundamentals.md)
- [Priority Queues](../../08-Heaps-Priority-Queues.md)

**After mastering this:**
- [Minimum Spanning Trees](../11-MST/11.1-MST-Introduction.md)
- [Network Flow](../12-Advanced/12.1-Advanced-Overview.md)
- A* Algorithm (heuristic search)

**Combines with:**
- Heap for Dijkstra's efficiency
- Dynamic Programming (Bellman-Ford is DP)
- BFS for unweighted shortest path

</details>

---

## ğŸ“ The Core Idea: Relaxation

All shortest path algorithms use the concept of **relaxation**:

```
Relaxation: If going through node u gives a shorter path to v, update it

if dist[u] + weight(u,v) < dist[v]:
    dist[v] = dist[u] + weight(u,v)
```

**Visualization:**
```
Current state: dist[A] = 0, dist[B] = 10, dist[C] = âˆ

     5
A â”€â”€â”€â”€â”€â”€â”€â†’ B â”€â”€â”€â”€â”€â”€â”€â†’ C
           â†“    3
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ D
                4

Relax Aâ†’B: dist[B] = min(10, 0+5) = 5  âœ“ Updated!
Relax Bâ†’C: dist[C] = min(âˆ, 5+3) = 8   âœ“ Updated!
Relax Bâ†’D: dist[D] = min(âˆ, 5+4) = 9   âœ“ Updated!
```

---

## ğŸ’» Algorithm Comparison Code

**Python - All three algorithms:**
```python
import heapq
from typing import Dict, List, Tuple
from collections import defaultdict

def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int, n: int) -> List[int]:
    """
    Shortest path with non-negative weights.
    graph[u] = [(v, weight), ...]
    
    Time: O(E log V), Space: O(V)
    """
    dist = [float('inf')] * n
    dist[start] = 0
    heap = [(0, start)]  # (distance, node)
    
    while heap:
        d, u = heapq.heappop(heap)
        if d > dist[u]:
            continue  # Already found better path
        
        for v, weight in graph[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(heap, (dist[v], v))
    
    return dist


def bellman_ford(edges: List[Tuple[int, int, int]], n: int, start: int) -> Tuple[List[int], bool]:
    """
    Shortest path with any weights, detects negative cycles.
    edges = [(u, v, weight), ...]
    
    Time: O(V Ã— E), Space: O(V)
    Returns: (distances, has_negative_cycle)
    """
    dist = [float('inf')] * n
    dist[start] = 0
    
    # Relax all edges V-1 times
    for _ in range(n - 1):
        for u, v, weight in edges:
            if dist[u] != float('inf') and dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
    
    # Check for negative cycle (one more iteration)
    for u, v, weight in edges:
        if dist[u] != float('inf') and dist[u] + weight < dist[v]:
            return dist, True  # Negative cycle exists!
    
    return dist, False


def floyd_warshall(n: int, edges: List[Tuple[int, int, int]]) -> List[List[int]]:
    """
    All-pairs shortest path.
    
    Time: O(VÂ³), Space: O(VÂ²)
    """
    INF = float('inf')
    dist = [[INF] * n for _ in range(n)]
    
    # Distance to self is 0
    for i in range(n):
        dist[i][i] = 0
    
    # Initialize with direct edges
    for u, v, weight in edges:
        dist[u][v] = min(dist[u][v], weight)
    
    # Floyd-Warshall: try each intermediate node
    for k in range(n):  # Intermediate node
        for i in range(n):  # Source
            for j in range(n):  # Destination
                if dist[i][k] != INF and dist[k][j] != INF:
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    return dist
```

**JavaScript:**
```javascript
// Dijkstra's Algorithm
function dijkstra(graph, start, n) {
    const dist = new Array(n).fill(Infinity);
    dist[start] = 0;
    const heap = [[0, start]]; // [distance, node]
    
    while (heap.length > 0) {
        heap.sort((a, b) => a[0] - b[0]); // Min-heap behavior
        const [d, u] = heap.shift();
        
        if (d > dist[u]) continue;
        
        for (const [v, weight] of (graph[u] || [])) {
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                heap.push([dist[v], v]);
            }
        }
    }
    
    return dist;
}

// Bellman-Ford Algorithm
function bellmanFord(edges, n, start) {
    const dist = new Array(n).fill(Infinity);
    dist[start] = 0;
    
    // Relax all edges V-1 times
    for (let i = 0; i < n - 1; i++) {
        for (const [u, v, weight] of edges) {
            if (dist[u] !== Infinity && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
            }
        }
    }
    
    // Check for negative cycle
    for (const [u, v, weight] of edges) {
        if (dist[u] !== Infinity && dist[u] + weight < dist[v]) {
            return { dist, hasNegativeCycle: true };
        }
    }
    
    return { dist, hasNegativeCycle: false };
}

// Floyd-Warshall Algorithm
function floydWarshall(n, edges) {
    const INF = Infinity;
    const dist = Array.from({ length: n }, () => 
        new Array(n).fill(INF)
    );
    
    for (let i = 0; i < n; i++) dist[i][i] = 0;
    
    for (const [u, v, weight] of edges) {
        dist[u][v] = Math.min(dist[u][v], weight);
    }
    
    for (let k = 0; k < n; k++) {
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (dist[i][k] !== INF && dist[k][j] !== INF) {
                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
    
    return dist;
}
```

---

## âš¡ Complexity Comparison

| Algorithm | Time | Space | Best For |
|-----------|------|-------|----------|
| **BFS** | O(V + E) | O(V) | Unweighted graphs |
| **Dijkstra** | O(E log V) | O(V) | Non-negative weights |
| **Bellman-Ford** | O(V Ã— E) | O(V) | Negative weights |
| **Floyd-Warshall** | O(VÂ³) | O(VÂ²) | All pairs, dense graphs |
| **A*** | O(E) best case | O(V) | With heuristic (games) |

**Why these complexities:**
- **BFS:** Visit each vertex and edge once
- **Dijkstra:** Each edge relaxation with heap push/pop
- **Bellman-Ford:** V-1 passes over all E edges
- **Floyd-Warshall:** Three nested loops over V vertices

---

## ğŸ”„ Variations

| Problem Variant | Algorithm Choice | Modification |
|-----------------|-----------------|--------------|
| Unweighted shortest path | BFS | Standard BFS |
| K stops maximum | Modified Dijkstra | Track stops in state |
| Minimum cost with refueling | State-space Dijkstra | (node, fuel) state |
| Shortest path in grid | Dijkstra or BFS | 4-directional movement |
| Path reconstruction | Any | Track predecessors |

---

## âš ï¸ Common Mistakes

### 1. Using Dijkstra with Negative Weights

```python
# âŒ Wrong: Dijkstra gives wrong answer with negative weights
graph = {0: [(1, 5), (2, 2)], 1: [(2, -10)], 2: []}
# Dijkstra processes 2 before 1, misses the shorter path 0â†’1â†’2

# âœ… Correct: Use Bellman-Ford for negative weights
dist, has_neg = bellman_ford(edges, n, start)
```

### 2. Not Skipping Outdated Heap Entries

```python
# âŒ Wrong: Processing outdated distances
while heap:
    d, u = heapq.heappop(heap)
    # Process even if we already found a better path

# âœ… Correct: Skip if we've found better
while heap:
    d, u = heapq.heappop(heap)
    if d > dist[u]:
        continue  # Already have better path
```

### 3. Forgetting Disconnected Components

```python
# âŒ Wrong: Assuming all nodes reachable
return dist[destination]  # Might be inf!

# âœ… Correct: Handle unreachable nodes
return dist[destination] if dist[destination] != float('inf') else -1
```

---

## ğŸ“ Practice Problems (Progressive)

### Easy (BFS variant)
- [ ] [Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/) - Grid BFS
- [ ] [Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/) - State BFS

### Medium (Dijkstra)
- [ ] [Network Delay Time](https://leetcode.com/problems/network-delay-time/) - Classic Dijkstra
- [ ] [Path with Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/) - Modified weight
- [ ] [Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/) - State with stops

### Hard (Bellman-Ford / Advanced)
- [ ] [Shortest Path with Alternating Colors](https://leetcode.com/problems/shortest-path-with-alternating-colors/) - State BFS
- [ ] [Find Shortest Path with K Edges](https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors/) - Floyd-Warshall

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

| Day | Activity |
|-----|----------|
| 1 | Implement Dijkstra from scratch |
| 3 | Implement Bellman-Ford, explain why V-1 iterations |
| 7 | Solve Network Delay Time without hints |
| 14 | Compare all three algorithms on paper |
| 30 | Solve a state-space Dijkstra problem |

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Opening statement:**
> "This is a shortest path problem in a weighted graph. Since the weights are [positive/negative], I'll use [Dijkstra/Bellman-Ford]."

**Explain the choice:**
> "Dijkstra is O(E log V) but only works with non-negative weights. Bellman-Ford is O(V Ã— E) but handles negatives."

**Red flags to avoid:**
- âŒ Using Dijkstra when weights can be negative
- âŒ Not mentioning time complexity
- âŒ Forgetting to handle unreachable nodes

</details>

**Company Focus:**
| Company | Frequency | Focus |
|---------|-----------|-------|
| **Google** | High | Complex variants, state-space |
| **Meta** | Medium | Standard Dijkstra |
| **Amazon** | High | Path optimization problems |
| **Uber/Lyft** | Very High | Real routing problems |

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn Dijkstra | 45 min | Core algorithm |
| Learn Bellman-Ford | 30 min | After Dijkstra |
| Learn Floyd-Warshall | 30 min | Different use case |
| Solve Medium problem | 25-35 min | Interview target |
| Master state-space | 2-3 hours | Multiple problems |

---

> **ğŸ’¡ Key Insight:** Shortest path is really about **relaxation** - repeatedly asking "can I do better by going through this node?" The algorithms differ only in *how* they explore nodes.

---

> **ğŸ”— Related:** [BFS Pattern](../03-BFS-Traversal/3.1-BFS-Fundamentals.md) | [Dijkstra Deep Dive](./8.2-Dijkstra.md) | [MST Algorithms](../11-MST/11.1-MST-Introduction.md)

---

**Next:** [Dijkstra's Algorithm â†’](./8.2-Dijkstra.md)
