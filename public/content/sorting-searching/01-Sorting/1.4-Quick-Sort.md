# 1.4 - Quick Sort

> **The Fast In-Place Sort**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - Most asked sorting algorithm  
> **Characteristics:** O(n log n) average, O(1) space, Not stable

---

## Overview

**Quick Sort** is a divide-and-conquer algorithm that:
1. **Picks a pivot** element
2. **Partitions** the array (elements smaller than pivot go left, larger go right)
3. **Recursively sorts** the two partitions

It's the most commonly used sorting algorithm in practice due to:
- Excellent cache performance
- In-place sorting (O(log n) space for recursion)
- Fast average case

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Quick Sort</strong></summary>

**Keywords:**
- "Sort in-place"
- "Kth largest/smallest" (Quick Select variant)
- "Partition array"
- "Sort colors" (Dutch National Flag)

**The pattern:**
```
Original: [8, 3, 7, 4, 9, 2, 6, 5]
Pivot = 5

Partition:
[3, 4, 2] [5] [8, 7, 9, 6]
   ‚Üì       ‚Üì       ‚Üì
  Sort   Done    Sort
   
Result: [2, 3, 4, 5, 6, 7, 8, 9]
```

</details>

---

## ‚úÖ When to Use

- **General-purpose sorting** - fastest in practice
- **Memory constrained** - O(1) extra space
- **Arrays with good distribution** - random data
- **Quick Select** - finding kth element in O(n) average

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Need stability | Merge Sort | Quick Sort not stable |
| Linked lists | Merge Sort | Random access needed |
| Nearly sorted data | Insertion Sort |" Quick Sort may hit O(n¬≤) "|
| Many duplicates | 3-way Quick Sort | Standard version inefficient |
|" Need guaranteed O(n log n) "| Merge/Heap Sort |" Quick Sort O(n¬≤) worst "|

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this:**
- [Recursion Basics](../../02-Recursion-Backtracking/01-Recursion/1.1-Recursion-Basics.md)
- [Two Pointers](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md)

**After mastering this:**
- [Quick Select](link) - O(n) kth element
- [3-Way Quick Sort](link) - Handle duplicates
- [Intro Sort](link) - Hybrid approach

**The partition operation is used in:**
- Kth Largest Element (LC 215)
- Sort Colors (LC 75)
- Wiggle Sort II (LC 324)

</details>

---

## üìê How It Works

### The Partition Operation

The key to Quick Sort is the **partition** function. It:
1. Chooses a pivot element
2. Rearranges so all elements < pivot are on the left
3. All elements > pivot are on the right
4. Returns the pivot's final position

**Lomuto Partition (simpler, less efficient):**
```
[8, 3, 7, 4, 9, 2, 6, 5]  pivot = 5 (last element)
 i                    p
 j

Scan j from left to right:
- If arr[j] < pivot: swap arr[i] with arr[j], increment i

[8, 3, 7, 4, 9, 2, 6, 5]  8 >= 5, no swap
 i  j

[3, 8, 7, 4, 9, 2, 6, 5]  3 < 5, swap, i++
    i  j

[3, 8, 7, 4, 9, 2, 6, 5]  7 >= 5, no swap
    i     j

[3, 4, 7, 8, 9, 2, 6, 5]  4 < 5, swap, i++
       i     j

[3, 4, 7, 8, 9, 2, 6, 5]  9 >= 5, no swap
       i        j

[3, 4, 2, 8, 9, 7, 6, 5]  2 < 5, swap, i++
          i        j

[3, 4, 2, 8, 9, 7, 6, 5]  6 >= 5, no swap
          i           j

Final: swap arr[i] with pivot
[3, 4, 2, 5, 9, 7, 6, 8]
          ‚Üë
        pivot at index 3
```

**Hoare Partition (faster, more swaps):**
```
Two pointers: left and right
Move toward each other, swapping when both find wrong elements

[8, 3, 7, 4, 9, 2, 6, 5]  pivot = 4
 L                    R

L finds >= pivot (8), R finds <= pivot (2)
Swap: [2, 3, 7, 4, 9, 8, 6, 5]
          L        R

L finds >= pivot (7), R finds <= pivot (4)
Swap: [2, 3, 4, 7, 9, 8, 6, 5]
             LR

Pointers cross, partition complete at index 2
```

---

## üíª Code Implementation

### Lomuto Partition (Standard)

**Python:**
```python
def quick_sort(arr: list[int]) -> list[int]:
    """
    Quick Sort using Lomuto partition.
    
    Time: O(n log n) average, O(n¬≤) worst
    Space: O(log n) for recursion stack
    Stable: No
    """
    def partition(low: int, high: int) -> int:
        """Lomuto partition: pivot is last element."""
        pivot = arr[high]
        i = low - 1  # Index of smaller element
        
        for j in range(low, high):
            if arr[j] < pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
        
        # Place pivot at correct position
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        return i + 1
    
    def sort(low: int, high: int) -> None:
        if low < high:
            pivot_idx = partition(low, high)
            sort(low, pivot_idx - 1)
            sort(pivot_idx + 1, high)
    
    sort(0, len(arr) - 1)
    return arr


# Example
arr = [8, 3, 7, 4, 9, 2, 6, 5]
print(quick_sort(arr))  # [2, 3, 4, 5, 6, 7, 8, 9]
```

**JavaScript:**
```javascript
function quickSort(arr) {
    function partition(low, high) {
        const pivot = arr[high];
        let i = low - 1;
        
        for (let j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }
        
        [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
        return i + 1;
    }
    
    function sort(low, high) {
        if (low < high) {
            const pivotIdx = partition(low, high);
            sort(low, pivotIdx - 1);
            sort(pivotIdx + 1, high);
        }
    }
    
    sort(0, arr.length - 1);
    return arr;
}

console.log(quickSort([8, 3, 7, 4, 9, 2, 6, 5]));
```

---

### Randomized Quick Sort (Avoid O(n¬≤))

```python
import random

def quick_sort_random(arr: list[int]) -> list[int]:
    """
    Quick Sort with random pivot selection.
    Avoids O(n¬≤) worst case for sorted/nearly sorted arrays.
    """
    def partition(low: int, high: int) -> int:
        # Random pivot selection
        rand_idx = random.randint(low, high)
        arr[rand_idx], arr[high] = arr[high], arr[rand_idx]
        
        pivot = arr[high]
        i = low - 1
        
        for j in range(low, high):
            if arr[j] < pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
        
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        return i + 1
    
    def sort(low: int, high: int) -> None:
        if low < high:
            pivot_idx = partition(low, high)
            sort(low, pivot_idx - 1)
            sort(pivot_idx + 1, high)
    
    sort(0, len(arr) - 1)
    return arr
```

---

### Hoare Partition (More Efficient)

```python
def quick_sort_hoare(arr: list[int]) -> list[int]:
    """
    Quick Sort using Hoare partition.
    More efficient (fewer swaps) but trickier to implement.
    """
    def partition(low: int, high: int) -> int:
        pivot = arr[(low + high) // 2]  # Middle element as pivot
        i, j = low - 1, high + 1
        
        while True:
            i += 1
            while arr[i] < pivot:
                i += 1
            
            j -= 1
            while arr[j] > pivot:
                j -= 1
            
            if i >= j:
                return j
            
            arr[i], arr[j] = arr[j], arr[i]
    
    def sort(low: int, high: int) -> None:
        if low < high:
            p = partition(low, high)
            sort(low, p)  # Note: includes p (Hoare partition)
            sort(p + 1, high)
    
    sort(0, len(arr) - 1)
    return arr
```

---

### 3-Way Quick Sort (Dutch National Flag)

For arrays with many duplicates:

```python
def quick_sort_3way(arr: list[int]) -> list[int]:
    """
    3-Way Quick Sort for arrays with many duplicates.
    Elements equal to pivot go to middle partition.
    
    Time: O(n) for arrays with all same elements
    """
    def sort(low: int, high: int) -> None:
        if low >= high:
            return
        
        pivot = arr[low]
        lt = low      # arr[low..lt-1] < pivot
        gt = high     # arr[gt+1..high] > pivot
        i = low + 1   # arr[lt..i-1] == pivot
        
        while i <= gt:
            if arr[i] < pivot:
                arr[lt], arr[i] = arr[i], arr[lt]
                lt += 1
                i += 1
            elif arr[i] > pivot:
                arr[i], arr[gt] = arr[gt], arr[i]
                gt -= 1
            else:
                i += 1
        
        # arr[low..lt-1] < pivot = arr[lt..gt] < arr[gt+1..high]
        sort(low, lt - 1)
        sort(gt + 1, high)
    
    sort(0, len(arr) - 1)
    return arr


# Example with duplicates
arr = [4, 9, 4, 4, 1, 9, 4, 4, 9, 4, 4, 1, 4]
print(quick_sort_3way(arr))
```

---

### Quick Select - Kth Largest (LC 215)

```python
import random

def find_kth_largest(nums: list[int], k: int) -> int:
    """
    Find the kth largest element using Quick Select.
    
    Time: O(n) average, O(n¬≤) worst
    Space: O(1)
    """
    k = len(nums) - k  # Convert to kth smallest (0-indexed)
    
    def partition(left: int, right: int) -> int:
        rand_idx = random.randint(left, right)
        nums[rand_idx], nums[right] = nums[right], nums[rand_idx]
        
        pivot = nums[right]
        i = left - 1
        
        for j in range(left, right):
            if nums[j] < pivot:
                i += 1
                nums[i], nums[j] = nums[j], nums[i]
        
        nums[i + 1], nums[right] = nums[right], nums[i + 1]
        return i + 1
    
    left, right = 0, len(nums) - 1
    
    while True:
        pivot_idx = partition(left, right)
        
        if pivot_idx == k:
            return nums[k]
        elif pivot_idx < k:
            left = pivot_idx + 1
        else:
            right = pivot_idx - 1


# Example
print(find_kth_largest([3, 2, 1, 5, 6, 4], 2))  # 5
print(find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4))  # 4
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space | When |
|------|------|-------|------|
| Best |" O(n log n) "| O(log n) | Good pivot choices |
| Average |" O(n log n) "| O(log n) | Random data |
| Worst |" O(n¬≤) "| O(n) | Already sorted + bad pivot |

**Why O(n log n) average?**
```
If pivot splits array roughly in half:
- log n levels of recursion
- O(n) work at each level (partitioning)
- Total: O(n log n)
```

**Why O(n¬≤) worst case?**
```
If pivot is always min or max:
- n levels of recursion (not log n)
- O(n) work at each level
- Total: O(n¬≤)

Example: Already sorted [1, 2, 3, 4, 5] with last element pivot
- Partition gives [1, 2, 3, 4] | 5 | []
- Then [1, 2, 3] | 4 | []
- Then [1, 2] | 3 | []
- ...
```

**Avoiding worst case:**
- Randomized pivot selection
- Median-of-three pivot
- Use IntroSort (switch to Heap Sort after log n depth)

---

## üîÑ Variations

| Variation | Description | When to Use |
|-----------|-------------|-------------|
| Lomuto Partition | Simpler, more swaps | Teaching, general use |
| Hoare Partition | Fewer swaps, trickier | Performance critical |
| Randomized | Random pivot | Avoid worst case |
| Median-of-Three | Pivot = median of first, middle, last | Better pivot selection |
| 3-Way | Dutch National Flag | Many duplicates |
| IntroSort | Switch to Heap Sort |" Guarantee O(n log n) "|
| Quick Select | Kth element only | Partial sorting |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Infinite Loop in Partition

‚ùå **Wrong:**
```python
while arr[left] <= pivot:  # Can go out of bounds
    left += 1
```

‚úÖ **Correct:**
```python
while left < high and arr[left] < pivot:
    left += 1
```

### 2. Wrong Recursion Bounds (Hoare)

‚ùå **Wrong:**
```python
p = partition(low, high)
sort(low, p - 1)  # Wrong for Hoare!
sort(p + 1, high)
```

‚úÖ **Correct:**
```python
p = partition(low, high)
sort(low, p)      # Hoare returns position differently
sort(p + 1, high)
```

### 3. Using Same Element Index Twice

‚ùå **Wrong:**
```python
def partition(low, high):
    pivot = arr[high]
    # ... partition logic ...
    return high  # Wrong! Pivot might not be at high anymore
```

‚úÖ **Correct:**
```python
def partition(low, high):
    pivot = arr[high]
    # ... partition logic ...
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1  # Actual position of pivot
```

### 4. Stack Overflow for Large Arrays

‚ùå **Wrong:**
```python
def sort(low, high):
    if low < high:
        p = partition(low, high)
        sort(low, p - 1)  # May cause deep recursion
        sort(p + 1, high)
```

‚úÖ **Better (Tail Recursion Optimization):**
```python
def sort(low, high):
    while low < high:
        p = partition(low, high)
        if p - low < high - p:
            sort(low, p - 1)
            low = p + 1  # Tail call elimination
        else:
            sort(p + 1, high)
            high = p - 1
```

---

## üìù Practice Problems

### Easy

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Sort an Array | Implement Quick Sort | [LC 912](https://leetcode.com/problems/sort-an-array/) |

### Medium

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Sort Colors | Dutch National Flag | [LC 75](https://leetcode.com/problems/sort-colors/) |
| Kth Largest Element | Quick Select | [LC 215](https://leetcode.com/problems/kth-largest-element-in-an-array/) |
| Top K Frequent Elements | Quick Select + Hash | [LC 347](https://leetcode.com/problems/top-k-frequent-elements/) |
| Wiggle Sort II | Partition application | [LC 324](https://leetcode.com/problems/wiggle-sort-ii/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement Lomuto partition Quick Sort

**Day 3:** LC 75 Sort Colors (Dutch National Flag)
- Understand 3-way partition

**Day 7:** LC 215 Kth Largest Element
- Quick Select variant

**Day 14:** Implement Hoare partition
- Compare with Lomuto

**Day 21:** Implement randomized + tail-call optimized version

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Choosing Quick Sort:**
> "I'll use Quick Sort because it's O(n log n) average case and in-place. I'll use randomized pivot to avoid O(n¬≤) worst case on sorted input."

**Explaining partition:**
> "The partition function places the pivot at its final sorted position, with smaller elements on the left and larger on the right."

**Discussing trade-offs:**
> "Quick Sort is faster than Merge Sort in practice due to cache locality, but it's not stable and has O(n¬≤) worst case. For guaranteed O(n log n), I'd use Merge Sort or Heap Sort."

**Common follow-ups:**
- "What's the worst case?" ‚Üí Already sorted with bad pivot
- "How to avoid worst case?" ‚Üí Random pivot or median-of-three
- "Is it stable?" ‚Üí No, swapping breaks relative order

**Company Focus:**

| Company | What They Ask |
|---------|---------------|
| Google | Implement Quick Sort + Quick Select |
| Amazon | LC 215 Kth Largest frequently |
| Meta | Dutch National Flag (LC 75) |
| Microsoft | Basic implementation |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand partition | 20-25 min | Key concept |
| Implement Lomuto | 15-20 min | Start here |
| LC 912 Sort Array | 15-20 min | Basic application |
| LC 75 Sort Colors | 25-30 min | 3-way partition |
| LC 215 Kth Largest | 25-35 min | Quick Select |

---

## üí° Key Insight

> **Quick Sort = Partition is everything**
>
> The partition operation is the core of Quick Sort:
> 1. Choose pivot (random for better average case)
> 2. Partition array around pivot
> 3. Recursively sort partitions
>
> **Partition is also used for:**
> - Quick Select (kth element in O(n))
> - Dutch National Flag (3-way partition)
> - Many interview problems
>
> Quick Sort is faster than Merge Sort in practice due to cache locality, but trade off is O(n¬≤) worst case and instability.

---

## üîó Related

- [Sorting Basics](./1.1-Sorting-Basics.md) - Algorithm overview
- [Merge Sort](./1.3-Merge-Sort.md) - Compare approaches
- [Two Pointers](../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md) - Partition uses this
- [Heap Sort](./1.5-Heap-Sort.md) - Another O(n log n) option
