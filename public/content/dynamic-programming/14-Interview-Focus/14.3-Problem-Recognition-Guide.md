# DP Problem Recognition Guide

> **Map problem signals to DP patterns instantly.** This guide helps you recognize which DP pattern to apply based on problem keywords, structure, and constraints.

---

## Signal â†’ Pattern Mapping

### Primary Signal Detection

| You See... | Think... | Pattern |
|------------|----------|---------|
| "minimum/maximum path" + grid | Grid traversal | **Grid DP** |
| "number of ways" + steps/stairs | Counting paths | **Fibonacci** |
| "subset with target sum" | Selection with constraint | **0/1 Knapsack** |
| "unlimited/infinite supply" | Reusable items | **Unbounded Knapsack** |
| "two strings" + "common/transform" | Sequence alignment | **LCS Family** |
| "longest increasing" | Ordered sequence | **LIS** |
| "palindrome" | Mirror property | **Palindrome DP** |
| "merge ranges/elements" | Combining parts | **Interval DP** |
| "pattern matching" with * or ? | String matching | **String DP** |
| Tree structure | Tree traversal | **Tree DP** |
| "buy/sell stock" | State transitions | **State Machine** |
| Small n (â‰¤ 20) + all subsets | Subset enumeration | **Bitmask DP** |
| "count numbers in range" | Digit constraints | **Digit DP** |

---

## Detailed Pattern Recognition

### 1. Fibonacci/Linear DP

**Keywords:**
- "climb stairs", "reach nth step"
- "number of ways"
- "decode", "count"
- "previous elements matter"

**Problem Structure:**
```
Answer(n) depends on Answer(n-1), Answer(n-2), ...
```

**Examples:**
- Climbing Stairs (1 or 2 steps)
- House Robber
- Decode Ways
- Fibonacci Number

**Confirm By:** Can you express f(n) using only f(n-1), f(n-2), etc.?

---

### 2. Grid DP

**Keywords:**
- "grid", "matrix", "2D"
- "path from top-left to bottom-right"
- "move right or down only"
- "minimum/maximum sum"

**Problem Structure:**
```
grid[m][n] â†’ dp[i][j] depends on dp[i-1][j] and/or dp[i][j-1]
```

**Examples:**
- Unique Paths
- Minimum Path Sum
- Dungeon Game
- Cherry Pickup

**Confirm By:** Is movement restricted? Do you need to visit cells?

---

### 3. 0/1 Knapsack

**Keywords:**
- "subset", "choose items"
- "each item used once"
- "capacity/weight/budget limit"
- "partition", "divide into groups"

**Problem Structure:**
```
Items + Constraint â†’ Maximize/Minimize/Check feasibility
Each item: include OR exclude (binary choice)
```

**Examples:**
- Subset Sum
- Partition Equal Subset Sum
- Target Sum (+/- signs)
- Last Stone Weight II

**Confirm By:** Is each item used at most once? Is there a capacity constraint?

---

### 4. Unbounded Knapsack

**Keywords:**
- "unlimited supply", "infinite"
- "minimum number of items"
- "coin change", "perfect squares"
- "combinations to reach target"

**Problem Structure:**
```
Items can be reused â†’ Find min/max/count to reach target
```

**Examples:**
- Coin Change (min coins)
- Coin Change II (count ways)
- Perfect Squares
- Integer Break

**Confirm By:** Can you use the same item multiple times?

---

### 5. LCS Family

**Keywords:**
- "two strings/sequences"
- "common subsequence"
- "edit distance", "transform"
- "minimum operations"

**Problem Structure:**
```
String A + String B â†’ Compare/Align/Transform
```

**Variants:**

| Variant | Signal |
|---------|--------|
| LCS | "longest common subsequence" |
| Edit Distance | "transform A to B", "minimum operations" |
| Shortest Common Supersequence | "shortest string containing both" |
| Longest Common Substring | "contiguous" + "common" |

**Confirm By:** Are you comparing/aligning two sequences?

---

### 6. LIS (Longest Increasing Subsequence)

**Keywords:**
- "longest increasing/decreasing"
- "maximum chain length"
- "envelope", "Russian dolls"
- "sorted subsequence"

**Problem Structure:**
```
Single sequence â†’ Find longest ordered subsequence
```

**Examples:**
- Longest Increasing Subsequence
- Russian Doll Envelopes
- Number of Longest Increasing Subsequence
- Increasing Triplet Subsequence

**Confirm By:** Do you need to maintain relative order while finding longest ordered sequence?

---

### 7. Palindrome DP

**Keywords:**
- "palindrome"
- "subsequence/substring"
- "minimum cuts"
- "minimum insertions/deletions"

**Problem Structure:**
```
Check if s[i..j] is palindrome: s[i] == s[j] AND s[i+1..j-1] is palindrome
```

**Examples:**
- Longest Palindromic Substring
- Longest Palindromic Subsequence
- Palindrome Partitioning II (min cuts)
- Minimum Insertions for Palindrome

**Key Insight:**
```python
# LPS = LCS(s, reverse(s))
lps_length = lcs(s, s[::-1])
```

**Confirm By:** Is "palindrome" in the problem? Or are you making something symmetric?

---

### 8. Interval DP

**Keywords:**
- "merge", "combine adjacent"
- "burst", "pop"
- "range [i, j]"
- "optimal order of operations"

**Problem Structure:**
```
Range [i, j] â†’ Split at k â†’ Combine [i, k] and [k+1, j]
Think about LAST operation, not first!
```

**Examples:**
- Burst Balloons (pop last)
- Matrix Chain Multiplication
- Minimum Cost to Merge Stones
- Stone Game variations

**Confirm By:** Are you merging/splitting ranges? Does order of operations matter?

---

### 9. String DP

**Keywords:**
- "wildcard", "pattern"
- "match string with pattern"
- "distinct subsequences"
- "interleaving"

**Problem Structure:**
```
String S + Pattern P â†’ Check match / Count ways
```

**Examples:**
- Wildcard Matching (* and ?)
- Regular Expression Matching
- Distinct Subsequences
- Interleaving String

**Confirm By:** Pattern matching with special characters? Counting string combinations?

---

### 10. Tree DP

**Keywords:**
- "tree", "binary tree"
- "path sum", "diameter"
- "rob houses" (tree structure)
- "height", "depth"

**Problem Structure:**
```
Tree node â†’ Use information from children
Return: What can be extended upward
Update Global: What completes here
```

**Examples:**
- House Robber III
- Binary Tree Maximum Path Sum
- Diameter of Binary Tree
- Longest Univalue Path

**Confirm By:** Is the input a tree? Do you need to combine info from subtrees?

---

### 11. State Machine DP

**Keywords:**
- "buy and sell stock"
- "cooldown", "fee"
- "at most k transactions"
- Multiple states with transitions

**Problem Structure:**
```
States: hold, sold, rest, etc.
Transitions: buy, sell, wait
```

**State Diagram:**
```
REST â”€â”€buyâ”€â”€> HOLD â”€â”€sellâ”€â”€> SOLD â”€â”€cooldownâ”€â”€> REST
  â†‘                                              â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€waitâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Examples:**
- Best Time to Buy and Sell Stock (I, II, III, IV)
- With Cooldown
- With Transaction Fee

**Confirm By:** Multiple states with defined transitions between them?

---

### 12. Bitmask DP

**Keywords:**
- "permutation", "arrangement"
- "visit all nodes" (small n)
- "partition into groups"
- "assign tasks to people"

**Problem Structure:**
```
n items (n â‰¤ 20) â†’ Track which items used via bitmask
State: dp[mask] or dp[mask][extra_info]
```

**Examples:**
- Traveling Salesman Problem
- Partition to K Equal Subsets
- Shortest Path Visiting All Nodes
- Number of Ways to Wear Different Hats

**Confirm By:** Small n (â‰¤ 20)? Need to track subset membership?

---

### 13. Digit DP

**Keywords:**
- "count numbers in range [L, R]"
- "digit sum", "no repeated digits"
- "divisible by k"
- "numbers satisfying property"

**Problem Structure:**
```
Build number digit by digit
Track: position, tight constraint, started, other properties
```

**Examples:**
- Count Numbers with Unique Digits
- Numbers At Most N Given Digit Set
- Count Integers in Range with Even Digit Sum
- K-th Smallest Number with Sum of Digits = Target

**Confirm By:** Range query on numbers? Digit-level constraints?

---

## Constraint-Based Selection

| Constraint | Pattern | Reason |
|------------|---------|--------|
| n â‰¤ 20 | Bitmask DP | 2^20 â‰ˆ 1 million states |
| n â‰¤ 100 | O(nÂ³) algorithms | Interval DP |
| n â‰¤ 1000 | O(nÂ²) algorithms | LCS, LIS (quadratic) |
| n â‰¤ 10^5 | O(n log n) algorithms | LIS (binary search) |
| n â‰¤ 10^6 | O(n) algorithms | Linear DP |
| Two sequences | LCS family | Sequence alignment |
| Tree structure | Tree DP | DFS-based |
| Multiple states | State Machine | Track state transitions |

---

## Problem â†’ Pattern Decision Tree

```
                         START
                           â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â–¼                         â–¼
         One Sequence              Two Sequences
              â”‚                         â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â–¼
    â–¼         â–¼         â–¼          LCS Family
  Grid    Selection   Ordering        â”‚
    â”‚         â”‚          â”‚       â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â–¼         â–¼          â–¼       â–¼         â–¼
 Grid DP  â”Œâ”€â”€â”´â”€â”€â”      LIS     Edit    Common
          â–¼     â–¼             Distance  Subseq
       Once?  Unlimited?
         â”‚       â”‚
         â–¼       â–¼
       0/1    Unbounded
     Knapsack  Knapsack


                         START
                           â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â–¼                         â–¼
         Structure                    Range
              â”‚                         â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â–¼
    â–¼                   â–¼          Interval DP
   Tree              States
    â”‚                   â”‚
    â–¼                   â–¼
 Tree DP          State Machine


                         START
                           â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â–¼                         â–¼
         Small n (â‰¤20)             Digit Query
              â”‚                         â”‚
              â–¼                         â–¼
         Bitmask DP               Digit DP
```

---

## Practice Identification

Try to identify the pattern for these problems:

| Problem | Your Answer | Pattern |
|---------|-------------|---------|
| "Minimum coins to make amount, unlimited coins" | <details><summary>Reveal</summary>Unbounded Knapsack</details> | |
| "Longest common subsequence of two strings" | <details><summary>Reveal</summary>LCS Family</details> | |
| "Maximum path sum in binary tree" | <details><summary>Reveal</summary>Tree DP</details> | |
| "Count numbers from 1 to n with no repeated digits" | <details><summary>Reveal</summary>Digit DP</details> | |
| "Minimum cost to merge all stones, k at a time" | <details><summary>Reveal</summary>Interval DP</details> | |
| "Buy and sell stock with cooldown" | <details><summary>Reveal</summary>State Machine DP</details> | |
| "Partition array into k equal sum subsets" (n â‰¤ 16) | <details><summary>Reveal</summary>Bitmask DP</details> | |
| "Longest palindromic subsequence" | <details><summary>Reveal</summary>Palindrome DP (or LCS with reverse)</details> | |

---

## Quick Reference Card

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DP PATTERN QUICK REFERENCE               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ğŸ”¢ Fibonacci: "steps", "ways", "decode"                    â”‚
â”‚  ğŸ“Š Grid: Matrix path, right/down moves                     â”‚
â”‚  ğŸ’ 0/1 Knapsack: Each item once, subset sum                â”‚
â”‚  â™¾ï¸ Unbounded: Unlimited supply, coin change                â”‚
â”‚  ğŸ”¤ LCS: Two strings, common/transform                      â”‚
â”‚  ğŸ“ˆ LIS: Longest increasing/decreasing                      â”‚
â”‚  ğŸ”„ Palindrome: Mirror symmetry                             â”‚
â”‚  ğŸ“ Interval: Merge ranges, think LAST                      â”‚
â”‚  ğŸ“ String: Pattern matching (* ? .)                        â”‚
â”‚  ğŸŒ³ Tree: Tree structure, path problems                     â”‚
â”‚  âš™ï¸ State Machine: Buy/sell, multiple states                â”‚
â”‚  ğŸ­ Bitmask: Small n â‰¤ 20, subset tracking                  â”‚
â”‚  ğŸ”¢ Digit: Range query, digit constraints                   â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Final Tips

1. **Read constraints first** - n size often determines pattern
2. **Look for keywords** - They map directly to patterns
3. **Identify the state** - What info do you need at each step?
4. **Check for overlapping subproblems** - Same computation repeated?
5. **Verify optimal substructure** - Does optimal use optimal sub-solutions?

---

> **ğŸ’¡ Key Insight:** Most DP problems fall into recognizable patterns. Learning to quickly identify the pattern is half the battle. The other half is correctly defining the state.

> **ğŸ”— Related:** [DP Interview Strategy](14.1-DP-Interview-Strategy.md) | [Common Patterns Cheatsheet](14.2-Common-Patterns-Cheatsheet.md) | [Problem-Solving Framework](../01-DP-Fundamentals/3.0-DP-Problem-Solving-Framework.md)
