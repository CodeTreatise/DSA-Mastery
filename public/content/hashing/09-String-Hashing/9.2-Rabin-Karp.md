# Rabin-Karp Algorithm

> A string searching algorithm that uses rolling hash to find pattern occurrences in O(n+m) average time.

Rabin-Karp combines the rolling hash technique with the hash-and-verify approach to efficiently find all occurrences of a pattern in text.

---

## üéØ Pattern Recognition

<details>
<summary><strong>Problem Signals</strong></summary>

**Keywords indicating Rabin-Karp:**
- "Find all occurrences of pattern"
- "String matching"
- "Multiple pattern search"
- "Substring search in large text"

**When Rabin-Karp shines:**
```
Single pattern: O(n + m) average ‚Äî competitive with KMP
Multiple patterns: O(n √ó k) ‚Äî better than running KMP k times
Plagiarism detection: Hash-based fingerprinting
```

**Problem Classification:**
```
Category: String Matching Algorithm
Technique: Rolling Hash + Verification
Time: O(n + m) average, O(n √ó m) worst
Space: O(1) or O(k) for k patterns
```

</details>

---

## ‚úÖ When to Use Rabin-Karp

- Finding single pattern in text
- **Multiple pattern search** (key advantage)
- Plagiarism/duplicate detection
- When you need simplicity over guaranteed worst-case

---

## ‚ùå When NOT to Use

| Scenario | Better Alternative | Why |
|----------|-------------------|-----|
| Need guaranteed O(n) | KMP | No worst-case risk |
| Single pattern, critical | Boyer-Moore | Faster in practice |
| Regex/wildcards | Regex engine | Rabin-Karp is exact match |
| Very short patterns | Naive | Overhead not worth it |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, understand:**
- [Rolling Hash Overview](./9.1-Rolling-Hash-Overview.md) - Core technique
- [Hash Functions](../01-Hash-Fundamentals/1.2-Hash-Functions.md) - Polynomial hash
- Modular arithmetic basics

**After mastering this:**
- [Longest Duplicate Substring (LC 1044)](https://leetcode.com/problems/longest-duplicate-substring/) - Binary search + Rabin-Karp
- [Repeated DNA Sequences (LC 187)](https://leetcode.com/problems/repeated-dna-sequences/)
- KMP Algorithm - Guaranteed linear time alternative
- Aho-Corasick - Multiple pattern matching with automaton

**Combines with:**
- Binary Search (for "longest X" substring problems)
- Sliding Window (window management)
- Double hashing (reduce false positives)

</details>

---

## ÔøΩüìê Algorithm Walkthrough

### High-Level Steps

1. **Precompute:** Hash the pattern
2. **Initialize:** Hash the first window of text
3. **Slide:** Roll the hash across text
4. **Compare:** If hash matches, verify actual characters
5. **Report:** Collect all match positions

### Visual Example

```
Text:    "abracadabra"    Pattern: "abra"
         01234567890

Step 1: Compute pattern hash
        hash("abra") = H_p

Step 2: Hash first window
        hash("abra") = H_t
        
        a b r a c a d a b r a
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        H_t = H_p ‚úì ‚Üí Verify ‚Üí Match at 0

Step 3: Roll to next window
        a b r a c a d a b r a
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        Roll: remove 'a', add 'c'
        H_t ‚â† H_p ‚Üí Skip

Step 4: Continue rolling
        a b r a c a d a b r a
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        H_t ‚â† H_p ‚Üí Skip
        
        ...continue...
        
        a b r a c a d a b r a
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        H_t = H_p ‚úì ‚Üí Verify ‚Üí Match at 7

Result: Matches at positions [0, 7]
```

### The Rolling Hash Update

```
Pattern length: m
Base: b (e.g., 26 or 256)
Remove leftmost: subtract char √ó b^(m-1)
Add rightmost: multiply by b, add new char

hash_new = (hash_old - text[i] √ó b^(m-1)) √ó b + text[i+m]
```

---

## üíª Code Implementation

### Python - Standard Rabin-Karp

```python
def rabin_karp(text: str, pattern: str) -> list[int]:
    """
    Find all occurrences of pattern in text using Rabin-Karp.
    
    Algorithm:
    1. Hash the pattern
    2. Hash first window of text
    3. Slide window, roll hash, check matches
    
    Time: O(n + m) average, O(n √ó m) worst (many collisions)
    Space: O(1) excluding output
    
    Returns list of starting indices where pattern occurs.
    """
    n, m = len(text), len(pattern)
    if m > n:
        return []
    
    # Hash parameters
    base = 256  # Works for all ASCII
    mod = 10**9 + 7
    
    # Precompute base^(m-1) for rolling
    h = pow(base, m - 1, mod)
    
    # Compute initial hashes
    pattern_hash = 0
    window_hash = 0
    
    for i in range(m):
        pattern_hash = (pattern_hash * base + ord(pattern[i])) % mod
        window_hash = (window_hash * base + ord(text[i])) % mod
    
    result = []
    
    # Slide the window
    for i in range(n - m + 1):
        # Check hash match
        if window_hash == pattern_hash:
            # Verify to handle hash collision
            if text[i:i + m] == pattern:
                result.append(i)
        
        # Roll to next window (if not at end)
        if i < n - m:
            # Remove leftmost character
            window_hash = (window_hash - ord(text[i]) * h) % mod
            # Shift left and add new character
            window_hash = (window_hash * base + ord(text[i + m])) % mod
            # Handle negative modulo
            window_hash = (window_hash + mod) % mod
    
    return result


# Example trace:
# text = "AABAACAADAABAAAB", pattern = "AABA"
#
# m = 4, base = 256, mod = 10^9 + 7
# h = 256^3 = 16777216
#
# pattern_hash = hash("AABA")
#              = 65√ó256¬≥ + 65√ó256¬≤ + 66√ó256 + 65
#              = ... (some value)
#
# i=0: window "AABA"
#      hash matches ‚Üí verify ‚Üí ‚úì Match at 0
# i=1: window "ABAA"
#      roll hash ‚Üí no match
# i=2: window "BAAC"
#      roll hash ‚Üí no match
# ...
# i=9: window "AABA"
#      roll hash ‚Üí hash matches ‚Üí verify ‚Üí ‚úì Match at 9
# i=10: window "ABAA"
#       roll hash ‚Üí no match
# ...
#
# Result: [0, 9]
```

### Python - Multiple Pattern Search

```python
def rabin_karp_multiple(text: str, patterns: list[str]) -> dict[str, list[int]]:
    """
    Find all occurrences of multiple patterns in text.
    
    This is where Rabin-Karp excels over KMP!
    - KMP: O(n √ó k) where k is number of patterns
    - Rabin-Karp: O(n √ó avg_len + total_pattern_length)
    
    Groups patterns by length for efficient processing.
    """
    result = {p: [] for p in patterns}
    
    if not text or not patterns:
        return result
    
    # Group patterns by length
    by_length = {}
    for p in patterns:
        length = len(p)
        if length not in by_length:
            by_length[length] = {}
        # Store hash ‚Üí pattern mapping
        by_length[length][p] = compute_hash(p)
    
    base = 256
    mod = 10**9 + 7
    n = len(text)
    
    # Process each pattern length group
    for m, pattern_hashes in by_length.items():
        if m > n:
            continue
        
        h = pow(base, m - 1, mod)
        
        # Compute hash of all patterns of this length
        hash_to_pattern = {}
        for p, p_hash in pattern_hashes.items():
            if p_hash not in hash_to_pattern:
                hash_to_pattern[p_hash] = []
            hash_to_pattern[p_hash].append(p)
        
        # Compute initial window hash
        window_hash = 0
        for i in range(m):
            window_hash = (window_hash * base + ord(text[i])) % mod
        
        # Slide window
        for i in range(n - m + 1):
            if window_hash in hash_to_pattern:
                # Check all patterns with this hash
                for p in hash_to_pattern[window_hash]:
                    if text[i:i + m] == p:
                        result[p].append(i)
            
            # Roll to next window
            if i < n - m:
                window_hash = (window_hash - ord(text[i]) * h) % mod
                window_hash = (window_hash * base + ord(text[i + m])) % mod
                window_hash = (window_hash + mod) % mod
    
    return result


def compute_hash(s: str, base: int = 256, mod: int = 10**9 + 7) -> int:
    h = 0
    for c in s:
        h = (h * base + ord(c)) % mod
    return h


# Example:
# text = "the quick brown fox"
# patterns = ["the", "fox", "quick"]
# Result: {"the": [0], "fox": [16], "quick": [4]}
```

### JavaScript - Rabin-Karp

```javascript
/**
 * Rabin-Karp algorithm for pattern matching.
 * @param {string} text - Text to search in
 * @param {string} pattern - Pattern to find
 * @return {number[]} - Starting indices of matches
 */
function rabinKarp(text, pattern) {
    const n = text.length;
    const m = pattern.length;
    
    if (m > n) return [];
    
    const base = 256;
    const mod = 1e9 + 7;
    
    // Compute base^(m-1) % mod
    let h = 1;
    for (let i = 0; i < m - 1; i++) {
        h = (h * base) % mod;
    }
    
    // Compute initial hashes
    let patternHash = 0;
    let windowHash = 0;
    
    for (let i = 0; i < m; i++) {
        patternHash = (patternHash * base + pattern.charCodeAt(i)) % mod;
        windowHash = (windowHash * base + text.charCodeAt(i)) % mod;
    }
    
    const result = [];
    
    // Slide window
    for (let i = 0; i <= n - m; i++) {
        // Check match
        if (windowHash === patternHash) {
            if (text.slice(i, i + m) === pattern) {
                result.push(i);
            }
        }
        
        // Roll to next window
        if (i < n - m) {
            windowHash = (windowHash - text.charCodeAt(i) * h) % mod;
            windowHash = (windowHash * base + text.charCodeAt(i + m)) % mod;
            windowHash = ((windowHash % mod) + mod) % mod;
        }
    }
    
    return result;
}

// Usage
console.log(rabinKarp("AABAACAADAABAAAB", "AABA")); // [0, 9]
console.log(rabinKarp("abracadabra", "abra")); // [0, 7]
```

### JavaScript - With Double Hash

```javascript
/**
 * Double-hash Rabin-Karp to minimize false positives.
 */
function rabinKarpDoubleHash(text, pattern) {
    const n = text.length;
    const m = pattern.length;
    
    if (m > n) return [];
    
    // Two independent hash functions
    const configs = [
        { base: 31, mod: 1e9 + 7 },
        { base: 37, mod: 1e9 + 9 }
    ];
    
    const result = [];
    
    // Compute initial values
    const patternHashes = configs.map(c => computeHash(pattern, c.base, c.mod));
    const powers = configs.map(c => {
        let p = 1;
        for (let i = 0; i < m - 1; i++) {
            p = (p * c.base) % c.mod;
        }
        return p;
    });
    
    let windowHashes = configs.map((c, idx) => {
        let h = 0;
        for (let i = 0; i < m; i++) {
            h = (h * c.base + text.charCodeAt(i)) % c.mod;
        }
        return h;
    });
    
    // Slide window
    for (let i = 0; i <= n - m; i++) {
        // Both hashes must match
        if (windowHashes[0] === patternHashes[0] && 
            windowHashes[1] === patternHashes[1]) {
            // With double hash, verification is often skipped
            result.push(i);
        }
        
        // Roll both hashes
        if (i < n - m) {
            windowHashes = windowHashes.map((h, idx) => {
                const { base, mod } = configs[idx];
                const power = powers[idx];
                
                h = (h - text.charCodeAt(i) * power) % mod;
                h = (h * base + text.charCodeAt(i + m)) % mod;
                h = ((h % mod) + mod) % mod;
                
                return h;
            });
        }
    }
    
    return result;
}

function computeHash(s, base, mod) {
    let h = 0;
    for (const c of s) {
        h = (h * base + c.charCodeAt(0)) % mod;
    }
    return h;
}
```

---

## ‚ö° Complexity Analysis

| Case | Time | When |
|------|------|------|
| Average | O(n + m) | Good hash function, few collisions |
| Best | O(n) | No matches, pattern hash unique |
| Worst | O(n √ó m) | Many hash collisions (pathological) |

**Space:** O(1) for single pattern, O(k) for k patterns

### Why Average is O(n + m)?

```
Hash computation: O(m) for pattern
Window initialization: O(m)
Rolling updates: O(1) √ó n positions = O(n)
Verification (rare): O(m) √ó expected collisions ‚âà O(m √ó n/mod) ‚âà O(1)

Total: O(m + m + n + 1) = O(n + m)
```

### Comparison with Other Algorithms

| Algorithm | Average | Worst | Space | Multiple Patterns |
|-----------|---------|-------|-------|-------------------|
| Naive | O(n √ó m) | O(n √ó m) | O(1) | O(n √ó m √ó k) |
| **Rabin-Karp** | O(n + m) | O(n √ó m) | O(1) | O(n + Œ£m) ‚úì |
| KMP | O(n + m) | O(n + m) | O(m) | O((n + m) √ó k) |
| Boyer-Moore | O(n/m) best | O(n √ó m) | O(m + œÉ) | O(n √ó k) |
| Aho-Corasick | - | O(n + Œ£m + occ) | O(Œ£m) | ‚úì (built for it) |

---

## üîÑ Variations

| Variation | Difference | Use Case |
|-----------|------------|----------|
| Single hash | Standard | Simple implementation |
| Double hash | Two hash functions | Reduced false positives |
| Multiple patterns | Hash set lookup | Plagiarism detection |
| Binary Rabin-Karp | Uses XOR | Binary data |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting Negative Modulo

```javascript
// ‚ùå WRONG: Can give negative result
windowHash = (windowHash - text.charCodeAt(i) * h) % mod;

// ‚úÖ CORRECT: Ensure positive
windowHash = (windowHash - text.charCodeAt(i) * h) % mod;
windowHash = ((windowHash % mod) + mod) % mod;
```

### 2. Not Verifying Matches

```python
# ‚ùå WRONG: Hash collision = false positive
if window_hash == pattern_hash:
    result.append(i)

# ‚úÖ CORRECT: Always verify
if window_hash == pattern_hash:
    if text[i:i+m] == pattern:  # Verify!
        result.append(i)
```

### 3. Integer Overflow (in typed languages)

```javascript
// ‚ùå RISKY: Can overflow for long patterns
let h = Math.pow(base, m - 1);  // Might exceed safe integer

// ‚úÖ CORRECT: Modular exponentiation
let h = 1;
for (let i = 0; i < m - 1; i++) {
    h = (h * base) % mod;
}
```

### 4. Wrong Loop Bounds

```python
# ‚ùå WRONG: Off by one
for i in range(n - m):  # Missing last position!
    ...

# ‚úÖ CORRECT: Include last valid window
for i in range(n - m + 1):  # +1 to include position n-m
    ...
```

### 5. Rolling After Last Window

```python
# ‚ùå WRONG: Index out of bounds
for i in range(n - m + 1):
    # Check match
    ...
    # Roll hash (fails when i = n - m)
    window_hash = roll(...)  # text[i + m] is out of bounds!

# ‚úÖ CORRECT: Only roll if not at last position
for i in range(n - m + 1):
    # Check match
    ...
    # Roll only if more windows remain
    if i < n - m:  # Guard condition
        window_hash = roll(...)
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Focus |
|---------|------------|-------|
| Implement strStr() | üü¢ Easy | Basic Rabin-Karp |
| Repeated DNA Sequences | üü° Medium | Fixed length hash |
| Find All Anagrams | üü° Medium | Character frequency hash |
| Longest Duplicate Substring | üî¥ Hard | Binary search + Rabin-Karp |

**LeetCode Links:**
- [28. Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/)
- [187. Repeated DNA Sequences](https://leetcode.com/problems/repeated-dna-sequences/)
- [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)
- [1044. Longest Duplicate Substring](https://leetcode.com/problems/longest-duplicate-substring/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement basic Rabin-Karp
- **Day 3:** Solve LC 28 (Find first occurrence)
- **Day 7:** Solve LC 187 (Repeated DNA)
- **Day 14:** Implement multiple pattern search
- **Day 30:** Solve LC 1044 (Advanced application)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Communication Template</strong></summary>

**1. State the approach:**
> "I'll use Rabin-Karp with rolling hash. The idea is to compute a hash value for the pattern and compare it with the hash of each text window."

**2. Explain rolling hash:**
> "Instead of recomputing the hash for each position, I 'roll' it by removing the old character's contribution and adding the new character's. This keeps each update O(1)."

**3. Address hash collision:**
> "Hash equality doesn't guarantee string equality due to collisions, so I verify actual matches. With a good modulo, collisions are rare."

**4. Compare with alternatives:**
> "Unlike KMP which guarantees O(n+m), Rabin-Karp can degrade to O(n√óm) in worst case. However, Rabin-Karp is simpler and excels at multiple pattern search."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê | String matching questions |
| Amazon | ‚≠ê‚≠ê‚≠ê | Practical applications |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Algorithm knowledge |
| Competitive | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand algorithm | 15 min |
| Implement basic version | 20 min |
| Handle edge cases | 10 min |
| Solve LC 28 | 15 min |
| Master multiple patterns | 30 min |

---

> **üí° Key Insight:** Rabin-Karp's elegance lies in treating strings as numbers. By computing a polynomial hash, we can compare m-character substrings in O(1) instead of O(m). The rolling update ensures we only pay O(m) once for initialization, then O(1) per position. The trade-off is potential false positives, which we handle with verification.

> **üîó Related:** [Rolling Hash Overview](./9.1-Rolling-Hash-Overview.md) | [Hash Functions](../01-Hash-Fundamentals/1.2-Hash-Functions.md) | [Sliding Window](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/02-Sliding-Window.md)
