# 4.1 Powers of 2 & Logarithms

> **If you can't instantly recognize that 2Â¹â° = 1,024 â‰ˆ 1K and 2Â²â° â‰ˆ 1M, you'll misjudge complexity in every interview.**
>
> â±ï¸ *Estimated reading: 12 minutes*

---

## ğŸ¯ Why This Matters

Logarithms appear everywhere in DSA:
- **Binary search** halves the array â†’ O(log n)
- **Balanced trees** have height log n
- **Merge sort** has log n levels of recursion
- **Bit manipulation** â€” how many bits to represent n? â†’ âŒŠlogâ‚‚(n)âŒ‹ + 1

If you don't know your powers of 2, you can't estimate whether an O(n log n) solution will pass for n = 10â¶.

---

## ğŸ“ Powers of 2 Table (Memorize This)

| Power | Value | Approx | Common Mapping |
|-------|-------|--------|----------------|
| 2â° | 1 | | |
| 2Â¹ | 2 | | |
| 2Â² | 4 | | |
| 2Â³ | 8 | | |
| 2â´ | 16 | | |
| 2âµ | 32 | | |
| 2â· | 128 | | signed byte max â‰ˆ 127 |
| 2â¸ | 256 | | ASCII characters, unsigned byte |
| 2Â¹â° | 1,024 | **â‰ˆ 1 Thousand (1K)** | 1 KB |
| 2Â¹â¶ | 65,536 | **â‰ˆ 65K** | unsigned short max |
| 2Â²â° | 1,048,576 | **â‰ˆ 1 Million (1M)** | 1 MB |
| 2Â³â° | 1,073,741,824 | **â‰ˆ 1 Billion (1B)** | 1 GB, int32 â‰ˆ 2 Ã— 10â¹ |
| 2Â³Â² | 4,294,967,296 | **â‰ˆ 4 Billion** | unsigned int32 max |
| 2â´â° | â€” | **â‰ˆ 1 Trillion** | 1 TB |

### The Key Shortcuts

```
2Â¹â° â‰ˆ 10Â³ (thousand)
2Â²â° â‰ˆ 10â¶ (million)
2Â³â° â‰ˆ 10â¹ (billion)

So: logâ‚‚(10â¶) â‰ˆ 20
    logâ‚‚(10â¹) â‰ˆ 30
```

---

## ğŸ“ Logarithm Intuition

### What logâ‚‚(n) Means

> **logâ‚‚(n) = "How many times can you halve n before reaching 1?"**

```
n = 1,000,000
Ã·2 â†’ 500,000
Ã·2 â†’ 250,000
Ã·2 â†’ 125,000
...
Ã·2 â†’ 1           â† about 20 times

So logâ‚‚(1,000,000) â‰ˆ 20
```

### Why It Appears in DSA

| Algorithm | Why log n? |
|-----------|-----------|
| **Binary search** | Halve search space each step |
| **Balanced BST** | Tree height = log n when balanced |
| **Merge sort** | log n levels of splitting |
| **Heap operations** | Bubble up/down through log n levels |
| **Binary lifting** | Jump 2â°, 2Â¹, 2Â², ... ancestors |

### Log Values to Know

| n | logâ‚‚(n) | Meaning for O(log n) |
|---|---------|---------------------|
| 16 | 4 | 4 operations |
| 1,000 | ~10 | ~10 operations |
| 1,000,000 | ~20 | ~20 operations |
| 1,000,000,000 | ~30 | ~30 operations |
| 10Â¹â¸ | ~60 | Still only ~60! |

> **ğŸ’¡ Key Insight:** Even for n = 10Â¹â¸ (a quintillion), logâ‚‚(n) is only ~60. This is why binary search is so powerful â€” it makes the astronomically large manageable.

---

## ğŸ“ How This Connects to Constraints

When LeetCode says n â‰¤ 10âµ:

```
n = 100,000

O(n)        = 100,000 ops         âœ… Fast
O(n log n)  = 100,000 Ã— 17       âœ… ~1.7M ops
             â‰ˆ 1,700,000 ops      

O(nÂ²)       = 10,000,000,000     âŒ 10 billion â€” TLE!
```

### The Rule of 10â¸

Modern computers execute ~10â¸ simple operations per second in competitive programming judges. So:

| Operations | Time | Verdict |
|-----------|------|---------|
| 10â¶ | ~10ms | âœ… Very fast |
| 10â· | ~100ms | âœ… Fast |
| 10â¸ | ~1s | âš ï¸ Borderline |
| 10â¹ | ~10s | âŒ TLE |

### Practical Application

```
Given: n â‰¤ 10âµ, time limit 1-2 seconds

n log n â‰ˆ 10âµ Ã— 17 â‰ˆ 1.7 Ã— 10â¶    âœ… 
nÂ²     â‰ˆ 10Â¹â°                       âŒ Way too slow
nâˆšn    â‰ˆ 10âµ Ã— 316 â‰ˆ 3 Ã— 10â·       âœ… Should work

â†’ Need O(n log n) or better, NOT O(nÂ²)
```

---

## ğŸ’» Code: Computing Logarithms

```python
import math

# log base 2
math.log2(1024)         # 10.0
math.log2(1000000)      # 19.93 â‰ˆ 20

# log base 10
math.log10(1000)        # 3.0

# Number of bits needed to represent n
n = 1000
n.bit_length()          # 10 (since 2â¹ = 512 < 1000 < 1024 = 2Â¹â°)

# Floor of log2 (without floating point issues)
def floor_log2(n):
    return n.bit_length() - 1

floor_log2(1024)        # 10
floor_log2(1000)        # 9
```

```javascript
// log base 2
Math.log2(1024);        // 10
Math.log2(1000000);     // 19.93

// log base 10
Math.log10(1000);       // 3

// Number of bits
function bitLength(n) {
    return Math.floor(Math.log2(n)) + 1;
}
bitLength(1000);        // 10

// Or using bit operations
function bitLength2(n) {
    let bits = 0;
    while (n > 0) {
        bits++;
        n >>= 1;       // Right shift = divide by 2
    }
    return bits;
}
```

---

## ğŸ“ Integer Division & Ceiling

A common operation in binary search and partitioning:

```python
# Floor division (round down) â€” built-in
7 // 2          # 3

# Ceiling division (round up) â€” no built-in!
# âŒ math.ceil(7/2) â€” float precision issues for large numbers
# âœ… Integer arithmetic trick:
def ceil_div(a, b):
    return (a + b - 1) // b

ceil_div(7, 2)   # 4
ceil_div(10, 3)  # 4
ceil_div(9, 3)   # 3
```

```javascript
// Floor division
Math.floor(7 / 2);     // 3

// Ceiling division
function ceilDiv(a, b) {
    return Math.floor((a + b - 1) / b);
}
```

### Binary Search Midpoint (Avoid Overflow)

```python
# âœ… Python â€” no integer overflow, so this is fine
mid = (left + right) // 2

# But conventionally:
mid = left + (right - left) // 2
```

```javascript
// âœ… JavaScript â€” use this form to avoid issues
const mid = Math.floor(left + (right - left) / 2);
// Or: const mid = (left + right) >> 1;  // Bitwise (but only for small numbers)
```

---

## âš ï¸ Common Mistakes

| Mistake | Why It's Wrong | Fix |
|---------|---------------|-----|
| Thinking logâ‚‚(1M) is large | It's only ~20! | Memorize: 2Â²â° â‰ˆ 10â¶ |
| Using `math.ceil(a/b)` for large integers | Float precision loss | Use `(a + b - 1) // b` |
| Confusing logâ‚‚ and logâ‚â‚€ | Different bases, different values | In DSA, "log" almost always means logâ‚‚ |
| Not recognizing 2Â³Â¹ - 1 | It's INT_MAX (~2.1 Ã— 10â¹) | Know this for overflow problems |

---

## ğŸ“ Practice

These problems require logarithmic thinking:

| Problem | Why Logarithms Matter | Difficulty |
|---------|----------------------|------------|
| [Binary Search (LC 704)](https://leetcode.com/problems/binary-search/) | O(log n) halving | Easy |
| [Pow(x, n) (LC 50)](https://leetcode.com/problems/powx-n/) | Fast exponentiation via halving | Medium |
| [Count Complete Tree Nodes (LC 222)](https://leetcode.com/problems/count-complete-tree-nodes/) | O(logÂ²n) using tree height | Medium |
| [Kth Smallest in BST (LC 230)](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) | BST height is log n | Medium |
| [Sqrt(x) (LC 69)](https://leetcode.com/problems/sqrtx/) | Binary search on answer | Easy |

---

> **ğŸ’¡ Key Insight:** Memorize three facts and you can estimate any complexity: (1) 2Â¹â° â‰ˆ 1K, (2) 2Â²â° â‰ˆ 1M, (3) 2Â³â° â‰ˆ 1B. From these, logâ‚‚(n) for any LeetCode constraint is instant mental math.

---

**Next:** [4.2 Series & Summations](./4.2-Series-And-Summations.md) â†’
