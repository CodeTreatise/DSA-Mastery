# 2.1 Top-Down Memoization

> **Memoization** is a DP implementation where you start with the original problem, recursively break it into subproblems, and cache results to avoid recomputation. It's called "top-down" because you start from the top (main problem) and work down to base cases.

---

## ðŸŽ¯ Pattern Recognition

<details>
<summary><strong>When to Use Top-Down (Memoization)</strong></summary>

**Choose memoization when:**
- You already have a working recursive solution
- Not all subproblems need to be solved (sparse)
- The recurrence relation is complex or hard to iterate
- You want to quickly convert recursion to DP

**Signals in problems:**
- Natural recursive structure
- Some branches of recursion may not be explored
- Top-down thinking feels more intuitive

</details>

---

## âœ… When to Use

- Converting existing recursive solution to DP
- Problems with complex state transitions
- When only some subproblems are actually needed
- When iterative fill order isn't obvious

## âŒ When NOT to Use

| Situation | Why | Alternative |
|-----------|-----|-------------|
| Deep recursion (n > 1000) | Stack overflow risk | Bottom-up |
| All subproblems needed | Iteration is faster | Tabulation |
| Need space optimization | Hard to optimize memo | Bottom-up |
| Performance critical | Function call overhead | Tabulation |

---

## ðŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Connections</strong></summary>

**Before this:**
- [What Is DP](./1.1-What-Is-DP.md)
- [Recursion Basics](../../02-Recursion-Backtracking/01-Recursion/1.1-Recursion-Basics.md)

**After this:**
- [Bottom-Up Tabulation](./2.2-Bottom-Up-Tabulation.md)
- [Space Optimization](./2.3-Space-Optimization.md)

**Key relationship:**
```
Recursion â†’ Add memo â†’ Memoization (Top-Down DP)
                           â†“ (convert)
                       Tabulation (Bottom-Up DP)
```

</details>

---

## ðŸ“ How It Works

### The 3-Step Memoization Pattern

```
Step 1: Check if already computed â†’ Return cached result
Step 2: If base case â†’ Return base value
Step 3: Compute recursively â†’ Cache and return result
```

**Template:**
```python
def solve(state, memo={}):
    # Step 1: Check cache
    if state in memo:
        return memo[state]
    
    # Step 2: Base case
    if is_base_case(state):
        return base_value
    
    # Step 3: Recursive computation
    result = compute_from_subproblems(state, memo)
    
    # Cache before returning
    memo[state] = result
    return result
```

### Visual Trace: Fibonacci(5)

**Without Memoization:**
```
                    fib(5)
                   /      \
              fib(4)      fib(3)        â† fib(3) computed TWICE
              /    \       /    \
         fib(3)  fib(2)  fib(2)  fib(1)  â† fib(2) computed 3 TIMES
         /    \
    fib(2)  fib(1)

Total calls: 15 (exponential growth)
```

**With Memoization:**
```
fib(5) â†’ not in memo â†’ compute
â”œâ”€â”€ fib(4) â†’ not in memo â†’ compute
â”‚   â”œâ”€â”€ fib(3) â†’ not in memo â†’ compute
â”‚   â”‚   â”œâ”€â”€ fib(2) â†’ not in memo â†’ compute
â”‚   â”‚   â”‚   â”œâ”€â”€ fib(1) â†’ base case â†’ return 1
â”‚   â”‚   â”‚   â””â”€â”€ fib(0) â†’ base case â†’ return 0
â”‚   â”‚   â”‚   â†’ memo[2] = 1, return 1
â”‚   â”‚   â””â”€â”€ fib(1) â†’ base case â†’ return 1
â”‚   â”‚   â†’ memo[3] = 2, return 2
â”‚   â””â”€â”€ fib(2) â†’ IN MEMO â†’ return 1 âœ“ (no recomputation!)
â”‚   â†’ memo[4] = 3, return 3
â””â”€â”€ fib(3) â†’ IN MEMO â†’ return 2 âœ“ (no recomputation!)
â†’ memo[5] = 5, return 5

Total unique computations: 5 (linear!)
```

---

## ðŸ’» Code Implementation

### Python - Memoization Patterns

```python
from functools import lru_cache
from typing import Dict, List

# ==========================
# Pattern 1: Dictionary Memo
# ==========================
def fib_dict_memo(n: int, memo: Dict[int, int] = None) -> int:
    """
    Classic memoization with explicit dictionary.
    Time: O(n), Space: O(n)
    """
    if memo is None:
        memo = {}
    
    # Step 1: Check cache
    if n in memo:
        return memo[n]
    
    # Step 2: Base case
    if n <= 1:
        return n
    
    # Step 3: Compute, cache, return
    memo[n] = fib_dict_memo(n - 1, memo) + fib_dict_memo(n - 2, memo)
    return memo[n]


# ==========================
# Pattern 2: @lru_cache (Python built-in)
# ==========================
@lru_cache(maxsize=None)
def fib_lru_cache(n: int) -> int:
    """
    Using Python's built-in memoization decorator.
    Cleaner code, same performance.
    """
    if n <= 1:
        return n
    return fib_lru_cache(n - 1) + fib_lru_cache(n - 2)


# ==========================
# Pattern 3: 2D State Memoization
# ==========================
def longest_common_subsequence(text1: str, text2: str) -> int:
    """
    LCS with 2D state: (i, j) = indices in both strings.
    Time: O(m*n), Space: O(m*n)
    """
    memo = {}
    
    def dp(i: int, j: int) -> int:
        # Check cache
        if (i, j) in memo:
            return memo[(i, j)]
        
        # Base case: either string exhausted
        if i == len(text1) or j == len(text2):
            return 0
        
        # Recurrence
        if text1[i] == text2[j]:
            result = 1 + dp(i + 1, j + 1)
        else:
            result = max(dp(i + 1, j), dp(i, j + 1))
        
        memo[(i, j)] = result
        return result
    
    return dp(0, 0)


# ==========================
# Pattern 4: Tuple State (for complex states)
# ==========================
def min_path_sum(grid: List[List[int]]) -> int:
    """
    Grid DP with (row, col) state.
    """
    rows, cols = len(grid), len(grid[0])
    
    @lru_cache(maxsize=None)
    def dp(r: int, c: int) -> int:
        # Base case: destination
        if r == rows - 1 and c == cols - 1:
            return grid[r][c]
        
        # Out of bounds
        if r >= rows or c >= cols:
            return float('inf')
        
        # Move right or down
        return grid[r][c] + min(dp(r + 1, c), dp(r, c + 1))
    
    return dp(0, 0)
```

### JavaScript - Memoization Patterns

```javascript
// ==========================
// Pattern 1: Map Memo
// ==========================
function fibMapMemo(n, memo = new Map()) {
    // Check cache
    if (memo.has(n)) return memo.get(n);
    
    // Base case
    if (n <= 1) return n;
    
    // Compute, cache, return
    const result = fibMapMemo(n - 1, memo) + fibMapMemo(n - 2, memo);
    memo.set(n, result);
    return result;
}

// ==========================
// Pattern 2: Object Memo
// ==========================
function fibObjectMemo(n, memo = {}) {
    if (n in memo) return memo[n];
    if (n <= 1) return n;
    
    memo[n] = fibObjectMemo(n - 1, memo) + fibObjectMemo(n - 2, memo);
    return memo[n];
}

// ==========================
// Pattern 3: 2D State (using string keys)
// ==========================
function longestCommonSubsequence(text1, text2) {
    const memo = {};
    
    function dp(i, j) {
        const key = `${i},${j}`;
        if (key in memo) return memo[key];
        
        if (i === text1.length || j === text2.length) {
            return 0;
        }
        
        let result;
        if (text1[i] === text2[j]) {
            result = 1 + dp(i + 1, j + 1);
        } else {
            result = Math.max(dp(i + 1, j), dp(i, j + 1));
        }
        
        memo[key] = result;
        return result;
    }
    
    return dp(0, 0);
}

// ==========================
// Pattern 4: Generic Memoizer
// ==========================
function memoize(fn) {
    const cache = new Map();
    return function(...args) {
        const key = JSON.stringify(args);
        if (cache.has(key)) return cache.get(key);
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    };
}

// Usage:
const memoizedFib = memoize(function fib(n) {
    if (n <= 1) return n;
    return memoizedFib(n - 1) + memoizedFib(n - 2);
});
```

---

## âš¡ Complexity Analysis

| Aspect | Without Memo | With Memo |
|--------|--------------|-----------|
| **Time** | O(2â¿) | O(n) |
| **Space** | O(n) call stack | O(n) memo + O(n) stack |
| **Function calls** | 2â¿ | n unique |

**Why the improvement:**
```
Without memo: Every branch fully explored
              fib(5) = fib(4) + fib(3)
                     = (fib(3) + fib(2)) + (fib(2) + fib(1))
                     = ... exponential expansion

With memo:    Each fib(k) computed ONCE, then O(1) lookup
              Total work = n computations Ã— O(1) each = O(n)
```

**Space breakdown:**
```
Memo dictionary: O(n) entries
Call stack:      O(n) max depth
Total:           O(n) space
```

---

## ðŸ”„ Variations

| Variation | Use Case | Example |
|-----------|----------|---------|
| Dict/Map memo | General purpose | Most DP problems |
| @lru_cache | Quick Python solution | Competitive programming |
| Array memo | Dense integer states | dp[i] where 0 â‰¤ i â‰¤ n |
| Tuple keys | Multi-dimensional state | dp[(i, j, k)] |

---

## âš ï¸ Common Mistakes

### 1. Mutable Default Argument Bug (Python)

**âŒ Wrong:**
```python
def fib(n, memo={}):  # Memo persists between calls!
    ...
```

**âœ… Correct:**
```python
def fib(n, memo=None):
    if memo is None:
        memo = {}
    ...
```

### 2. Forgetting to Return Cached Value

**âŒ Wrong:**
```python
def solve(n, memo={}):
    if n in memo:
        memo[n]  # Oops! Forgot return
    ...
```

**âœ… Correct:**
```python
def solve(n, memo={}):
    if n in memo:
        return memo[n]  # Return the cached value!
    ...
```

### 3. Wrong Key for 2D State

**âŒ Wrong:**
```python
# Using list as key (unhashable!)
memo[[i, j]] = result
```

**âœ… Correct:**
```python
# Use tuple (hashable)
memo[(i, j)] = result
```

### 4. Stack Overflow for Large n

**Problem:** Python default recursion limit is ~1000

**Solution:**
```python
import sys
sys.setrecursionlimit(10000)  # Increase limit

# Or better: convert to bottom-up
```

---

## ðŸ“ Practice Problems (Progressive)

**Easy (Single state):**
- [ ] [Fibonacci Number](https://leetcode.com/problems/fibonacci-number/) - Classic intro
- [ ] [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/) - Fibonacci variant

**Medium (Multi-dimensional state):**
- [ ] [Unique Paths](https://leetcode.com/problems/unique-paths/) - 2D state (row, col)
- [ ] [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/) - 2D (i, j)
- [ ] [Coin Change](https://leetcode.com/problems/coin-change/) - 1D with choices

**Hard (Complex state):**
- [ ] [Edit Distance](https://leetcode.com/problems/edit-distance/) - 2D with 3 choices
- [ ] [Burst Balloons](https://leetcode.com/problems/burst-balloons/) - Interval state

<details>
<summary><strong>ðŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement Fibonacci with memoization from scratch
- **Day 3:** Convert a recursive solution to memoized (Climbing Stairs)
- **Day 7:** Solve 2D memoization problem (Unique Paths)
- **Day 14:** Solve without looking at template (LCS)
- **Day 30:** Teach memoization to someone else

</details>

---

## ðŸŽ¤ Interview Context

<details>
<summary><strong>Communicating Memoization in Interviews</strong></summary>

**Step 1: Start with recursive solution**
> "Let me first write the recursive solution to make sure I understand the problem correctly."

**Step 2: Identify overlapping subproblems**
> "I notice that in this recursion tree, we're computing fib(3) multiple times. This tells me we have overlapping subproblems."

**Step 3: Add memoization**
> "I'll add memoization to cache results. Before computing, I'll check if we've seen this state before."

**When to mention bottom-up:**
> "I could also convert this to a bottom-up solution which would avoid the recursion overhead and potential stack overflow issues. Would you like me to show that approach?"

</details>

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 20-30 min | This document |
| Implement Fibonacci | 10-15 min | First practice |
| Solve 2D memoization | 25-35 min | LCS, Grid problems |
| Master pattern | 3-5 problems | Until automatic |

---

> **ðŸ’¡ Key Insight:** Memoization is just recursion with a cache. If you can write a recursive solution, you can convert it to DP by adding 3 lines: (1) check if in cache, (2) store result before returning, (3) return cached result.

> **ðŸ”— Related:** [What Is DP](./1.1-What-Is-DP.md) | [Bottom-Up Tabulation](./2.2-Bottom-Up-Tabulation.md) | [Space Optimization](./2.3-Space-Optimization.md)
