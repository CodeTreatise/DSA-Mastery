# Trie StartsWith (Prefix) Operation

> **StartsWith checks if ANY word in the Trie begins with a given prefix - this is Trie's killer feature that Hash Maps can't do efficiently.**

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Prefix Patterns</strong></summary>

**Look for these signals:**
- "Find all words starting with..."
- "Autocomplete suggestions"
- "Does any word begin with...?"
- "Longest common prefix"
- Real-time search as user types

**Keywords in problem statement:**
- "prefix", "starts with", "beginning"
- "autocomplete", "type-ahead"
- "suggestions", "search bar"

</details>

---

## ‚úÖ When to Use

| Scenario | Why StartsWith |
|----------|----------------|
| **Autocomplete** | Find all words with prefix |
| **Search suggestions** | Filter as user types |
| **Prefix validation** | Check if prefix could lead to words |
| **Dictionary features** | "Words starting with 'un-'" |

---

## ‚ùå StartsWith vs Search (Critical Distinction)

| Trie contains: ["apple", "app"] | search() | startsWith() |
|---------------------------------|----------|--------------|
| Query: "app" | **True** ‚úì | **True** ‚úì |
| Query: "apple" | **True** ‚úì | **True** ‚úì |
| Query: "ap" | **False** ‚úó | **True** ‚úì |
| Query: "application" | **False** ‚úó | **False** ‚úó |

**Key difference:**
- `search("ap")` ‚Üí False (no word "ap" exists)
- `startsWith("ap")` ‚Üí True (words "app", "apple" start with "ap")

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Trie](../01-Trie-Fundamentals/1.1-What-Is-Trie.md) - Basic concept
- [Search Operation](./3.2-Search-Operation.md) - To understand the difference

**After mastering this:**
- [Trie + DFS](../03-Trie-Patterns/4.3-Collect-All-Words.md) - Get all words with prefix
- [Autocomplete Pattern](../06-Applications/7.1-Autocomplete-System.md) - Build search suggestions

**StartsWith enables:**
- Autocomplete systems
- Search pruning in Word Search
- Prefix-based filtering

</details>

---

## üìê How It Works

### The StartsWith Algorithm

```
FUNCTION startsWith(prefix):
    1. Start at root node
    2. FOR each character in prefix:
        a. If child for character doesn't exist:
           ‚Üí Return False (no words with this prefix)
        b. Move to child node
    3. Return True (path exists, words may continue)
    END
```

### Key Insight: Why No is_end Check?

**Search:** Must reach END of a complete word ‚Üí checks `is_end`
**StartsWith:** Just needs PATH to exist ‚Üí no `is_end` check

### Step-by-Step Visualization

**Trie contains: ["apple", "app", "application"]**

```
Trie structure:
    (root)
       ‚îÇ
       a
       ‚îÇ
       p
       ‚îÇ
       p ‚Üê is_end = True ("app")
       ‚îÇ
       l
       ‚îÇ
       i ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ                      ‚îÇ
       e ‚Üê is_end ("apple")   c
                              ‚îÇ
                              a
                              ‚îÇ
                              t
                              ‚îÇ
                              i
                              ‚îÇ
                              o
                              ‚îÇ
                              n ‚Üê is_end ("application")
```

**startsWith("app"):**
```
Step 1: At root, look for 'a' ‚Üí Found ‚úì
Step 2: At 'a', look for 'p' ‚Üí Found ‚úì
Step 3: At 'p', look for 'p' ‚Üí Found ‚úì
Step 4: Reached end of prefix, path exists ‚Üí True ‚úì
```

**startsWith("apl"):**
```
Step 1: At root, look for 'a' ‚Üí Found ‚úì
Step 2: At 'a', look for 'p' ‚Üí Found ‚úì
Step 3: At 'p', look for 'l' ‚Üí NOT FOUND ‚úó
Result: False (no words start with "apl")
```

---

## üíª Code Implementation

### Basic StartsWith (HashMap)

**Python:**
```python
class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def startsWith(self, prefix: str) -> bool:
        """
        Check if any word in trie starts with prefix.
        
        Time: O(m) where m = len(prefix)
        Space: O(1) - no extra space
        
        Args:
            prefix: Prefix to check
            
        Returns:
            True if any word starts with prefix
        """
        node = self.root
        
        for char in prefix:
            if char not in node.children:
                return False  # Path doesn't exist
            node = node.children[char]
        
        return True  # Path exists (no is_end check needed!)
```

**JavaScript:**
```javascript
class Trie {
    constructor() {
        this.root = new TrieNode();
    }
    
    /**
     * Check if any word starts with prefix.
     * @param {string} prefix - Prefix to check
     * @returns {boolean}
     */
    startsWith(prefix) {
        let node = this.root;
        
        for (const char of prefix) {
            if (!node.children.has(char)) {
                return false;
            }
            node = node.children.get(char);
        }
        
        return true;  // Just path existence, not is_end!
    }
}
```

---

### Using Shared Helper

**Python:**
```python
class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def _traverse(self, s: str) -> TrieNode:
        """
        Traverse trie following string s.
        Returns final node or None if path doesn't exist.
        """
        node = self.root
        for char in s:
            if char not in node.children:
                return None
            node = node.children[char]
        return node
    
    def search(self, word: str) -> bool:
        """Check if exact word exists."""
        node = self._traverse(word)
        return node is not None and node.is_end  # ‚Üê Checks is_end
    
    def startsWith(self, prefix: str) -> bool:
        """Check if any word starts with prefix."""
        return self._traverse(prefix) is not None  # ‚Üê No is_end check!
```

---

### Extended: Get All Words With Prefix

**Python:**
```python
class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def get_words_with_prefix(self, prefix: str) -> list[str]:
        """
        Get all words starting with prefix.
        
        Time: O(m + k) where m = prefix length, k = total chars in results
        Space: O(k) for result storage
        
        This is the power of Tries - Hash Maps can't do this efficiently!
        """
        # First, navigate to prefix node
        node = self._traverse(prefix)
        if node is None:
            return []  # No words with this prefix
        
        # DFS to collect all words from this node
        results = []
        self._collect_words(node, prefix, results)
        return results
    
    def _collect_words(self, node: TrieNode, current: str, results: list) -> None:
        """DFS helper to collect all words below a node."""
        if node.is_end:
            results.append(current)
        
        for char, child in node.children.items():
            self._collect_words(child, current + char, results)
```

**JavaScript:**
```javascript
class Trie {
    constructor() {
        this.root = new TrieNode();
    }
    
    getWordsWithPrefix(prefix) {
        const node = this._traverse(prefix);
        if (node === null) {
            return [];
        }
        
        const results = [];
        this._collectWords(node, prefix, results);
        return results;
    }
    
    _collectWords(node, current, results) {
        if (node.isEnd) {
            results.push(current);
        }
        
        for (const [char, child] of node.children) {
            this._collectWords(child, current + char, results);
        }
    }
}
```

---

### Extended: Count Words With Prefix

**Python:**
```python
class Trie:
    def count_words_with_prefix(self, prefix: str) -> int:
        """
        Count words starting with prefix.
        
        If using extended node with prefix_count, this is O(m)!
        Otherwise need to DFS and count.
        """
        node = self._traverse(prefix)
        if node is None:
            return 0
        
        # If tracking prefix_count during insert:
        return node.prefix_count
        
        # Or count via DFS:
        # return self._count_words_below(node)
    
    def _count_words_below(self, node: TrieNode) -> int:
        """DFS to count words below node."""
        count = 1 if node.is_end else 0
        for child in node.children.values():
            count += self._count_words_below(child)
        return count
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| **startsWith** | O(m) | O(1) | m = prefix length |
| **get_words_with_prefix** | O(m + k) | O(k) | k = result chars |
| **count_words_with_prefix** | O(m) | O(1) | If tracking count |

**Why Trie is better than Hash Map for prefix:**

| Structure | Find all words with prefix |
|-----------|---------------------------|
| **Trie** | O(m + k) - traverse + collect |
| **Hash Set** | O(n √ó m) - check every word! |

For n = 100,000 words, Trie is **~100,000x faster** for prefix queries!

---

## üîÑ Variations

| Variation | Returns | Use Case |
|-----------|---------|----------|
| **startsWith (bool)** | True/False | Existence check |
| **getWordsWithPrefix** | List of words | Autocomplete |
| **countWordsWithPrefix** | Integer count | Statistics |
| **getLongestPrefix** | Longest matching prefix | IP routing |
| **getTopKWithPrefix** | Top K suggestions | Search ranking |

### Longest Matching Prefix

```python
def longest_prefix(self, word: str) -> str:
    """Find longest prefix of word that exists in trie."""
    node = self.root
    longest = ""
    current = ""
    
    for char in word:
        if char not in node.children:
            break
        node = node.children[char]
        current += char
        if node.is_end:
            longest = current
    
    return longest
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Checking is_end (Wrong for StartsWith!)

**‚ùå Wrong:**
```python
def startsWith(self, prefix):
    node = self._traverse(prefix)
    return node is not None and node.is_end  # Wrong! That's search()!
```

**‚úÖ Correct:**
```python
def startsWith(self, prefix):
    node = self._traverse(prefix)
    return node is not None  # Just path existence!
```

### 2. Confusing Empty String Behavior

**‚úÖ Correct:**
```python
def startsWith(self, prefix):
    if not prefix:
        return True  # Every word starts with empty string!
```

### 3. Inefficient Word Collection

**‚ùå Wrong:**
```python
def get_words_with_prefix(self, prefix):
    # Checking every word in trie!
    all_words = self.get_all_words()
    return [w for w in all_words if w.startswith(prefix)]
```

**‚úÖ Correct:**
```python
def get_words_with_prefix(self, prefix):
    node = self._traverse(prefix)  # Navigate directly!
    if node is None:
        return []
    return self._collect_from(node, prefix)
```

---

## üìù Practice Problems

### Easy (Master basic prefix)
- [ ] [Implement Trie](https://leetcode.com/problems/implement-trie-prefix-tree/) - LC 208 ‚≠ê
- [ ] [Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/) - LC 14

### Medium (Prefix applications)
- [ ] [Search Suggestions System](https://leetcode.com/problems/search-suggestions-system/) - LC 1268 ‚≠ê
- [ ] [Replace Words](https://leetcode.com/problems/replace-words/) - LC 648
- [ ] [Longest Word in Dictionary](https://leetcode.com/problems/longest-word-in-dictionary/) - LC 720

### Hard (Complex prefix patterns)
- [ ] [Word Search II](https://leetcode.com/problems/word-search-ii/) - LC 212
- [ ] [Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/) - LC 336

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

For prefix mastery:
- **Day 1:** Implement startsWith, understand vs search
- **Day 3:** Implement getWordsWithPrefix
- **Day 7:** Solve "Search Suggestions System" (LC 1268)
- **Day 14:** Build simple autocomplete feature
- **Day 30:** Explain prefix operations to someone

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Discuss Prefix Operations</strong></summary>

**Explaining the difference:**
> "StartsWith just checks if the path exists in the trie - if I can traverse all characters of the prefix, at least one word starts with it. Unlike search, I don't check is_end because I don't need a complete word, just the prefix path."

**Why Trie for autocomplete:**
> "A hash map can't efficiently find all words starting with a prefix - you'd have to check every word. A Trie lets me navigate to the prefix in O(m) time, then collect all words below that node. That's why Tries are used for autocomplete."

**Common follow-up - getting suggestions:**
> "To get all words with a prefix, I first navigate to the prefix node in O(m) time, then do a DFS to collect all complete words below it. For top-K suggestions, I'd add a priority queue."

</details>

**Company Applications:**

| Company | Use Case |
|---------|----------|
| **Google** | Search suggestions |
| **Uber** | Location autocomplete |
| **Airbnb** | Address search |
| **LinkedIn** | People/skill search |
| **Amazon** | Product search |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand startsWith | 10 min | This file |
| Implement basic startsWith | 5 min | Simple traversal |
| Understand vs search | 5-10 min | Key distinction |
| Implement getWordsWithPrefix | 15-20 min | DFS collection |
| Build autocomplete | 30-45 min | Full feature |

---

> **üí° Key Insight:** StartsWith is Trie's killer feature. While Hash Maps need O(n) to find words with a prefix, Tries do it in O(m + k) - that's the difference between unusable and instant for large dictionaries.

> **üîó Related:** [Search Operation](./3.2-Search-Operation.md) | [Collect All Words](../03-Trie-Patterns/4.3-Collect-All-Words.md) | [Autocomplete System](../06-Applications/7.1-Autocomplete-System.md)
