# 3.0 Greedy Problem-Solving Framework

> **Definition:** A systematic approach to solving greedy problems‚Äîfrom recognition to implementation to verification.

---

## üéØ The 5-Step Framework

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  STEP 1: RECOGNIZE  ‚Üí  Is this a greedy problem?           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  STEP 2: IDENTIFY   ‚Üí  What's the greedy criterion?        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  STEP 3: VERIFY     ‚Üí  Does greedy work? (counterexample?) ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  STEP 4: IMPLEMENT  ‚Üí  Sort + iterate + decide             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  STEP 5: VALIDATE   ‚Üí  Test with examples, analyze O(n)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## ‚úÖ Step 1: Recognize

### Greedy Problem Signals

| Signal | Example |
|--------|---------|
| **Optimization** | "Maximum/minimum number of..." |
| **Sequential decisions** | "At each step, choose..." |
| **Independent choices** | Previous choice doesn't constrain next |
| **Sorting helps** | Problem becomes obvious after sorting |
| **Intervals/scheduling** | Start/end times, deadlines |
| **Assignment** | Match items to slots/people |

### Quick Recognition Checklist

```python
def is_likely_greedy(problem):
    """Quick heuristic for greedy recognition."""
    signals = [
        "maximize" in problem or "minimize" in problem,
        "non-overlapping" in problem,
        "schedule" in problem or "intervals" in problem,
        "assign" in problem or "distribute" in problem,
        "earliest" in problem or "latest" in problem,
        "most" in problem or "least" in problem,
    ]
    return sum(signals) >= 2  # Multiple signals = likely greedy
```

---

## ‚úÖ Step 2: Identify the Greedy Criterion

### Common Criteria

| Problem Type | Greedy Criterion | Why It Works |
|--------------|------------------|--------------|
| **Interval scheduling** | Sort by END time | Leaves most room for remaining |
| **Interval merging** | Sort by START time | Process in order |
| **Fractional knapsack** | Sort by VALUE/WEIGHT ratio | Best bang for buck |
| **Job with deadlines** | Sort by PROFIT descending | Take most valuable first |
| **Assignment** | Sort BOTH lists | Match smallest to smallest |
| **Jump/reach** | Track MAX reachable | Always extend farthest |
| **Two-pass** | Left-to-right, right-to-left | Handle both directions |

### Criterion Selection Process

```
1. What are we optimizing? (max activities, min removals, etc.)

2. What property should we prioritize?
   - For "fit more things": prioritize what ends earliest
   - For "maximize value": prioritize highest value
   - For "cover everything": prioritize what covers most

3. Does sorting by this property make the solution obvious?
   - Yes ‚Üí Good criterion
   - No ‚Üí Try different property or it's not greedy
```

---

## ‚úÖ Step 3: Verify (Counterexample Check)

### The 3-Case Test

Before implementing, test with:

1. **Small example (n=3-4)**: Trace greedy manually
2. **Edge case**: All same values, all overlapping, empty
3. **Adversarial case**: Try to break greedy

```python
def find_counterexample(greedy_func, brute_force_func, test_cases):
    """
    Compare greedy with brute force to find counterexamples.
    """
    for i, test in enumerate(test_cases):
        greedy_result = greedy_func(test)
        optimal_result = brute_force_func(test)
        
        if greedy_result != optimal_result:
            print(f"‚ùå Counterexample #{i}: {test}")
            print(f"   Greedy: {greedy_result}")
            print(f"   Optimal: {optimal_result}")
            return False
    
    print("‚úÖ No counterexample found")
    return True
```

### If Counterexample Found ‚Üí Use DP

If greedy fails on any test case:
- Problem likely needs Dynamic Programming
- Or your greedy criterion is wrong

---

## ‚úÖ Step 4: Implement

### Universal Greedy Template

```python
def greedy_template(items):
    """
    Universal greedy algorithm structure.
    
    Time: O(n log n) for sorting + O(n) for processing
    Space: O(1) to O(n) depending on output
    """
    # === STEP 1: Sort by greedy criterion ===
    sorted_items = sorted(items, key=lambda x: GREEDY_CRITERION(x))
    
    # === STEP 2: Initialize state ===
    result = []  # or: count = 0, last_end = 0, etc.
    
    # === STEP 3: Iterate and make greedy choices ===
    for item in sorted_items:
        if CAN_TAKE(item, current_state):
            TAKE_ITEM(item, result)
            UPDATE_STATE(item, current_state)
    
    # === STEP 4: Return result ===
    return result


# Example: Activity Selection
def activity_selection(intervals):
    # Sort by end time
    sorted_intervals = sorted(intervals, key=lambda x: x[1])
    
    result = []
    last_end = 0
    
    for start, end in sorted_intervals:
        if start >= last_end:  # Can take?
            result.append((start, end))  # Take
            last_end = end  # Update state
    
    return result
```

```javascript
// JavaScript Template
function greedyTemplate(items) {
    // Sort by greedy criterion
    const sorted = [...items].sort((a, b) => criterion(a) - criterion(b));
    
    const result = [];
    let state = initialState;
    
    for (const item of sorted) {
        if (canTake(item, state)) {
            result.push(item);
            state = updateState(item, state);
        }
    }
    
    return result;
}
```

---

## ‚úÖ Step 5: Validate

### Validation Checklist

- [ ] Trace through 2-3 examples by hand
- [ ] Verify edge cases (empty, single element, all same)
- [ ] Confirm time complexity (should be O(n log n) or O(n))
- [ ] Check space complexity
- [ ] Consider: could DP give same answer but slower?

---

## üíª Complete Example: Framework in Action

### Problem: Non-overlapping Intervals

**Given:** Array of intervals `[[s1,e1], [s2,e2], ...]`
**Goal:** Find minimum number of intervals to remove for non-overlapping

---

**STEP 1: RECOGNIZE**
- ‚úÖ Optimization (minimize removals)
- ‚úÖ Intervals/scheduling
- ‚úÖ Sequential choices
- ‚Üí Likely greedy!

---

**STEP 2: IDENTIFY CRITERION**
- We want to KEEP maximum intervals
- Keep those that "leave most room" ‚Üí sort by END time
- Criterion: Sort by end time ascending

---

**STEP 3: VERIFY**
```
Test: [[1,3], [2,4], [3,5]]
Greedy (sort by end): [1,3] ‚Üí keep, [2,4] ‚Üí skip (overlaps), [3,5] ‚Üí keep
Result: Keep 2, remove 1 ‚úì

Test: [[1,2], [2,3], [3,4]]
Greedy: Keep all 3, remove 0 ‚úì

No counterexample found!
```

---

**STEP 4: IMPLEMENT**

```python
def erase_overlap_intervals(intervals):
    """
    LeetCode 435: Non-overlapping Intervals
    
    Time: O(n log n), Space: O(1)
    """
    if not intervals:
        return 0
    
    # Sort by end time
    intervals.sort(key=lambda x: x[1])
    
    keep_count = 1
    last_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] >= last_end:  # Non-overlapping
            keep_count += 1
            last_end = intervals[i][1]
    
    return len(intervals) - keep_count  # Removed = total - kept
```

```javascript
function eraseOverlapIntervals(intervals) {
    if (intervals.length === 0) return 0;
    
    // Sort by end time
    intervals.sort((a, b) => a[1] - b[1]);
    
    let keepCount = 1;
    let lastEnd = intervals[0][1];
    
    for (let i = 1; i < intervals.length; i++) {
        if (intervals[i][0] >= lastEnd) {
            keepCount++;
            lastEnd = intervals[i][1];
        }
    }
    
    return intervals.length - keepCount;
}
```

---

**STEP 5: VALIDATE**
```
intervals = [[1,2],[2,3],[3,4],[1,3]]
Sorted by end: [[1,2], [2,3], [1,3], [3,4]]
Process:
  [1,2]: keep (first), last_end=2
  [2,3]: keep (2>=2), last_end=3
  [1,3]: skip (1<3)
  [3,4]: keep (3>=3), last_end=4
Keep: 3, Remove: 1 ‚úì

Time: O(n log n) ‚úì
Space: O(1) (in-place sort) ‚úì
```

---

## ‚ö° Complexity Analysis

| Step | Typical Complexity |
|------|-------------------|
| Sort | O(n log n) |
| Process | O(n) |
| **Total** | **O(n log n)** |
| Space | O(1) to O(n) |

---

## üîÑ Common Patterns

| Pattern | Criterion | Examples |
|---------|-----------|----------|
| **Max non-overlapping** | Sort by END | Activity Selection |
| **Merge overlapping** | Sort by START | Merge Intervals |
| **Min to cover** | Sort by END | Meeting Rooms count |
| **Max value** | Sort by RATIO | Fractional Knapsack |
| **Match pairs** | Sort BOTH | Assign Cookies |
| **Extend reach** | Track MAX | Jump Game |
| **Two-pass** | L‚ÜíR then R‚ÜíL | Candy |

---

## ‚ö†Ô∏è Common Mistakes

1. **Wrong sorting criterion**
   - ‚ùå Sort intervals by start time for selection
   - ‚úÖ Sort by END time for selection

2. **Not handling ties**
   - ‚ùå Undefined behavior on equal values
   - ‚úÖ Define secondary sort key

3. **Off-by-one in comparisons**
   - ‚ùå `if start > last_end` (misses touching intervals)
   - ‚úÖ `if start >= last_end` (or clarify with interviewer)

4. **Forgetting edge cases**
   - ‚ùå Crashes on empty input
   - ‚úÖ Handle empty, single element

---

## üìù Practice Problems (by Framework Step)

### Easy (Practice recognition + implementation)
- [ ] [Assign Cookies](https://leetcode.com/problems/assign-cookies/)
- [ ] [Lemonade Change](https://leetcode.com/problems/lemonade-change/)
- [ ] [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)

### Medium (Practice criterion selection)
- [ ] [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)
- [ ] [Merge Intervals](https://leetcode.com/problems/merge-intervals/)
- [ ] [Jump Game](https://leetcode.com/problems/jump-game/)

### Hard (Practice verification + edge cases)
- [ ] [Candy](https://leetcode.com/problems/candy/)
- [ ] [Course Schedule III](https://leetcode.com/problems/course-schedule-iii/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Apply framework to Merge Intervals
- **Day 3:** Apply to Jump Game
- **Day 7:** Solve 3 problems using framework
- **Day 14:** Explain framework to someone
- **Day 30:** Apply to unfamiliar problem

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Framework in Action During Interview</strong></summary>

**Verbal walkthrough (2-3 minutes):**

```
"Let me apply my greedy problem-solving framework:

STEP 1 - RECOGNIZE:
This looks greedy because we're optimizing (minimize removals)
and it involves intervals with sequential decisions.

STEP 2 - IDENTIFY CRITERION:
To keep maximum intervals, I should prioritize those ending
earliest‚Äîthey leave the most room. So I'll sort by end time.

STEP 3 - VERIFY:
Let me trace through [[1,3], [2,4], [3,5]]...
[traces through]
That works. I can't think of a counterexample.

STEP 4 - IMPLEMENT:
[writes code]
Sort by end, iterate, keep non-overlapping.

STEP 5 - VALIDATE:
Time is O(n log n), space is O(1). Let me trace [[1,2],[2,3]]...
[traces, confirms]
Looks correct."
```

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Recognition | 30 sec |
| Identify criterion | 1-2 min |
| Verify (trace examples) | 2-3 min |
| Implement | 5-10 min |
| Validate | 2-3 min |
| **Total** | **10-20 min** |

---

> **üí° Key Insight:** The framework turns "intuition" into a systematic process. Even if you're unsure, following these steps helps you either confirm greedy works or discover you need DP.

> **üîó Related:** [Recognition Guide](./3.1-Greedy-Recognition-Guide.md) | [Greedy vs DP](./1.3-Greedy-vs-DP.md) | [Interval Pattern](../02-Interval-Pattern/4.1-Interval-Greedy-Overview.md)
