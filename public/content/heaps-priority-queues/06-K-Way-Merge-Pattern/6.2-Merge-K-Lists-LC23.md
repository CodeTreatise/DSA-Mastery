# 6.2 Merge K Sorted Lists (LC 23)

## Problem Statement

[LeetCode 23 - Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)

You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.

```
Example 1:
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
Merging them gives 1->1->2->3->4->4->5->6

Example 2:
Input: lists = []
Output: []

Example 3:
Input: lists = [[]]
Output: []
```

**Constraints:**
- k == lists.length
- 0 ‚â§ k ‚â§ 10‚Å¥
- 0 ‚â§ lists[i].length ‚â§ 500
- -10‚Å¥ ‚â§ lists[i][j] ‚â§ 10‚Å¥
- lists[i] is sorted in ascending order
- Sum of lists[i].length ‚â§ 10‚Å¥

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is the canonical K-Way Merge problem:**
- K sorted sequences
- Need to merge into one sorted output
- Efficient access to minimum across all K

**Why use K-Way Merge:**
- Each list contributes candidates for "next smallest"
- Heap gives O(log K) access to minimum
- Better than merging pairs repeatedly for large K

**Alternative approaches:**
- Merge pairs: O(N log K) but simpler implementation
- Heap: O(N log K) and works on streams

</details>

---

## ‚úÖ When to Use

- Merging K sorted linked lists
- External sort merge phase
- Multiple sorted streams

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Only 2 lists | Simpler two-pointer | LC 21 approach |
| Unsorted lists | Pattern requires sorted | Sort first |
| Very small K | Overhead not worth it | Simple merge |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [K-Way Merge Overview](./6.1-K-Way-Merge-Overview.md)
- [Merge Two Sorted Lists (LC 21)](https://leetcode.com/problems/merge-two-sorted-lists/)
- Linked List basics

**After mastering this:**
- [Kth Smallest in Matrix (LC 378)](./6.3-Kth-Smallest-Matrix-LC378.md)
- [Smallest Range Covering K Lists (LC 632)](./6.4-Smallest-Range-LC632.md)

**Related:**
- Divide and conquer merge approach
- External sorting

</details>

---

## üìê How It Works

### Approach 1: Min-Heap (K-Way Merge)

```
Strategy:
1. Add head of each list to min-heap
2. Pop minimum, add to result
3. Push next node from same list
4. Repeat until heap empty

Visualization:

Lists: 1‚Üí4‚Üí5, 1‚Üí3‚Üí4, 2‚Üí6

Heap (min at top):
   (1, list0)     
  /          \    
(1, list1)  (2, list2)

Pop (1, list0), Result: 1‚Üí
Push (4, list0):
   (1, list1)
  /          \
(4, list0)  (2, list2)

Pop (1, list1), Result: 1‚Üí1‚Üí
Push (3, list1):
   (2, list2)
  /          \
(4, list0)  (3, list1)

Continue until all nodes processed...
Final: 1‚Üí1‚Üí2‚Üí3‚Üí4‚Üí4‚Üí5‚Üí6
```

### Approach 2: Divide and Conquer

```
Strategy: Merge pairs, then merge results

Round 1: Merge pairs
  [1,4,5] + [1,3,4] = [1,1,3,4,4,5]
  [2,6] (odd one out)

Round 2: Merge results
  [1,1,3,4,4,5] + [2,6] = [1,1,2,3,4,4,5,6]

Each round halves the number of lists
log K rounds, each round processes N total elements
Total: O(N log K)
```

---

## üíª Code Implementation

### Approach 1: Min-Heap Solution

**Python:**
```python
import heapq
from typing import Optional, List

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:
    """
    Merge K sorted linked lists using min-heap.
    
    Time: O(N log K) where N = total nodes, K = number of lists
    Space: O(K) for the heap
    
    Pattern: K-Way Merge
    """
    # Handle edge cases
    if not lists:
        return None
    
    # Min-heap: (value, unique_index, node)
    # unique_index prevents comparison errors when values are equal
    min_heap = []
    
    # Initialize with head of each non-empty list
    for i, head in enumerate(lists):
        if head:
            heapq.heappush(min_heap, (head.val, i, head))
    
    # Dummy head for result list
    dummy = ListNode(0)
    current = dummy
    
    # Process until heap is empty
    while min_heap:
        val, idx, node = heapq.heappop(min_heap)
        
        # Add this node to result
        current.next = node
        current = current.next
        
        # If this list has more nodes, push next to heap
        if node.next:
            heapq.heappush(min_heap, (node.next.val, idx, node.next))
    
    return dummy.next


# Example usage (assuming ListNode is defined):
# l1 = ListNode(1, ListNode(4, ListNode(5)))
# l2 = ListNode(1, ListNode(3, ListNode(4)))
# l3 = ListNode(2, ListNode(6))
# result = mergeKLists([l1, l2, l3])
```

**JavaScript:**
```javascript
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

var mergeKLists = function(lists) {
    // Filter out null/empty lists
    lists = lists.filter(list => list !== null);
    if (lists.length === 0) return null;
    
    const minHeap = new MinHeap();
    
    // Initialize with head of each list
    for (let i = 0; i < lists.length; i++) {
        if (lists[i]) {
            minHeap.push([lists[i].val, i, lists[i]]);
        }
    }
    
    const dummy = new ListNode(0);
    let current = dummy;
    
    while (minHeap.size() > 0) {
        const [val, idx, node] = minHeap.pop();
        
        current.next = node;
        current = current.next;
        
        if (node.next) {
            minHeap.push([node.next.val, idx, node.next]);
        }
    }
    
    return dummy.next;
};

class MinHeap {
    constructor() { this.heap = []; }
    
    size() { return this.heap.length; }
    
    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return min;
    }
    
    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.heap[parent][0] <= this.heap[i][0]) break;
            [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
            i = parent;
        }
    }
    
    _bubbleDown(i) {
        while (true) {
            let smallest = i;
            const left = 2 * i + 1, right = 2 * i + 2;
            if (left < this.heap.length && this.heap[left][0] < this.heap[smallest][0]) {
                smallest = left;
            }
            if (right < this.heap.length && this.heap[right][0] < this.heap[smallest][0]) {
                smallest = right;
            }
            if (smallest === i) break;
            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
            i = smallest;
        }
    }
}
```

### Approach 2: Divide and Conquer

**Python:**
```python
def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:
    """
    Merge K sorted lists using divide and conquer.
    
    Time: O(N log K)
    Space: O(log K) recursion stack
    """
    if not lists:
        return None
    if len(lists) == 1:
        return lists[0]
    
    def mergeTwoLists(l1, l2):
        """Merge two sorted lists - O(n+m)"""
        dummy = ListNode(0)
        curr = dummy
        
        while l1 and l2:
            if l1.val <= l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        
        curr.next = l1 if l1 else l2
        return dummy.next
    
    # Divide and conquer: merge pairs
    while len(lists) > 1:
        merged = []
        for i in range(0, len(lists), 2):
            l1 = lists[i]
            l2 = lists[i + 1] if i + 1 < len(lists) else None
            merged.append(mergeTwoLists(l1, l2))
        lists = merged
    
    return lists[0]
```

**JavaScript:**
```javascript
var mergeKLists = function(lists) {
    if (!lists || lists.length === 0) return null;
    if (lists.length === 1) return lists[0];
    
    function mergeTwoLists(l1, l2) {
        const dummy = new ListNode(0);
        let curr = dummy;
        
        while (l1 && l2) {
            if (l1.val <= l2.val) {
                curr.next = l1;
                l1 = l1.next;
            } else {
                curr.next = l2;
                l2 = l2.next;
            }
            curr = curr.next;
        }
        
        curr.next = l1 || l2;
        return dummy.next;
    }
    
    // Merge pairs until one list remains
    while (lists.length > 1) {
        const merged = [];
        for (let i = 0; i < lists.length; i += 2) {
            const l1 = lists[i];
            const l2 = i + 1 < lists.length ? lists[i + 1] : null;
            merged.push(mergeTwoLists(l1, l2));
        }
        lists = merged;
    }
    
    return lists[0];
};
```

---

## ‚ö° Complexity Analysis

### Approach 1: Min-Heap

| Case | Time | Space | Notes |
|------|------|-------|-------|
| All |" O(N log K) "| O(K) | N = total nodes |

**Why O(N log K):**
- N total nodes, each pushed and popped once
- Heap has at most K nodes
- Each heap operation: O(log K)
- Total: N * O(log K) = O(N log K)

### Approach 2: Divide and Conquer

| Case | Time | Space | Notes |
|------|------|-------|-------|
| All |" O(N log K) "| O(log K) | Recursion depth |

**Why O(N log K):**
- log K rounds of merging
- Each round processes all N nodes
- Total: N * log K

### Comparison

| Approach | Time | Space | Pros | Cons |
|----------|------|-------|------|------|
| Heap |" O(N log K) "| O(K) | Works with streams | Extra heap space |
| D&C |" O(N log K) "| O(log K) | Less space | Requires all lists upfront |
| Merge one by one |" O(NK) "| O(1) | Simple | Too slow |

---

## üîÑ Variations

| Variation | Key Difference | Notes |
|-----------|----------------|-------|
| **Arrays instead of lists** | Use indices | [K-Way Merge Overview](./6.1-K-Way-Merge-Overview.md) |
| **K largest** | Use max-heap | Reverse problem |
| **With duplicates** | Handle tie-breaking | Add list index |
| **Stream input** | Can't use D&C | Heap only |

---

## ‚ö†Ô∏è Common Mistakes

### 1. ListNode Comparison in Heap

```python
# ‚ùå Wrong: ListNode objects can't be compared directly
heapq.heappush(heap, (node.val, node))  # TypeError when values equal!

# ‚úÖ Correct: Add unique tiebreaker (list index)
heapq.heappush(heap, (node.val, i, node))  # i is unique
```

### 2. Not Handling Empty Lists

```python
# ‚ùå Wrong: Pushing None heads
for head in lists:
    heapq.heappush(heap, (head.val, i, head))  # AttributeError if head is None!

# ‚úÖ Correct: Check for None
for i, head in enumerate(lists):
    if head:  # Only non-empty lists
        heapq.heappush(heap, (head.val, i, head))
```

### 3. Forgetting to Advance Node

```python
# ‚ùå Wrong: Not pushing next node
while min_heap:
    val, idx, node = heapq.heappop(min_heap)
    current.next = node
    current = current.next
    # Missing: push node.next!

# ‚úÖ Correct: Push next node from same list
while min_heap:
    val, idx, node = heapq.heappop(min_heap)
    current.next = node
    current = current.next
    if node.next:  # If more nodes in this list
        heapq.heappush(min_heap, (node.next.val, idx, node.next))
```

### 4. Off-by-One in D&C Pairing

```python
# ‚ùå Wrong: Not handling odd number of lists
for i in range(0, len(lists), 2):
    merged.append(mergeTwoLists(lists[i], lists[i+1]))  # IndexError!

# ‚úÖ Correct: Check bounds for second list
for i in range(0, len(lists), 2):
    l1 = lists[i]
    l2 = lists[i+1] if i+1 < len(lists) else None
    merged.append(mergeTwoLists(l1, l2))
```

---

## üìù Practice Problems (Progressive)

### Easy (Build up)
- [ ] [Merge Two Sorted Lists (LC 21)](https://leetcode.com/problems/merge-two-sorted-lists/) - Foundation

### Medium (This level)
- [ ] [Merge K Sorted Lists (LC 23)](https://leetcode.com/problems/merge-k-sorted-lists/) - **This problem**
- [ ] [Kth Smallest in Sorted Matrix (LC 378)](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/) - Matrix variant

### Hard (Advanced)
- [ ] [Smallest Range Covering K Lists (LC 632)](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/) - Track all K
- [ ] [Find K Pairs with Smallest Sums (LC 373)](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/) - Pair generation

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement heap solution from scratch
- **Day 3:** Implement D&C solution
- **Day 7:** Code both approaches, compare
- **Day 14:** Solve LC 378 (matrix variant)
- **Day 30:** Attempt LC 632 (advanced)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening (1 min):**
"For merging K sorted lists, I'll use a min-heap to efficiently find the next smallest node. The heap will contain one node from each list, and I'll always extract the minimum and push the next node from the same list."

**Alternative mention:**
"I could also use divide and conquer - merge pairs of lists repeatedly. Both are O(N log K), but the heap approach works for streaming data while D&C needs all lists upfront."

**Drawing:**
```
Lists: 1‚Üí4, 2‚Üí5, 3‚Üí6

Heap:    1          Pop 1, push 4
        / \    ‚Üí    
       2   3        Heap:    2
                           / \
                          4   3

Result so far: 1‚Üí
```

**Edge cases to mention:**
- Empty lists array
- Lists containing None
- Single list (just return it)

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very commonly asked |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Frequently asked |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard interview question |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Common |
| Apple | ‚≠ê‚≠ê‚≠ê | Occasionally asked |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Clear from examples |
| Explain approach | 3-5 min | Heap vs D&C |
| Code heap solution | 12-15 min | Watch for edge cases |
| Code D&C solution | 12-15 min | Pair merging |
| Complexity analysis | 2-3 min |" Explain O(N log K) "|
| Total interview time | 25-30 min | Hard-rated problem |

---

## üí° Key Insight

> **The min-heap acts as a "priority queue of list heads."** At any time, it contains exactly one node from each non-exhausted list. The minimum in the heap is guaranteed to be the smallest among all remaining nodes. After extracting, we maintain the invariant by pushing the next node from the same list.

---

## üîó Related

- **Pattern Overview:** [K-Way Merge Pattern](./6.1-K-Way-Merge-Overview.md)
- **Foundation:** [Merge Two Sorted Lists (LC 21)](https://leetcode.com/problems/merge-two-sorted-lists/)
- **Next:** [Kth Smallest in Matrix (LC 378)](./6.3-Kth-Smallest-Matrix-LC378.md)
- **Advanced:** [Smallest Range Covering K Lists (LC 632)](./6.4-Smallest-Range-LC632.md)
