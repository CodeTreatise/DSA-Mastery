# 11.1 Minimum Spanning Tree Introduction

> **Connect all nodes with minimum total edge weight**
>
> â±ï¸ **Study Time:** 30 min | ğŸ“Š **Priority:** Medium | ğŸ¯ **Pattern:** Greedy

---

## Overview

A **Minimum Spanning Tree (MST)** is a subset of edges that:
1. **Connects all vertices** (spanning)
2. **Has no cycles** (tree)
3. **Has minimum total edge weight** (minimum)

```
Graph:                    MST:
    4                        
1 â”€â”€â”€ 2                 1 â”€â”€â”€ 2
â”‚ \   â”‚                 â”‚     â”‚
â”‚  8  â”‚ 7               1     7
1   \ â”‚                 â”‚     â”‚
â”‚    \â”‚                 â”‚     â”‚
3 â”€â”€â”€ 4                 3     4
    9
    
Total weight = 4 + 7 + 1 = 12 (not 1+8+9+7 = 25)
```

**Key Properties:**
- An MST has exactly **V-1 edges** (for V vertices)
- MST may not be unique (multiple valid MSTs possible)
- Removing any edge disconnects the graph
- Adding any edge creates a cycle

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>How to Identify MST Problems</strong></summary>

**Look for these signals:**
- "Connect all points/cities with minimum cost"
- "Minimum total wire/cable/road length"
- "Build a network connecting everything"
- Optimization over a connected graph structure

**Keywords in problem statement:**
- "minimum cost to connect all"
- "spanning", "network", "connect"
- "cable", "wire", "road", "pipe"

**NOT MST if:**
- Need shortest path between two nodes (use Dijkstra)
- Graph is directed (MST is for undirected)
- Don't need to connect all nodes

</details>

---

## âœ… When to Use

- Connecting all points with minimum cost
- Network design (cables, roads, pipes)
- Clustering (remove heaviest edges from MST)
- Approximation for traveling salesman

## âŒ When NOT to Use

| Instead of... | Use... | When... |
|--------------|--------|---------|
| MST | Dijkstra | Need shortest path A to B |
| MST | BFS | Unweighted connectivity |
| Prim's | Kruskal's | Sparse graph, edges given |
| Kruskal's | Prim's | Dense graph, need from specific start |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Graph Basics](../01-Graph-Fundamentals/1.1-Graph-Terminology.md)
- [Union-Find](../07-Union-Find/7.1-Union-Find-Basics.md)
- [Dijkstra](../08-Shortest-Path/8.2-Dijkstra.md) (similar to Prim's)

**After mastering this:**
- Steiner Tree (connect subset of nodes)
- Maximum Spanning Tree (negate weights)
- Second MST

**Combines with:**
- Union-Find for Kruskal's
- Priority Queue for Prim's

</details>

---

## ğŸ“ Two Algorithms Overview

### Kruskal's Algorithm (Edge-centric)

```
1. Sort all edges by weight
2. For each edge (in order):
   - If adding it doesn't create cycle, add it to MST
   - Stop when we have V-1 edges

Uses: Union-Find to check for cycles
Time: O(E log E) for sorting
```

### Prim's Algorithm (Vertex-centric)

```
1. Start with any vertex
2. Repeatedly add the cheapest edge that:
   - Connects MST to a new vertex
3. Stop when all vertices included

Uses: Priority Queue (like Dijkstra)
Time: O(E log V) with binary heap
```

---

## ğŸ’» Quick Reference Code

**Python - Both Algorithms:**
```python
import heapq
from typing import List, Tuple
from collections import defaultdict


class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        root_x, root_y = self.find(x), self.find(y)
        if root_x == root_y:
            return False
        if self.rank[root_x] < self.rank[root_y]:
            root_x, root_y = root_y, root_x
        self.parent[root_y] = root_x
        if self.rank[root_x] == self.rank[root_y]:
            self.rank[root_x] += 1
        return True


def kruskal(n: int, edges: List[Tuple[int, int, int]]) -> int:
    """
    Kruskal's MST algorithm.
    edges = [(u, v, weight), ...]
    
    Time: O(E log E)
    Space: O(V)
    """
    edges.sort(key=lambda x: x[2])  # Sort by weight
    uf = UnionFind(n)
    mst_weight = 0
    edges_used = 0
    
    for u, v, weight in edges:
        if uf.union(u, v):
            mst_weight += weight
            edges_used += 1
            if edges_used == n - 1:
                break
    
    return mst_weight if edges_used == n - 1 else -1


def prim(n: int, graph: dict) -> int:
    """
    Prim's MST algorithm.
    graph[u] = [(v, weight), ...]
    
    Time: O(E log V)
    Space: O(V)
    """
    visited = [False] * n
    heap = [(0, 0)]  # (weight, node)
    mst_weight = 0
    edges_used = 0
    
    while heap and edges_used < n:
        weight, u = heapq.heappop(heap)
        
        if visited[u]:
            continue
        
        visited[u] = True
        mst_weight += weight
        edges_used += 1
        
        for v, w in graph[u]:
            if not visited[v]:
                heapq.heappush(heap, (w, v))
    
    return mst_weight if edges_used == n else -1


# Test
edges = [(0, 1, 4), (0, 2, 1), (1, 2, 2), (1, 3, 5), (2, 3, 8)]
print(f"Kruskal's MST: {kruskal(4, edges)}")  # 7

graph = {
    0: [(1, 4), (2, 1)],
    1: [(0, 4), (2, 2), (3, 5)],
    2: [(0, 1), (1, 2), (3, 8)],
    3: [(1, 5), (2, 8)]
}
print(f"Prim's MST: {prim(4, graph)}")  # 7
```

---

## âš¡ Complexity Comparison

| Algorithm | Time | Space | Best For |
|-----------|------|-------|----------|
| **Kruskal's** | O(E log E) | O(V) | Sparse graphs, edge list |
| **Prim's (heap)** | O(E log V) | O(V) | Dense graphs, adjacency list |
| **Prim's (matrix)** | O(VÂ²) | O(V) | Very dense, no heap needed |

**When to use which:**
- **Kruskal's:** Edges given as list, sparse graph
- **Prim's:** Adjacency list given, dense graph, need to start from specific node

---

## ğŸ”„ Variations

### Maximum Spanning Tree

Just negate all weights:

```python
def max_spanning_tree(n, edges):
    # Negate weights
    neg_edges = [(u, v, -w) for u, v, w in edges]
    neg_edges.sort(key=lambda x: x[2])  # Now sorts max-first
    
    uf = UnionFind(n)
    total = 0
    
    for u, v, neg_w in neg_edges:
        if uf.union(u, v):
            total -= neg_w  # Un-negate
    
    return total
```

### Connect Points (LC 1584)

Given 2D points, connect all with minimum Manhattan distance:

```python
def minCostConnectPoints(points):
    """
    Create complete graph with Manhattan distances,
    then run MST algorithm.
    """
    n = len(points)
    edges = []
    
    for i in range(n):
        for j in range(i + 1, n):
            dist = abs(points[i][0] - points[j][0]) + \
                   abs(points[i][1] - points[j][1])
            edges.append((i, j, dist))
    
    return kruskal(n, edges)
```

---

## âš ï¸ Common Mistakes

### 1. Forgetting Graph is Undirected

```python
# âŒ WRONG: Only adding one direction
graph[u].append((v, w))

# âœ… CORRECT: Add both directions
graph[u].append((v, w))
graph[v].append((u, w))
```

### 2. Not Checking Connectivity

```python
# âŒ WRONG: Assuming all nodes connected
return mst_weight

# âœ… CORRECT: Check if MST actually spans all nodes
return mst_weight if edges_used == n - 1 else -1
```

### 3. Processing Visited Nodes (Prim's)

```python
# âŒ WRONG: Process without checking visited
weight, u = heapq.heappop(heap)
mst_weight += weight  # Might add edge to already-included node!

# âœ… CORRECT: Skip if already in MST
if visited[u]:
    continue
```

---

## ğŸ“ Practice Problems (Progressive)

### Easy (Direct application)
- [ ] [Min Cost to Connect All Points](https://leetcode.com/problems/min-cost-to-connect-all-points/) - MST on points

### Medium (Variations)
- [ ] [Minimum Spanning Tree](https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/) - MST with analysis
- [ ] [Connecting Cities With Minimum Cost](https://leetcode.com/problems/connecting-cities-with-minimum-cost/) - Basic MST

### Hard (Advanced)
- [ ] [Optimize Water Distribution](https://leetcode.com/problems/optimize-water-distribution-in-a-village/) - Virtual node trick
- [ ] [Critical Edges in MST](https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/) - Identify important edges

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

| Day | Activity |
|-----|----------|
| 1 | Implement Kruskal's |
| 3 | Implement Prim's |
| 7 | Solve Min Cost Connect Points |
| 14 | Compare when to use each |

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening:**
> "This is a minimum spanning tree problem. I need to connect all nodes with minimum total weight. I'll use [Kruskal's/Prim's] because [reason]."

**Algorithm choice explanation:**
> "Kruskal's works by sorting edges and greedily adding them if they don't create a cycle. Prim's grows the tree from a starting node, always adding the cheapest edge to a new node."

**Why they work (greedy correctness):**
> "The greedy choice is always safe because the cheapest edge crossing any cut must be in some MST. This is the Cut Property."

</details>

**Company Focus:**
| Company | Frequency | Notes |
|---------|-----------|-------|
| **Amazon** | High | Network design problems |
| **Google** | Medium | Usually with twist |
| **Meta** | Low | Less common |

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn concept | 20 min | Properties of MST |
| Implement Kruskal's | 15 min | With Union-Find |
| Implement Prim's | 15 min | With heap |
| Solve basic problem | 20 min | Connect Points |

---

> **ğŸ’¡ Key Insight:** Both Kruskal's and Prim's are greedy algorithms that work because of the **Cut Property**: the minimum weight edge crossing any cut is safe to add to the MST.

---

> **ğŸ”— Related:** [Union-Find](../07-Union-Find/7.1-Union-Find-Basics.md) | [Dijkstra](../08-Shortest-Path/8.2-Dijkstra.md) | [Prim's Details](./11.2-Prims-Algorithm.md)

---

**Next:** [Prim's Algorithm â†’](./11.2-Prims-Algorithm.md)
