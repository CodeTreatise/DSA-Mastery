# 8.3 Greedy Sorting Tricks

> **Definition:** Many greedy problems require specific sorting strategies to enable optimal choices. The sorting criterion is often the key insight that makes greedy work.

---

## ğŸ¯ Pattern Recognition

**Sorting is likely needed when:**

| Signal | Sorting Strategy |
|--------|------------------|
| "Maximize/minimize" with constraints | Sort by the constraint |
| Intervals | By start OR end (depends on problem) |
| Matching problems | Sort both arrays |
| "Best first" | Sort by value/ratio |
| Deadlines | Sort by deadline |
| Two choices per item | Sort by difference |

---

## ğŸ“ The Major Sorting Strategies

### 1. Sort by End (Activity Selection)

**Use when:** Maximizing count of non-overlapping items

```python
# Maximum non-overlapping intervals
intervals.sort(key=lambda x: x[1])  # Sort by END
```

**Why:** Earlier end = more room for future selections

**Problems:** Activity Selection, Non-overlapping Intervals, Arrows to Burst Balloons

---

### 2. Sort by Start (Merging)

**Use when:** Detecting or merging overlaps

```python
# Merge overlapping intervals
intervals.sort(key=lambda x: x[0])  # Sort by START
```

**Why:** Processing in order reveals overlaps immediately

**Problems:** Merge Intervals, Insert Interval, Meeting Rooms

---

### 3. Sort by Deadline

**Use when:** Completing tasks before deadlines

```python
# Maximum tasks before deadline
tasks.sort(key=lambda x: x[1])  # Sort by DEADLINE
```

**Why:** Handle urgent tasks first

**Problems:** Course Schedule III, Job Sequencing

---

### 4. Sort by Ratio (Value per Unit)

**Use when:** Optimizing value with capacity constraint

```python
# Fractional knapsack
items.sort(key=lambda x: x.value / x.weight, reverse=True)
```

**Why:** Maximize "bang for buck"

**Problems:** Fractional Knapsack

---

### 5. Sort by Difference

**Use when:** Binary choice with equal split constraint

```python
# Two City Scheduling
costs.sort(key=lambda x: x[0] - x[1])  # Sort by (costA - costB)
```

**Why:** Reveals who benefits most from each choice

**Problems:** Two City Scheduling

---

### 6. Sort Both Arrays (Matching)

**Use when:** Matching items from two sets

```python
# Assign Cookies
children.sort()
cookies.sort()
# Then two-pointer matching
```

**Why:** Match smallest to smallest to maximize matches

**Problems:** Assign Cookies, Boats to Save People

---

## ğŸ’» Code Examples

### Activity Selection (Sort by End)

```python
def maxActivities(activities: list[tuple[int, int]]) -> int:
    """
    Maximum non-overlapping activities.
    Sort by end time, greedily pick.
    """
    activities.sort(key=lambda x: x[1])  # By END
    
    count = 0
    last_end = float('-inf')
    
    for start, end in activities:
        if start >= last_end:
            count += 1
            last_end = end
    
    return count
```

### Merge Intervals (Sort by Start)

```python
def merge(intervals: list[list[int]]) -> list[list[int]]:
    """
    Merge overlapping intervals.
    Sort by start time, merge as we go.
    """
    intervals.sort(key=lambda x: x[0])  # By START
    
    merged = [intervals[0]]
    
    for start, end in intervals[1:]:
        if start <= merged[-1][1]:
            merged[-1][1] = max(merged[-1][1], end)
        else:
            merged.append([start, end])
    
    return merged
```

### Fractional Knapsack (Sort by Ratio)

```python
def fractionalKnapsack(items: list[tuple[int, int]], capacity: int) -> float:
    """
    items: list of (value, weight)
    """
    # Sort by value/weight ratio (descending)
    items.sort(key=lambda x: x[0] / x[1], reverse=True)
    
    total = 0.0
    remaining = capacity
    
    for value, weight in items:
        if weight <= remaining:
            total += value
            remaining -= weight
        else:
            total += (value / weight) * remaining
            break
    
    return total
```

### Two City Scheduling (Sort by Difference)

```python
def twoCitySchedCost(costs: list[list[int]]) -> int:
    """
    Sort by costA - costB to find who benefits most from A.
    """
    n = len(costs) // 2
    costs.sort(key=lambda x: x[0] - x[1])
    
    total = 0
    for i in range(n):
        total += costs[i][0]  # First n to A
    for i in range(n, 2 * n):
        total += costs[i][1]  # Rest to B
    
    return total
```

---

## ğŸ“Š Sorting Strategy Cheat Sheet

| Problem Type | Sort By | Order | Reason |
|--------------|---------|-------|--------|
| Max non-overlapping | End | Ascending | Leave room for more |
| Merge overlaps | Start | Ascending | Detect overlaps |
| Meet deadlines | Deadline | Ascending | Urgent first |
| Value optimization | Ratio | Descending | Best value first |
| Binary choice | Difference | Ascending | Best benefit |
| Matching | Both arrays | Ascending | Two-pointer |
| Minimize total | Duration | Ascending | Short jobs first |

---

## âš¡ Complexity Impact

| Operation | Complexity | Impact on Total |
|-----------|------------|-----------------|
| Sorting | O(n log n) | Usually dominates |
| Greedy scan | O(n) | After sort |
| With heap | O(n log k) | May exceed sort |

**Key insight:** Sorting is often the most expensive step, making the overall complexity O(n log n).

---

## âš ï¸ Common Mistakes

### 1. Wrong Sort Key

```python
# âŒ Wrong: Sort by start for activity selection
activities.sort(key=lambda x: x[0])  # Wrong!

# âœ… Correct: Sort by END for activity selection
activities.sort(key=lambda x: x[1])
```

### 2. Forgetting Reverse

```python
# âŒ Wrong: Ascending for "best first"
items.sort(key=lambda x: x.value)  # Smallest first!

# âœ… Correct: Descending for best first
items.sort(key=lambda x: x.value, reverse=True)
```

### 3. Not Sorting Before Processing

```python
# âŒ Wrong: Processing unsorted
for interval in intervals:
    if overlaps(interval, prev):
        merge(...)

# âœ… Correct: Sort first
intervals.sort(key=lambda x: x[0])
for interval in intervals:
    ...
```

### 4. Modifying While Sorting

```python
# âŒ Wrong: Modifying list during iteration
for i, interval in enumerate(intervals):
    intervals.sort()  # Chaos!

# âœ… Correct: Sort once before loop
intervals.sort(key=lambda x: x[0])
for interval in intervals:
    ...
```

---

## ğŸ“ Decision Tree: Which Sort?

```
Is it an interval problem?
â”œâ”€â”€ Yes: Do you need non-overlapping?
â”‚   â”œâ”€â”€ Yes â†’ Sort by END
â”‚   â””â”€â”€ No (merging) â†’ Sort by START
â”‚
â””â”€â”€ No: Is there a deadline?
    â”œâ”€â”€ Yes â†’ Sort by DEADLINE
    â”‚
    â””â”€â”€ No: Is there a capacity/limit?
        â”œâ”€â”€ Yes â†’ Sort by RATIO (value/weight)
        â”‚
        â””â”€â”€ No: Is it a binary choice?
            â”œâ”€â”€ Yes â†’ Sort by DIFFERENCE
            â”‚
            â””â”€â”€ No: Is it matching?
                â”œâ”€â”€ Yes â†’ Sort BOTH arrays
                â””â”€â”€ No â†’ Consider other criteria
```

---

## ğŸ“ Practice Problems by Sort Type

### Sort by End
- [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)
- [Minimum Arrows](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)
- [Erase Overlap Intervals](https://leetcode.com/problems/non-overlapping-intervals/)

### Sort by Start
- [Merge Intervals](https://leetcode.com/problems/merge-intervals/)
- [Insert Interval](https://leetcode.com/problems/insert-interval/)
- [Meeting Rooms](https://leetcode.com/problems/meeting-rooms/)

### Sort by Deadline
- [Course Schedule III](https://leetcode.com/problems/course-schedule-iii/)

### Sort by Ratio
- Fractional Knapsack (GFG)

### Sort by Difference
- [Two City Scheduling](https://leetcode.com/problems/two-city-scheduling/)

### Sort Both
- [Assign Cookies](https://leetcode.com/problems/assign-cookies/)
- [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/)

---

## ğŸ¤ Interview Tips

<details>
<summary><strong>How to Communicate Sort Choice</strong></summary>

**When explaining:**
"The key insight is sorting by [criterion]. This works because [reason]."

**Examples:**

**Activity Selection:**
"I'll sort by end time. This ensures that when I pick an activity, I leave maximum room for future activities."

**Merge Intervals:**
"Sorting by start time lets me process intervals in order. When I see a new interval, I can immediately tell if it overlaps with the previous one."

**Two City Scheduling:**
"I'll sort by the difference (costA - costB). Negative differences mean A is cheaper, so I send those people to A."

</details>

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Identify sort needed | 1-2 min |
| Determine sort key | 2-3 min |
| Implement sort | 1 min |
| Greedy logic after sort | 3-5 min |
| **Total** | **7-11 min** |

---

> **ğŸ’¡ Key Insight:** The sorting criterion often IS the greedy insight. If you're stuck, ask "what should I process first?" - the answer suggests the sort key.

> **ğŸ”— Related:** [Interval Patterns](../02-Interval-Pattern/4.1-Interval-Greedy-Overview.md) | [Classic Problems](../05-Classic-Greedy/7.1-Classic-Problems-Overview.md)
