# 3.2 BFS Template

> **The universal BFS template for any problem - memorize this pattern**
>
> â±ï¸ **Time:** 30-40 min | ğŸ“Š **Difficulty:** Core | ğŸ¯ **Interview Frequency:** â­â­â­â­â­

---

## Overview

This template is the **foundation for all BFS problems**. Memorize it, understand each part, and adapt it to specific problems.

```
The BFS Template Components:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. INITIALIZATION                                   â”‚
â”‚     - Queue with starting state(s)                  â”‚
â”‚     - Visited set with starting state(s)            â”‚
â”‚     - (Optional) Distance/level tracking            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  2. BFS LOOP                                         â”‚
â”‚     while queue:                                    â”‚
â”‚         - Dequeue current state                     â”‚
â”‚         - (Optional) Check if goal reached          â”‚
â”‚         - Generate next states (neighbors)          â”‚
â”‚         - For each valid unvisited state:           â”‚
â”‚           - Mark visited                            â”‚
â”‚           - Enqueue                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  3. RETURN RESULT                                    â”‚
â”‚     - Path found / distance / visited states        â”‚
â”‚     - Or -1 / empty if no solution                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>When to Apply This Template</strong></summary>

**Direct application (change nothing):**
- Basic graph traversal
- Shortest path (unweighted)
- Level-order tree traversal

**Modify initialization:**
- Multi-source BFS â†’ Start with multiple nodes in queue
- Grid BFS â†’ Start at (row, col)

**Modify "get neighbors":**
- Grid â†’ 4 or 8 directions
- State machine â†’ Valid transitions
- Word ladder â†’ Words differing by 1 character

**Modify visited representation:**
- Simple graph â†’ Set of nodes
- Grid â†’ Set of (row, col)
- Complex state â†’ Set of (state tuple)

</details>

---

## âœ… When to Use This Template

| Scenario | Template Adaptation |
|----------|---------------------|
| Graph shortest path | Standard template |
| Grid traversal | Neighbors = 4/8 directions |
| Level-order traversal | Track level with size loop |
| State transformation | State = problem-specific tuple |
| Multi-source | Initialize queue with all sources |

---

## âŒ When NOT to Use This Template

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Weighted graphs | Need priority | Dijkstra template |
| Find all paths | Need enumeration | DFS with backtracking |
| Topological order | Special processing | Kahn's algorithm |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BFS Fundamentals](./3.1-BFS-Fundamentals.md)
- Queue data structure

**This template applies to:**
- [Multi-Source BFS](./3.3-Multi-Source-BFS.md)
- [Grid Traversal](../05-Grid-Traversal/5.1-Grid-Introduction.md)
- All BFS practice problems

</details>

---

## ğŸ’» The Universal BFS Template

### Template 1: Basic BFS (Graph/State)

**Python:**
```python
from collections import deque

def bfs_template(graph, start, target=None):
    """
    Universal BFS template.
    
    Adapt by changing:
    - What goes in queue (state representation)
    - How to get neighbors (graph[node] vs. generate states)
    - What to check (visited representation)
    - When to return (target condition)
    
    Time: O(V + E) or O(states Ã— transitions)
    Space: O(V) or O(states)
    """
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 1: INITIALIZATION
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    visited = set([start])           # Mark start as visited
    queue = deque([start])           # Add start to queue
    # Optional: track distance/parent
    # distance = {start: 0}
    # parent = {start: None}
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 2: BFS LOOP
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    while queue:
        current = queue.popleft()    # Dequeue (FIFO)
        
        # Optional: Check if we've reached the goal
        if current == target:
            return True  # or return distance[current], reconstruct path, etc.
        
        # Process all neighbors/next states
        for neighbor in get_neighbors(current, graph):  # Adapt this!
            if neighbor not in visited:
                visited.add(neighbor)     # Mark visited BEFORE adding
                queue.append(neighbor)
                # Optional: track distance/parent
                # distance[neighbor] = distance[current] + 1
                # parent[neighbor] = current
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 3: RETURN RESULT
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    return False  # Target not found (or return visited, distance, etc.)


def get_neighbors(node, graph):
    """Adapt this function based on problem type."""
    return graph.get(node, [])
```

### Template 2: BFS with Distance Tracking

**Python:**
```python
from collections import deque

def bfs_with_distance(graph, start, target):
    """
    BFS that returns shortest distance to target.
    
    Key: Store (node, distance) tuples in queue
    """
    if start == target:
        return 0
    
    visited = set([start])
    queue = deque([(start, 0)])  # (node, distance)
    
    while queue:
        node, dist = queue.popleft()
        
        for neighbor in graph.get(node, []):
            if neighbor == target:
                return dist + 1
            
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, dist + 1))
    
    return -1  # Not reachable
```

### Template 3: BFS Level by Level

**Python:**
```python
from collections import deque

def bfs_by_level(graph, start):
    """
    BFS that processes one level at a time.
    
    Use when you need:
    - Count number of levels
    - Process all nodes at same distance together
    - Tree level-order traversal
    """
    visited = set([start])
    queue = deque([start])
    level = 0
    
    while queue:
        level_size = len(queue)  # Nodes at current level
        
        # Process entire level
        for _ in range(level_size):
            node = queue.popleft()
            # Process node at current level
            
            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        level += 1  # Move to next level
    
    return level  # Total depth
```

### Template 4: BFS on Grid

**Python:**
```python
from collections import deque

def bfs_grid(grid, start_row, start_col, target_val):
    """
    BFS template for 2D grid problems.
    
    Adapt:
    - DIRECTIONS for 8-directional movement
    - is_valid() for problem-specific constraints
    - target condition
    """
    if not grid or not grid[0]:
        return -1
    
    rows, cols = len(grid), len(grid[0])
    
    # 4-directional movement (up, down, left, right)
    DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    # For 8-directional: add diagonals
    # DIRECTIONS = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
    
    def is_valid(r, c):
        """Check if cell is within bounds and not blocked."""
        return (0 <= r < rows and 
                0 <= c < cols and 
                grid[r][c] != 0)  # Adapt this condition
    
    # Initialize
    visited = set()
    visited.add((start_row, start_col))
    queue = deque([(start_row, start_col, 0)])  # (row, col, distance)
    
    while queue:
        row, col, dist = queue.popleft()
        
        # Check if target reached
        if grid[row][col] == target_val:
            return dist
        
        # Explore 4 directions
        for dr, dc in DIRECTIONS:
            new_row, new_col = row + dr, col + dc
            
            if is_valid(new_row, new_col) and (new_row, new_col) not in visited:
                visited.add((new_row, new_col))
                queue.append((new_row, new_col, dist + 1))
    
    return -1  # Target not reachable
```

### Template 5: Multi-Source BFS

**Python:**
```python
from collections import deque

def multi_source_bfs(grid, sources):
    """
    BFS starting from multiple sources simultaneously.
    
    Use for:
    - Rotting Oranges (all rotten start together)
    - 01 Matrix (all 0s start together)
    - Walls and Gates
    
    Key insight: Add ALL sources to queue initially
    """
    if not grid:
        return -1
    
    rows, cols = len(grid), len(grid[0])
    DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    # Initialize with ALL sources
    visited = set(sources)
    queue = deque()
    for r, c in sources:
        queue.append((r, c, 0))  # All start at distance 0
    
    max_distance = 0
    
    while queue:
        row, col, dist = queue.popleft()
        max_distance = max(max_distance, dist)
        
        for dr, dc in DIRECTIONS:
            new_row, new_col = row + dr, col + dc
            
            if (0 <= new_row < rows and 
                0 <= new_col < cols and 
                (new_row, new_col) not in visited):
                
                visited.add((new_row, new_col))
                queue.append((new_row, new_col, dist + 1))
    
    return max_distance
```

### Template 6: BFS with State

**Python:**
```python
from collections import deque

def bfs_with_state(start_state, is_goal, get_next_states):
    """
    BFS for complex state problems.
    
    Use for:
    - Open the Lock (state = lock combination)
    - Word Ladder (state = current word)
    - Shortest Path with Keys (state = (position, keys_collected))
    
    Key: State must be hashable (tuple, string, frozenset)
    """
    visited = set([start_state])
    queue = deque([(start_state, 0)])  # (state, steps)
    
    while queue:
        state, steps = queue.popleft()
        
        if is_goal(state):
            return steps
        
        for next_state in get_next_states(state):
            if next_state not in visited:
                visited.add(next_state)
                queue.append((next_state, steps + 1))
    
    return -1


# Example: Open the Lock
def solve_open_lock(deadends, target):
    """Example using BFS with state template."""
    dead = set(deadends)
    if "0000" in dead:
        return -1
    
    def is_goal(state):
        return state == target
    
    def get_next_states(state):
        """Generate all possible next states (turn one wheel up or down)."""
        states = []
        for i in range(4):
            digit = int(state[i])
            # Turn up
            up = (digit + 1) % 10
            states.append(state[:i] + str(up) + state[i+1:])
            # Turn down  
            down = (digit - 1) % 10
            states.append(state[:i] + str(down) + state[i+1:])
        return [s for s in states if s not in dead]
    
    return bfs_with_state("0000", is_goal, get_next_states)
```

**JavaScript:**
```javascript
// Template 1: Basic BFS
function bfsTemplate(graph, start, target = null) {
    const visited = new Set([start]);
    const queue = [start];
    
    while (queue.length > 0) {
        const current = queue.shift();
        
        if (current === target) {
            return true;
        }
        
        for (const neighbor of graph.get(current) || []) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }
    
    return false;
}

// Template 2: BFS with Distance
function bfsWithDistance(graph, start, target) {
    if (start === target) return 0;
    
    const visited = new Set([start]);
    const queue = [[start, 0]];
    
    while (queue.length > 0) {
        const [node, dist] = queue.shift();
        
        for (const neighbor of graph.get(node) || []) {
            if (neighbor === target) return dist + 1;
            
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push([neighbor, dist + 1]);
            }
        }
    }
    
    return -1;
}

// Template 4: BFS on Grid
function bfsGrid(grid, startRow, startCol) {
    const rows = grid.length, cols = grid[0].length;
    const DIRECTIONS = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    
    const visited = new Set();
    visited.add(`${startRow},${startCol}`);
    const queue = [[startRow, startCol, 0]];
    
    while (queue.length > 0) {
        const [row, col, dist] = queue.shift();
        
        for (const [dr, dc] of DIRECTIONS) {
            const newRow = row + dr;
            const newCol = col + dc;
            const key = `${newRow},${newCol}`;
            
            if (newRow >= 0 && newRow < rows &&
                newCol >= 0 && newCol < cols &&
                !visited.has(key) &&
                grid[newRow][newCol] !== 0) {
                
                visited.add(key);
                queue.push([newRow, newCol, dist + 1]);
            }
        }
    }
    
    return -1;
}
```

---

## ğŸ“ Template Decision Flowchart

```
                    Start
                      â”‚
                      â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Shortest path â”‚â”€â”€Yesâ”€â”€â–º Template 2 (with distance)
              â”‚ needed?       â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ No
                      â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Level-by-levelâ”‚â”€â”€Yesâ”€â”€â–º Template 3 (level processing)
              â”‚ processing?   â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ No
                      â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ 2D Grid?      â”‚â”€â”€Yesâ”€â”€â–º Template 4 (grid BFS)
              â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ No
                      â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Multiple      â”‚â”€â”€Yesâ”€â”€â–º Template 5 (multi-source)
              â”‚ start points? â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ No
                      â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Complex state?â”‚â”€â”€Yesâ”€â”€â–º Template 6 (state BFS)
              â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ No
                      â–¼
                Template 1 (basic)
```

---

## âš¡ Complexity Analysis

| Template | Time | Space | Use Case |
|----------|------|-------|----------|
| Basic | O(V + E) | O(V) | Simple traversal |
| With Distance | O(V + E) | O(V) | Shortest path |
| By Level | O(V + E) | O(V) | Level-order |
| Grid | O(R Ã— C) | O(R Ã— C) | 2D matrix |
| Multi-Source | O(R Ã— C) | O(R Ã— C) | Multiple starts |
| With State | O(States Ã— Transitions) | O(States) | Complex state |

---

## ğŸ”„ Template Adaptations

| Problem Type | Key Modification |
|--------------|------------------|
| Tree (not graph) | No visited set needed |
| Implicit graph | Generate neighbors dynamically |
| Bidirectional | Two queues, meet in middle |
| Weighted 0-1 | Use deque (addleft for 0-weight) |

---

## âš ï¸ Common Mistakes

### 1. Forgetting Edge Cases

```python
# âŒ Wrong: No check for empty input
def bfs(grid, start):
    queue = deque([start])
    # Crashes if grid is empty

# âœ… Correct: Handle edge cases first
def bfs(grid, start):
    if not grid or not grid[0]:
        return -1
    # ...
```

### 2. Wrong State Representation

```python
# âŒ Wrong: Using list (unhashable) for visited
state = [row, col, keys]
visited.add(state)  # Error!

# âœ… Correct: Use tuple (hashable)
state = (row, col, frozenset(keys))
visited.add(state)
```

### 3. Modifying Queue During Iteration

```python
# âŒ Wrong: Modifying while iterating
for item in queue:
    queue.append(new_item)  # Undefined behavior

# âœ… Correct: Use while loop with popleft
while queue:
    item = queue.popleft()
    queue.append(new_item)  # Safe
```

---

## ğŸ“ Practice Problems

### Apply Template 2 (Distance)
| Problem | Link |
|---------|------|
| Word Ladder | [LC 127](https://leetcode.com/problems/word-ladder/) |

### Apply Template 3 (Level)
| Problem | Link |
|---------|------|
| Binary Tree Level Order | [LC 102](https://leetcode.com/problems/binary-tree-level-order-traversal/) |

### Apply Template 4 (Grid)
| Problem | Link |
|---------|------|
| Shortest Path in Binary Matrix | [LC 1091](https://leetcode.com/problems/shortest-path-in-binary-matrix/) |

### Apply Template 5 (Multi-Source)
| Problem | Link |
|---------|------|
| Rotting Oranges | [LC 994](https://leetcode.com/problems/rotting-oranges/) |

### Apply Template 6 (State)
| Problem | Link |
|---------|------|
| Open the Lock | [LC 752](https://leetcode.com/problems/open-the-lock/) |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Write Template 1 from memory
- **Day 3:** Write Templates 2, 4 from memory
- **Day 7:** Solve one problem with each template
- **Day 14:** Identify which template to use for 5 new problems

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>Template Discussion in Interviews</strong></summary>

**When starting a BFS problem:**
> "I'll use the standard BFS template: initialize queue and visited set, then process level by level. Let me adapt it for this specific problem..."

**When choosing template:**
> "Since I need the minimum number of steps, I'll track distance in my queue. Each entry will be (node, distance)."

**When explaining modifications:**
> "The key modification here is how I generate neighbors. Instead of using an adjacency list, I'll generate all valid next states by [problem-specific logic]."

</details>

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Memorize Template 1 | 15-20 min |
| Learn all 6 templates | 45-60 min |
| Apply to first problem | 20-30 min |
| **Master template selection** | **2-3 hours** |

---

> **ğŸ’¡ Key Insight:** The BFS template is remarkably consistent across problems. The only things that change are: (1) what you put in the queue (your "state"), (2) how you generate neighbors, and (3) when you stop.

> **ğŸ”— Related:** [BFS Fundamentals](./3.1-BFS-Fundamentals.md) | [Multi-Source BFS](./3.3-Multi-Source-BFS.md) | [Grid Traversal](../05-Grid-Traversal/5.1-Grid-Introduction.md)

---

**Previous:** [â† 3.1 BFS Fundamentals](./3.1-BFS-Fundamentals.md)  
**Next:** [3.3 Multi-Source BFS â†’](./3.3-Multi-Source-BFS.md)
