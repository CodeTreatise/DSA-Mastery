# 1.1 - Tree Terminology

> **Foundation:** Essential vocabulary for understanding trees
>
> **Priority:** Must learn first before any tree problems

---

## Overview

Trees are hierarchical data structures consisting of **nodes** connected by **edges**. Unlike linear structures (arrays, linked lists), trees branch out, making them perfect for representing hierarchical relationships.

```
        Root
       /    \
   Child    Child
   /   \       \
Leaf  Leaf    Leaf
```

---

## üéØ Core Terminology

### Node Components

| Term | Definition | Example |
|------|------------|---------|
| **Node** | Basic unit containing data | Each circle in diagram |
| **Edge** | Connection between two nodes | Lines connecting circles |
| **Root** | Topmost node, no parent | Node A below |
| **Leaf** | Node with no children | Nodes D, E, F, G |
| **Internal Node** | Node with at least one child | Nodes B, C |

```
        A        ‚Üê Root
       / \
      B   C      ‚Üê Internal nodes
     / \   \
    D   E   F    ‚Üê Leaves
```

### Relationships

| Term | Definition | Example |
|------|------------|---------|
| **Parent** | Node directly above | B is parent of D, E |
| **Child** | Node directly below | D, E are children of B |
| **Siblings** | Nodes with same parent | D and E are siblings |
| **Ancestor** | Any node on path to root | A, B are ancestors of D |
| **Descendant** | Any node in subtree below | D, E are descendants of B |

### Path & Distance

| Term | Definition | Example |
|------|------------|---------|
| **Path** | Sequence of nodes connected by edges | A ‚Üí B ‚Üí D |
| **Depth** | Distance from root (edges) | D has depth 2 |
| **Height** | Longest path to a leaf | A has height 2 |
| **Level** | All nodes at same depth | Level 1: B, C |

```
Level 0:      A         ‚Üê Height = 2
             / \
Level 1:    B   C       ‚Üê Depth = 1
           / \   \
Level 2:  D   E   F     ‚Üê Depth = 2 (leaves)
```

---

## üìê Tree Properties

### Height vs Depth

```
        A    depth=0, height=3
       / \
      B   C  depth=1, height=2
     / \
    D   E    depth=2, height=1
   /
  F          depth=3, height=0 (leaf)

Height of tree = height of root = 3
Depth of F = 3
Height of F = 0
```

**Key difference:**
- **Depth:** Count edges DOWN from root TO node
- **Height:** Count edges UP from node TO deepest leaf

### Size Calculations

| Property | Formula | Notes |
|----------|---------|-------|
| Minimum nodes (height h) | h + 1 | Skewed tree |
| Maximum nodes (height h) | 2^(h+1) - 1 | Perfect binary tree |
| Minimum height (n nodes) | ‚åälog‚ÇÇ n‚åã | Balanced tree |
| Maximum height (n nodes) | n - 1 | Skewed tree |

---

## üå≥ Binary Tree Types

### By Node Count

| Type | Definition | Diagram |
|------|------------|---------|
| **Full** | Every node has 0 or 2 children | ![Full](# "Every internal node has 2 children") |
| **Complete** | All levels filled except last, filled left to right | Heap-like |
| **Perfect** | All internal nodes have 2 children, all leaves same level | Symmetric |

```
Full:           Complete:        Perfect:
    1               1                1
   / \             / \              / \
  2   3           2   3            2   3
 / \             / \              / \ / \
4   5           4   5            4  5 6  7
```

### By Balance

| Type | Definition | Height Guarantee |
|------|------------|------------------|
| **Balanced** | Height difference ‚â§ 1 for all nodes |" O(log n) "|
| **Skewed** | All nodes lean one direction |" O(n) "|

```
Balanced:          Left-Skewed:    Right-Skewed:
    2                 1                1
   / \                 \              /
  1   3                 2            2
                         \            /
                          3          3
```

### Special Binary Trees

| Type | Property | Use Case |
|------|----------|----------|
| **BST** | Left < Node < Right | Searching, sorting |
| **Heap** | Parent ‚â• or ‚â§ children | Priority queues |
| **AVL** | Self-balancing BST |" Guaranteed O(log n) "|
| **Red-Black** | Self-balancing with colors | std::map, TreeMap |

---

## üíª Code Representation

### TreeNode Class

**Python:**
```python
class TreeNode:
    """Standard binary tree node."""
    
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left      # Left child
        self.right = right    # Right child
```

**JavaScript:**
```javascript
class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### Building a Tree

**Python:**
```python
# Manual construction
#       1
#      / \
#     2   3
#    / \
#   4   5

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
```

### Helper: Build from List

**Python:**
```python
from collections import deque
from typing import Optional, List

def build_tree(values: List[Optional[int]]) -> Optional[TreeNode]:
    """
    Build tree from level-order list (LeetCode format).
    Example: [1, 2, 3, None, None, 4, 5]
    """
    if not values or values[0] is None:
        return None
    
    root = TreeNode(values[0])
    queue = deque([root])
    i = 1
    
    while queue and i < len(values):
        node = queue.popleft()
        
        # Left child
        if i < len(values) and values[i] is not None:
            node.left = TreeNode(values[i])
            queue.append(node.left)
        i += 1
        
        # Right child
        if i < len(values) and values[i] is not None:
            node.right = TreeNode(values[i])
            queue.append(node.right)
        i += 1
    
    return root

# Usage
root = build_tree([1, 2, 3, None, None, 4, 5])
```

---

## ‚ö° Why Trees Matter

### Time Complexity Comparison

| Operation | Array (sorted) | Linked List | Binary Tree (balanced) | BST (balanced) |
|-----------|---------------|-------------|----------------------|----------------|
| Search |" O(log n) "| O(n) |" O(n) "| O(log n) |
| Insert |" O(n) "| O(1) |" O(1)* "| O(log n) |
| Delete |" O(n) "| O(1)* |" O(1)* "| O(log n) |

*After finding the position

### Real-World Uses

| Structure | Example |
|-----------|---------|
| File System | Directories and files |
| DOM | HTML document structure |
| Organization | Company hierarchy |
| Database | B-trees for indexing |
| Compiler | Syntax trees |

---

## üîÑ Tree Traversal Overview

| Traversal | Order | Common Use |
|-----------|-------|------------|
| **Preorder** | Root ‚Üí Left ‚Üí Right | Copy tree, prefix expression |
| **Inorder** | Left ‚Üí Root ‚Üí Right | BST sorted order |
| **Postorder** | Left ‚Üí Right ‚Üí Root | Delete tree, postfix expression |
| **Level-order** | Level by level | BFS, find depth |

```
        1
       / \
      2   3

Preorder:    1, 2, 3  (Root first)
Inorder:     2, 1, 3  (Root middle)
Postorder:   2, 3, 1  (Root last)
Level-order: 1, 2, 3  (Top to bottom)
```

---

## ‚ö†Ô∏è Common Terminology Mistakes

### 1. Height vs Depth

```python
# ‚ùå WRONG: Thinking height and depth are the same
height_of_node = depth_of_node  # NO!

# ‚úÖ CORRECT:
# Depth = distance from root (going DOWN)
# Height = distance to deepest leaf (going UP)
```

### 2. Edge vs Node Counting

```python
# ‚ùå WRONG: Counting nodes for depth
depth = number_of_nodes_from_root

# ‚úÖ CORRECT: Count edges for depth
depth = number_of_edges_from_root
# A node at level 2 has depth 2 (2 edges from root)
```

### 3. Full vs Complete

```python
# Full: Every node has 0 OR 2 children (can have gaps)
# Complete: All levels full except last, which is filled left-to-right

# This is COMPLETE but NOT FULL:
#       1
#      / \
#     2   3
#    /
#   4

# This is FULL but NOT COMPLETE:
#       1
#      / \
#     2   3
#        / \
#       4   5
```

---

## üìù Quick Reference Card

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   TREE TERMINOLOGY                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Root: Top node, no parent                          ‚îÇ
‚îÇ  Leaf: Bottom node, no children                     ‚îÇ
‚îÇ  Internal: Has at least one child                   ‚îÇ
‚îÇ  Depth: Edges from root TO node                     ‚îÇ
‚îÇ  Height: Edges from node TO deepest leaf            ‚îÇ
‚îÇ  Level: All nodes at same depth                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Full: 0 or 2 children for every node               ‚îÇ
‚îÇ  Complete: Filled left-to-right on last level       ‚îÇ
‚îÇ  Perfect: Full + all leaves same level              ‚îÇ
‚îÇ  Balanced: Height difference ‚â§ 1                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Binary Tree: Max 2 children per node               ‚îÇ
‚îÇ  BST: Left < Node < Right                           ‚îÇ
‚îÇ  Heap: Parent ‚â• or ‚â§ children                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üé§ Interview Context

<details>
<summary><strong>Clarifying Questions to Ask</strong></summary>

When given a tree problem, clarify:
1. "Is this a binary tree or can nodes have more than 2 children?"
2. "Is it a BST with ordering property?"
3. "Can nodes have duplicate values?"
4. "Is the tree balanced?"
5. "How is the tree represented? (TreeNode class, array, etc.)"

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn terminology | 15-20 min | Foundation |
| Practice identifying | 10 min | Quiz yourself |
| Remember long-term | Review weekly | Spaced repetition |

---

> **üí° Key Insight:** Mastering terminology is like learning a language - it makes communication (with interviewers and code) much clearer. When you hear "depth 3, balanced BST," you should immediately visualize the structure.

---

## üîó Related

- [TreeNode Class](./1.2-TreeNode-Class.md)
- [Tree Traversal Overview](./1.3-Traversal-Overview.md)
- [Binary Tree vs BST](../02-Binary-Tree-Basics/2.1-Binary-Trees.md)
