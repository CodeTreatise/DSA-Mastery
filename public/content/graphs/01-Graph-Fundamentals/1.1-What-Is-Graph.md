# 1.1 What Is a Graph?

> **Foundation concept for all graph algorithms**
>
> â±ï¸ **Time:** 20-30 min | ğŸ“Š **Difficulty:** Beginner | ğŸ¯ **Interview Frequency:** Foundation

---

## Overview

A **graph** is a non-linear data structure consisting of **vertices** (nodes) and **edges** (connections between nodes). Graphs model relationships between entities and are fundamental to solving problems involving networks, paths, dependencies, and connections.

**Formal Definition:** A graph G is defined as G = (V, E) where:
- **V** = Set of vertices (nodes)
- **E** = Set of edges (connections)

```
Graph G = (V, E)
V = {A, B, C, D}
E = {(A,B), (A,C), (B,D), (C,D)}

    A â”€â”€â”€ B
    â”‚     â”‚
    C â”€â”€â”€ D
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>When Graph Concepts Apply</strong></summary>

**You're dealing with a graph when you see:**

- **Relationships/Connections:** "cities connected by roads", "friends in a network"
- **Dependencies:** "course prerequisites", "task ordering"
- **Paths/Routes:** "shortest path between", "all possible ways"
- **Groups/Components:** "connected regions", "clusters"
- **Networks:** "computer network", "social network"

**Keywords in problem statements:**
- "connected", "path", "reachable", "neighbors"
- "network", "graph", "nodes", "edges"
- "dependencies", "prerequisites", "ordering"
- "shortest", "minimum steps", "fewest hops"

</details>

---

## âœ… When to Use Graphs

| Scenario | Example |
|----------|---------|
| Modeling connections | Social networks, road maps |
| Finding paths | Navigation, routing algorithms |
| Detecting cycles | Deadlock detection, dependency validation |
| Grouping connected items | Connected components, clustering |
| Ordering with dependencies | Task scheduling, build systems |

---

## âŒ When NOT to Use Graphs

| Scenario | Better Alternative |
|----------|-------------------|
| Linear sequential data | Arrays, Linked Lists |
| Hierarchical parent-child only | Trees |
| Key-value lookups | Hash Maps |
| Sorted range queries | BST, Balanced Trees |
| Simple FIFO/LIFO operations | Queues, Stacks |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Arrays & Lists](../../01-Arrays-Strings/01-Arrays/1.1-Array-Basics.md)
- [Hash Maps](../../09-Hashing/01-Hash-Fundamentals/1.1-What-Is-Hashing.md)
- [Recursion](../../02-Recursion-Backtracking/01-Recursion/1.1-Recursion-Basics.md)

**After mastering this:**
- [Graph Terminology](./1.2-Graph-Terminology.md) - Learn all the vocabulary
- [Types of Graphs](./1.3-Types-Of-Graphs.md) - Directed, weighted, etc.
- [Graph Representation](../02-Graph-Representation/2.1-Adjacency-Matrix.md) - How to store graphs

**Foundation for:**
- BFS and DFS traversals
- Shortest path algorithms
- Topological sorting
- Union-Find data structure

</details>

---

## ğŸ“ How It Works

### Components of a Graph

```
          GRAPH STRUCTURE
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                             â”‚
    â”‚    [A] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [B]       â”‚   Vertices: A, B, C, D
    â”‚     â”‚ \           |         â”‚   Edges: (A,B), (A,C), (A,D)
    â”‚     â”‚  \          |         â”‚          (B,D), (C,D)
    â”‚     â”‚   \         |         â”‚
    â”‚    [C] â”€â”€â”€â”€â”€â”€â”€â”€ [D]         â”‚   5 vertices would need
    â”‚                             â”‚   at most 10 edges (complete)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Graph vs Tree

A **tree** is a special case of a graph with specific constraints:

| Property | Graph | Tree |
|----------|-------|------|
| Cycles | Can have cycles | No cycles (acyclic) |
| Root | No root concept | Has a root node |
| Connectivity | May be disconnected | Connected (single component) |
| Edge count | Any number | Exactly V-1 edges |
| Parent relationship | No inherent parent | Each node has one parent |

```
    TREE (Special Graph)          GENERAL GRAPH
         [A]                      [A] â”€â”€ [B]
        / | \                      â”‚ \  / â”‚
      [B][C][D]                    â”‚  \/  â”‚
      /                            â”‚  /\  â”‚
    [E]                           [C] â”€â”€ [D]
                                  (has cycle A-B-D-C-A)
```

**Key Insight:** Every tree is a graph, but not every graph is a tree!

---

## ğŸ’» Code Implementation

### Basic Graph Representation (Adjacency List)

**Python:**
```python
from collections import defaultdict

class Graph:
    """Basic undirected graph using adjacency list."""
    
    def __init__(self):
        # defaultdict creates empty list for new keys
        self.graph = defaultdict(list)
        self.vertices = set()
    
    def add_vertex(self, v):
        """Add a vertex to the graph."""
        self.vertices.add(v)
    
    def add_edge(self, u, v):
        """Add an undirected edge between u and v."""
        self.graph[u].append(v)
        self.graph[v].append(u)  # Undirected: add both ways
        self.vertices.add(u)
        self.vertices.add(v)
    
    def get_neighbors(self, v):
        """Return all neighbors of vertex v."""
        return self.graph[v]
    
    def has_edge(self, u, v):
        """Check if edge exists between u and v."""
        return v in self.graph[u]
    
    def __str__(self):
        """String representation of the graph."""
        result = []
        for vertex in self.graph:
            result.append(f"{vertex} -> {self.graph[vertex]}")
        return "\n".join(result)

# Example usage
g = Graph()
g.add_edge('A', 'B')
g.add_edge('A', 'C')
g.add_edge('B', 'D')
g.add_edge('C', 'D')

print(g)
# Output:
# A -> ['B', 'C']
# B -> ['A', 'D']
# C -> ['A', 'D']
# D -> ['B', 'C']
```

**JavaScript:**
```javascript
class Graph {
    constructor() {
        this.adjacencyList = new Map();
    }
    
    addVertex(vertex) {
        if (!this.adjacencyList.has(vertex)) {
            this.adjacencyList.set(vertex, []);
        }
    }
    
    addEdge(v1, v2) {
        // Add vertices if they don't exist
        this.addVertex(v1);
        this.addVertex(v2);
        
        // Undirected: add both directions
        this.adjacencyList.get(v1).push(v2);
        this.adjacencyList.get(v2).push(v1);
    }
    
    getNeighbors(vertex) {
        return this.adjacencyList.get(vertex) || [];
    }
    
    hasEdge(v1, v2) {
        return this.adjacencyList.get(v1)?.includes(v2) || false;
    }
    
    display() {
        for (const [vertex, edges] of this.adjacencyList) {
            console.log(`${vertex} -> [${edges.join(', ')}]`);
        }
    }
}

// Example usage
const g = new Graph();
g.addEdge('A', 'B');
g.addEdge('A', 'C');
g.addEdge('B', 'D');
g.addEdge('C', 'D');
g.display();
// A -> [B, C]
// B -> [A, D]
// C -> [A, D]
// D -> [B, C]
```

---

## âš¡ Complexity Analysis

| Operation | Adjacency List | Adjacency Matrix |
|-----------|---------------|------------------|
| Add Vertex | O(1) | O(VÂ²) - resize |
| Add Edge | O(1) | O(1) |
| Remove Edge | O(E) | O(1) |
| Check Edge | O(degree) | O(1) |
| Get Neighbors | O(1) | O(V) |
| **Space** | O(V + E) | O(VÂ²) |

**Why these complexities:**
- **Adjacency List:** Each vertex stores only its neighbors, so space is proportional to vertices + edges
- **Adjacency Matrix:** Must allocate VÃ—V matrix regardless of edge count

---

## ğŸ”„ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| Directed Graph | Edges have direction | Dependencies, one-way streets |
| Weighted Graph | Edges have values/costs | Shortest path, network flow |
| Multigraph | Multiple edges between vertices | Parallel routes |
| Hypergraph | Edges connect multiple vertices | Complex relationships |

---

## âš ï¸ Common Mistakes

### 1. Confusing Directed vs Undirected

```python
# âŒ Wrong: Treating undirected as directed
graph[u].append(v)  # Only one direction!

# âœ… Correct: Add both directions for undirected
graph[u].append(v)
graph[v].append(u)
```

### 2. Forgetting to Handle Disconnected Graphs

```python
# âŒ Wrong: Assuming all vertices reachable from start
def traverse(graph, start):
    visited = set()
    dfs(start, visited)
    # May miss disconnected components!

# âœ… Correct: Iterate through all vertices
def traverse_all(graph):
    visited = set()
    for vertex in graph:
        if vertex not in visited:
            dfs(vertex, visited)
```

### 3. Not Initializing Vertices Without Edges

```python
# âŒ Wrong: Vertex with no edges won't exist in adjacency list
graph = defaultdict(list)
# If vertex 'X' has no edges, graph['X'] won't show it exists

# âœ… Correct: Explicitly track all vertices
vertices = set()
vertices.add('X')  # Track even if no edges
```

---

## ğŸ“ Practice Problems

### Foundation (Understanding Graphs)
| Problem | Difficulty | Purpose |
|---------|------------|---------|
| [Find the Town Judge](https://leetcode.com/problems/find-the-town-judge/) | ğŸŸ¢ Easy | Degree calculation |
| [Find Center of Star Graph](https://leetcode.com/problems/find-center-of-star-graph/) | ğŸŸ¢ Easy | Graph structure |

### After BFS/DFS
| Problem | Difficulty | Purpose |
|---------|------------|---------|
| [Number of Islands](https://leetcode.com/problems/number-of-islands/) | ğŸŸ¡ Medium | Connected components |
| [Clone Graph](https://leetcode.com/problems/clone-graph/) | ğŸŸ¡ Medium | Graph traversal |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Review definition, draw 3 example graphs
- **Day 3:** Implement basic Graph class from memory
- **Day 7:** Solve an easy graph problem without hints
- **Day 14:** Explain graph vs tree differences to someone
- **Day 30:** Identify graph patterns in 5 random problems

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>What Interviewers Look For</strong></summary>

**When discussing graphs in interviews:**

1. **Clarify the graph type:**
   - "Is this directed or undirected?"
   - "Are edges weighted?"
   - "Can there be cycles?"

2. **Choose representation wisely:**
   - Adjacency list for sparse graphs (most interview problems)
   - Adjacency matrix for dense graphs or frequent edge checks

3. **Consider edge cases:**
   - Empty graph
   - Single node
   - Disconnected components

**Company Focus:**
| Company | Graph Emphasis |
|---------|---------------|
| Google | Heavy - complex graph problems |
| Meta | Medium - BFS/DFS, shortest path |
| Amazon | Medium - practical applications |
| Microsoft | Light-Medium - tree/graph traversal |

</details>

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Read and understand concept | 15-20 min |
| Implement basic Graph class | 15-20 min |
| Draw and trace examples | 10-15 min |
| **Total to understand** | **40-55 min** |

---

> **ğŸ’¡ Key Insight:** A graph is the most general way to represent relationships. Every tree, linked list, and even array can be viewed as a special case of a graph with specific constraints.

> **ğŸ”— Related:** [Graph Terminology](./1.2-Graph-Terminology.md) | [Types of Graphs](./1.3-Types-Of-Graphs.md) | [Graph Representation](../02-Graph-Representation/2.1-Adjacency-Matrix.md)

---

**Next:** [1.2 Graph Terminology â†’](./1.2-Graph-Terminology.md)
