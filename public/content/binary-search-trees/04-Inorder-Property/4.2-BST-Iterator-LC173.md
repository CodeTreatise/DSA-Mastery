# 4.2 Binary Search Tree Iterator (LC 173)

## Problem Statement

[LeetCode 173 - Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)

Implement the `BSTIterator` class that represents an iterator over the inorder traversal of a BST:
- `BSTIterator(root)` - Initialize with root
- `hasNext()` - Return true if there's a next number
- `next()` - Return the next smallest number

```
        7
       / \
      3   15
         /  \
        9    20

Iterator: 3 ‚Üí 7 ‚Üí 9 ‚Üí 15 ‚Üí 20 (inorder sequence)
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a Controlled Traversal / Iterator problem:**
- Need to pause and resume inorder traversal
- Each next() returns one element
- Maintain state between calls

**Keywords:**
- "iterator", "next()", "hasNext()"
- "in-order", "sorted order"
- "traverse one at a time"

**Pattern:** Iterative inorder with explicit stack, paused between elements.

</details>

---

## ‚úÖ When to Use

- Controlled traversal with pausing
- Lazy evaluation of tree elements
- When caller controls iteration pace
- Two-pointer techniques on BST (via two iterators)

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Need all elements at once | Iterator is overhead | Full inorder traversal |
| Random access | Iterator is sequential | Different structure |
| Modify during iteration | Invalidates iterator | Copy or restructure |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Inorder Traversal](../../06-Trees/03-Tree-Traversals/3.1-DFS-Traversals/)
- [Kth Smallest (LC 230)](./4.1-Kth-Smallest-LC230.md) - Iterative inorder
- [Inorder Successor](../02-BST-Operations/2.4-Inorder-Successor-LC285.md)

**After mastering this:**
- [Two Sum BST (LC 653)](./4.4-Two-Sum-BST-LC653.md) - Uses iterator
- Complex iterator patterns

**Combines with:**
- Stack-based iteration
- Two-pointer patterns (with two iterators)

</details>

---

## üìê How It Works

### The Key Insight

```
Normal iterative inorder uses a stack and loop:

stack = []
while stack or current:
    while current:
        stack.push(current)
        current = current.left
    current = stack.pop()
    process(current)          ‚Üê We want to PAUSE here
    current = current.right

For an iterator, we pause after each "process" step
and resume when next() is called.
```

### Visualization

```
        7
       / \
      3   15
         /  \
        9    20

Initial state (go left from root):
Stack: [7, 3]      ‚Üê 3 is top (leftmost)
Next(): pop 3, push nothing (no right child)
        Return 3

Stack: [7]
Next(): pop 7, push 15, then go left to 9
        Return 7

Stack: [15, 9]
Next(): pop 9, push nothing
        Return 9

Stack: [15]
Next(): pop 15, push 20
        Return 15

Stack: [20]
Next(): pop 20
        Return 20

Stack: []
hasNext(): False
```

---

## üíª Code Implementation

### Standard Approach (O(h) Space)

**Python:**
```python
class BSTIterator:
    """
    BST Iterator - controlled inorder traversal.
    
    Time: O(1) average for next() and hasNext()
    Space: O(h) - stack holds at most h nodes
    """
    
    def __init__(self, root: Optional[TreeNode]):
        self.stack = []
        self._push_left(root)
    
    def _push_left(self, node: TreeNode) -> None:
        """Push all left children onto stack."""
        while node:
            self.stack.append(node)
            node = node.left
    
    def next(self) -> int:
        """Return next smallest element."""
        node = self.stack.pop()
        # After visiting, explore right subtree
        self._push_left(node.right)
        return node.val
    
    def hasNext(self) -> bool:
        """Return True if there are more elements."""
        return len(self.stack) > 0
```

**JavaScript:**
```javascript
class BSTIterator {
    constructor(root) {
        this.stack = [];
        this._pushLeft(root);
    }
    
    _pushLeft(node) {
        // Push all left children onto stack
        while (node) {
            this.stack.push(node);
            node = node.left;
        }
    }
    
    next() {
        // Return next smallest element
        const node = this.stack.pop();
        this._pushLeft(node.right);
        return node.val;
    }
    
    hasNext() {
        return this.stack.length > 0;
    }
}
```

### Alternative: Store All Elements (O(n) Space)

**Python:**
```python
class BSTIterator:
    """Simpler but O(n) space - stores entire inorder."""
    
    def __init__(self, root: Optional[TreeNode]):
        self.nodes = []
        self.index = 0
        self._inorder(root)
    
    def _inorder(self, node):
        if node:
            self._inorder(node.left)
            self.nodes.append(node.val)
            self._inorder(node.right)
    
    def next(self) -> int:
        val = self.nodes[self.index]
        self.index += 1
        return val
    
    def hasNext(self) -> bool:
        return self.index < len(self.nodes)
```

### Bidirectional Iterator (Forward and Backward)

**Python:**
```python
class BidirectionalBSTIterator:
    """Iterator that can go forward (next) and backward (prev)."""
    
    def __init__(self, root: Optional[TreeNode]):
        self.forward_stack = []
        self.backward_stack = []
        self._push_left(root, self.forward_stack)
        self._push_right(root, self.backward_stack)
    
    def _push_left(self, node, stack):
        while node:
            stack.append(node)
            node = node.left
    
    def _push_right(self, node, stack):
        while node:
            stack.append(node)
            node = node.right
    
    def next(self) -> int:
        """Get next smallest."""
        node = self.forward_stack.pop()
        self._push_left(node.right, self.forward_stack)
        return node.val
    
    def prev(self) -> int:
        """Get next largest (reverse direction)."""
        node = self.backward_stack.pop()
        self._push_right(node.left, self.backward_stack)
        return node.val
    
    def hasNext(self) -> bool:
        return len(self.forward_stack) > 0
    
    def hasPrev(self) -> bool:
        return len(self.backward_stack) > 0
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Amortized | Notes |
|-----------|------|-----------|-------|
| Constructor |" O(h) "| - | Push leftmost path |
| next() |" O(h) "| O(1) | May push h nodes |
| hasNext() |" O(1) "| O(1) | Check stack size |
| **Space** |" O(h) "| - | Stack holds path |

**Why O(1) amortized for next():**
```
Over n calls to next(), each node is:
- Pushed onto stack exactly once
- Popped from stack exactly once

Total work = O(n) for n calls
Average per call = O(n)/n = O(1)

Any single call might take O(h), but averaged over
all calls, it's O(1) per call.
```

---

## üîÑ Variations

| Variation | Modification | Use Case |
|-----------|--------------|----------|
| **Reverse iterator** | Start with rightmost, go left | K-th largest |
| **Bidirectional** | Both forward and backward | Two-pointer patterns |
| **With peek** | Look at next without consuming | Lookahead needed |
| **With skip** | Skip to k-th element | Optimization |

### Iterator with Peek

```python
class BSTIteratorWithPeek(BSTIterator):
    def peek(self) -> int:
        """Look at next element without consuming."""
        if not self.hasNext():
            raise StopIteration
        return self.stack[-1].val
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Pushing Left Children After Right

```python
# ‚ùå Wrong: Only popping, not exploring right subtree
def next(self):
    node = self.stack.pop()
    return node.val  # Forgot to push right subtree's left path!

# ‚úÖ Correct: After visiting, explore right subtree
def next(self):
    node = self.stack.pop()
    self._push_left(node.right)  # Important!
    return node.val
```

### 2. Returning Node Instead of Value

```python
# ‚ùå Wrong: Returns node object
def next(self):
    return self.stack.pop()  # Returns TreeNode, not int!

# ‚úÖ Correct: Return the value
def next(self):
    node = self.stack.pop()
    self._push_left(node.right)
    return node.val  # Return the integer value
```

### 3. Empty Stack Check in next()

```python
# ‚ùå Wrong: No check for empty stack
def next(self):
    return self.stack.pop().val  # Crashes if empty!

# ‚úÖ Better: Assume hasNext() is called first (per problem spec)
# Or add defensive check:
def next(self):
    if not self.hasNext():
        raise StopIteration
    node = self.stack.pop()
    self._push_left(node.right)
    return node.val
```

---

## üìù Practice Problems (Progressive)

### Easy (Build up)
- [ ] [Kth Smallest (LC 230)](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) - Inorder pattern

### Medium (Apply pattern)
- [ ] [BST Iterator (LC 173)](https://leetcode.com/problems/binary-search-tree-iterator/) - This problem
- [ ] [Two Sum IV - BST (LC 653)](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) - Uses iterator
- [ ] [Flatten BST to Sorted List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/) - Related

### Hard (Master)
- [ ] [Binary Search Tree Iterator II (LC 1586)](https://leetcode.com/problems/binary-search-tree-iterator-ii/) - With prev()
- [ ] Implement Morris traversal iterator

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement standard iterator
- **Day 3:** Trace through example step by step
- **Day 7:** Implement reverse iterator
- **Day 14:** Use in LC 653 (Two Sum)
- **Day 30:** Implement bidirectional iterator

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"I'll use an iterative inorder approach with an explicit stack. The key is that after visiting a node, I need to explore its right subtree. I'll push all left children when I enter a subtree, pop to visit, then handle the right child."

**Key points:**
1. "Space is O(h) because stack holds at most one root-to-leaf path"
2. "next() is O(1) amortized ‚Äî each node pushed and popped once"
3. "This is essentially iterative inorder, paused between elements"

**Follow-up questions:**
- "Can you do it with O(1) space?" ‚Üí Morris traversal (modifies tree temporarily)
- "What about prev()?" ‚Üí Maintain two stacks or parent pointers

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Iterator patterns |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard BST |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Design question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 3-4 min | Clear interface |
| Design approach | 5-7 min | Stack-based iteration |
| Code solution | 10-12 min | Handle push_left |
| Complexity analysis | 3-4 min | Explain amortized |
| Total interview time | 22-28 min | Medium difficulty |

---

## üí° Key Insight

> **An iterator is a "paused" traversal.** Normal inorder uses a loop; an iterator is that same loop, frozen mid-execution, with the stack holding the traversal state. Each next() call executes one iteration of the loop.

---

## üîó Related

- **Previous:** [Kth Smallest (LC 230)](./4.1-Kth-Smallest-LC230.md)
- **Next:** [Greater Sum Tree (LC 538)](./4.3-Greater-Sum-Tree-LC538.md)
- **Uses This:** [Two Sum BST (LC 653)](./4.4-Two-Sum-BST-LC653.md)
- **Concept:** [Inorder Traversal](../../06-Trees/03-Tree-Traversals/3.1-DFS-Traversals/)
