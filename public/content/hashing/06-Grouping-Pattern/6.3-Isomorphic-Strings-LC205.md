# Isomorphic Strings (LeetCode 205)

> **Easy** | Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t.

This problem tests bidirectional mapping - a key variant of the grouping pattern where we must verify a one-to-one correspondence.

---

## ðŸŽ¯ Pattern Recognition

<details>
<summary><strong>Problem Signals</strong></summary>

**Keywords indicating this pattern:**
- "Can be replaced/mapped"
- "Same pattern/structure"
- "One-to-one correspondence"
- "Character mapping"
- "Isomorphic/equivalent"

**Problem classification:**
```
Category: Grouping Pattern - Mapping Variant
Subcategory: Bidirectional character mapping
Key insight: Both sâ†’t AND tâ†’s mappings must be consistent
```

</details>

---

## ðŸ“‹ Problem Statement

**LeetCode 205:** [Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/)

```
Given two strings s and t, determine if they are isomorphic.

Two strings s and t are isomorphic if the characters in s can be 
replaced to get t, where:
- All occurrences of a character must be replaced with another character
- No two characters may map to the same character
- A character may map to itself

Example 1:
Input: s = "egg", t = "add"
Output: true
Explanation: eâ†’a, gâ†’d works

Example 2:
Input: s = "foo", t = "bar"
Output: false
Explanation: o maps to both 'a' and 'r' - inconsistent

Example 3:
Input: s = "paper", t = "title"
Output: true
Explanation: pâ†’t, aâ†’i, eâ†’l, râ†’e

Constraints:
- 1 <= s.length <= 5 * 10^4
- t.length == s.length
- s and t consist of any valid ASCII character
```

---

## âœ… When to Use This Approach

- Checking if two strings follow the same pattern
- Validating bijective (one-to-one) mappings
- Word pattern matching problems
- Substitution cipher detection

## âŒ When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Anagram check | Same chars, not pattern | Frequency count |
| Substring matching | Different problem type | KMP / Rabin-Karp |
| Multiple strings | Different approach | Group by signature |

---

## ðŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Related</strong></summary>

**Before this:**
- [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
- [Grouping Pattern](./6.1-Grouping-Overview.md)

**Related problems:**
- [Word Pattern (LC 290)](./6.4-Word-Pattern-LC290.md) - Same concept with words
- [Group Anagrams (LC 49)](./6.2-Group-Anagrams-LC49.md) - Different: uses frequency

</details>

---

## ðŸ“ Solution Approaches

### Approach 1: Two Hash Maps (Bidirectional Mapping)

**Key Insight:** We need BOTH:
1. s â†’ t mapping (each s char maps to one t char)
2. t â†’ s mapping (each t char is mapped by one s char)

```
"foo" vs "bar"
sâ†’t: {f:b, o:a} ... but wait, o is also at index 2
     At index 2: s='o', t='r'
     But we already have oâ†’a!
     Inconsistent â†’ false

"ab" vs "aa"  
sâ†’t: {a:a, b:a} â† Looks OK (each s char maps to one t char)
tâ†’s: {a:a} ... but wait, both a and b map to 'a'
     Two different s chars map to same t char!
     Inconsistent â†’ false
```

**Visualization:**
```
s = "egg", t = "add"

Position 0: s[0]='e', t[0]='a'
  s_to_t: {'e': 'a'}
  t_to_s: {'a': 'e'}

Position 1: s[1]='g', t[1]='d'
  s_to_t: {'e': 'a', 'g': 'd'}
  t_to_s: {'a': 'e', 'd': 'g'}

Position 2: s[2]='g', t[2]='d'
  Check: s_to_t['g'] = 'd' âœ“ (matches t[2])
  Check: t_to_s['d'] = 'g' âœ“ (matches s[2])

All positions consistent â†’ true
```

```
s = "ab", t = "aa"

Position 0: s[0]='a', t[0]='a'
  s_to_t: {'a': 'a'}
  t_to_s: {'a': 'a'}

Position 1: s[1]='b', t[1]='a'
  Check: 'b' not in s_to_t â†’ add it
  Check: 'a' in t_to_s, but t_to_s['a']='a' â‰  'b'
  
Two s chars (a, b) map to same t char (a) â†’ false
```

### Approach 2: Pattern Signature

Convert both strings to a canonical form and compare.

```
"egg" â†’ [0, 1, 1]  (e=0, g=1, g=1)
"add" â†’ [0, 1, 1]  (a=0, d=1, d=1)
Same pattern â†’ isomorphic!

"foo" â†’ [0, 1, 1]  (f=0, o=1, o=1)
"bar" â†’ [0, 1, 2]  (b=0, a=1, r=2)
Different pattern â†’ not isomorphic!
```

---

## ðŸ’» Code Implementation

### Python - Approach 1: Two Hash Maps

```python
def isIsomorphic(s: str, t: str) -> bool:
    """
    Check if two strings are isomorphic using bidirectional mapping.
    
    Algorithm:
    1. Maintain two maps: sâ†’t and tâ†’s
    2. For each position, check consistency
    3. If any inconsistency, return False
    
    Time: O(n) - single pass
    Space: O(k) where k = number of unique characters
    """
    if len(s) != len(t):
        return False
    
    s_to_t = {}  # Maps s chars to t chars
    t_to_s = {}  # Maps t chars to s chars
    
    for char_s, char_t in zip(s, t):
        # Check s â†’ t mapping
        if char_s in s_to_t:
            if s_to_t[char_s] != char_t:
                return False  # Inconsistent: s char maps to different t chars
        else:
            s_to_t[char_s] = char_t
        
        # Check t â†’ s mapping
        if char_t in t_to_s:
            if t_to_s[char_t] != char_s:
                return False  # Inconsistent: same t char from different s chars
        else:
            t_to_s[char_t] = char_s
    
    return True


# Example trace:
# s = "paper", t = "title"
#
# i=0: s='p', t='t' â†’ s_to_t={'p':'t'}, t_to_s={'t':'p'}
# i=1: s='a', t='i' â†’ s_to_t={'p':'t','a':'i'}, t_to_s={'t':'p','i':'a'}
# i=2: s='p', t='t' â†’ s_to_t['p']='t' âœ“, t_to_s['t']='p' âœ“
# i=3: s='e', t='l' â†’ s_to_t={'p':'t','a':'i','e':'l'}, t_to_s={...,'l':'e'}
# i=4: s='r', t='e' â†’ s_to_t={...,'r':'e'}, t_to_s={...,'e':'r'}
# Return True
```

### Python - Approach 2: Pattern Signature

```python
def isIsomorphic(s: str, t: str) -> bool:
    """
    Check isomorphism by comparing pattern signatures.
    
    Convert each string to a canonical form:
    - First unique char â†’ 0
    - Second unique char â†’ 1
    - etc.
    
    Time: O(n)
    Space: O(n) for patterns
    """
    def get_pattern(string: str) -> tuple:
        char_to_id = {}
        pattern = []
        next_id = 0
        
        for char in string:
            if char not in char_to_id:
                char_to_id[char] = next_id
                next_id += 1
            pattern.append(char_to_id[char])
        
        return tuple(pattern)
    
    return get_pattern(s) == get_pattern(t)


# Example:
# get_pattern("egg") â†’ (0, 1, 1)
# get_pattern("add") â†’ (0, 1, 1)
# (0, 1, 1) == (0, 1, 1) â†’ True
```

### Python - Approach 3: Index Mapping (Clever One-Liner)

```python
def isIsomorphic(s: str, t: str) -> bool:
    """
    Use first occurrence index as pattern.
    
    For "egg": [s.index('e'), s.index('g'), s.index('g')] = [0, 1, 1]
    For "add": [t.index('a'), t.index('d'), t.index('d')] = [0, 1, 1]
    
    Note: This is O(nÂ²) due to index() calls - not optimal!
    """
    return [s.index(c) for c in s] == [t.index(c) for c in t]


# More efficient version using map:
def isIsomorphic_map(s: str, t: str) -> bool:
    """
    Use zip to compare transformations.
    Two strings are isomorphic iff:
    - Same number of unique character pairs
    - And character pairs are consistent
    """
    return len(set(zip(s, t))) == len(set(s)) == len(set(t))


# Explanation:
# "ab" vs "aa"
# zip: [('a','a'), ('b','a')]
# set(zip): {('a','a'), ('b','a')} â†’ 2 pairs
# set(s): {'a', 'b'} â†’ 2 unique
# set(t): {'a'} â†’ 1 unique
# 2 == 2 == 1 â†’ False! (not all equal)
#
# "egg" vs "add"
# zip: [('e','a'), ('g','d'), ('g','d')]
# set(zip): {('e','a'), ('g','d')} â†’ 2 pairs
# set(s): {'e', 'g'} â†’ 2 unique
# set(t): {'a', 'd'} â†’ 2 unique
# 2 == 2 == 2 â†’ True!
```

### JavaScript - Approach 1: Two Hash Maps

```javascript
/**
 * Check if two strings are isomorphic.
 * 
 * @param {string} s - First string
 * @param {string} t - Second string
 * @return {boolean} - True if isomorphic
 * 
 * Time: O(n)
 * Space: O(k) where k = unique characters
 */
function isIsomorphic(s, t) {
    if (s.length !== t.length) return false;
    
    const sToT = new Map();
    const tToS = new Map();
    
    for (let i = 0; i < s.length; i++) {
        const charS = s[i];
        const charT = t[i];
        
        // Check s â†’ t mapping
        if (sToT.has(charS)) {
            if (sToT.get(charS) !== charT) return false;
        } else {
            sToT.set(charS, charT);
        }
        
        // Check t â†’ s mapping
        if (tToS.has(charT)) {
            if (tToS.get(charT) !== charS) return false;
        } else {
            tToS.set(charT, charS);
        }
    }
    
    return true;
}
```

### JavaScript - Approach 2: Pattern Signature

```javascript
/**
 * Check isomorphism using pattern comparison.
 * 
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
function isIsomorphic(s, t) {
    function getPattern(str) {
        const charToId = new Map();
        const pattern = [];
        let nextId = 0;
        
        for (const char of str) {
            if (!charToId.has(char)) {
                charToId.set(char, nextId++);
            }
            pattern.push(charToId.get(char));
        }
        
        return pattern.join(',');
    }
    
    return getPattern(s) === getPattern(t);
}

// Alternative: using set comparison
function isIsomorphicSet(s, t) {
    // Create pairs
    const pairs = new Set();
    const sChars = new Set();
    const tChars = new Set();
    
    for (let i = 0; i < s.length; i++) {
        pairs.add(s[i] + ',' + t[i]);
        sChars.add(s[i]);
        tChars.add(t[i]);
    }
    
    return pairs.size === sChars.size && sChars.size === tChars.size;
}
```

---

## âš¡ Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Two Hash Maps | O(n) | O(k) | k = unique chars, â‰¤ 256 |
| Pattern Signature | O(n) | O(n) | Stores full pattern |
| Set Comparison | O(n) | O(k) | Most concise |
| Index-based | O(nÂ²) | O(n) | Not recommended |

**Detailed Analysis - Two Maps:**
```
Time: O(n)
  - Single pass through both strings
  - Hash map operations are O(1)

Space: O(k) where k = number of unique characters
  - Maximum 256 for ASCII
  - Often much smaller
  - Can be considered O(1) for fixed alphabet
```

---

## ðŸ”„ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Word Pattern | Words instead of chars | LC 290 |
| Group Isomorphic | Group all isomorphic strings | Custom |
| Longest Isomorphic Substring | Maximize length | Custom |

---

## âš ï¸ Common Mistakes

### 1. Only Checking One Direction

```python
# âŒ WRONG: Only checking sâ†’t
def isIsomorphic(s, t):
    s_to_t = {}
    for i in range(len(s)):
        if s[i] in s_to_t:
            if s_to_t[s[i]] != t[i]:
                return False
        else:
            s_to_t[s[i]] = t[i]
    return True

# "ab", "aa" would return True incorrectly!
# aâ†’a, bâ†’a (both map to 'a' - no conflict detected)

# âœ… CORRECT: Check both directions
def isIsomorphic(s, t):
    s_to_t = {}
    t_to_s = {}
    for i in range(len(s)):
        # Check sâ†’t
        if s[i] in s_to_t:
            if s_to_t[s[i]] != t[i]:
                return False
        else:
            s_to_t[s[i]] = t[i]
        
        # Check tâ†’s
        if t[i] in t_to_s:
            if t_to_s[t[i]] != s[i]:
                return False
        else:
            t_to_s[t[i]] = s[i]
    return True
```

### 2. Not Handling Equal Characters Mapping to Themselves

```python
# This is actually OK, but some people overcomplicate it
# "abc" and "abc" should return True

# Character can map to itself:
# aâ†’a, bâ†’b, câ†’c is a valid isomorphism
```

### 3. Forgetting Length Check

```python
# âŒ WRONG: Missing length check
def isIsomorphic(s, t):
    s_to_t = {}
    t_to_s = {}
    for cs, ct in zip(s, t):  # zip stops at shorter string!
        # ...

# "abc" and "ab" would not error but give wrong result

# âœ… CORRECT: Check length first
def isIsomorphic(s, t):
    if len(s) != len(t):
        return False
    # ...
```

### 4. Wrong Set Comparison Logic

```python
# âŒ WRONG: Incorrect set comparison
def isIsomorphic(s, t):
    return len(set(zip(s, t))) == len(set(s))
# Missing check for t uniqueness!

# âœ… CORRECT: All three must be equal
def isIsomorphic(s, t):
    return len(set(zip(s, t))) == len(set(s)) == len(set(t))
```

---

## ðŸ“ Practice Problems (Progressive)

| Problem | Difficulty | Key Insight |
|---------|------------|-------------|
| Isomorphic Strings | ðŸŸ¢ Easy | This problem |
| Word Pattern | ðŸŸ¢ Easy | Same pattern with words |
| Word Pattern II | ðŸ”´ Hard | Backtracking variant |

**Related LeetCode:**
- [290. Word Pattern](https://leetcode.com/problems/word-pattern/)
- [291. Word Pattern II](https://leetcode.com/problems/word-pattern-ii/)

<details>
<summary><strong>ðŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand why both directions needed
- **Day 3:** Implement without looking at solution
- **Day 7:** Solve LC 290 (Word Pattern)
- **Day 14:** Explain the set-based one-liner
- **Day 30:** < 5 min implementation

</details>

---

## ðŸŽ¤ Interview Context

<details>
<summary><strong>Communication Template</strong></summary>

**1. Clarify:**
> "So I need to check if there's a one-to-one mapping from characters in s to characters in t. Each s character maps to exactly one t character, and no two s characters map to the same t character?"

**2. Edge cases:**
> "What about empty strings? Same length guaranteed?"

**3. Approach:**
> "I'll use two hash maps - one for sâ†’t mapping and one for tâ†’s mapping. This ensures bidirectional consistency."

**4. Key insight to mention:**
> "We need both directions because checking only sâ†’t would miss cases like 'ab' and 'aa' where two source characters map to the same target."

</details>

**Company Frequency:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| LinkedIn | â­â­â­â­ | Common |
| Google | â­â­â­ | May ask follow-ups |
| Amazon | â­â­â­ | Standard |
| Bloomberg | â­â­â­ | String focus |

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Understand problem | 2 min |
| Identify bidirectional need | 1 min |
| Implement | 5-7 min |
| Test edge cases | 2 min |
| **Total** | **10-12 min** |

---

> **ðŸ’¡ Key Insight:** The trap in this problem is only checking one direction. "ab" â†’ "aa" passes sâ†’t check (aâ†’a, bâ†’a both valid individually) but fails tâ†’s check (a maps from both 'a' and 'b'). Always check both directions for bijective mappings.

> **ðŸ”— Related:** [Word Pattern](./6.4-Word-Pattern-LC290.md) | [Grouping Pattern](./6.1-Grouping-Overview.md) | [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
