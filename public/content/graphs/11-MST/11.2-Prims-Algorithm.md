# 11.2 Prim's Algorithm

> **Grow MST from a starting vertex - similar to Dijkstra**
>
> â±ï¸ **Study Time:** 25 min | ğŸ“Š **Priority:** Medium | ğŸ¯ **Pattern:** Greedy + Priority Queue

---

## Overview

**Prim's Algorithm** builds the MST by growing it one vertex at a time, always adding the **cheapest edge** that connects the current tree to a new vertex.

```
Algorithm:
1. Start with any vertex in the MST
2. Add the minimum-weight edge connecting MST to non-MST vertex
3. Repeat until all vertices included

Similar to Dijkstra, but:
- Dijkstra: Track distance FROM source
- Prim's: Track cheapest edge TO tree
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>When to Use Prim's</strong></summary>

**Choose Prim's over Kruskal's when:**
- Graph is dense (E close to VÂ²)
- Have adjacency list representation
- Need to start from specific vertex
- Already familiar with Dijkstra (similar structure)

**Prim's is NOT ideal when:**
- Edges given as list (Kruskal's avoids building graph)
- Sparse graph (Kruskal's may be faster)

</details>

---

## ğŸ“ How It Works

### Step-by-Step Example

```
Graph:
    4
1 â”€â”€â”€â”€â”€ 2
â”‚       â”‚
â”‚1      â”‚2
â”‚       â”‚
3 â”€â”€â”€â”€â”€ 4
    3

Start from vertex 1:

Step 1: MST = {1}
        Edges to consider: (1,2,4), (1,3,1)
        Add cheapest: (1,3,1) âœ“
        MST = {1,3}, total = 1

Step 2: MST = {1,3}
        Edges to consider: (1,2,4), (3,4,3)
        Add cheapest: (3,4,3) âœ“
        MST = {1,3,4}, total = 4

Step 3: MST = {1,3,4}
        Edges to consider: (1,2,4), (4,2,2)
        Add cheapest: (4,2,2) âœ“
        MST = {1,2,3,4}, total = 6

Final MST: edges (1,3), (3,4), (4,2) with total weight 6
```

---

## ğŸ’» Code Implementation

**Python:**
```python
import heapq
from typing import List, Tuple, Dict
from collections import defaultdict

def prim_basic(n: int, graph: Dict[int, List[Tuple[int, int]]]) -> int:
    """
    Basic Prim's algorithm using min-heap.
    graph[u] = [(v, weight), ...]
    
    Time: O(E log V)
    Space: O(V + E)
    """
    if n == 0:
        return 0
    
    visited = [False] * n
    heap = [(0, 0)]  # (weight, node)
    mst_weight = 0
    edges_added = 0
    
    while heap and edges_added < n:
        weight, u = heapq.heappop(heap)
        
        if visited[u]:
            continue
        
        # Add this vertex to MST
        visited[u] = True
        mst_weight += weight
        edges_added += 1
        
        # Add all edges to unvisited neighbors
        for v, w in graph[u]:
            if not visited[v]:
                heapq.heappush(heap, (w, v))
    
    return mst_weight if edges_added == n else -1  # -1 if disconnected


def prim_with_edges(n: int, graph: Dict[int, List[Tuple[int, int]]]) -> List[Tuple[int, int, int]]:
    """
    Prim's algorithm that returns the MST edges.
    """
    visited = [False] * n
    heap = [(0, 0, -1)]  # (weight, node, parent)
    mst_edges = []
    
    while heap and len(mst_edges) < n - 1:
        weight, u, parent = heapq.heappop(heap)
        
        if visited[u]:
            continue
        
        visited[u] = True
        if parent != -1:
            mst_edges.append((parent, u, weight))
        
        for v, w in graph[u]:
            if not visited[v]:
                heapq.heappush(heap, (w, v, u))
    
    return mst_edges


def prim_dense_graph(n: int, adj_matrix: List[List[int]]) -> int:
    """
    Prim's for dense graphs using adjacency matrix.
    No heap needed - O(VÂ²) but faster for very dense graphs.
    
    adj_matrix[i][j] = weight of edge i-j (or inf if no edge)
    """
    INF = float('inf')
    in_mst = [False] * n
    min_edge = [INF] * n  # min_edge[v] = min weight edge to v from MST
    min_edge[0] = 0
    
    mst_weight = 0
    
    for _ in range(n):
        # Find minimum edge to non-MST vertex
        u = -1
        for v in range(n):
            if not in_mst[v] and (u == -1 or min_edge[v] < min_edge[u]):
                u = v
        
        if min_edge[u] == INF:
            return -1  # Disconnected
        
        in_mst[u] = True
        mst_weight += min_edge[u]
        
        # Update min edges to remaining vertices
        for v in range(n):
            if not in_mst[v] and adj_matrix[u][v] < min_edge[v]:
                min_edge[v] = adj_matrix[u][v]
    
    return mst_weight


# Example
graph = {
    0: [(1, 4), (2, 1)],
    1: [(0, 4), (2, 2), (3, 5)],
    2: [(0, 1), (1, 2), (3, 8)],
    3: [(1, 5), (2, 8)]
}
print(f"MST weight: {prim_basic(4, graph)}")  # 8
print(f"MST edges: {prim_with_edges(4, graph)}")
```

**JavaScript:**
```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    push(item) {
        this.heap.push(item);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        if (this.heap.length === 0) return null;
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return min;
    }
    
    isEmpty() {
        return this.heap.length === 0;
    }
    
    _bubbleUp(index) {
        while (index > 0) {
            const parent = Math.floor((index - 1) / 2);
            if (this.heap[parent][0] <= this.heap[index][0]) break;
            [this.heap[parent], this.heap[index]] = 
                [this.heap[index], this.heap[parent]];
            index = parent;
        }
    }
    
    _bubbleDown(index) {
        const n = this.heap.length;
        while (true) {
            let smallest = index;
            const left = 2 * index + 1, right = 2 * index + 2;
            
            if (left < n && this.heap[left][0] < this.heap[smallest][0]) {
                smallest = left;
            }
            if (right < n && this.heap[right][0] < this.heap[smallest][0]) {
                smallest = right;
            }
            if (smallest === index) break;
            
            [this.heap[smallest], this.heap[index]] = 
                [this.heap[index], this.heap[smallest]];
            index = smallest;
        }
    }
}

function prim(n, graph) {
    const visited = new Array(n).fill(false);
    const heap = new MinHeap();
    heap.push([0, 0]); // [weight, node]
    
    let mstWeight = 0;
    let edgesAdded = 0;
    
    while (!heap.isEmpty() && edgesAdded < n) {
        const [weight, u] = heap.pop();
        
        if (visited[u]) continue;
        
        visited[u] = true;
        mstWeight += weight;
        edgesAdded++;
        
        for (const [v, w] of (graph[u] || [])) {
            if (!visited[v]) {
                heap.push([w, v]);
            }
        }
    }
    
    return edgesAdded === n ? mstWeight : -1;
}
```

---

## âš¡ Complexity Analysis

| Implementation | Time | Space | Notes |
|---------------|------|-------|-------|
| **Binary Heap** | O(E log V) | O(V + E) | Most common |
| **Fibonacci Heap** | O(E + V log V) | O(V + E) | Theoretical best |
| **No Heap (matrix)** | O(VÂ²) | O(V) | Best for very dense |

**Comparison with Dijkstra:**
| Aspect | Dijkstra | Prim's |
|--------|----------|--------|
| Purpose | Shortest path | MST |
| Heap value | Distance from source | Edge weight to tree |
| Works for | Directed/Undirected | Undirected only |
| Negative edges | No | Yes (no path concept) |

---

## ğŸ”„ Variations

### Min Cost to Connect Points (LC 1584)

```python
def minCostConnectPoints(points: List[List[int]]) -> int:
    """
    Connect all points with minimum Manhattan distance.
    Build complete graph, then run Prim's.
    """
    n = len(points)
    
    def manhattan(i, j):
        return abs(points[i][0] - points[j][0]) + \
               abs(points[i][1] - points[j][1])
    
    visited = [False] * n
    heap = [(0, 0)]
    total = 0
    count = 0
    
    while heap and count < n:
        cost, u = heapq.heappop(heap)
        
        if visited[u]:
            continue
        
        visited[u] = True
        total += cost
        count += 1
        
        for v in range(n):
            if not visited[v]:
                heapq.heappush(heap, (manhattan(u, v), v))
    
    return total
```

### Optimized with Lazy Updates

Track minimum edge to each vertex:

```python
def prim_optimized(n: int, graph: dict) -> int:
    """
    Optimized: only push better edges to heap.
    """
    INF = float('inf')
    visited = [False] * n
    min_cost = [INF] * n
    min_cost[0] = 0
    heap = [(0, 0)]
    total = 0
    
    while heap:
        cost, u = heapq.heappop(heap)
        
        if visited[u]:
            continue
        
        visited[u] = True
        total += cost
        
        for v, w in graph[u]:
            if not visited[v] and w < min_cost[v]:
                min_cost[v] = w
                heapq.heappush(heap, (w, v))
    
    return total
```

---

## âš ï¸ Common Mistakes

### 1. Not Skipping Visited Nodes

```python
# âŒ WRONG: Adding weight without checking
weight, u = heapq.heappop(heap)
total += weight  # May double-count!

# âœ… CORRECT: Skip if already in MST
if visited[u]:
    continue
visited[u] = True
total += weight
```

### 2. Confusing with Dijkstra

```python
# âŒ WRONG: Using distance from start (Dijkstra logic)
# Prim's tracks edge weight, not path distance!
if dist[u] + weight < dist[v]:  # This is Dijkstra!

# âœ… CORRECT: Just use edge weight
if not visited[v]:
    heapq.heappush(heap, (weight, v))
```

### 3. Starting with Empty Heap

```python
# âŒ WRONG: Forgetting to add starting vertex
heap = []
# Nothing to pop!

# âœ… CORRECT: Start with initial vertex
heap = [(0, 0)]  # Start from vertex 0 with cost 0
```

---

## ğŸ“ Practice Problems

- [ ] [Min Cost to Connect All Points](https://leetcode.com/problems/min-cost-to-connect-all-points/) - Direct Prim's
- [ ] [Connecting Cities With Minimum Cost](https://leetcode.com/problems/connecting-cities-with-minimum-cost/) - Basic MST

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate</strong></summary>

**Opening:**
> "I'll use Prim's algorithm, which is like Dijkstra but for MST. We grow the tree from a starting vertex, always adding the cheapest edge to a new vertex."

**Comparison to Dijkstra:**
> "The key difference is what we track: Dijkstra tracks total distance from source, Prim's just tracks the edge weight to connect to the tree."

</details>

---

> **ğŸ’¡ Key Insight:** Prim's is "Dijkstra for MST" - same structure, different purpose. Track **edge weight to tree** instead of **distance from source**.

---

**Back:** [â† MST Introduction](./11.1-MST-Introduction.md) | **Next:** [Kruskal's Algorithm â†’](./11.3-Kruskals-Algorithm.md)
