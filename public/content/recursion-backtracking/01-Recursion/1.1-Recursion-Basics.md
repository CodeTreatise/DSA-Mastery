# 1.1 Recursion Basics

> **Foundation: Understanding How Recursion Works**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - Required for Trees, Graphs, DP, Backtracking  
> **Prerequisites:** Function calls, basic data structures

---

## Overview

**Recursion** is a technique where a function calls itself to solve smaller instances of the same problem. It's the foundation for solving tree/graph traversals, divide-and-conquer algorithms, dynamic programming, and backtracking.

> **üí° Key Insight:** Every recursive problem has two parts:
> 1. **Base case** - The simplest case where the answer is known directly
> 2. **Recursive case** - Breaking the problem into smaller versions of itself

---

## üéØ Pattern Recognition

<details>
<summary><strong>When Does Recursion Apply?</strong></summary>

**Look for these signals:**
- Problem can be broken into **smaller subproblems** of the same type
- **Tree or graph** structure (natural recursive shapes)
- "All combinations", "all paths", "all possibilities"
- Problem has **self-similar structure** (parts look like the whole)
- Divide-and-conquer opportunities

**Keywords in problem statement:**
- "recursively", "nested", "hierarchical"
- "all possible", "every path", "count ways"
- Tree/graph terminology

</details>

---

## ‚úÖ When to Use Recursion

- **Tree/Graph problems** - Natural recursive structures
- **Divide and conquer** - Merge sort, quick sort, binary search
- **Backtracking** - Generate all combinations/permutations
- **Dynamic programming** - Often starts as recursion + memoization
- **Nested structures** - Parsing, nested lists, directory traversal

---

## ‚ùå When NOT to Use Recursion

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Simple iteration (1D loop) | for/while loop | Simpler, no stack overhead |
| Very deep recursion | Iteration + stack | Avoid stack overflow |
| Repeated subproblems | DP with memoization | Avoid exponential time |
| Performance critical | Tail recursion or iteration | Better constants |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- How function calls work (call stack)
- Basic data structures (arrays, linked lists)
- Time/space complexity basics

**After mastering this:**
- [Recursion Patterns](./1.2-Recursion-Patterns.md) - Common patterns
- [Thinking Recursively](./1.3-Thinking-Process.md) - Mental model
- [Backtracking](../02-Backtracking/2.2-Backtracking-Template.md) - Generate all solutions

**Enables understanding of:**
- Tree traversals (inorder, preorder, postorder)
- Graph DFS
- Dynamic programming
- Divide and conquer

</details>

---

## üìê How Recursion Works

### The Call Stack

Every function call creates a **stack frame** containing:
- Local variables
- Parameters
- Return address (where to resume after returning)

```
factorial(4) calls:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  factorial(1) ‚Üí returns 1   ‚îÇ  ‚Üê Top (evaluates first)
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  factorial(2) ‚Üí 2 * 1 = 2   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  factorial(3) ‚Üí 3 * 2 = 6   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  factorial(4) ‚Üí 4 * 6 = 24  ‚îÇ  ‚Üê Bottom (started here)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### The Two Essential Components

```python
def recursive_function(problem):
    # 1. BASE CASE - Stop condition
    if problem is simplest form:
        return direct answer
    
    # 2. RECURSIVE CASE - Break down and combine
    smaller_problem = break_down(problem)
    sub_result = recursive_function(smaller_problem)
    return combine(sub_result)
```

---

## üíª Code Implementation

### Example 1: Factorial

```python
def factorial(n: int) -> int:
    """
    Calculate n! = n * (n-1) * (n-2) * ... * 1
    
    Base case: 0! = 1! = 1
    Recursive case: n! = n * (n-1)!
    
    Time: O(n), Space: O(n) for call stack
    """
    # Base case
    if n <= 1:
        return 1
    
    # Recursive case
    return n * factorial(n - 1)

# Trace for factorial(4):
# factorial(4) = 4 * factorial(3)
#              = 4 * (3 * factorial(2))
#              = 4 * (3 * (2 * factorial(1)))
#              = 4 * (3 * (2 * 1))
#              = 4 * (3 * 2)
#              = 4 * 6
#              = 24
```

```javascript
function factorial(n) {
    // Base case
    if (n <= 1) return 1;
    
    // Recursive case
    return n * factorial(n - 1);
}
```

### Example 2: Sum of Array

```python
def array_sum(arr: list[int]) -> int:
    """
    Sum elements recursively.
    
    Base case: empty array ‚Üí 0
    Recursive case: first element + sum of rest
    """
    # Base case
    if not arr:
        return 0
    
    # Recursive case
    return arr[0] + array_sum(arr[1:])

# More efficient version (avoids slicing)
def array_sum_efficient(arr: list[int], index: int = 0) -> int:
    """Sum using index instead of slicing."""
    if index == len(arr):
        return 0
    return arr[index] + array_sum_efficient(arr, index + 1)
```

```javascript
function arraySum(arr) {
    if (arr.length === 0) return 0;
    return arr[0] + arraySum(arr.slice(1));
}

// Efficient version
function arraySumEfficient(arr, index = 0) {
    if (index === arr.length) return 0;
    return arr[index] + arraySumEfficient(arr, index + 1);
}
```

### Example 3: Fibonacci (with warning)

```python
def fibonacci(n: int) -> int:
    """
    F(0) = 0, F(1) = 1
    F(n) = F(n-1) + F(n-2)
    
    WARNING: O(2^n) time - exponential!
    This is for demonstration only.
    """
    # Base cases
    if n <= 0:
        return 0
    if n == 1:
        return 1
    
    # Recursive case
    return fibonacci(n - 1) + fibonacci(n - 2)

# Efficient version with memoization
def fibonacci_memo(n: int, memo: dict = None) -> int:
    """O(n) time with memoization."""
    if memo is None:
        memo = {}
    
    if n in memo:
        return memo[n]
    
    if n <= 0:
        return 0
    if n == 1:
        return 1
    
    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
    return memo[n]
```

```javascript
function fibonacci(n) {
    if (n <= 0) return 0;
    if (n === 1) return 1;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// With memoization
function fibonacciMemo(n, memo = {}) {
    if (n in memo) return memo[n];
    if (n <= 0) return 0;
    if (n === 1) return 1;
    
    memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
    return memo[n];
}
```

---

## ‚ö° Complexity Analysis

| Function | Time | Space | Notes |
|----------|------|-------|-------|
| Factorial |" O(n) "| O(n) | Linear, stack depth n |
| Array sum |" O(n) "| O(n) | Linear, stack depth n |
| Fibonacci (naive) |" O(2‚Åø) "| O(n) | Exponential! |
| Fibonacci (memo) |" O(n) "| O(n) | Linear with cache |

**Space Complexity in Recursion:**
- Each call adds a stack frame ‚Üí O(depth of recursion)
- Tail-recursive functions can be optimized to O(1) space (in some languages)

---

## üîÑ Variations

| Variation | Description | Example |
|-----------|-------------|---------|
| **Linear recursion** | One recursive call | Factorial |
| **Binary recursion** | Two recursive calls | Fibonacci, tree traversal |
| **Tail recursion** | Recursive call is last operation | Can be optimized |
| **Mutual recursion** | Two functions call each other | isEven/isOdd |
| **Multiple recursion** | More than two calls | N-ary tree traversal |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Missing or Wrong Base Case

‚ùå **Wrong:** (Missing base case - infinite recursion)
```python
def countdown(n):
    print(n)
    countdown(n - 1)  # Never stops!
```

‚úÖ **Correct:**
```python
def countdown(n):
    if n < 0:  # Base case
        return
    print(n)
    countdown(n - 1)
```

### 2. Not Making Progress Toward Base Case

‚ùå **Wrong:**
```python
def sum_to_n(n):
    if n == 0:
        return 0
    return n + sum_to_n(n)  # n never changes!
```

‚úÖ **Correct:**
```python
def sum_to_n(n):
    if n == 0:
        return 0
    return n + sum_to_n(n - 1)  # n decreases each call
```

### 3. Stack Overflow for Large Inputs

‚ùå **Wrong:**
```python
def deep_recursion(n):
    if n == 0:
        return 0
    return 1 + deep_recursion(n - 1)

deep_recursion(100000)  # RecursionError!
```

‚úÖ **Correct:**
```python
# Use iteration for very deep recursion
def deep_iteration(n):
    result = 0
    for _ in range(n):
        result += 1
    return result

# Or increase limit (use with caution)
import sys
sys.setrecursionlimit(200000)
```

### 4. Modifying Shared State

‚ùå **Wrong:**
```python
result = []

def collect(arr):
    if not arr:
        return
    result.append(arr[0])  # Modifies global!
    collect(arr[1:])
```

‚úÖ **Correct:**
```python
def collect(arr):
    if not arr:
        return []
    return [arr[0]] + collect(arr[1:])
```

---

## üìù Practice Problems

### Beginner (Understand the concept)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Factorial | Linear recursion | - |
| Sum of N numbers | Base case practice | - |
| Fibonacci Number | Binary recursion | [LC 509](https://leetcode.com/problems/fibonacci-number/) |

### Easy (Learn the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Reverse String | Array recursion | [LC 344](https://leetcode.com/problems/reverse-string/) |
| Power of Two | Division recursion | [LC 231](https://leetcode.com/problems/power-of-two/) |
| Maximum Depth of Binary Tree | Tree recursion | [LC 104](https://leetcode.com/problems/maximum-depth-of-binary-tree/) |

### Medium (Apply to problems)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Pow(x, n) | Efficient recursion | [LC 50](https://leetcode.com/problems/powx-n/) |
| Climbing Stairs | With memoization | [LC 70](https://leetcode.com/problems/climbing-stairs/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1-2: Foundations**
- Day 1: Implement factorial, trace through calls
- Day 2: Implement array sum, understand slicing cost
- Day 3: Implement Fibonacci, see why it's slow
- Day 5: Add memoization to Fibonacci
- Day 7: Solve LC 509 (Fibonacci Number)

**Week 3-4: Applications**
- Solve tree depth problems
- Solve binary search recursively
- Practice tracing call stacks

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate About Recursion</strong></summary>

**When explaining your approach:**
> "I'll solve this recursively by identifying the base case and recursive relationship."

**Key phrases to use:**
- "The base case is when..."
- "In the recursive case, I break down the problem by..."
- "Each recursive call brings us closer to the base case because..."

**What interviewers look for:**
1. Clear identification of base case
2. Understanding of recursive relationship
3. Awareness of space complexity (call stack)
4. Knowledge of when to use memoization

**Common follow-up questions:**
- "What's the time/space complexity?"
- "What if n is very large?" (stack overflow concern)
- "Can you convert this to iteration?"

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 30-45 min | First exposure |
| Write factorial/sum | 10-15 min | Practice |
| Trace call stacks | 15-20 min | Draw diagrams |
| Add memoization | 15-20 min | Fibonacci example |
| Solve 3 Easy problems | 45-60 min | Application |

---

## üí° Key Insight

> **Think of recursion as delegation:**  
> "I'll handle this part, and I'll trust my recursive call to handle the rest correctly."
>
> You don't need to think about all the recursive calls at once. Just think about:
> 1. What's the simplest case I can solve directly? (base case)
> 2. If I assume the recursive call gives me the right answer for a smaller problem, how do I use it to solve my current problem? (recursive case)

---

## üîó Related

- [Recursion Patterns](./1.2-Recursion-Patterns.md) - Common patterns
- [Thinking Recursively](./1.3-Thinking-Process.md) - Mental model
- [Memoization](../04-Optimization/4.1-Memoization.md) - Optimizing recursion
- [Backtracking Template](../02-Backtracking/2.2-Backtracking-Template.md) - Building on recursion
