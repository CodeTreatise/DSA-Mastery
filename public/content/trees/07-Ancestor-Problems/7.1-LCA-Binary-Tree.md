# 7.1 - Lowest Common Ancestor of Binary Tree (LC 236)

> **Grokking Pattern:** #11 Tree DFS (LCA Pattern)
>
> **Difficulty:** Medium | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very Common

---

## Problem Statement

Given a binary tree, find the **lowest common ancestor (LCA)** of two given nodes in the tree.

According to the definition of LCA on Wikipedia: "The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself)."

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1

        3
       / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4

Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
```

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4

Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a 
descendant of itself.
```

[LeetCode 236 - Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Lowest common ancestor"
- "First common node above"
- "Find meeting point"

**Key insight:**
The LCA is the node where p and q are found in **different** subtrees,
OR where the current node IS one of p/q and the other is in a subtree.

Use postorder DFS: check children first, then make decision at current node.

</details>

---

## ‚úÖ When to Use

- Finding common ancestor
- Binary tree (not BST)
- Nodes guaranteed to exist

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Binary Search Tree | Can use BST property | LC 235 - compare values |
| Nodes might not exist | Need extra validation | Modified LCA |
| Need all ancestors | Different problem | Path to root |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [DFS Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
- [Maximum Depth](../04-Tree-Properties/4.1-Maximum-Depth.md) - Postorder basics

**After mastering this:**
- [LCA of BST](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) - LC 235
- [LCA with Parent Pointers](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/) - LC 1650
- [Deepest Leaves LCA](./7.2-Deepest-Leaves-LCA.md)

</details>

---

## üìê How It Works

### The Insight

For any node during DFS:
1. If current node is `p` or `q`, return it
2. Recursively search left and right subtrees
3. If both subtrees return non-null, current node is LCA
4. If only one subtree returns non-null, propagate that up

### Visualization

```
Looking for LCA(5, 1):

        3          ‚Üê Both children returned non-null: LCA!
       / \
      5   1        ‚Üê Left returns 5, Right returns 1
     / \ / \
    6  2 0  8

Looking for LCA(5, 4):

        3          ‚Üê Only left returned (5), propagate up
       / \
      5   1        ‚Üê Found 5, AND right subtree found 4
     / \ / \         So 5 is LCA (node can be its own descendant)
    6  2 0  8
      / \
     7   4         ‚Üê Found 4
```

### Decision Tree

```
At each node:
‚îú‚îÄ‚îÄ node is p or q? ‚Üí Return node
‚îú‚îÄ‚îÄ left AND right found something? ‚Üí Current is LCA
‚îú‚îÄ‚îÄ left found something? ‚Üí Propagate left result
‚îú‚îÄ‚îÄ right found something? ‚Üí Propagate right result
‚îî‚îÄ‚îÄ Neither found? ‚Üí Return null
```

---

## üíª Code Implementation

### Solution 1: Recursive DFS (Elegant)

**Python:**
```python
from typing import Optional

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


def lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """
    Find LCA of p and q in binary tree.
    
    Returns:
    - p if p is found (and q might be below)
    - q if q is found (and p might be below)
    - LCA if both p and q are in different subtrees
    - None if neither found
    
    Time: O(n), Space: O(h)
    """
    # Base case: empty or found target
    if not root or root == p or root == q:
        return root
    
    # Search both subtrees
    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)
    
    # If both subtrees found something, current is LCA
    if left and right:
        return root
    
    # Otherwise, return whichever side found something (or None)
    return left if left else right
```

**JavaScript:**
```javascript
function lowestCommonAncestor(root, p, q) {
    // Base case
    if (!root || root === p || root === q) {
        return root;
    }
    
    // Search both subtrees
    const left = lowestCommonAncestor(root.left, p, q);
    const right = lowestCommonAncestor(root.right, p, q);
    
    // Both sides found something: current is LCA
    if (left && right) {
        return root;
    }
    
    // Return non-null side
    return left || right;
}
```

### Solution 2: Path Finding Approach

**Python:**
```python
def lowest_common_ancestor_paths(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """
    Alternative: Find paths to p and q, then find last common node.
    More intuitive but uses more space.
    """
    def find_path(node, target, path):
        """Find path from root to target."""
        if not node:
            return False
        
        path.append(node)
        
        if node == target:
            return True
        
        if find_path(node.left, target, path) or find_path(node.right, target, path):
            return True
        
        path.pop()
        return False
    
    path_p, path_q = [], []
    find_path(root, p, path_p)
    find_path(root, q, path_q)
    
    # Find last common node
    lca = None
    for node_p, node_q in zip(path_p, path_q):
        if node_p == node_q:
            lca = node_p
        else:
            break
    
    return lca
```

### Solution 3: Iterative with Parent Pointers

**Python:**
```python
def lowest_common_ancestor_iterative(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """
    Build parent map, then find ancestors of p, check if q's ancestors match.
    """
    from collections import deque
    
    parent = {root: None}
    queue = deque([root])
    
    # Build parent map until we find both p and q
    while p not in parent or q not in parent:
        node = queue.popleft()
        if node.left:
            parent[node.left] = node
            queue.append(node.left)
        if node.right:
            parent[node.right] = node
            queue.append(node.right)
    
    # Get all ancestors of p
    ancestors_p = set()
    while p:
        ancestors_p.add(p)
        p = parent[p]
    
    # First ancestor of q that's also in p's ancestors is LCA
    while q not in ancestors_p:
        q = parent[q]
    
    return q
```

**JavaScript:**
```javascript
function lowestCommonAncestorIterative(root, p, q) {
    const parent = new Map();
    parent.set(root, null);
    
    const queue = [root];
    
    // Build parent map
    while (!parent.has(p) || !parent.has(q)) {
        const node = queue.shift();
        if (node.left) {
            parent.set(node.left, node);
            queue.push(node.left);
        }
        if (node.right) {
            parent.set(node.right, node);
            queue.push(node.right);
        }
    }
    
    // Get ancestors of p
    const ancestorsP = new Set();
    while (p) {
        ancestorsP.add(p);
        p = parent.get(p);
    }
    
    // Find first common ancestor
    while (!ancestorsP.has(q)) {
        q = parent.get(q);
    }
    
    return q;
}
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Recursive DFS |" O(n) "| O(h) | Most elegant |
| Path Finding |" O(n) "| O(n) | Store paths |
| Parent Pointers |" O(n) "| O(n) | Build map |

**Why recursive is preferred:**
- O(h) space vs O(n)
- Single pass
- Clean logic

---

## üîÑ Variations

| Variation | Difference | LeetCode |
|-----------|------------|----------|
| LCA in BST | Use value comparison | LC 235 |
| LCA with parent | Nodes have parent pointers | LC 1650 |
| LCA of deepest leaves | Find LCA of all deepest | LC 1123 |
| Nodes might not exist | Return null if either missing | Different handling |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Understanding the Return Value

```python
# The return value means:
# - Found p or q in this subtree (returns that node)
# - Found LCA in this subtree (returns LCA)
# - Found nothing (returns None)

# ‚ùå WRONG thinking: "return p" means "p is the answer"
# ‚úÖ CORRECT: "return p" means "I found p, let parent decide"
```

### 2. Checking Equality Wrong

```python
# ‚ùå WRONG: Comparing values
if root.val == p.val:

# ‚úÖ CORRECT: Comparing node references
if root == p:
```

### 3. Missing Base Case

```python
# ‚ùå WRONG: Not handling when root is p or q
if not root:
    return None
left = lca(root.left, p, q)
right = lca(root.right, p, q)
# Never finds p or q if they're at the root!

# ‚úÖ CORRECT: Check if root is p or q first
if not root or root == p or root == q:
    return root
```

### 4. Assuming Nodes Must Exist

```python
# This solution ASSUMES both p and q exist in the tree
# If they might not exist, need modified approach
def lca_safe(root, p, q):
    lca = [None]
    found = [False, False]  # [found_p, found_q]
    
    def dfs(node):
        if not node:
            return None
        left = dfs(node.left)
        right = dfs(node.right)
        
        if node == p:
            found[0] = True
        if node == q:
            found[1] = True
        
        if (left and right) or ((node == p or node == q) and (left or right)):
            lca[0] = node
        
        if node == p or node == q:
            return node
        return left or right
    
    dfs(root)
    return lca[0] if found[0] and found[1] else None
```

---

## üìù Practice Problems

### This Problem
- [ ] [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) - LC 236

### Related LCA Problems
- [ ] [LCA of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) - LC 235 (Easier)
- [ ] [LCA of Binary Tree III](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/) - LC 1650
- [ ] [LCA of Deepest Leaves](https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/) - LC 1123

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Understand recursive logic
**Day 3:** Implement from scratch
**Day 7:** Solve BST version (easier)
**Day 14:** Explain the return value meaning

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Explaining the approach:**
> "I'll use postorder DFS. At each node, I check if it's p or q, then search both subtrees. If both subtrees return something, this node is the LCA. Otherwise, I propagate up whichever side found something."

**Why it works:**
> "If p and q are in different subtrees, the first node where both subtrees are non-null is the LCA. If p is an ancestor of q, when I find p I return it, and since q is below, eventually p gets returned as the LCA."

**BST follow-up:**
> "For a BST, I can use the property: if both values are less than current, go left; if both greater, go right; otherwise current is LCA. No need to explore both subtrees."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Classic question |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Often asked |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard problem |
| Apple | ‚≠ê‚≠ê‚≠ê | Occasionally |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Clear definition |
| Implement recursive | 8-10 min | Clean solution |
| Implement iterative | 12-15 min | More complex |

---

> **üí° Key Insight:** The beauty of this solution is the meaning of the return value: it's not "this is the LCA" but rather "I found something here." The LCA is determined by the first node where both children return non-null, or where the node itself is one of the targets and a child returns the other.

---

## üîó Related

- [DFS Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
- [Deepest Leaves LCA](./7.2-Deepest-Leaves-LCA.md)
- [Same Tree](../04-Tree-Properties/4.5-Same-Tree.md) - Node comparison
