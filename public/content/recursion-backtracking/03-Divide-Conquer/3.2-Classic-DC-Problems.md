# 3.2 Classic Divide and Conquer Problems

> **Applying D&C to Real Interview Problems**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - Direct interview questions  
> **Prerequisites:** [3.1-DC-Basics](./3.1-DC-Basics.md)

---

## Overview

This file covers classic divide and conquer problems frequently asked in interviews. Master these patterns to recognize when D&C applies.

**Problems covered:**
1. Maximum Subarray (Kadane's D&C approach)
2. Merge K Sorted Lists
3. Kth Largest Element (Quick Select)
4. Closest Pair of Points
5. Count Inversions

---

## üéØ Pattern Recognition

<details>
<summary><strong>D&C Problem Categories</strong></summary>

| Category | Signal | Example |
|----------|--------|---------|
| **Search** | Sorted data, halving | Binary search variants |
| **Sort** | Order output | Merge sort, quick sort |
| **Select** | Find kth element | Quick select, median |
| **Counting** | Count pairs | Inversions, smaller after |
| **Optimization** | Max/min with splitting | Max subarray, closest pair |

</details>

---

## ‚úÖ When to Use D&C Approach

- Problem has **optimal substructure**
- Subproblems are **independent** (not overlapping)
- **Combining** results is efficient (O(n) or less)
- Looking for O(n log n) solution

---

## ‚ùå When NOT to Use

| Situation | Better Alternative |
|-----------|-------------------|
| Overlapping subproblems | Dynamic Programming |
| Simple linear scan works | Greedy / Linear |
| Constant extra operations | Direct computation |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this:**
- [D&C Basics](./3.1-DC-Basics.md)
- [Recursion Patterns](../01-Recursion/1.2-Recursion-Patterns.md)

**After mastering this:**
- Advanced: FFT, Strassen's Matrix
- [Memoization](../04-Optimization/4.1-Memoization.md)

</details>

---

## üìê Problem 1: Maximum Subarray

**LC 53 - Maximum Subarray**

Find contiguous subarray with largest sum.

### D&C Approach

```
Array: [-2, 1, -3, 4, -1, 2, 1, -5, 4]
                    |
           Left     |     Right
     [-2, 1, -3, 4] | [-1, 2, 1, -5, 4]
     
Max is one of:
1. Max in left half
2. Max in right half  
3. Max crossing the middle (spans both halves)
```

### üíª Implementation

```python
def max_subarray_dc(nums: list[int]) -> int:
    """
    Find maximum subarray sum using D&C.
    
    Time: O(n log n), Space: O(log n)
    """
    def helper(lo: int, hi: int) -> int:
        # Base case: single element
        if lo == hi:
            return nums[lo]
        
        mid = (lo + hi) // 2
        
        # Option 1: max in left half
        left_max = helper(lo, mid)
        
        # Option 2: max in right half
        right_max = helper(mid + 1, hi)
        
        # Option 3: max crossing middle
        cross_max = max_crossing(lo, mid, hi)
        
        return max(left_max, right_max, cross_max)
    
    def max_crossing(lo: int, mid: int, hi: int) -> int:
        # Max sum going left from mid
        left_sum = float('-inf')
        current = 0
        for i in range(mid, lo - 1, -1):
            current += nums[i]
            left_sum = max(left_sum, current)
        
        # Max sum going right from mid+1
        right_sum = float('-inf')
        current = 0
        for i in range(mid + 1, hi + 1):
            current += nums[i]
            right_sum = max(right_sum, current)
        
        return left_sum + right_sum
    
    return helper(0, len(nums) - 1)


# Example trace:
# nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
# 
# Split at index 4:
#   Left: [-2, 1, -3, 4] ‚Üí max = 4
#   Right: [-1, 2, 1, -5, 4] ‚Üí max = 4
#   Cross: 4 + (-1+2+1) = 6
# 
# Answer: 6 (subarray [4, -1, 2, 1])
```

```javascript
function maxSubarrayDC(nums) {
    function helper(lo, hi) {
        if (lo === hi) return nums[lo];
        
        const mid = Math.floor((lo + hi) / 2);
        const leftMax = helper(lo, mid);
        const rightMax = helper(mid + 1, hi);
        const crossMax = maxCrossing(lo, mid, hi);
        
        return Math.max(leftMax, rightMax, crossMax);
    }
    
    function maxCrossing(lo, mid, hi) {
        let leftSum = -Infinity;
        let current = 0;
        for (let i = mid; i >= lo; i--) {
            current += nums[i];
            leftSum = Math.max(leftSum, current);
        }
        
        let rightSum = -Infinity;
        current = 0;
        for (let i = mid + 1; i <= hi; i++) {
            current += nums[i];
            rightSum = Math.max(rightSum, current);
        }
        
        return leftSum + rightSum;
    }
    
    return helper(0, nums.length - 1);
}
```

---

## üìê Problem 2: Merge K Sorted Lists

**LC 23 - Merge k Sorted Lists**

Merge k sorted linked lists into one sorted list.

### D&C Approach

```
Lists: L1, L2, L3, L4, L5, L6, L7, L8
           /              \
   [L1, L2, L3, L4]  [L5, L6, L7, L8]
        /    \            /    \
   [L1,L2] [L3,L4]  [L5,L6] [L7,L8]
     |       |         |       |
    M12     M34       M56     M78
      \     /           \     /
       M1234             M5678
             \         /
              Final Merged
```

### üíª Implementation

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def merge_k_lists(lists: list[ListNode]) -> ListNode:
    """
    Merge k sorted lists using D&C.
    
    Time: O(N log k) where N = total nodes, k = number of lists
    Space: O(log k) for recursion
    """
    if not lists:
        return None
    if len(lists) == 1:
        return lists[0]
    
    # DIVIDE
    mid = len(lists) // 2
    left = merge_k_lists(lists[:mid])
    right = merge_k_lists(lists[mid:])
    
    # COMBINE
    return merge_two_lists(left, right)


def merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode:
    """Merge two sorted linked lists."""
    dummy = ListNode(0)
    current = dummy
    
    while l1 and l2:
        if l1.val <= l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    
    current.next = l1 or l2
    return dummy.next
```

```javascript
function mergeKLists(lists) {
    if (!lists.length) return null;
    if (lists.length === 1) return lists[0];
    
    const mid = Math.floor(lists.length / 2);
    const left = mergeKLists(lists.slice(0, mid));
    const right = mergeKLists(lists.slice(mid));
    
    return mergeTwoLists(left, right);
}

function mergeTwoLists(l1, l2) {
    const dummy = { val: 0, next: null };
    let current = dummy;
    
    while (l1 && l2) {
        if (l1.val <= l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    current.next = l1 || l2;
    return dummy.next;
}
```

---

## üìê Problem 3: Kth Largest Element (Quick Select)

**LC 215 - Kth Largest Element in an Array**

Find kth largest element without fully sorting.

### Quick Select Algorithm

Based on Quick Sort's partition, but only recurse into one side.

```
Find 2nd largest in [3, 2, 1, 5, 6, 4]
‚Üí Find element at index 5-2 = 3 (0-indexed) after partition

Partition around 4:
[3, 2, 1, 4, 6, 5]
          ^ pivot at index 3

k=4 > 3, so search right: [6, 5]
```

### üíª Implementation

```python
import random


def find_kth_largest(nums: list[int], k: int) -> int:
    """
    Find kth largest using Quick Select.
    
    Time: O(n) average, O(n¬≤) worst
    Space: O(1)
    """
    # Convert to index (kth largest = (n-k)th smallest)
    target_idx = len(nums) - k
    
    def quick_select(lo: int, hi: int) -> int:
        if lo == hi:
            return nums[lo]
        
        # Randomize pivot to avoid worst case
        pivot_idx = random.randint(lo, hi)
        pivot_idx = partition(lo, hi, pivot_idx)
        
        if pivot_idx == target_idx:
            return nums[pivot_idx]
        elif pivot_idx < target_idx:
            return quick_select(pivot_idx + 1, hi)
        else:
            return quick_select(lo, pivot_idx - 1)
    
    def partition(lo: int, hi: int, pivot_idx: int) -> int:
        pivot = nums[pivot_idx]
        # Move pivot to end
        nums[pivot_idx], nums[hi] = nums[hi], nums[pivot_idx]
        
        store_idx = lo
        for i in range(lo, hi):
            if nums[i] < pivot:
                nums[store_idx], nums[i] = nums[i], nums[store_idx]
                store_idx += 1
        
        # Move pivot to final position
        nums[store_idx], nums[hi] = nums[hi], nums[store_idx]
        return store_idx
    
    return quick_select(0, len(nums) - 1)


# Why O(n) average?
# First partition: n work
# Second partition: n/2 work (only one half)
# Third partition: n/4 work
# Total: n + n/2 + n/4 + ... = 2n = O(n)
```

```javascript
function findKthLargest(nums, k) {
    const targetIdx = nums.length - k;
    
    function quickSelect(lo, hi) {
        if (lo === hi) return nums[lo];
        
        const pivotIdx = partition(lo, hi);
        
        if (pivotIdx === targetIdx) return nums[pivotIdx];
        if (pivotIdx < targetIdx) return quickSelect(pivotIdx + 1, hi);
        return quickSelect(lo, pivotIdx - 1);
    }
    
    function partition(lo, hi) {
        const pivot = nums[hi];
        let storeIdx = lo;
        
        for (let i = lo; i < hi; i++) {
            if (nums[i] < pivot) {
                [nums[storeIdx], nums[i]] = [nums[i], nums[storeIdx]];
                storeIdx++;
            }
        }
        
        [nums[storeIdx], nums[hi]] = [nums[hi], nums[storeIdx]];
        return storeIdx;
    }
    
    return quickSelect(0, nums.length - 1);
}
```

---

## üìê Problem 4: Count Inversions

**Count pairs (i, j) where i < j but arr[i] > arr[j]**

Used in: ranking problems, sorting difficulty analysis

### D&C Approach (Modified Merge Sort)

```
Array: [2, 4, 1, 3, 5]

Split: [2, 4] | [1, 3, 5]
       ‚Üì        ‚Üì
       sorted   sorted
       [2, 4]   [1, 3, 5]

During merge, count cross-inversions:
When taking 1 from right: 2 elements in left > 1 ‚Üí count += 2
When taking 3 from right: 1 element in left > 3 ‚Üí count += 1
Total inversions = left_inv + right_inv + cross_inv
```

### üíª Implementation

```python
def count_inversions(arr: list[int]) -> int:
    """
    Count inversions using merge sort.
    
    Time: O(n log n), Space: O(n)
    """
    def merge_count(arr: list[int], temp: list[int], lo: int, hi: int) -> int:
        if lo >= hi:
            return 0
        
        mid = (lo + hi) // 2
        
        # Count in each half
        inv_count = merge_count(arr, temp, lo, mid)
        inv_count += merge_count(arr, temp, mid + 1, hi)
        
        # Count cross-inversions during merge
        inv_count += merge_and_count(arr, temp, lo, mid, hi)
        
        return inv_count
    
    def merge_and_count(arr: list[int], temp: list[int], lo: int, mid: int, hi: int) -> int:
        i = lo       # Left half pointer
        j = mid + 1  # Right half pointer
        k = lo       # Temp array pointer
        inv_count = 0
        
        while i <= mid and j <= hi:
            if arr[i] <= arr[j]:
                temp[k] = arr[i]
                i += 1
            else:
                temp[k] = arr[j]
                # All remaining elements in left half > arr[j]
                inv_count += (mid - i + 1)
                j += 1
            k += 1
        
        # Copy remaining
        while i <= mid:
            temp[k] = arr[i]
            i += 1
            k += 1
        while j <= hi:
            temp[k] = arr[j]
            j += 1
            k += 1
        
        # Copy back to original
        for i in range(lo, hi + 1):
            arr[i] = temp[i]
        
        return inv_count
    
    temp = [0] * len(arr)
    return merge_count(arr, temp, 0, len(arr) - 1)


# Example: [2, 4, 1, 3, 5]
# Inversions: (2,1), (4,1), (4,3) = 3
```

```javascript
function countInversions(arr) {
    const temp = new Array(arr.length);
    
    function mergeCount(lo, hi) {
        if (lo >= hi) return 0;
        
        const mid = Math.floor((lo + hi) / 2);
        let count = mergeCount(lo, mid);
        count += mergeCount(mid + 1, hi);
        count += mergeAndCount(lo, mid, hi);
        
        return count;
    }
    
    function mergeAndCount(lo, mid, hi) {
        let i = lo, j = mid + 1, k = lo;
        let count = 0;
        
        while (i <= mid && j <= hi) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
                count += (mid - i + 1);
            }
        }
        
        while (i <= mid) temp[k++] = arr[i++];
        while (j <= hi) temp[k++] = arr[j++];
        
        for (let x = lo; x <= hi; x++) arr[x] = temp[x];
        
        return count;
    }
    
    return mergeCount(0, arr.length - 1);
}
```

---

## ‚ö° Complexity Summary

| Problem | Time | Space | Notes |
|---------|------|-------|-------|
| Max Subarray (D&C) |" O(n log n) "| O(log n) |" Kadane's is O(n) "|
| Merge K Lists |" O(N log k) "| O(log k) | N = total nodes |
| Quick Select |" O(n) avg "| O(1) |" O(n¬≤) worst "|
| Count Inversions |" O(n log n) "| O(n) | Modified merge sort |

---

## üîÑ Variations

| Base Problem | Variation | Difference |
|--------------|-----------|------------|
| Max Subarray | Max product | Handle negatives |
| Merge K Lists | Merge K arrays | Same idea |
| Kth Largest | Median of medians |" O(n) worst case "|
| Count Inversions | Count smaller after | Index tracking |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Quick Select: Wrong K Conversion

‚ùå **Wrong:**
```python
# Kth largest directly
if pivot_idx == k:  # Wrong! k is 1-indexed from largest
```

‚úÖ **Correct:**
```python
target_idx = len(nums) - k  # Convert to 0-indexed from smallest
```

### 2. Count Inversions: Missing Copy Back

‚ùå **Wrong:**
```python
# Merge but don't copy back to original
for i in range(lo, hi + 1):
    temp[i] = arr[i]  # Copying wrong direction!
```

‚úÖ **Correct:**
```python
for i in range(lo, hi + 1):
    arr[i] = temp[i]  # Copy temp back to arr
```

### 3. Merge K Lists: Empty List Handling

‚ùå **Wrong:**
```python
def merge_k_lists(lists):
    mid = len(lists) // 2  # Crashes if lists is empty
```

‚úÖ **Correct:**
```python
def merge_k_lists(lists):
    if not lists:
        return None
    if len(lists) == 1:
        return lists[0]
```

---

## üìù Practice Problems

### Essential Problems

| Problem | Type | LeetCode |
|---------|------|----------|
| Maximum Subarray | D&C or DP | [LC 53](https://leetcode.com/problems/maximum-subarray/) |
| Merge k Sorted Lists | D&C merge | [LC 23](https://leetcode.com/problems/merge-k-sorted-lists/) |
| Kth Largest Element | Quick Select | [LC 215](https://leetcode.com/problems/kth-largest-element-in-an-array/) |
| Sort an Array | Merge/Quick | [LC 912](https://leetcode.com/problems/sort-an-array/) |

### Advanced Problems

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Median of Two Sorted Arrays | Complex D&C | [LC 4](https://leetcode.com/problems/median-of-two-sorted-arrays/) |
| Count of Smaller Numbers After Self | Merge sort + index | [LC 315](https://leetcode.com/problems/count-of-smaller-numbers-after-self/) |
| Reverse Pairs | Modified inversions | [LC 493](https://leetcode.com/problems/reverse-pairs/) |
| The Skyline Problem | D&C + merge | [LC 218](https://leetcode.com/problems/the-skyline-problem/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: LC 53 (Max Subarray - both D&C and Kadane)
- Day 3: LC 215 (Kth Largest - Quick Select)
- Day 5: LC 23 (Merge K Lists)

**Week 2:**
- Day 8: Count inversions (from scratch)
- Day 10: LC 315 (Count Smaller After)
- Day 14: LC 4 (Median of Two Arrays)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Present D&C Solutions</strong></summary>

**For Max Subarray:**
> "The D&C approach splits the array in half and considers three cases: max in left, max in right, or max crossing the middle. The crossing case requires O(n) work, giving us O(n log n) overall. However, I should mention that Kadane's algorithm solves this in O(n)."

**For Merge K Lists:**
> "I'll use D&C to pair up the lists and merge them. With k lists of total N nodes, this gives O(N log k) time because we have log k levels of merging and O(N) work at each level."

**For Quick Select:**
> "I'll use Quick Select, which is like Quick Sort but only recurses into one partition. Average O(n) time because we do n + n/2 + n/4 + ... = 2n work."

**When asked about alternatives:**
- Max Subarray: "Kadane's is O(n), better for this specific problem"
- Merge K: "Heap is also O(N log k) but with different constants"
- Kth Largest: "Heap is O(n log k), sorting is O(n log n)"

</details>

---

## ‚è±Ô∏è Time Estimates

| Problem | Expected Time | Interview Target |
|---------|---------------|------------------|
| Max Subarray | 15-20 min | 15 min |
| Merge K Lists | 20-25 min | 20 min |
| Quick Select | 25-30 min | 25 min |
| Count Inversions | 30-35 min | 30 min |

---

## üí° Key Insight

> **D&C works when:**
> 1. Problem naturally splits (halving, partitioning)
> 2. Subproblems are **independent**
> 3. Combining is **efficient** (O(n) or better)
>
> If subproblems overlap ‚Üí use Dynamic Programming!

---

## üîó Related

- [D&C Basics](./3.1-DC-Basics.md) - Templates
- [Memoization](../04-Optimization/4.1-Memoization.md) - When D&C has overlap
- [Sorting topic](../../03-Sorting-Searching.md) - Full sorting coverage
