# 6.3 Unbounded Knapsack Pattern

> **Unbounded Knapsack** is the "items can be reused" variant. While 0/1 Knapsack uses each item at most once, Unbounded allows unlimited copies. This small change has a big impact: **forward iteration instead of backward**.

---

## ðŸŽ¯ Pattern Recognition

<details>
<summary><strong>How to Identify Unbounded Knapsack</strong></summary>

**Look for these signals:**
- Items/choices can be used **multiple times**
- Making change with coins (infinite supply)
- Cutting a rod into pieces (can use same length multiple times)
- Filling a container with repeatable units

**Keywords:**
- "unlimited supply", "infinite copies"
- "as many times as you want"
- "coin change", "rod cutting"
- "combinations" vs "permutations"

**The pattern signature:**
```
For each capacity w, try ALL items that fit:
  dp[w] = best of (dp[w-weight[i]] + value[i]) for all i
```

</details>

---

## âœ… When to Use

- Each item has unlimited copies
- Order doesn't matter (combinations)
- Filling capacity/making amount with repeatable units
- Rod cutting, coin change, complete knapsack

## âŒ When NOT to Use

| Situation | Why | Use Instead |
|-----------|-----|-------------|
| Each item used once | Limited supply | 0/1 Knapsack |
| Order matters | Permutations | Different DP formulation |
| Items have limited count | Bounded | Bounded Knapsack |

---

## ðŸ“ 0/1 vs Unbounded: The Key Difference

```python
# 0/1 Knapsack: BACKWARD iteration
for i in range(n):
    for w in range(W, weights[i] - 1, -1):  # â† BACKWARD
        dp[w] = max(dp[w], dp[w - weights[i]] + values[i])

# Unbounded Knapsack: FORWARD iteration
for i in range(n):
    for w in range(weights[i], W + 1):  # â† FORWARD
        dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
```

**Why forward works for unbounded:**
```
Forward iteration in same row allows using same item again.
When we compute dp[w], dp[w - weights[i]] may already include item i.
This is EXACTLY what we want for unbounded!
```

---

## ðŸ’» Core Template: Unbounded Knapsack

```python
def unbounded_knapsack(weights: list[int], values: list[int], W: int) -> int:
    """
    Each item has infinite copies.
    Time: O(n*W), Space: O(W)
    """
    dp = [0] * (W + 1)
    
    for w in range(W + 1):
        for i in range(len(weights)):
            if weights[i] <= w:
                dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[W]
```

**Alternative loop order:**
```python
def unbounded_knapsack_alt(weights: list[int], values: list[int], W: int) -> int:
    dp = [0] * (W + 1)
    
    for i in range(len(weights)):
        for w in range(weights[i], W + 1):  # Forward!
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[W]
```

---

## ðŸ’» Problem 1: Coin Change (Minimum Coins)

**Problem:** Given coins of different denominations and a total amount, find minimum coins needed.

```python
def coin_change(coins: list[int], amount: int) -> int:
    """
    Minimum number of coins to make amount.
    Return -1 if impossible.
    
    Time: O(amount * n), Space: O(amount)
    """
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # 0 coins to make amount 0
    
    for coin in coins:
        for a in range(coin, amount + 1):  # Forward = unlimited coins
            dp[a] = min(dp[a], dp[a - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1
```

```javascript
function coinChange(coins, amount) {
    const dp = new Array(amount + 1).fill(Infinity);
    dp[0] = 0;
    
    for (const coin of coins) {
        for (let a = coin; a <= amount; a++) {
            dp[a] = Math.min(dp[a], dp[a - coin] + 1);
        }
    }
    
    return dp[amount] === Infinity ? -1 : dp[amount];
}
```

**Visualization:**
```
coins = [1, 2, 5], amount = 11

dp = [0, âˆž, âˆž, âˆž, âˆž, âˆž, âˆž, âˆž, âˆž, âˆž, âˆž, âˆž]

After coin 1:
dp = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

After coin 2:
dp = [0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6]

After coin 5:
dp = [0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3]

Answer: dp[11] = 3 (5 + 5 + 1)
```

---

## ðŸ’» Problem 2: Coin Change II (Count Ways)

**Problem:** Count the number of combinations that make up the amount.

```python
def change(amount: int, coins: list[int]) -> int:
    """
    Count combinations (not permutations).
    
    Time: O(amount * n), Space: O(amount)
    """
    dp = [0] * (amount + 1)
    dp[0] = 1  # One way to make 0: use no coins
    
    for coin in coins:
        for a in range(coin, amount + 1):
            dp[a] += dp[a - coin]
    
    return dp[amount]
```

**Why this counts combinations, not permutations:**
```
Loop order: for each coin, update all amounts.
This means we consider coins in order: all 1s, then all 2s, then all 5s.
[1,1,2] and [2,1,1] are counted as ONE combination.

For permutations, swap loops:
for a in range(1, amount + 1):
    for coin in coins:
        if coin <= a:
            dp[a] += dp[a - coin]
```

---

## ðŸ’» Problem 3: Rod Cutting

**Problem:** Cut a rod of length n to maximize profit. Each length has a price.

```python
def rod_cutting(prices: list[int], n: int) -> int:
    """
    prices[i] = price for rod of length i+1
    Maximize profit for rod of length n.
    
    Time: O(nÂ²), Space: O(n)
    """
    dp = [0] * (n + 1)
    
    for length in range(1, n + 1):  # Length of cut piece
        for rod_len in range(length, n + 1):
            dp[rod_len] = max(dp[rod_len], dp[rod_len - length] + prices[length - 1])
    
    return dp[n]
```

**Alternative formulation:**
```python
def rod_cutting_v2(prices: list[int], n: int) -> int:
    """prices[i] = price for length i+1"""
    dp = [0] * (n + 1)
    
    for i in range(1, n + 1):
        for j in range(1, i + 1):  # Try all first-cut positions
            dp[i] = max(dp[i], prices[j - 1] + dp[i - j])
    
    return dp[n]
```

---

## ðŸ’» Problem 4: Perfect Squares

**Problem:** Given n, find minimum number of perfect squares summing to n.

```python
def num_squares(n: int) -> int:
    """
    Like coin change with coins = [1, 4, 9, 16, ...]
    
    Time: O(nâˆšn), Space: O(n)
    """
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    # Generate squares up to n
    squares = []
    i = 1
    while i * i <= n:
        squares.append(i * i)
        i += 1
    
    for sq in squares:
        for num in range(sq, n + 1):
            dp[num] = min(dp[num], dp[num - sq] + 1)
    
    return dp[n]
```

---

## ðŸ”„ Combinations vs Permutations

| Type | Loop Order | Counts |
|------|------------|--------|
| Combinations | Coins outer, amount inner | [1,2] = [2,1] |
| Permutations | Amount outer, coins inner | [1,2] â‰  [2,1] |

```python
# Combinations: each unique set counted once
for coin in coins:
    for a in range(coin, amount + 1):
        dp[a] += dp[a - coin]

# Permutations: each ordering counted separately  
for a in range(1, amount + 1):
    for coin in coins:
        if coin <= a:
            dp[a] += dp[a - coin]
```

---

## âš¡ Complexity Analysis

| Problem | Time | Space |
|---------|------|-------|
| Unbounded Knapsack | O(nÃ—W) | O(W) |
| Coin Change (min) | O(nÃ—amount) | O(amount) |
| Coin Change II (count) | O(nÃ—amount) | O(amount) |
| Rod Cutting | O(nÂ²) | O(n) |
| Perfect Squares | O(nâˆšn) | O(n) |

---

## âš ï¸ Common Mistakes

### 1. Using Backward Loop (Wrong for Unbounded)

**âŒ Wrong:**
```python
for coin in coins:
    for a in range(amount, coin - 1, -1):  # Backward!
        dp[a] = min(dp[a], dp[a - coin] + 1)
# This is 0/1 - each coin used at most once
```

**âœ… Correct:**
```python
for coin in coins:
    for a in range(coin, amount + 1):  # Forward!
        dp[a] = min(dp[a], dp[a - coin] + 1)
```

### 2. Wrong Initialization for Counting

**âŒ Wrong:**
```python
dp = [1] * (amount + 1)  # Wrong! Only dp[0] should be 1
```

**âœ… Correct:**
```python
dp = [0] * (amount + 1)
dp[0] = 1  # One way to make 0
```

### 3. Wrong Initialization for Minimum

**âŒ Wrong:**
```python
dp = [0] * (amount + 1)  # Wrong! 0 means 0 coins needed
```

**âœ… Correct:**
```python
dp = [float('inf')] * (amount + 1)
dp[0] = 0  # 0 coins for amount 0
```

### 4. Forgetting -1 for Impossible Cases

**âŒ Wrong:**
```python
return dp[amount]  # Returns infinity if impossible
```

**âœ… Correct:**
```python
return dp[amount] if dp[amount] != float('inf') else -1
```

---

## ðŸ“ Practice Problems (Progressive)

**Easy/Medium:**
- [ ] [Coin Change](https://leetcode.com/problems/coin-change/) - Minimum coins
- [ ] [Coin Change II](https://leetcode.com/problems/coin-change-ii/) - Count ways

**Medium:**
- [ ] [Perfect Squares](https://leetcode.com/problems/perfect-squares/) - Squares as coins
- [ ] [Integer Break](https://leetcode.com/problems/integer-break/) - Rod cutting variant
- [ ] [Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/) - Permutations!

**Hard:**
- [ ] [Rod Cutting](https://www.geeksforgeeks.org/cutting-a-rod-dp-13/) - Classic

<details>
<summary><strong>ðŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Coin Change (understand forward iteration)
- **Day 3:** Coin Change II (combinations counting)
- **Day 7:** Perfect Squares (coins = squares)
- **Day 14:** Rod Cutting (maximize value)
- **Day 30:** Mixedâ€”identify 0/1 vs unbounded instantly

</details>

---

## ðŸŽ¤ Interview Context

<details>
<summary><strong>How to Communicate Unbounded vs 0/1</strong></summary>

**Pattern identification:**
> "Since each coin can be used unlimited times, this is Unbounded Knapsack, not 0/1. I'll iterate forward over amounts to allow reusing the same coin."

**Explaining loop direction:**
> "I iterate forward because when I compute dp[a], I want dp[a - coin] to potentially include the same coin already. That's how I get unlimited usage."

**For combinations vs permutations:**
> "Outer loop over coins gives combinationsâ€”[1,2] and [2,1] are the same. If I wanted permutations, I'd swap the loops."

</details>

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Understand unbounded vs 0/1 | 20-30 min |
| Coin Change | 15-20 min |
| Coin Change II | 15-20 min |
| Perfect Squares | 15-20 min |
| Rod Cutting | 20-25 min |

---

> **ðŸ’¡ Key Insight:** The ONLY difference from 0/1 Knapsack is iteration direction. Forward = unbounded (same item reusable). Backward = 0/1 (each item once). Remember: "Forward for Infinite, Backward for Bounded."

> **ðŸ”— Related:** [0/1 Knapsack](../04-Knapsack-01/) | [Coin Change Practice](./6.4-Unbounded-Practice/) | [DP Fundamentals](../01-DP-Fundamentals/)
