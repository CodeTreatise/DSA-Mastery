# Advanced Data Structures - Quick Reference

> **One-page cheat sheet for interview preparation.**

---

## üìä Decision Matrix: Which Structure to Use?

| Problem Type | First Choice | Alternative |
|--------------|--------------|-------------|
| Connected components | **Union-Find** | BFS/DFS |
| Cycle detection (undirected) | **Union-Find** | DFS |
| Range sum with updates | **Segment Tree** | BIT |
| Range min/max with updates | **Segment Tree** | - |
| Range min/max (static) | **Sparse Table** | Segment Tree |
| O(1) LRU Cache | **HashMap + DLL** | OrderedDict |
| Count inversions | **Merge Sort** or **BIT** | - |
| Sliding window max/min | **Monotonic Deque** | Segment Tree |
| Next greater element | **Monotonic Stack** | - |
| Dynamic kth element | **Ordered Set** | Two heaps |
| Membership with space constraint | **Bloom Filter** | - |

---

## ‚ö° Complexity Cheat Sheet

### Union-Find (Disjoint Set Union)

```
With Path Compression + Union by Rank:
- Find: O(Œ±(n)) ‚âà O(1) amortized
- Union: O(Œ±(n)) ‚âà O(1) amortized
- Space: O(n)
```

**Template:**
```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py: return False
        if self.rank[px] < self.rank[py]: px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]: self.rank[px] += 1
        return True
```

---

### LRU Cache

```
All operations: O(1)
Space: O(capacity)
```

**Template:**
```python
class LRUCache:
    def __init__(self, capacity):
        self.cache = OrderedDict()
        self.capacity = capacity
    
    def get(self, key):
        if key not in self.cache: return -1
        self.cache.move_to_end(key)
        return self.cache[key]
    
    def put(self, key, value):
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

---

### Segment Tree

```
Build: O(n)
Query: O(log n)
Update: O(log n)
Space: O(n) or O(4n) for array implementation
```

**Template (Range Sum):**
```python
class SegmentTree:
    def __init__(self, arr):
        self.n = len(arr)
        self.tree = [0] * (2 * self.n)
        # Build
        for i, val in enumerate(arr):
            self.tree[self.n + i] = val
        for i in range(self.n - 1, 0, -1):
            self.tree[i] = self.tree[2*i] + self.tree[2*i+1]
    
    def update(self, i, val):
        i += self.n
        self.tree[i] = val
        while i > 1:
            i //= 2
            self.tree[i] = self.tree[2*i] + self.tree[2*i+1]
    
    def query(self, l, r):  # [l, r)
        result = 0
        l += self.n
        r += self.n
        while l < r:
            if l & 1:
                result += self.tree[l]
                l += 1
            if r & 1:
                r -= 1
                result += self.tree[r]
            l //= 2
            r //= 2
        return result
```

> **‚ö†Ô∏è Convention Note:** This iterative template uses `[l, r)` (r exclusive). The recursive version in [3.1-Segment-Tree-Fundamentals.md](../03-Segment-Tree/3.1-Segment-Tree-Fundamentals.md) uses `[l, r]` (r inclusive). Be consistent within your solution!

---

### Fenwick Tree (BIT)

```
Build: O(n log n) or O(n)
Query (prefix): O(log n)
Update (point): O(log n)
Space: O(n)
```

**Template:**
```python
class BIT:
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)
    
    def update(self, i, delta):
        i += 1
        while i <= self.n:
            self.tree[i] += delta
            i += i & (-i)
    
    def query(self, i):  # Prefix sum [0, i]
        i += 1
        result = 0
        while i > 0:
            result += self.tree[i]
            i -= i & (-i)
        return result
    
    def range_query(self, l, r):
        return self.query(r) - (self.query(l-1) if l > 0 else 0)
```

---

### Sparse Table

```
Build: O(n log n)
Query: O(1) for idempotent operations
Space: O(n log n)
```

**Note:** Only for STATIC arrays with min/max/GCD queries.

---

## üéØ Pattern Recognition Quick Check

| Signal | Think... |
|--------|----------|
| "Union" or "connect" | Union-Find |
| "Are X and Y connected?" | Union-Find |
| "Number of connected components" | Union-Find |
| "Cycle in undirected graph" | Union-Find |
| "LRU/LFU Cache" | HashMap + LinkedList |
| "Range sum/min/max with updates" | Segment Tree |
| "Count elements less than X in range" | Segment Tree + Coordinate Compression |
| "Range min/max, no updates" | Sparse Table |
| "Count inversions" | Merge Sort or BIT |
| "Sliding window max/min" | Monotonic Deque |
| "Next greater/smaller element" | Monotonic Stack |

---

## ‚ö†Ô∏è Common Interview Mistakes

| Mistake | Fix |
|---------|-----|
| Forgetting path compression | Always flatten in `find()` |
| Wrong index in BIT (0 vs 1-based) | Add 1 to convert |
| Range [l, r] vs [l, r) confusion | Clarify with interviewer |
| Using BIT for range min/max | Use Segment Tree instead |
| Implementing segment tree recursively when iterative is cleaner | Know iterative version |
| LRU without dummy nodes | Use dummy head/tail for edge cases |

---

## üìù Must-Know Problems

| Structure | Problem | LeetCode |
|-----------|---------|----------|
| Union-Find | Number of Provinces | #547 |
| Union-Find | Redundant Connection | #684 |
| LRU Cache | LRU Cache | #146 |
| LFU Cache | LFU Cache | #460 |
| Segment Tree | Range Sum Query - Mutable | #307 |
| BIT | Count of Smaller Numbers After Self | #315 |
| Monotonic Stack | Daily Temperatures | #739 |
| Monotonic Deque | Sliding Window Maximum | #239 |

---

## üé§ Interview Tips

1. **Start with brute force:** Show you understand the problem
2. **Identify the pattern:** "This looks like a connected components problem..."
3. **Explain trade-offs:** "Union-Find gives us near-O(1) unions vs O(V+E) for BFS"
4. **Know your complexities:** Be ready to justify O(Œ±(n)) vs O(log n)
5. **Handle edge cases:** Empty input, single element, duplicates

---

> **üí° Key Insight:** In interviews, correctness beats optimization. Implement the simpler version first, then optimize if asked.

> **üîó Related:** [Common Mistakes ‚Üí](./6.2-Common-Mistakes.md) | [Practice Roadmap ‚Üí](./6.3-Practice-Roadmap.md)
