# 4.3 Convert BST to Greater Sum Tree (LC 538 / LC 1038)

## Problem Statement

[LeetCode 538 - Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree/)
[LeetCode 1038 - BST to Greater Sum Tree](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/) (Same problem)

Given the root of a BST, convert it to a Greater Tree where every node's value is replaced by the sum of all values greater than or equal to the original value.

```
Input:              Output:
      4                   30
     / \                 /  \
    1   6               36   21
   / \ / \             / \   / \
  0  2 5  7           36 35 26  15
         \                      \
          8                      8

Node 4: 4 + 5 + 6 + 7 + 8 = 30
Node 6: 6 + 7 + 8 = 21
Node 1: 1 + 2 + 4 + 5 + 6 + 7 + 8 = 33... wait, let me recalculate.
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a Reverse Inorder / Running Sum problem:**
- Need sum of all greater values
- Reverse inorder (right ‚Üí node ‚Üí left) visits in descending order
- Maintain running sum as we traverse

**Keywords:**
- "greater sum", "cumulative sum from right"
- "sum of values greater than"
- "transform each node"

**Pattern:** Reverse inorder traversal with running sum.

</details>

---

## ‚úÖ When to Use

- Cumulative sum from right/greater side
- Any problem requiring "sum of all larger elements"
- Suffix sum in sorted context

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Sum of smaller elements | Regular inorder instead | Prefix sum |
| General tree | No ordering | Different approach |
| Need original tree | This modifies in-place | Copy first |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Inorder Traversal](../../06-Trees/03-Tree-Traversals/3.1-DFS-Traversals/)
- [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
- Prefix/suffix sum concept

**After mastering this:**
- [BST Iterator](./4.2-BST-Iterator-LC173.md) - Controlled traversal
- More complex tree transformations

**Combines with:**
- Reverse inorder pattern
- Running sum / prefix sum technique

</details>

---

## üìê How It Works

### The Key Insight

```
Regular inorder: 0, 1, 2, 4, 5, 6, 7, 8 (ascending)
Reverse inorder: 8, 7, 6, 5, 4, 2, 1, 0 (descending)

For each node, we need sum of all nodes with value ‚â• current.

Reverse inorder with running sum:
Visit 8: sum = 0 + 8 = 8, replace 8 with 8
Visit 7: sum = 8 + 7 = 15, replace 7 with 15
Visit 6: sum = 15 + 6 = 21, replace 6 with 21
Visit 5: sum = 21 + 5 = 26, replace 5 with 26
Visit 4: sum = 26 + 4 = 30, replace 4 with 30
...and so on
```

### Visualization

```
Original:       Reverse Inorder Order:    Running Sum:
      4         8 ‚Üí 7 ‚Üí 6 ‚Üí 5 ‚Üí 4 ‚Üí       8, 15, 21, 26, 30,
     / \        2 ‚Üí 1 ‚Üí 0                 35, 36, 36
    1   6
   / \ / \      Each node gets replaced with running sum
  0  2 5  7     at the moment we visit it.
         \
          8

Result:
      30
     /  \
    36   21
   / \   / \
  36 35 26  15
            \
             8
```

---

## üíª Code Implementation

### Recursive (Clean)

**Python:**
```python
def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    """
    Convert BST to Greater Sum Tree.
    
    Time: O(n) - visit each node once
    Space: O(h) - recursion stack
    
    Pattern: Reverse inorder (right ‚Üí node ‚Üí left) with running sum.
    """
    self.running_sum = 0
    
    def reverse_inorder(node):
        if not node:
            return
        
        # Visit right first (larger values)
        reverse_inorder(node.right)
        
        # Process current node
        self.running_sum += node.val
        node.val = self.running_sum
        
        # Visit left (smaller values)
        reverse_inorder(node.left)
    
    reverse_inorder(root)
    return root
```

**JavaScript:**
```javascript
var convertBST = function(root) {
    // Reverse inorder with running sum
    let runningSum = 0;
    
    function reverseInorder(node) {
        if (!node) return;
        
        // Right first (larger values)
        reverseInorder(node.right);
        
        // Process current
        runningSum += node.val;
        node.val = runningSum;
        
        // Left (smaller values)
        reverseInorder(node.left);
    }
    
    reverseInorder(root);
    return root;
};
```

### Iterative (Using Stack)

**Python:**
```python
def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    """
    Iterative reverse inorder traversal.
    
    Time: O(n), Space: O(h)
    """
    running_sum = 0
    stack = []
    current = root
    
    while stack or current:
        # Go right as far as possible
        while current:
            stack.append(current)
            current = current.right
        
        # Visit node
        current = stack.pop()
        running_sum += current.val
        current.val = running_sum
        
        # Go left
        current = current.left
    
    return root
```

**JavaScript:**
```javascript
var convertBST = function(root) {
    // Iterative reverse inorder
    let runningSum = 0;
    const stack = [];
    let current = root;
    
    while (stack.length > 0 || current) {
        // Go right
        while (current) {
            stack.push(current);
            current = current.right;
        }
        
        // Visit
        current = stack.pop();
        runningSum += current.val;
        current.val = runningSum;
        
        // Go left
        current = current.left;
    }
    
    return root;
};
```

### Morris Traversal (O(1) Space)

**Python:**
```python
def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    """
    Morris reverse inorder - O(1) space.
    
    Uses temporary right-threaded links.
    """
    running_sum = 0
    current = root
    
    while current:
        if current.right is None:
            # Visit current
            running_sum += current.val
            current.val = running_sum
            current = current.left
        else:
            # Find inorder predecessor of current in right subtree
            # (leftmost in right subtree for reverse inorder)
            successor = current.right
            while successor.left and successor.left != current:
                successor = successor.left
            
            if successor.left is None:
                # Create link
                successor.left = current
                current = current.right
            else:
                # Remove link, visit current
                successor.left = None
                running_sum += current.val
                current.val = running_sum
                current = current.left
    
    return root
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Recursive |" O(n) "| O(h) | Simple, clean |
| Iterative |" O(n) "| O(h) | Explicit stack |
| Morris |" O(n) "| O(1) | Modifies links temporarily |

**Why O(n) time:**
- Each node is visited exactly once
- O(1) work per node (add, assign)

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **Smaller sum tree** | Regular inorder instead | Prefix sum |
| **Range sum tree** | Sum within [lo, hi] | Combined problem |
| **Don't modify original** | Create new tree | Copy approach |
| **Count instead of sum** | Count larger elements | Different application |

### Convert to Smaller Sum Tree

```python
def convertToSmallerSumTree(root: TreeNode) -> TreeNode:
    """Regular inorder with running sum."""
    running_sum = 0
    
    def inorder(node):
        nonlocal running_sum
        if not node:
            return
        
        inorder(node.left)
        
        running_sum += node.val
        node.val = running_sum
        
        inorder(node.right)
    
    inorder(root)
    return root
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Regular Inorder Instead of Reverse

```python
# ‚ùå Wrong: Left ‚Üí Node ‚Üí Right gives prefix sum, not suffix
def convert(node):
    if not node:
        return
    convert(node.left)
    self.sum += node.val
    node.val = self.sum
    convert(node.right)

# ‚úÖ Correct: Right ‚Üí Node ‚Üí Left for suffix sum
def convert(node):
    if not node:
        return
    convert(node.right)   # Visit right FIRST
    self.sum += node.val
    node.val = self.sum
    convert(node.left)
```

### 2. Forgetting to Add Current Value

```python
# ‚ùå Wrong: Excluding current value from sum
def convert(node):
    convert(node.right)
    node.val = self.sum  # Didn't add node.val!
    self.sum += node.val  # This is the old value now
    convert(node.left)

# ‚úÖ Correct: Add first, then assign
def convert(node):
    convert(node.right)
    self.sum += node.val  # Add current value first
    node.val = self.sum   # Then assign
    convert(node.left)
```

### 3. Not Using Instance Variable for Running Sum

```python
# ‚ùå Wrong: Local variable doesn't persist across calls
def convert(node):
    running_sum = 0  # Resets each call!
    ...

# ‚úÖ Correct: Use instance variable or nonlocal
self.running_sum = 0

def convert(node):
    self.running_sum += node.val  # Persists across calls
    ...
```

---

## üìù Practice Problems (Progressive)

### Easy (Build up)
- [ ] [Range Sum of BST (LC 938)](https://leetcode.com/problems/range-sum-of-bst/) - Range traversal

### Medium (Apply pattern)
- [ ] [Convert BST to Greater Tree (LC 538)](https://leetcode.com/problems/convert-bst-to-greater-tree/) - This problem
- [ ] [BST to GST (LC 1038)](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/) - Same problem
- [ ] [Kth Smallest (LC 230)](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) - Inorder variant

### Hard (Master)
- [ ] Implement with Morris traversal

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand reverse inorder concept
- **Day 3:** Implement recursive solution
- **Day 7:** Implement iterative solution
- **Day 14:** Solve without looking
- **Day 30:** Compare with regular inorder sum

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"For each node, I need the sum of all values greater than or equal to it. If I traverse in reverse inorder (right ‚Üí node ‚Üí left), I visit nodes in descending order. I maintain a running sum, and each node's new value is that running sum at the time of visit."

**Key points:**
1. "Reverse inorder visits in descending order"
2. "Running sum naturally accumulates 'greater or equal' values"
3. "Time O(n), space O(h) for recursion stack"

**Follow-up: O(1) space?**
"I can use Morris traversal with reverse inorder threading."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê | BST transformation |
| Google | ‚≠ê‚≠ê‚≠ê | Traversal variation |
| Microsoft | ‚≠ê‚≠ê | Less common |
| Meta | ‚≠ê‚≠ê | Occasionally asked |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 3-5 min | Trace example |
| Code recursive | 8-10 min | Simple once understood |
| Code iterative | 10-12 min | Stack manipulation |
| Discuss complexity | 2-3 min |" O(n) time, O(h) space "|
| Total interview time | 20-25 min | Medium difficulty |

---

## üí° Key Insight

> **Reverse inorder = descending order traversal.** Just as inorder gives ascending order, reverse inorder gives descending. For "sum of greater elements," this means we naturally encounter all greater values before each node, making a running sum the perfect solution.

---

## üîó Related

- **Previous:** [BST Iterator (LC 173)](./4.2-BST-Iterator-LC173.md)
- **Next:** [Two Sum BST (LC 653)](./4.4-Two-Sum-BST-LC653.md)
- **Pattern:** Reverse Inorder Traversal
- **Similar:** [Range Sum BST (LC 938)](../05-BST-Range-Problems/5.2-Range-Sum-BST-LC938.md)
