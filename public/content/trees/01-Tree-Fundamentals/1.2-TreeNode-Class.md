# 1.2 - TreeNode Class

> **Foundation:** The building block for all tree problems
>
> **Priority:** Must understand before solving any tree problem

---

## Overview

The `TreeNode` class is the fundamental building block for binary trees. Every LeetCode tree problem uses this structure (or a similar one). Understanding it deeply is essential.

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

---

## ðŸŽ¯ The Standard Definition

### Python (LeetCode Standard)

```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val        # Node's value
        self.left = left      # Left child (TreeNode or None)
        self.right = right    # Right child (TreeNode or None)
```

### JavaScript (LeetCode Standard)

```javascript
// Definition for a binary tree node.
function TreeNode(val, left, right) {
    this.val = (val === undefined ? 0 : val);
    this.left = (left === undefined ? null : left);
    this.right = (right === undefined ? null : right);
}

// Modern class syntax
class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### TypeScript

```typescript
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    
    constructor(val: number = 0, left: TreeNode | null = null, right: TreeNode | null = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

---

## ðŸ“ Creating Trees

### Method 1: Manual Node Creation

```python
# Build this tree:
#       1
#      / \
#     2   3
#    / \
#   4   5

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
```

### Method 2: Nested Constructor

```python
# Same tree, single expression
root = TreeNode(1,
    TreeNode(2,
        TreeNode(4),
        TreeNode(5)
    ),
    TreeNode(3)
)
```

### Method 3: From Level-Order Array (LeetCode Format)

```python
from collections import deque
from typing import Optional, List

def build_tree(values: List[Optional[int]]) -> Optional[TreeNode]:
    """
    Build tree from LeetCode-style level-order list.
    
    [1, 2, 3, None, None, 4, 5] creates:
           1
          / \
         2   3
            / \
           4   5
    """
    if not values or values[0] is None:
        return None
    
    root = TreeNode(values[0])
    queue = deque([root])
    i = 1
    
    while queue and i < len(values):
        node = queue.popleft()
        
        # Left child
        if i < len(values):
            if values[i] is not None:
                node.left = TreeNode(values[i])
                queue.append(node.left)
            i += 1
        
        # Right child
        if i < len(values):
            if values[i] is not None:
                node.right = TreeNode(values[i])
                queue.append(node.right)
            i += 1
    
    return root

# Usage
root = build_tree([1, 2, 3, None, None, 4, 5])
```

**JavaScript version:**

```javascript
function buildTree(values) {
    if (!values || !values.length || values[0] === null) {
        return null;
    }
    
    const root = new TreeNode(values[0]);
    const queue = [root];
    let i = 1;
    
    while (queue.length > 0 && i < values.length) {
        const node = queue.shift();
        
        // Left child
        if (i < values.length) {
            if (values[i] !== null) {
                node.left = new TreeNode(values[i]);
                queue.push(node.left);
            }
            i++;
        }
        
        // Right child
        if (i < values.length) {
            if (values[i] !== null) {
                node.right = new TreeNode(values[i]);
                queue.push(node.right);
            }
            i++;
        }
    }
    
    return root;
}
```

---

## ðŸ’» Essential Tree Utilities

### Print Tree (for Debugging)

```python
def print_tree(root: Optional[TreeNode], level: int = 0, prefix: str = "Root: ") -> None:
    """
    Pretty print a tree structure.
    
    Output for [1, 2, 3, 4, 5]:
    Root: 1
        L--- 2
            L--- 4
            R--- 5
        R--- 3
    """
    if root is not None:
        print(" " * (level * 4) + prefix + str(root.val))
        if root.left or root.right:
            if root.left:
                print_tree(root.left, level + 1, "L--- ")
            else:
                print(" " * ((level + 1) * 4) + "L--- None")
            if root.right:
                print_tree(root.right, level + 1, "R--- ")
            else:
                print(" " * ((level + 1) * 4) + "R--- None")
```

### Tree Equality Check

```python
def is_same_tree(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
    """Check if two trees are identical."""
    if not p and not q:
        return True
    if not p or not q:
        return False
    return (p.val == q.val and 
            is_same_tree(p.left, q.left) and 
            is_same_tree(p.right, q.right))
```

### Count Nodes

```python
def count_nodes(root: Optional[TreeNode]) -> int:
    """Count total nodes in tree."""
    if not root:
        return 0
    return 1 + count_nodes(root.left) + count_nodes(root.right)
```

### Find Node by Value

```python
def find_node(root: Optional[TreeNode], target: int) -> Optional[TreeNode]:
    """Find first node with given value."""
    if not root:
        return None
    if root.val == target:
        return root
    left_result = find_node(root.left, target)
    return left_result if left_result else find_node(root.right, target)
```

### Tree to List (Level Order)

```python
def tree_to_list(root: Optional[TreeNode]) -> List[Optional[int]]:
    """Convert tree back to LeetCode-style list."""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(node.val)
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append(None)
    
    # Remove trailing Nones
    while result and result[-1] is None:
        result.pop()
    
    return result
```

---

## ðŸ”„ TreeNode Variations

### With Parent Pointer

```python
class TreeNodeWithParent:
    """Used in some problems (e.g., LC 1650)."""
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None
        self.parent = None
```

### N-ary Tree Node

```python
class NaryNode:
    """For trees with multiple children (e.g., LC 428, 589)."""
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children else []
```

### Node with Additional Data

```python
class TreeNodeExtended:
    """Custom node with extra fields."""
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None
        self.count = 1      # For counting duplicates
        self.height = 1     # For AVL trees
        self.size = 1       # Subtree size
```

---

## âš ï¸ Common Mistakes

### 1. Modifying Node Instead of Reassigning

```python
# âŒ WRONG: Trying to change a node by reassigning parameter
def delete_leaf(node):
    node = None  # This only changes local variable!

# âœ… CORRECT: Modify parent's pointer
def delete_leaf(parent, is_left):
    if is_left:
        parent.left = None
    else:
        parent.right = None
```

### 2. Forgetting None Checks

```python
# âŒ WRONG: Will crash if root is None
def get_height(root):
    return 1 + max(get_height(root.left), get_height(root.right))

# âœ… CORRECT: Handle None first
def get_height(root):
    if not root:
        return 0
    return 1 + max(get_height(root.left), get_height(root.right))
```

### 3. Confusing Node Reference vs Value

```python
# âŒ WRONG: Comparing values when you need reference
if node == target:  # Works for values, not for finding specific node

# âœ… CORRECT: Be clear about what you're comparing
if node.val == target:  # Comparing values
if node is target_node:  # Comparing references (same object)
```

### 4. Not Understanding Mutability

```python
# TreeNode objects are mutable
def modify_tree(root):
    root.val = 100  # This DOES modify the original tree
    root = TreeNode(999)  # This does NOT affect original tree
```

---

## ðŸ“ Local Testing Template

```python
# Complete template for testing tree problems locally

from collections import deque
from typing import Optional, List

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def build_tree(values: List[Optional[int]]) -> Optional[TreeNode]:
    """Build tree from list."""
    if not values or values[0] is None:
        return None
    
    root = TreeNode(values[0])
    queue = deque([root])
    i = 1
    
    while queue and i < len(values):
        node = queue.popleft()
        if i < len(values) and values[i] is not None:
            node.left = TreeNode(values[i])
            queue.append(node.left)
        i += 1
        if i < len(values) and values[i] is not None:
            node.right = TreeNode(values[i])
            queue.append(node.right)
        i += 1
    
    return root

def tree_to_list(root: Optional[TreeNode]) -> List[Optional[int]]:
    """Convert tree to list."""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(node.val)
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append(None)
    
    while result and result[-1] is None:
        result.pop()
    
    return result

# Your solution function here
def your_solution(root: Optional[TreeNode]) -> any:
    pass

# Test
if __name__ == "__main__":
    # Test case 1
    root = build_tree([1, 2, 3, 4, 5])
    result = your_solution(root)
    print(f"Result: {result}")
    
    # Test case 2
    root = build_tree([1, None, 2, None, 3])
    result = your_solution(root)
    print(f"Result: {result}")
```

---

## ðŸŽ¤ Interview Context

<details>
<summary><strong>TreeNode in Interviews</strong></summary>

**What interviewers expect:**
1. Know the TreeNode structure without looking it up
2. Quickly build test trees for your examples
3. Handle None/null cases correctly
4. Understand the difference between node and value

**Common interview question:**
> "Define a TreeNode class for a binary tree"

```python
# Perfect answer:
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

</details>

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Memorize TreeNode | 5 min | Should be automatic |
| Write build_tree | 10 min | Practice until fast |
| Write tree_to_list | 10 min | For debugging |

---

> **ðŸ’¡ Key Insight:** The TreeNode class is deceptively simple - just three fields. But understanding how to create, traverse, and modify trees using this structure is the foundation for all 50+ tree problems on LeetCode. Master the basics before moving to complex problems.

---

## ðŸ”— Related

- [Tree Terminology](./1.1-Tree-Terminology.md)
- [Traversal Overview](./1.3-Traversal-Overview.md)
- [DFS Traversals](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
