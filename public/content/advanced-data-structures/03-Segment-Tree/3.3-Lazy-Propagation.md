# Lazy Propagation

> **Efficiently handle range updates in O(log n) instead of O(n).**
>
> "Lazy" means we delay propagating updates until absolutely necessary.

---

## ðŸŽ¯ The Problem

### Without Lazy Propagation

```
Update all elements in range [L, R] by adding value X.

Naive approach:
- Visit each element in [L, R]
- Update each one individually
- Time: O(R - L + 1) per update = O(n) worst case

With n updates, total time: O(nÂ²)
```

### With Lazy Propagation

```
Store pending updates at nodes.
Only propagate when needed.

Time: O(log n) per range update
With n updates, total time: O(n log n)
```

---

## ðŸ“ How It Works

### The Lazy Array

Each node stores a "pending" update that hasn't been pushed to children yet.

```
Concept:
- When updating a range, if node is completely covered, mark it "lazy"
- Don't update children yet
- When querying/updating that node later, push lazy value down first

tree[node] = aggregate of current segment
lazy[node] = pending update to apply to this segment
```

### Push Down Operation

Before accessing a node's children, push its lazy value down.

```python
def push_down(self, node, start, end):
    """Push lazy value to children."""
    if self.lazy[node] != 0:
        mid = (start + end) // 2
        left, right = 2 * node, 2 * node + 1
        
        # Update children's values
        self.tree[left] += self.lazy[node] * (mid - start + 1)
        self.tree[right] += self.lazy[node] * (end - mid)
        
        # Pass lazy to children
        self.lazy[left] += self.lazy[node]
        self.lazy[right] += self.lazy[node]
        
        # Clear current lazy
        self.lazy[node] = 0
```

---

## ðŸ’» Complete Implementation

**Python:**
```python
class LazySegmentTree:
    """
    Segment Tree with Lazy Propagation for range updates.
    
    Supports:
    - Range add: add X to all elements in [L, R]
    - Range sum query: sum of [L, R]
    
    Both operations: O(log n)
    """
    
    def __init__(self, arr: list):
        self.n = len(arr)
        self.tree = [0] * (4 * self.n)
        self.lazy = [0] * (4 * self.n)  # Pending updates
        if self.n > 0:
            self._build(arr, 1, 0, self.n - 1)
    
    def _build(self, arr: list, node: int, start: int, end: int) -> None:
        if start == end:
            self.tree[node] = arr[start]
        else:
            mid = (start + end) // 2
            self._build(arr, 2 * node, start, mid)
            self._build(arr, 2 * node + 1, mid + 1, end)
            self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]
    
    def _push_down(self, node: int, start: int, end: int) -> None:
        """Push pending update to children."""
        if self.lazy[node] != 0:
            mid = (start + end) // 2
            left, right = 2 * node, 2 * node + 1
            
            # Apply pending update to children
            # For sum: add lazy * count of elements
            self.tree[left] += self.lazy[node] * (mid - start + 1)
            self.tree[right] += self.lazy[node] * (end - mid)
            
            # Pass lazy to children
            self.lazy[left] += self.lazy[node]
            self.lazy[right] += self.lazy[node]
            
            # Clear current node's lazy
            self.lazy[node] = 0
    
    def range_update(self, L: int, R: int, val: int) -> None:
        """Add val to all elements in arr[L:R+1]."""
        self._range_update(1, 0, self.n - 1, L, R, val)
    
    def _range_update(self, node: int, start: int, end: int, 
                       L: int, R: int, val: int) -> None:
        # No overlap
        if R < start or end < L:
            return
        
        # Complete overlap - apply lazily
        if L <= start and end <= R:
            self.tree[node] += val * (end - start + 1)
            self.lazy[node] += val
            return
        
        # Partial overlap - push down and recurse
        self._push_down(node, start, end)
        
        mid = (start + end) // 2
        self._range_update(2 * node, start, mid, L, R, val)
        self._range_update(2 * node + 1, mid + 1, end, L, R, val)
        
        # Update current node
        self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]
    
    def query(self, L: int, R: int) -> int:
        """Return sum of arr[L:R+1]."""
        return self._query(1, 0, self.n - 1, L, R)
    
    def _query(self, node: int, start: int, end: int, L: int, R: int) -> int:
        # No overlap
        if R < start or end < L:
            return 0
        
        # Complete overlap
        if L <= start and end <= R:
            return self.tree[node]
        
        # Partial overlap - push down first!
        self._push_down(node, start, end)
        
        mid = (start + end) // 2
        left_sum = self._query(2 * node, start, mid, L, R)
        right_sum = self._query(2 * node + 1, mid + 1, end, L, R)
        return left_sum + right_sum


# Example
arr = [1, 3, 5, 7, 9]
st = LazySegmentTree(arr)

print(st.query(0, 4))      # 1+3+5+7+9 = 25

st.range_update(1, 3, 10)  # Add 10 to arr[1], arr[2], arr[3]
# Array becomes: [1, 13, 15, 17, 9]

print(st.query(0, 4))      # 1+13+15+17+9 = 55
print(st.query(1, 3))      # 13+15+17 = 45
```

**JavaScript:**
```javascript
class LazySegmentTree {
    constructor(arr) {
        this.n = arr.length;
        this.tree = new Array(4 * this.n).fill(0);
        this.lazy = new Array(4 * this.n).fill(0);
        if (this.n > 0) {
            this._build(arr, 1, 0, this.n - 1);
        }
    }
    
    _build(arr, node, start, end) {
        if (start === end) {
            this.tree[node] = arr[start];
        } else {
            const mid = Math.floor((start + end) / 2);
            this._build(arr, 2 * node, start, mid);
            this._build(arr, 2 * node + 1, mid + 1, end);
            this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1];
        }
    }
    
    _pushDown(node, start, end) {
        if (this.lazy[node] !== 0) {
            const mid = Math.floor((start + end) / 2);
            const left = 2 * node, right = 2 * node + 1;
            
            this.tree[left] += this.lazy[node] * (mid - start + 1);
            this.tree[right] += this.lazy[node] * (end - mid);
            this.lazy[left] += this.lazy[node];
            this.lazy[right] += this.lazy[node];
            this.lazy[node] = 0;
        }
    }
    
    rangeUpdate(L, R, val) {
        this._rangeUpdate(1, 0, this.n - 1, L, R, val);
    }
    
    _rangeUpdate(node, start, end, L, R, val) {
        if (R < start || end < L) return;
        
        if (L <= start && end <= R) {
            this.tree[node] += val * (end - start + 1);
            this.lazy[node] += val;
            return;
        }
        
        this._pushDown(node, start, end);
        
        const mid = Math.floor((start + end) / 2);
        this._rangeUpdate(2 * node, start, mid, L, R, val);
        this._rangeUpdate(2 * node + 1, mid + 1, end, L, R, val);
        this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1];
    }
    
    query(L, R) {
        return this._query(1, 0, this.n - 1, L, R);
    }
    
    _query(node, start, end, L, R) {
        if (R < start || end < L) return 0;
        if (L <= start && end <= R) return this.tree[node];
        
        this._pushDown(node, start, end);
        
        const mid = Math.floor((start + end) / 2);
        return this._query(2 * node, start, mid, L, R) +
               this._query(2 * node + 1, mid + 1, end, L, R);
    }
}
```

---

## ðŸ” Visualization

```
Array: [1, 2, 3, 4]
Operation: range_update(0, 2, 5)  // Add 5 to arr[0], arr[1], arr[2]

Initial:
tree:  [_, 10, 3, 7, 1, 2, 3, 4]
lazy:  [_,  0, 0, 0, 0, 0, 0, 0]

               10
              /  \
            3      7
           / \    / \
          1   2  3   4

After range_update(0, 2, 5):

Step 1: At root [0-3], partial overlap â†’ push down (nothing), recurse

Step 2: At [0-1], COMPLETE overlap (0-1 âŠ† 0-2)
  tree[2] += 5 * 2 = 13
  lazy[2] = 5
  Return (don't go to children!)

Step 3: At [2-3], partial overlap â†’ push down (nothing)
  - At [2]: COMPLETE overlap, tree[6] += 5 * 1 = 8, lazy[6] = 5
  - At [3]: NO overlap, return
  tree[3] = 8 + 4 = 12

Step 4: Update root: tree[1] = 13 + 12 = 25

After:
tree:  [_, 25, 13, 12, 1, 2, 8, 4]
lazy:  [_,  0,  5,  0, 0, 0, 5, 0]

Note: Leaves 4 and 5 still have old values (1, 2),
but their parent [0-1] has correct sum (13) and lazy (5).
When we query leaves later, lazy will be pushed down.
```

---

## âš¡ Complexity Analysis

| Operation | Without Lazy | With Lazy |
|-----------|--------------|-----------|
| Build | O(n) | O(n) |
| Point Update | O(log n) | O(log n) |
| **Range Update** | O(n) | **O(log n)** |
| Range Query | O(log n) | O(log n) |

**Why O(log n) for range update?**
- At each level, at most O(1) nodes have partial overlap
- Nodes with complete overlap are marked lazy (O(1))
- Total nodes visited: O(log n)

---

## âš ï¸ Common Mistakes

### 1. Forgetting to Push Down

```python
# âŒ Wrong: Query without push down
def _query(self, node, start, end, L, R):
    if R < start or end < L:
        return 0
    if L <= start and end <= R:
        return self.tree[node]
    # MISSING: self._push_down(node, start, end)
    mid = (start + end) // 2
    return self._query(...) + self._query(...)

# âœ… Correct: Always push down before accessing children
def _query(self, node, start, end, L, R):
    if R < start or end < L:
        return 0
    if L <= start and end <= R:
        return self.tree[node]
    self._push_down(node, start, end)  # Push before recurse!
    mid = (start + end) // 2
    return self._query(...) + self._query(...)
```

### 2. Wrong Lazy Application for Different Operations

```python
# For range ADD:
self.tree[node] += lazy * (end - start + 1)  # Add to each element

# For range SET (assign):
self.tree[node] = lazy * (end - start + 1)   # Replace entirely

# For range MIN update:
# More complex - need to track multiple things
```

### 3. Not Updating Tree After Range Update

```python
# âŒ Wrong: Missing recalculation
def _range_update(self, node, start, end, L, R, val):
    ...
    self._range_update(left, ...)
    self._range_update(right, ...)
    # MISSING: recalculate current node!

# âœ… Correct
def _range_update(self, node, start, end, L, R, val):
    ...
    self._range_update(left, ...)
    self._range_update(right, ...)
    self.tree[node] = self.tree[2*node] + self.tree[2*node+1]
```

---

## ðŸ”„ Variations

### Range Set (Assign)

```python
def _range_set(self, node, start, end, L, R, val):
    if R < start or end < L:
        return
    
    if L <= start and end <= R:
        self.tree[node] = val * (end - start + 1)
        self.lazy[node] = val
        self.has_lazy[node] = True  # Need flag for "set" operation
        return
    
    self._push_down(node, start, end)
    mid = (start + end) // 2
    self._range_set(2 * node, start, mid, L, R, val)
    self._range_set(2 * node + 1, mid + 1, end, L, R, val)
    self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]
```

### Combining Range Operations

Sometimes you need both add and set. Use careful precedence rules:
- SET clears pending ADD
- ADD accumulates

---

## ðŸ“ Practice Problems

| Problem | Difficulty | Key Concept |
|---------|------------|-------------|
| [Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/) | Medium | Point update (no lazy needed) |
| [Corporate Flight Bookings](https://leetcode.com/problems/corporate-flight-bookings/) | Medium | Range add, point query |
| [Falling Squares](https://leetcode.com/problems/falling-squares/) | Hard | Range max, range update |

---

## ðŸŽ¤ Interview Tips

**When to mention lazy propagation:**
> "If we have range updates, naive O(n) per update won't scale. I'll use lazy propagation to achieve O(log n) per range update."

**Explaining the concept:**
> "Instead of immediately updating all children, I store the pending update at the node. When I later need to access children, I push the pending update down first. This amortizes the update cost."

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Understand concept | 20 min |
| Implement push_down | 10 min |
| Modify update/query | 15 min |
| Debug edge cases | 15 min |
| Total | 60 min |

---

> **ðŸ’¡ Key Insight:** Lazy propagation is essentially "memoizing" range updates. Instead of doing O(n) work immediately, we store the work to be done and only execute it when needed. This converts O(n) range updates to O(log n).

> **ðŸ”— Related:** [Build, Query, Update](./3.2-Build-Query-Update.md) | [Segment Tree Problems â†’](./3.4-Segment-Tree-Problems.md)

---

**Next:** [Segment Tree Problems â†’](./3.4-Segment-Tree-Problems.md)
