# 7.4 Reorganize String (LC 767)

## Problem Statement

Given a string `s`, rearrange the characters of `s` so that any two adjacent characters are not the same.

Return any possible rearrangement of `s` or return `""` if not possible.

```
Example 1:
Input: s = "aab"
Output: "aba"

Example 2:
Input: s = "aaab"
Output: ""
Explanation: No valid arrangement exists.
```

**Constraints:**
- 1 ‚â§ s.length ‚â§ 500
- s consists of lowercase English letters

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Problem Type</strong></summary>

**Key signals:**
- "No two adjacent same"
- "Rearrange characters/elements"
- "Alternating placement"
- "Greedy character selection"

**Why max-heap?**
- Always place the most frequent character
- This maximizes chances of success
- Alternate with second-most-frequent

**Impossibility check:**
- If any character appears more than `(n + 1) / 2` times
- Example: "aaab" (n=4), max allowed = 2, but 'a' = 3

</details>

---

## ‚úÖ When to Use This Approach

- Rearranging with "no adjacent same" constraint
- Greedy placement to construct valid sequence
- Checking feasibility of alternating arrangement

## ‚ùå When NOT to Use

| Scenario | Alternative |
|----------|-------------|
| Finding all arrangements | Backtracking |
| With cooldown period | Task Scheduler approach |
| Specific positions required | Constraint satisfaction |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this:**
- [Heap Fundamentals](../01-Heap-Fundamentals/1.1-What-Is-Heap.md)
- [Task Scheduler (LC 621)](./7.2-Task-Scheduler-LC621.md)

**Related problems:**
- [Distant Barcodes (LC 1054)](https://leetcode.com/problems/distant-barcodes/)
- [Task Scheduler (LC 621)](https://leetcode.com/problems/task-scheduler/)

</details>

---

## üìê Solution Approaches

### Approach 1: Max-Heap with Previous Tracking

**Intuition:**
```
s = "aab"

Heap: [('a', 2), ('b', 1)]  ‚Üí sorted by count

Step 1: Pop 'a' (count=2), add to result
        result = "a"
        prev = ('a', 1)  # Still has 1 remaining
        
Step 2: Pop 'b' (count=1), add to result
        result = "ab"
        Push prev back ‚Üí Heap: [('a', 1)]
        prev = ('b', 0)  # No remaining
        
Step 3: Pop 'a' (count=1), add to result
        result = "aba"
        (prev has 0, don't push back)

Answer: "aba"
```

**Python:**
```python
import heapq
from collections import Counter

def reorganizeString(s: str) -> str:
    """
    Max-heap approach with previous tracking.
    Time: O(n log k), Space: O(k) where k = unique chars
    """
    count = Counter(s)
    
    # Check impossibility
    max_count = max(count.values())
    if max_count > (len(s) + 1) // 2:
        return ""
    
    # Max-heap: (-count, char)
    max_heap = [(-cnt, char) for char, cnt in count.items()]
    heapq.heapify(max_heap)
    
    result = []
    prev_count, prev_char = 0, ''
    
    while max_heap:
        neg_count, char = heapq.heappop(max_heap)
        result.append(char)
        
        # Push previous character back if it has remaining count
        if prev_count < 0:
            heapq.heappush(max_heap, (prev_count, prev_char))
        
        # Current becomes previous for next iteration
        prev_count = neg_count + 1  # +1 because we used one
        prev_char = char
    
    return ''.join(result)
```

**JavaScript:**
```javascript
function reorganizeString(s) {
    const count = new Map();
    for (const char of s) {
        count.set(char, (count.get(char) || 0) + 1);
    }
    
    // Check impossibility
    const maxCount = Math.max(...count.values());
    if (maxCount > Math.floor((s.length + 1) / 2)) {
        return "";
    }
    
    // Max-heap simulation with array
    const heap = [];
    for (const [char, cnt] of count) {
        heap.push([-cnt, char]);
    }
    heap.sort((a, b) => a[0] - b[0]);  // Sort ascending (negatives = max-heap)
    
    const result = [];
    let prevCount = 0, prevChar = '';
    
    while (heap.length > 0) {
        heap.sort((a, b) => a[0] - b[0]);
        const [negCount, char] = heap.shift();
        result.push(char);
        
        if (prevCount < 0) {
            heap.push([prevCount, prevChar]);
        }
        
        prevCount = negCount + 1;
        prevChar = char;
    }
    
    return result.join('');
}
```

### Approach 2: Place at Even/Odd Indices

**Intuition:**
- Fill even indices first (0, 2, 4, ...)
- Then fill odd indices (1, 3, 5, ...)
- Most frequent character at even positions first

```python
from collections import Counter

def reorganizeString_indices(s: str) -> str:
    """
    Fill even indices, then odd indices.
    Time: O(n), Space: O(n)
    """
    count = Counter(s)
    n = len(s)
    
    # Check impossibility
    max_count = max(count.values())
    if max_count > (n + 1) // 2:
        return ""
    
    # Sort characters by frequency (descending)
    sorted_chars = sorted(count.keys(), key=lambda x: -count[x])
    
    result = [''] * n
    idx = 0  # Start with even indices
    
    for char in sorted_chars:
        for _ in range(count[char]):
            result[idx] = char
            idx += 2
            
            # Switch to odd indices when even are full
            if idx >= n:
                idx = 1
    
    return ''.join(result)
```

### Approach 3: Interleave Two Most Frequent

```python
import heapq
from collections import Counter

def reorganizeString_interleave(s: str) -> str:
    """
    Pop two at a time, interleave them.
    Time: O(n log k), Space: O(k)
    """
    count = Counter(s)
    
    max_count = max(count.values())
    if max_count > (len(s) + 1) // 2:
        return ""
    
    max_heap = [(-cnt, char) for char, cnt in count.items()]
    heapq.heapify(max_heap)
    
    result = []
    
    while len(max_heap) >= 2:
        # Pop two most frequent
        cnt1, char1 = heapq.heappop(max_heap)
        cnt2, char2 = heapq.heappop(max_heap)
        
        result.extend([char1, char2])
        
        # Push back if remaining
        if cnt1 + 1 < 0:
            heapq.heappush(max_heap, (cnt1 + 1, char1))
        if cnt2 + 1 < 0:
            heapq.heappush(max_heap, (cnt2 + 1, char2))
    
    # Handle last remaining character (if any)
    if max_heap:
        result.append(max_heap[0][1])
    
    return ''.join(result)
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Max-Heap + Prev |" O(n log k) "| O(k) | k = unique chars (‚â§ 26) |
| Even/Odd Indices |" O(n) "| O(n) | Result array |
| Interleave Two |" O(n log k) "| O(k) | Cleaner logic |

**Why O(n log k)?**
- Each character processed once: O(n)
- Each heap operation: O(log k)
- k ‚â§ 26 for lowercase letters, so effectively O(n log 26) = O(n)

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Integers | Same concept, different data | LC 1054 Distant Barcodes |
| With cooldown K | K positions apart | Modified problem |
| Count possible arrangements | Need backtracking | Different problem |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Missing Impossibility Check

```python
# ‚ùå Wrong: May try to construct impossible result
def reorganize(s):
    # Start building without checking...

# ‚úÖ Correct: Check first
max_count = max(count.values())
if max_count > (len(s) + 1) // 2:
    return ""
```

### 2. Forgetting to Push Previous Back

```python
# ‚ùå Wrong: Previous character lost
while max_heap:
    neg_count, char = heappop(max_heap)
    result.append(char)
    # Where does char go after being used?

# ‚úÖ Correct: Track and push back
if prev_count < 0:  # Still has remaining
    heappush(max_heap, (prev_count, prev_char))
```

### 3. Wrong Remaining Count

```python
# ‚ùå Wrong: Using positive counts in max-heap
prev_count = neg_count - 1  # This makes it more negative!

# ‚úÖ Correct: Add 1 to negative count (reduces magnitude)
prev_count = neg_count + 1  # -3 + 1 = -2 (one less remaining)
```

### 4. Edge Case: Single Character

```python
# s = "a" ‚Üí should return "a"
# max_count = 1, (1 + 1) // 2 = 1
# 1 > 1 is False, so it's possible ‚úì
```

---

## üìù Practice Problems

### This Problem
- [ ] [Reorganize String (LC 767)](https://leetcode.com/problems/reorganize-string/) ‚≠ê

### Related Problems
- [ ] [Distant Barcodes (LC 1054)](https://leetcode.com/problems/distant-barcodes/)
- [ ] [Task Scheduler (LC 621)](https://leetcode.com/problems/task-scheduler/)
- [ ] [Rearrange String k Distance Apart (LC 358)](https://leetcode.com/problems/rearrange-string-k-distance-apart/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement max-heap approach
- **Day 3:** Implement index-based approach
- **Day 7:** Solve Distant Barcodes
- **Day 14:** Explain impossibility condition

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This Solution</strong></summary>

**Opening:**
"This is a greedy placement problem. I want to avoid placing the same character twice in a row."

**Impossibility:**
"First, I check if it's even possible. If any character appears more than ‚åàn/2‚åâ times, there's no valid arrangement. For example, 'aaab' has 4 characters, max allowed per char is 2, but 'a' appears 3 times."

**Approach:**
"I use a max-heap to always get the most frequent character. After placing it, I track it as 'previous' and push it back later to avoid placing it adjacent."

**Why greedy works:**
"By always placing the most frequent character, I minimize the risk of being stuck with only that character left at the end."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Multiple variations |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Common |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Sometimes asked |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand problem | 2-3 min |
| Impossibility check | 3-5 min |
| Heap solution | 15-20 min |
| Edge cases | 5 min |

---

## üí° Key Insight

> **The greedy approach works because placing the most frequent character first gives the most flexibility for the remaining positions.** The impossibility condition `max_count > (n + 1) // 2` comes from the pigeonhole principle: in a string of length n, we can only have at most ‚åàn/2‚åâ of the same character in non-adjacent positions.

---

## üîó Related

- **Previous:** [Meeting Rooms II](./7.3-Meeting-Rooms-II-LC253.md)
- **Section:** [Scheduling Overview](./7.1-Task-Scheduler-Overview.md)
- **Similar:** [Task Scheduler](./7.2-Task-Scheduler-LC621.md)
