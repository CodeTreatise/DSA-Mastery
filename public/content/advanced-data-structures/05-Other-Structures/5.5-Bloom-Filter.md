# Bloom Filter

> **A space-efficient probabilistic data structure for membership testing.**
>
> Can have false positives, but never false negatives.

---

## ðŸŽ¯ When to Use

| Scenario | Why Bloom Filter |
|----------|------------------|
| Check membership before expensive lookup | Fast negative response saves work |
| Huge dataset that can't fit in memory | Very space-efficient |
| Cache existence checking | Filter before DB query |
| Duplicate detection at scale | Used by databases, web crawlers |

**Example use cases:**
- Is this URL already crawled? (web crawlers)
- Is this username taken? (quick check before DB)
- Is this IP in blocklist? (network filtering)
- Is this word spelled correctly? (spell checkers)

---

## ðŸ“ How It Works

### Structure

A Bloom filter is a bit array with k hash functions.

```
Bit array:  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
             0  1  2  3  4  5  6  7  8  9
```

### Insert("hello")

Apply k hash functions, set those bits to 1:

```
hash1("hello") = 2
hash2("hello") = 5
hash3("hello") = 7

Bit array:  [0, 0, 1, 0, 0, 1, 0, 1, 0, 0]
             0  1  2  3  4  5  6  7  8  9
                   â†‘        â†‘     â†‘
```

### Query("world")

Check if ALL k bits are set:

```
hash1("world") = 3
hash2("world") = 5
hash3("world") = 9

Check bits:  [0, 0, 1, 0, 0, 1, 0, 1, 0, 0]
                       â†‘     â†‘           â†‘
                       0     1           0

Result: NOT all 1s â†’ "world" is DEFINITELY NOT in set
```

### Query("apple")

```
hash1("apple") = 2
hash2("apple") = 5  
hash3("apple") = 7

Check bits:  [0, 0, 1, 0, 0, 1, 0, 1, 0, 0]
                   â†‘        â†‘     â†‘
                   1        1     1

Result: All 1s â†’ "apple" MIGHT be in set (false positive!)
```

---

## ðŸ’» Implementation

**Python:**
```python
import hashlib

class BloomFilter:
    """
    Simple Bloom Filter implementation.
    
    False positive rate depends on:
    - m: size of bit array
    - n: expected number of elements
    - k: number of hash functions
    
    Optimal k = (m/n) * ln(2) â‰ˆ 0.7 * (m/n)
    """
    
    def __init__(self, size: int, num_hashes: int):
        self.size = size
        self.num_hashes = num_hashes
        self.bit_array = [False] * size
    
    def _hashes(self, item: str):
        """Generate k hash values for item."""
        hashes = []
        for i in range(self.num_hashes):
            # Create different hashes by appending seed
            h = hashlib.sha256((str(i) + item).encode())
            hashes.append(int(h.hexdigest(), 16) % self.size)
        return hashes
    
    def add(self, item: str):
        """Add item to bloom filter."""
        for h in self._hashes(item):
            self.bit_array[h] = True
    
    def contains(self, item: str) -> bool:
        """
        Check if item might be in set.
        
        Returns:
            False: Definitely NOT in set
            True: MIGHT be in set (possible false positive)
        """
        return all(self.bit_array[h] for h in self._hashes(item))


# Example
bf = BloomFilter(size=100, num_hashes=3)

# Add some items
bf.add("hello")
bf.add("world")

# Check membership
print(bf.contains("hello"))   # True (definitely added)
print(bf.contains("world"))   # True (definitely added)
print(bf.contains("foo"))     # Likely False (not added)
print(bf.contains("bar"))     # Likely False (not added)
# Note: Some items might return True due to hash collisions
```

**JavaScript:**
```javascript
class BloomFilter {
    constructor(size, numHashes) {
        this.size = size;
        this.numHashes = numHashes;
        this.bitArray = new Array(size).fill(false);
    }
    
    _hash(item, seed) {
        // Simple hash function (use better one in production)
        let hash = 0;
        const str = seed + item;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash;
        }
        return Math.abs(hash) % this.size;
    }
    
    add(item) {
        for (let i = 0; i < this.numHashes; i++) {
            const idx = this._hash(item, String(i));
            this.bitArray[idx] = true;
        }
    }
    
    contains(item) {
        for (let i = 0; i < this.numHashes; i++) {
            const idx = this._hash(item, String(i));
            if (!this.bitArray[idx]) return false;
        }
        return true;
    }
}
```

---

## âš¡ Properties

### False Positive Rate

```
p = (1 - e^(-kn/m))^k

Where:
- m = bit array size
- n = number of elements inserted
- k = number of hash functions
```

### Optimal Parameters

Given n elements and desired false positive rate p:

```
m = -n * ln(p) / (ln(2)^2)    # Optimal bit array size
k = (m/n) * ln(2)              # Optimal number of hash functions
```

**Example:**
- n = 1,000,000 elements
- p = 1% false positive rate
- m â‰ˆ 9.6 million bits â‰ˆ 1.2 MB
- k â‰ˆ 7 hash functions

---

## ðŸ“Š Comparison

| Structure | Contains | Insert | Delete | Space | False Positives |
|-----------|----------|--------|--------|-------|-----------------|
| Hash Set | O(1) | O(1) | O(1) | O(n) | None |
| Bloom Filter | O(k) | O(k) | âŒ | O(m) << O(n) | Yes |

**Key advantage:** Bloom filter uses 10-100x less space than hash set!

---

## âš ï¸ Limitations

1. **No deletion:** Removing an element might create false negatives
   - Solution: Counting Bloom Filter (counts instead of bits)

2. **No enumeration:** Cannot list stored elements

3. **False positives:** Must verify with actual data source

4. **Sizing:** Need to know approximate n beforehand

---

## ðŸ“ Real-World Usage

| System | Use Case |
|--------|----------|
| Google Bigtable | Reduce disk lookups for non-existent rows |
| Apache Cassandra | Check if SSTable might have key |
| Chrome | Safe Browsing (malicious URL detection) |
| Medium | Recommend articles not yet read |
| Bitcoin | SPV clients filter transactions |

---

## ðŸ“ Practice Problems

Bloom filters rarely appear in coding interviews but are important for:
- System Design interviews
- Understanding probabilistic data structures
- Scaling problems

---

> **ðŸ’¡ Key Insight:** Bloom filters trade exactness for space. They answer "definitely no" or "probably yes" - useful when the cost of a false positive is low but space is at a premium.

> **ðŸ”— Related:** [Quick Reference â†’](../06-Interview-Focus/6.1-Quick-Reference.md)
