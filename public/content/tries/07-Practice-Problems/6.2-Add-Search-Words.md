# LC 211: Design Add and Search Words Data Structure

> **The classic wildcard search problem - extends basic Trie with DFS for '.' pattern matching.**

---

## ğŸ“‹ Problem Statement

**LeetCode 211 - Medium**

Design a data structure that supports adding new words and finding if a string matches any previously added string.

Implement the `WordDictionary` class:
- `WordDictionary()` Initializes the object.
- `void addWord(word)` Adds word to the data structure.
- `bool search(word)` Returns true if any string matches word. word may contain `'.'` where `.` can match any letter.

```
WordDictionary wd = new WordDictionary();
wd.addWord("bad");
wd.addWord("dad");
wd.addWord("mad");
wd.search("pad");  // return False
wd.search("bad");  // return True
wd.search(".ad");  // return True (matches bad, dad, mad)
wd.search("b..");  // return True (matches bad)
```

**Constraints:**
- 1 <= word.length <= 25
- word consists of lowercase English letters
- word in search may contain '.' (matches any letter)
- At most 10â´ calls to addWord and search

---

## ğŸ¯ Pattern Recognition

**This is the Wildcard Search pattern:**
- Regular characters â†’ follow normal trie path
- `.` wildcard â†’ try ALL children (DFS/backtracking)

**Key insight:** When we hit `.`, we can't follow one path - we must explore all possibilities.

---

## ğŸ“ Approach

### Key Observations

1. **addWord:** Identical to regular Trie insert
2. **search without `.`:** Identical to regular Trie search
3. **search with `.`:** Must try all children at that position

### Algorithm

```
FUNCTION search(word):
    return searchFrom(root, word, index=0)

FUNCTION searchFrom(node, word, index):
    IF index == len(word):
        return node.is_end
    
    char = word[index]
    
    IF char == '.':
        FOR each child in node.children:
            IF searchFrom(child, word, index + 1):
                return True
        return False
    ELSE:
        IF char not in node.children:
            return False
        return searchFrom(node.children[char], word, index + 1)
```

---

## ğŸ’» Solution

### Complete Solution

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False


class WordDictionary:
    """
    Time Complexity:
        - addWord: O(m) where m = word length
        - search without '.': O(m)
        - search with '.' : O(26^k Ã— m) worst case, k = number of dots
    
    Space Complexity:
        - O(n Ã— m) for trie storage
        - O(m) for recursion stack
    """
    
    def __init__(self):
        self.root = TrieNode()
    
    def addWord(self, word: str) -> None:
        """Add word to dictionary. Standard trie insert."""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def search(self, word: str) -> bool:
        """
        Search with wildcard support.
        '.' matches any single character.
        """
        return self._search_from(self.root, word, 0)
    
    def _search_from(self, node: TrieNode, word: str, index: int) -> bool:
        """
        DFS helper for wildcard search.
        
        Args:
            node: Current trie node
            word: Search pattern
            index: Current position in word
        
        Returns:
            True if pattern matches any word from this node
        """
        # Base case: reached end of pattern
        if index == len(word):
            return node.is_end
        
        char = word[index]
        
        if char == '.':
            # Wildcard: try ALL children
            for child in node.children.values():
                if self._search_from(child, word, index + 1):
                    return True  # Found a match!
            return False  # No match in any branch
        else:
            # Regular character: follow specific path
            if char not in node.children:
                return False
            return self._search_from(node.children[char], word, index + 1)
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = new Map();
        this.isEnd = false;
    }
}

class WordDictionary {
    constructor() {
        this.root = new TrieNode();
    }
    
    addWord(word) {
        let node = this.root;
        for (const char of word) {
            if (!node.children.has(char)) {
                node.children.set(char, new TrieNode());
            }
            node = node.children.get(char);
        }
        node.isEnd = true;
    }
    
    search(word) {
        return this._searchFrom(this.root, word, 0);
    }
    
    _searchFrom(node, word, index) {
        // Base case
        if (index === word.length) {
            return node.isEnd;
        }
        
        const char = word[index];
        
        if (char === '.') {
            // Try all children
            for (const child of node.children.values()) {
                if (this._searchFrom(child, word, index + 1)) {
                    return true;
                }
            }
            return false;
        } else {
            // Follow specific path
            if (!node.children.has(char)) {
                return false;
            }
            return this._searchFrom(node.children.get(char), word, index + 1);
        }
    }
}
```

---

### Optimized with Length Bucketing

**Python:**
```python
class WordDictionary:
    """
    Optimization: Separate tries by word length.
    
    Benefit: Searching "...." only searches words of length 4.
    """
    
    def __init__(self):
        self.tries = {}  # length -> TrieNode (root)
    
    def addWord(self, word: str) -> None:
        length = len(word)
        if length not in self.tries:
            self.tries[length] = TrieNode()
        
        node = self.tries[length]
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def search(self, word: str) -> bool:
        length = len(word)
        if length not in self.tries:
            return False
        
        return self._search_from(self.tries[length], word, 0)
    
    def _search_from(self, node, word, index):
        # Same implementation as before
        if index == len(word):
            return node.is_end
        
        char = word[index]
        
        if char == '.':
            for child in node.children.values():
                if self._search_from(child, word, index + 1):
                    return True
            return False
        else:
            if char not in node.children:
                return False
            return self._search_from(node.children[char], word, index + 1)
```

---

## âš¡ Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| **addWord** | O(m) | O(m) |
| **search (no dots)** | O(m) | O(m) stack |
| **search (k dots)** | O(26^k Ã— m) | O(m) stack |
| **search (all dots)** | O(n Ã— m) | O(m) stack |

**Where:**
- m = word length
- k = number of '.' in pattern
- n = total words in trie

**Why exponential for dots:**
- Each '.' branches to up to 26 children
- k dots = 26^k possible paths
- Practical performance is better due to sparse tries

---

## âš ï¸ Edge Cases

| Case | Handling |
|------|----------|
| All dots `"..."` | Must check all 3-letter words |
| No dots `"bad"` | Regular trie search |
| Mixed `"b.d"` | 'b' normal, '.' branch, 'd' normal |
| Single dot `"."` | Match all 1-letter words |
| No words added | Return False for any search |

---

## ğŸ” Walkthrough

```
wd = WordDictionary()
wd.addWord("bad")
wd.addWord("bed")
wd.addWord("bid")

Trie structure:
    (root)
       â”‚
       b
      /â”‚\
     a e i
     â”‚ â”‚ â”‚
     d d d
    (âœ“)(âœ“)(âœ“)

wd.search("b.d"):
  'b' â†’ Found, move to 'b' node
  '.' â†’ Try all children: 'a', 'e', 'i'
        'a' â†’ check 'd' â†’ Found, is_end=True âœ“
  Return True (first match found)

wd.search("b.g"):
  'b' â†’ Found
  '.' â†’ Try 'a', 'e', 'i'
        'a' + 'g' â†’ Not found
        'e' + 'g' â†’ Not found
        'i' + 'g' â†’ Not found
  Return False (all branches failed)
```

---

## ğŸ¤ Interview Tips

**What to say:**

1. **Recognize:** "This is a Trie problem with wildcard support. The '.' requires trying all children."

2. **Approach:** "addWord is standard insert. For search, I use DFS. Regular chars follow the path, '.' explores all children."

3. **Complexity:** "Without dots, O(m). With k dots, worst case O(26^k Ã— m), but real tries are sparse so it's usually much better."

4. **Optimization:** "I could bucket by word length so '...' only searches 3-letter words."

**Common follow-ups:**
- "What if '*' means zero or more?" â†’ Much harder, needs DP
- "How to handle case insensitivity?" â†’ Normalize on insert/search
- "Support multiple wildcards?" â†’ Already handled!

---

## ğŸ“ Practice Checklist

- [ ] Solve in < 20 minutes
- [ ] Handle all-dots case
- [ ] Explain complexity correctly
- [ ] Mention length bucketing optimization
- [ ] Don't return after first failed branch (common bug)

---

> **ğŸ’¡ Key Insight:** The '.' wildcard turns search into DFS. For regular chars, follow one path. For '.', fork to all children and return true if ANY path succeeds.

> **ğŸ”— Related:** [Wildcard Search Pattern](../03-Trie-Patterns/4.1-Wildcard-Search.md) | [Basic Trie](./6.1-Implement-Trie.md)
