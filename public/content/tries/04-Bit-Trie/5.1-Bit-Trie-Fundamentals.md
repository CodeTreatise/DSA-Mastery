# Bit Trie (Binary Trie) Fundamentals

> **A specialized Trie where each edge represents a single bit (0 or 1). Essential for XOR-based problems and bit manipulation.**

---

## üìã Definition

A **Bit Trie** (also called Binary Trie or Bitwise Trie) is a Trie where:
- Each node has at most **2 children** (for 0 and 1)
- Numbers are inserted **bit by bit**, from most significant to least
- Tree height is fixed at **number of bits** (usually 31 or 32)

**Key insight:** Just like a regular Trie organizes strings by common prefixes, a Bit Trie organizes numbers by common bit prefixes.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Bit Trie Problems</strong></summary>

**Look for these signals:**
- "Maximum XOR" in problem statement
- Finding pairs with XOR property
- Need to check bit patterns across multiple numbers
- Problems involving most significant bit comparisons

**Keywords:**
- "XOR", "maximum XOR", "subarray XOR"
- "bit manipulation", "binary representation"
- "pairs with XOR greater than..."

**Classic problems:**
- Maximum XOR of Two Numbers (LC 421)
- Maximum XOR With an Element From Array (LC 1707)
- Count Pairs With XOR in a Range (LC 1803)

</details>

---

## ‚úÖ When to Use Bit Trie

| Scenario | Why Bit Trie Works |
|----------|-------------------|
| Maximum XOR problems | Greedy bit-by-bit maximization |
| Find number with closest XOR | Navigate by bits |
| XOR queries on arrays | Prefix XOR + Bit Trie |
| Binary pattern matching | Similar to string prefix matching |

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|-------------------|
| Simple XOR calculations | Direct XOR operation |
| AND/OR operations | Different logic, no Trie benefit |
| Memory constrained + sparse numbers | Hash-based approaches |
| Small number range | Brute force is fine |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Basic Trie Operations](../02-Trie-Operations/3.1-Insert-Operation.md)
- Bit manipulation basics (XOR properties)
- Binary representation of integers

**After mastering this:**
- [Maximum XOR](5.2-Maximum-XOR.md)
- XOR subarray problems
- Advanced bit manipulation patterns

**Key XOR Properties to Remember:**
- `a ^ a = 0` (XOR with self is 0)
- `a ^ 0 = a` (XOR with 0 is self)
- `a ^ b = c` means `a ^ c = b` (reversible)
- `(a ^ b) ^ c = a ^ (b ^ c)` (associative)

</details>

---

## üìê How It Works

### Structure Comparison

**Regular Trie (26 or more children):**
```
    root
   /  |  \
  a   b   c  ... (26 branches)
```

**Bit Trie (exactly 2 children):**
```
      root
     /    \
    0      1   (bit 31)
   / \    / \
  0   1  0   1  (bit 30)
 ...
```

### Insertion: Number 5 (binary: 101)

Using 3 bits for simplicity:
```
5 = 101 in binary

Step 1: Bit 2 (MSB) = 1 ‚Üí go right
Step 2: Bit 1 = 0 ‚Üí go left  
Step 3: Bit 0 (LSB) = 1 ‚Üí go right

       root
          \
           1 (bit 2)
          /
         0 (bit 1)
          \
           1 (bit 0) ‚Üê end
```

### Why MSB First?

**Critical insight:** We process from Most Significant Bit because:
1. MSB has the largest impact on magnitude
2. For maximum XOR, getting a 1 in MSB is worth more than all lower bits combined

Example: `1000` (8) > `0111` (7)

---

## üíª Implementation

### Python: Bit Trie for XOR

```python
class BitTrieNode:
    """Node in a binary Trie."""
    def __init__(self):
        self.children = [None, None]  # [bit_0, bit_1]
        self.count = 0  # Number of numbers passing through


class BitTrie:
    """
    Binary Trie for XOR operations.
    Assumes 32-bit non-negative integers.
    """
    
    def __init__(self, max_bits: int = 31):
        self.root = BitTrieNode()
        self.max_bits = max_bits  # 31 for non-negative ints, 32 for full range
    
    def insert(self, num: int) -> None:
        """
        Insert number into Trie, bit by bit from MSB to LSB.
        Time: O(max_bits)
        """
        node = self.root
        
        # Process from MSB (bit max_bits-1) to LSB (bit 0)
        for i in range(self.max_bits - 1, -1, -1):
            bit = (num >> i) & 1  # Extract i-th bit
            
            if node.children[bit] is None:
                node.children[bit] = BitTrieNode()
            
            node = node.children[bit]
            node.count += 1
    
    def get_max_xor(self, num: int) -> int:
        """
        Find number in Trie that gives maximum XOR with num.
        
        Strategy: For each bit, try to go the OPPOSITE direction
        (to make that bit 1 in the XOR result).
        
        Time: O(max_bits)
        """
        node = self.root
        max_xor = 0
        
        for i in range(self.max_bits - 1, -1, -1):
            bit = (num >> i) & 1
            opposite = 1 - bit  # The bit we WANT to find
            
            if node.children[opposite] is not None:
                # Found opposite bit - XOR result has 1 here
                max_xor |= (1 << i)
                node = node.children[opposite]
            elif node.children[bit] is not None:
                # No opposite, use same bit - XOR result has 0 here
                node = node.children[bit]
            else:
                # Empty Trie edge case
                break
        
        return max_xor
    
    def delete(self, num: int) -> None:
        """
        Remove a number from the Trie.
        Time: O(max_bits)
        """
        node = self.root
        
        for i in range(self.max_bits - 1, -1, -1):
            bit = (num >> i) & 1
            
            if node.children[bit] is None:
                return  # Number not in Trie
            
            node = node.children[bit]
            node.count -= 1


# Usage Example:
trie = BitTrie(max_bits=4)  # For numbers 0-15
trie.insert(5)   # Binary: 0101
trie.insert(10)  # Binary: 1010
trie.insert(3)   # Binary: 0011

print(trie.get_max_xor(5))   # Best XOR with 5 ‚Üí 5^10=15
print(trie.get_max_xor(10))  # Best XOR with 10 ‚Üí 10^5=15
```

### JavaScript: Bit Trie

```javascript
class BitTrieNode {
    constructor() {
        this.children = [null, null];
        this.count = 0;
    }
}

class BitTrie {
    constructor(maxBits = 31) {
        this.root = new BitTrieNode();
        this.maxBits = maxBits;
    }
    
    insert(num) {
        let node = this.root;
        
        for (let i = this.maxBits - 1; i >= 0; i--) {
            const bit = (num >> i) & 1;
            
            if (node.children[bit] === null) {
                node.children[bit] = new BitTrieNode();
            }
            
            node = node.children[bit];
            node.count++;
        }
    }
    
    getMaxXor(num) {
        let node = this.root;
        let maxXor = 0;
        
        for (let i = this.maxBits - 1; i >= 0; i--) {
            const bit = (num >> i) & 1;
            const opposite = 1 - bit;
            
            if (node.children[opposite] !== null) {
                maxXor |= (1 << i);
                node = node.children[opposite];
            } else if (node.children[bit] !== null) {
                node = node.children[bit];
            } else {
                break;
            }
        }
        
        return maxXor;
    }
    
    delete(num) {
        let node = this.root;
        
        for (let i = this.maxBits - 1; i >= 0; i--) {
            const bit = (num >> i) & 1;
            
            if (node.children[bit] === null) return;
            
            node = node.children[bit];
            node.count--;
        }
    }
}
```

---

## üîÑ Visualization: Maximum XOR

**Finding max XOR between 5 (0101) and numbers {3, 10, 7}:**

```
Trie after inserting 3 (0011), 10 (1010), 7 (0111):

           root
          /    \
         0      1
        / \      \
       0   1      0
      / \   \      \
     1   1   1      1
     |   |   |      |
    [3] [7]  ?     [10]

Query: 5 (0101)

Bit 3: 5 has 0 ‚Üí want 1 ‚Üí go to 1 ‚úì (will get 1xxx)
Bit 2: 5 has 1 ‚Üí want 0 ‚Üí go to 0 ‚úì (will get 10xx)
Bit 1: 5 has 0 ‚Üí want 1 ‚Üí go to 1 ‚úì (will get 101x)
Bit 0: 5 has 1 ‚Üí want 0 ‚Üí go to 0 ‚úì (will get 1010)

Result: We found path to 10 (1010)
Max XOR = 5 ^ 10 = 0101 ^ 1010 = 1111 = 15
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| Insert | O(max_bits) | O(max_bits) per number |
| Get Max XOR | O(max_bits) | O(1) |
| Delete | O(max_bits) | O(1) |
| Build from n numbers | O(n √ó max_bits) | O(n √ó max_bits) |

**Typical values:**
- `max_bits = 31` for non-negative 32-bit integers
- `max_bits = 20` for numbers up to 10^6

**Space calculation:**
- Each number creates at most `max_bits` new nodes
- Each node uses O(1) space
- Total: O(n √ó max_bits) in worst case

---

## üîÑ Variations

| Variation | Difference | Use Case |
|-----------|------------|----------|
| With count | Track number of occurrences | Delete support |
| With min/max value | Store min/max at each node | Range queries |
| Persistent | Immutable versions | Historical XOR queries |
| 64-bit | Use 63 bits | Large numbers |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Bit Direction

```python
# ‚ùå Wrong: LSB first
for i in range(max_bits):
    bit = (num >> i) & 1

# ‚úÖ Correct: MSB first  
for i in range(max_bits - 1, -1, -1):
    bit = (num >> i) & 1
```

### 2. Forgetting Empty Trie Check

```python
# ‚ùå Wrong: Assumes Trie always has path
node = node.children[opposite]  # Might be None!

# ‚úÖ Correct: Check before accessing
if node.children[opposite] is not None:
    node = node.children[opposite]
```

### 3. Wrong Bit Count

```python
# ‚ùå Wrong: 32 bits for non-negative numbers
max_bits = 32  # Sign bit is always 0

# ‚úÖ Correct: 31 bits for non-negative
max_bits = 31  # Or calculate from max(nums).bit_length()
```

### 4. Off-by-One in Range

```python
# ‚ùå Wrong: Missing bit 0
for i in range(max_bits - 1, 0, -1):  # Stops at 1!

# ‚úÖ Correct: Include bit 0
for i in range(max_bits - 1, -1, -1):  # Goes to 0
```

---

## üìù Practice Problems

**Foundation:**
- [ ] [Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) - LC 421

**Medium Difficulty:**
- [ ] [Maximum XOR With an Element From Array](https://leetcode.com/problems/maximum-xor-with-an-element-from-array/) - LC 1707

**Hard:**
- [ ] [Count Pairs With XOR in a Range](https://leetcode.com/problems/count-pairs-with-xor-in-a-range/) - LC 1803

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

After solving each problem:
- **Day 1:** Trace through the bit-by-bit process manually
- **Day 3:** Implement Bit Trie from scratch
- **Day 7:** Solve Maximum XOR without looking at solution
- **Day 14:** Explain the greedy "opposite bit" strategy

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"When I see maximum XOR, I think of Bit Trie. The key insight is that to maximize XOR, we greedily want the opposite bit at each position, starting from the most significant bit."

**Explain the strategy:**
1. "XOR gives 1 when bits differ, so we want different bits"
2. "MSB matters most - a 1 in position 31 beats any combination of lower bits"
3. "So we greedily pick the opposite bit at each level"

**Common follow-ups:**
- "What if numbers can be added/removed?" ‚Üí Track count at nodes
- "What about negative numbers?" ‚Üí Handle sign bit separately
- "Memory optimization?" ‚Üí Use bit count based on max value

</details>

**Company Focus:**
| Company | Frequency | Notes |
|---------|-----------|-------|
| Google | Medium | Novel XOR problems |
| Amazon | Low | Occasionally seen |
| Meta | Low | Rare |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn concept | 45-60 min | First exposure |
| Implement Bit Trie | 20-30 min | Practice |
| Solve LC 421 | 25-35 min | First problem |
| Master pattern | 3-4 hours | Multiple problems |

---

> **üí° Key Insight:** The maximum XOR problem becomes greedy with Bit Trie: at each bit position, we try to go the opposite way to maximize the resulting XOR. MSB matters most, so we process from high to low bits.

> **üîó Related:** [Maximum XOR](5.2-Maximum-XOR.md) | [Bit Manipulation](../../15-Bit-Manipulation.md)
