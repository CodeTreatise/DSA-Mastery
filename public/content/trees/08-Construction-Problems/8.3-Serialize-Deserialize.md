# 8.3 - Serialize and Deserialize Binary Tree (LC 297)

> **Grokking Pattern:** #11 Tree DFS + #10 Tree BFS (Serialization Pattern)
>
> **Difficulty:** Hard | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very Common

---

## Problem Statement

Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection.

Design an algorithm to **serialize** and **deserialize** a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

```
Input: root = [1,2,3,null,null,4,5]

        1
       / \
      2   3
         / \
        4   5

serialize(root) ‚Üí "1,2,null,null,3,4,null,null,5,null,null"

deserialize("1,2,null,null,3,4,null,null,5,null,null") ‚Üí original tree
```

[LeetCode 297 - Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- Convert tree to string and back
- Store/transmit tree structure
- "Serialize" or "deserialize" mentioned

**Key insight:**
We need to include **null markers** to preserve tree structure.
Without null markers, we can't distinguish where subtrees end.

Common approaches:
1. **Preorder DFS** - Most intuitive
2. **Level-order BFS** - LeetCode's default format
3. **Parentheses notation** - e.g., `1(2)(3(4)(5))`

</details>

---

## ‚úÖ When to Use

- Storing tree in file/database
- Transmitting tree over network
- Deep copying a tree
- Interview serialization questions

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| BST only | Can use sorted array | Simpler format |
| Complete binary tree | Array indices work | Level-order array |
| Just need traversal | Don't need full structure | Regular traversal |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Preorder Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/02-Preorder-Traversal.md)
- [Level Order Traversal](../03-Tree-Traversals/3.2-BFS-Traversals/01-Level-Order.md)

**Related problems:**
- [Serialize BST](https://leetcode.com/problems/serialize-and-deserialize-bst/) - LC 449
- [Construct from traversals](./8.1-Construct-Preorder-Inorder.md)

</details>

---

## üìê How It Works

### Why Null Markers Are Needed

Without null markers:
```
Preorder: [1, 2, 3]

Could be:       Or:         Or:
    1            1           1
   / \          /             \
  2   3        2               2
              /                 \
             3                   3
```

With null markers:
```
    1
   / \
  2   3

Preorder: [1, 2, null, null, 3, null, null]
          ‚Üí Unambiguous! Each node followed by its children (or null)
```

### DFS Preorder Approach

**Serialize:**
```
        1
       / \
      2   3
         / \
        4   5

Visit order: 1 ‚Üí 2 ‚Üí null ‚Üí null ‚Üí 3 ‚Üí 4 ‚Üí null ‚Üí null ‚Üí 5 ‚Üí null ‚Üí null
Result: "1,2,null,null,3,4,null,null,5,null,null"
```

**Deserialize:**
```
Read tokens left to right:
1. Read "1" ‚Üí Create node 1
2. Recurse for left child:
   - Read "2" ‚Üí Create node 2
   - Recurse for left: Read "null" ‚Üí return None
   - Recurse for right: Read "null" ‚Üí return None
3. Recurse for right child:
   - Read "3" ‚Üí Create node 3
   - (continue recursively...)
```

---

## üíª Code Implementation

### Solution 1: DFS Preorder (Recommended)

**Python:**
```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Codec:
    """
    DFS Preorder serialization with null markers.
    Time: O(n), Space: O(n)
    """
    
    def serialize(self, root: Optional[TreeNode]) -> str:
        """Encodes a tree to a single string."""
        result = []
        
        def dfs(node):
            if not node:
                result.append("null")
                return
            
            result.append(str(node.val))
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)
        return ",".join(result)
    
    def deserialize(self, data: str) -> Optional[TreeNode]:
        """Decodes your encoded data to tree."""
        tokens = iter(data.split(","))
        
        def dfs():
            val = next(tokens)
            if val == "null":
                return None
            
            node = TreeNode(int(val))
            node.left = dfs()
            node.right = dfs()
            return node
        
        return dfs()
```

**JavaScript:**
```javascript
class Codec {
    serialize(root) {
        const result = [];
        
        function dfs(node) {
            if (!node) {
                result.push("null");
                return;
            }
            result.push(node.val.toString());
            dfs(node.left);
            dfs(node.right);
        }
        
        dfs(root);
        return result.join(",");
    }
    
    deserialize(data) {
        const tokens = data.split(",");
        let index = 0;
        
        function dfs() {
            const val = tokens[index++];
            if (val === "null") return null;
            
            const node = new TreeNode(parseInt(val));
            node.left = dfs();
            node.right = dfs();
            return node;
        }
        
        return dfs();
    }
}
```

### Solution 2: BFS Level Order

**Python:**
```python
from collections import deque

class CodecBFS:
    """
    BFS Level-order serialization (LeetCode format).
    """
    
    def serialize(self, root: Optional[TreeNode]) -> str:
        if not root:
            return ""
        
        result = []
        queue = deque([root])
        
        while queue:
            node = queue.popleft()
            if node:
                result.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
            else:
                result.append("null")
        
        # Remove trailing nulls (optional, for cleaner output)
        while result and result[-1] == "null":
            result.pop()
        
        return ",".join(result)
    
    def deserialize(self, data: str) -> Optional[TreeNode]:
        if not data:
            return None
        
        tokens = data.split(",")
        root = TreeNode(int(tokens[0]))
        queue = deque([root])
        index = 1
        
        while queue and index < len(tokens):
            node = queue.popleft()
            
            # Left child
            if index < len(tokens) and tokens[index] != "null":
                node.left = TreeNode(int(tokens[index]))
                queue.append(node.left)
            index += 1
            
            # Right child
            if index < len(tokens) and tokens[index] != "null":
                node.right = TreeNode(int(tokens[index]))
                queue.append(node.right)
            index += 1
        
        return root
```

**JavaScript:**
```javascript
class CodecBFS {
    serialize(root) {
        if (!root) return "";
        
        const result = [];
        const queue = [root];
        
        while (queue.length > 0) {
            const node = queue.shift();
            if (node) {
                result.push(node.val.toString());
                queue.push(node.left);
                queue.push(node.right);
            } else {
                result.push("null");
            }
        }
        
        // Remove trailing nulls
        while (result.length && result[result.length - 1] === "null") {
            result.pop();
        }
        
        return result.join(",");
    }
    
    deserialize(data) {
        if (!data) return null;
        
        const tokens = data.split(",");
        const root = new TreeNode(parseInt(tokens[0]));
        const queue = [root];
        let index = 1;
        
        while (queue.length > 0 && index < tokens.length) {
            const node = queue.shift();
            
            if (index < tokens.length && tokens[index] !== "null") {
                node.left = new TreeNode(parseInt(tokens[index]));
                queue.push(node.left);
            }
            index++;
            
            if (index < tokens.length && tokens[index] !== "null") {
                node.right = new TreeNode(parseInt(tokens[index]));
                queue.push(node.right);
            }
            index++;
        }
        
        return root;
    }
}
```

### Solution 3: Parentheses Notation

**Python:**
```python
class CodecParentheses:
    """
    Parentheses notation: 1(2)(3(4)(5))
    More compact for sparse trees.
    """
    
    def serialize(self, root: Optional[TreeNode]) -> str:
        if not root:
            return ""
        
        # Leaf node
        if not root.left and not root.right:
            return str(root.val)
        
        # Has children
        left_str = self.serialize(root.left) if root.left else ""
        right_str = self.serialize(root.right) if root.right else ""
        
        return f"{root.val}({left_str})({right_str})"
    
    def deserialize(self, data: str) -> Optional[TreeNode]:
        if not data:
            return None
        
        # Find the value (before first parenthesis)
        i = 0
        while i < len(data) and data[i] not in '()':
            i += 1
        
        val = int(data[:i])
        node = TreeNode(val)
        
        if i == len(data):
            return node  # Leaf
        
        # Find matching parentheses for left and right
        def find_matching_paren(s, start):
            count = 0
            for j in range(start, len(s)):
                if s[j] == '(':
                    count += 1
                elif s[j] == ')':
                    count -= 1
                    if count == 0:
                        return j
            return -1
        
        # Parse left child
        if i < len(data) and data[i] == '(':
            left_end = find_matching_paren(data, i)
            node.left = self.deserialize(data[i+1:left_end])
            i = left_end + 1
        
        # Parse right child
        if i < len(data) and data[i] == '(':
            right_end = find_matching_paren(data, i)
            node.right = self.deserialize(data[i+1:right_end])
        
        return node
```

---

## ‚ö° Complexity Analysis

| Approach | Serialize | Deserialize | Space |
|----------|-----------|-------------|-------|
| DFS Preorder |" O(n) "| O(n) |" O(n) "|
| BFS Level-order |" O(n) "| O(n) |" O(n) "|
| Parentheses |" O(n) "| O(n) |" O(n) "|

**Output size considerations:**
- DFS: Always 2n+1 tokens (each node + 2 nulls for each leaf)
- BFS: Can remove trailing nulls for shorter output
- Parentheses: Most compact for sparse trees

---

## üîÑ Variations

| Variation | Difference | LeetCode |
|-----------|------------|----------|
| Serialize BST | Can omit nulls, use bounds | LC 449 |
| N-ary tree | Multiple children | LC 428 |
| Encode with shortest length | Compression | LC 535 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting Null Markers

```python
# ‚ùå WRONG: No null markers
def serialize(root):
    if not root:
        return ""
    return f"{root.val},{serialize(root.left)},{serialize(root.right)}"
# Can't tell where subtrees end!

# ‚úÖ CORRECT: Include null markers
def serialize(root):
    if not root:
        return "null"  # Explicit null marker
    return f"{root.val},{serialize(root.left)},{serialize(root.right)}"
```

### 2. Using Wrong Delimiter

```python
# ‚ùå WRONG: No delimiter
result.append(str(node.val))  # "123" - is it 1,2,3 or 12,3 or 123?

# ‚úÖ CORRECT: Use delimiter
",".join(result)  # "1,2,3" - clear separation
```

### 3. Not Handling Negative Numbers

```python
# ‚ùå WRONG: Using - as delimiter
"-".join(values)  # Breaks with negative values like -10

# ‚úÖ CORRECT: Use comma or other safe delimiter
",".join(values)
```

### 4. Iterator vs Index in Deserialize

```python
# ‚ùå WRONG: Global index without proper scoping
index = 0
def dfs():
    global index  # Messy
    ...

# ‚úÖ BETTER: Use iterator
tokens = iter(data.split(","))
def dfs():
    val = next(tokens)  # Clean, automatic advancement
```

---

## üìù Practice Problems

### This Problem
- [ ] [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) - LC 297

### Related Serialization
- [ ] [Serialize and Deserialize BST](https://leetcode.com/problems/serialize-and-deserialize-bst/) - LC 449 (Easier)
- [ ] [Serialize and Deserialize N-ary Tree](https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree/) - LC 428
- [ ] [Encode and Decode Strings](https://leetcode.com/problems/encode-and-decode-strings/) - LC 271

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Understand why null markers are needed
**Day 3:** Implement DFS approach
**Day 7:** Implement BFS approach
**Day 14:** Compare trade-offs between approaches

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Clarifying questions:**
> "Can node values be negative? Any constraints on value range? Is there a preferred format?"

**Choosing approach:**
> "I'll use DFS preorder because it's the most intuitive - visit node, serialize value, then recursively serialize children. I include null markers so we know exactly when subtrees end."

**Trade-offs:**
> "BFS produces output similar to LeetCode's format and might be more efficient for wide trees. DFS is better for deep narrow trees. Parentheses notation is most compact for sparse trees."

**Follow-up: BST version:**
> "For a BST, I could skip null markers entirely. Serialize with preorder, then deserialize using min/max bounds - similar to validating a BST."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Classic question |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Often asked |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard problem |
| LinkedIn | ‚≠ê‚≠ê‚≠ê‚≠ê | Frequently asked |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 3-5 min | Clarify format |
| Implement serialize | 8-10 min | Straightforward |
| Implement deserialize | 10-12 min | More complex |
| Handle edge cases | 2-3 min | Empty tree, single node |

---

> **üí° Key Insight:** The crucial insight is that **null markers preserve structure**. Without them, we can't distinguish tree shapes from traversal order alone. With preorder DFS + null markers, we can uniquely reconstruct any binary tree. The deserialize function mirrors serialize exactly - read value, recursively build left, recursively build right.

---

## üîó Related

- [Preorder Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/02-Preorder-Traversal.md)
- [Level Order Traversal](../03-Tree-Traversals/3.2-BFS-Traversals/01-Level-Order.md)
- [Construct from Preorder + Inorder](./8.1-Construct-Preorder-Inorder.md)
