# LC 1803: Count Pairs With XOR in a Range

> **Advanced Bit Trie problem: count pairs where XOR falls within [low, high]. Uses prefix count technique.**

---

## ğŸ“‹ Problem Statement

**LeetCode 1803 - Hard**

Given an integer array `nums` and two integers `low` and `high`, return the count of pairs (i, j) where 0 <= i < j < n and low <= (nums[i] XOR nums[j]) <= high.

```
Input: nums = [1,4,2,7], low = 2, high = 6
Output: 6
Explanation:
All pairs and their XORs:
- (0,1): 1 ^ 4 = 5 âœ“
- (0,2): 1 ^ 2 = 3 âœ“
- (0,3): 1 ^ 7 = 6 âœ“
- (1,2): 4 ^ 2 = 6 âœ“
- (1,3): 4 ^ 7 = 3 âœ“
- (2,3): 2 ^ 7 = 5 âœ“
All 6 pairs satisfy 2 <= XOR <= 6
```

**Constraints:**
- 1 <= nums.length <= 2 Ã— 10^4
- 1 <= nums[i] <= 2 Ã— 10^4
- 1 <= low <= high <= 2 Ã— 10^4

---

## ğŸ¯ Pattern Recognition

**Pattern:** Bit Trie with Counting

**Key insight:** 
- Count pairs with XOR < high+1 - Count pairs with XOR < low
- Use Trie to count pairs with XOR less than a threshold

**Formula:** `count(low, high) = countLessThan(high+1) - countLessThan(low)`

---

## ğŸ“ Approach

### Strategy: Count XOR < Limit

For a given number `num` and limit `L`, we traverse the Trie bit by bit:

At each bit position from MSB to LSB:
- **If limit bit is 1:** All paths with XOR bit = 0 are valid (count them all), then we MUST continue where XOR bit = 1
- **If limit bit is 0:** We MUST continue where XOR bit = 0 (no counting yet)

Why? Because we want XOR < L, so if we can make a bit smaller, all subsequent bits don't matter (all valid).

---

## ğŸ’» Solution

### Optimal: Bit Trie with Count

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = [None, None]
        self.count = 0  # Numbers passing through this node


class Solution:
    """
    Count pairs where low <= XOR <= high.
    Use: count(XOR <= high) - count(XOR <= low-1)
    
    Time: O(n Ã— 15) for nums up to 2Ã—10^4 (15 bits)
    Space: O(n Ã— 15)
    """
    
    def countPairs(self, nums: list[int], low: int, high: int) -> int:
        root = TrieNode()
        max_bits = 15  # For values up to 2Ã—10^4
        
        def insert(num: int) -> None:
            node = root
            for i in range(max_bits - 1, -1, -1):
                bit = (num >> i) & 1
                if node.children[bit] is None:
                    node.children[bit] = TrieNode()
                node = node.children[bit]
                node.count += 1
        
        def count_less_than(num: int, limit: int) -> int:
            """Count numbers in Trie where num XOR x < limit."""
            node = root
            count = 0
            
            for i in range(max_bits - 1, -1, -1):
                if node is None:
                    break
                
                num_bit = (num >> i) & 1
                limit_bit = (limit >> i) & 1
                
                if limit_bit == 1:
                    # XOR bit = 0 is definitely < limit at this position
                    # All numbers where XOR gives 0 are valid
                    same_bit = num_bit  # XOR with same bit gives 0
                    if node.children[same_bit] is not None:
                        count += node.children[same_bit].count
                    
                    # Continue down path where XOR bit = 1
                    opposite_bit = 1 - num_bit
                    node = node.children[opposite_bit]
                else:
                    # limit_bit = 0, we must have XOR bit = 0
                    # Continue down path where XOR gives 0
                    same_bit = num_bit
                    node = node.children[same_bit]
            
            return count
        
        result = 0
        
        for num in nums:
            # Count pairs with current number and all previously inserted
            # XOR in [low, high] = XOR < high+1 minus XOR < low
            result += count_less_than(num, high + 1) - count_less_than(num, low)
            insert(num)
        
        return result


# Test
sol = Solution()
print(sol.countPairs([1,4,2,7], 2, 6))  # 6
print(sol.countPairs([9,8,4,2,1], 5, 14))  # 8
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = [null, null];
        this.count = 0;
    }
}

function countPairs(nums, low, high) {
    const root = new TrieNode();
    const maxBits = 15;
    
    function insert(num) {
        let node = root;
        for (let i = maxBits - 1; i >= 0; i--) {
            const bit = (num >> i) & 1;
            if (node.children[bit] === null) {
                node.children[bit] = new TrieNode();
            }
            node = node.children[bit];
            node.count++;
        }
    }
    
    function countLessThan(num, limit) {
        let node = root;
        let count = 0;
        
        for (let i = maxBits - 1; i >= 0; i--) {
            if (node === null) break;
            
            const numBit = (num >> i) & 1;
            const limitBit = (limit >> i) & 1;
            
            if (limitBit === 1) {
                // Count all where XOR bit = 0 (same bit)
                const sameBit = numBit;
                if (node.children[sameBit] !== null) {
                    count += node.children[sameBit].count;
                }
                // Continue where XOR bit = 1
                node = node.children[1 - numBit];
            } else {
                // Must have XOR bit = 0, continue same bit path
                node = node.children[numBit];
            }
        }
        
        return count;
    }
    
    let result = 0;
    
    for (const num of nums) {
        result += countLessThan(num, high + 1) - countLessThan(num, low);
        insert(num);
    }
    
    return result;
}
```

---

## ğŸ” Walkthrough: Count XOR < Limit

```
Trie contains: [4] = 0100
Query: num = 1 (0001), limit = 6 (0110)

Goal: Count numbers x where 1 ^ x < 6

Bit 3 (MSB): num=0, limit=0
  - limit_bit = 0, we must get XOR bit 0
  - Go same direction (bit 0)
  - count = 0

Bit 2: num=0, limit=1
  - limit_bit = 1!
  - XOR bit = 0 is valid, count nums with bit 0 at this position
  - Same bit path (0) â†’ if exists, add its count
  - Trie has 4 (bit=1 here), so same_bit path count = 0
  - Continue opposite direction (bit 1)
  - count = 0

Bit 1: num=0, limit=1
  - limit_bit = 1!
  - Same bit (0) path â†’ Trie has 4 which is 0 here... no, 4 = 0100
  - At bit 1, value 4 has bit = 0
  - Same bit path count = 1 (the value 4 is here)
  - count = 1
  - Continue opposite (bit 1)

Bit 0: num=1, limit=0
  - limit_bit = 0
  - Must go same bit (1) path
  - 4 at bit 0 = 0, so no path
  
Final count = 1

Verify: 1 ^ 4 = 5, and 5 < 6 âœ“
```

---

## âš¡ Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| Insert each number | O(max_bits) | O(max_bits) new nodes |
| Count less than | O(max_bits) | O(1) |
| Total for n numbers | O(n Ã— max_bits) | O(n Ã— max_bits) |

**For this problem:**
- max_bits = 15 (since values â‰¤ 2Ã—10^4)
- n â‰¤ 2Ã—10^4
- Total: ~300K operations âœ“

---

## âš ï¸ Common Mistakes

### 1. Wrong Range Formula

```python
# âŒ Wrong: Forgetting +1
count_less_than(high) - count_less_than(low)  # Misses pairs where XOR = high

# âœ… Correct: Include high in range
count_less_than(high + 1) - count_less_than(low)  # [low, high]
```

### 2. Wrong Bit Selection

```python
# âŒ Wrong: Opposite when should be same
if limit_bit == 1:
    opposite_bit = 1 - num_bit  # Wrong for counting!

# âœ… Correct: Same bit for XOR = 0
if limit_bit == 1:
    same_bit = num_bit  # XOR with same gives 0
    count += node.children[same_bit].count
```

### 3. Forgetting to Insert After Count

```python
# âŒ Wrong: Insert before count
for num in nums:
    insert(num)  # Now we count pairs twice!
    result += count_less_than(num, limit)

# âœ… Correct: Count first, then insert
for num in nums:
    result += count_less_than(num, limit)
    insert(num)
```

---

## ğŸ¤ Interview Tips

**Opening statement:**
"To count pairs in a range, I'll use the formula: count(low, high) = count(< high+1) - count(< low). Then I use a Bit Trie with counts at each node."

**Explain the counting logic:**
"When limit bit is 1, any XOR with bit 0 at that position is definitely less than limit. So I count all numbers that give XOR bit 0, then continue where XOR bit is 1."

**Common follow-up:**
"What if we need XOR in multiple ranges?" â†’ Multiple difference queries
"Optimize for memory?" â†’ Use dictionary-based nodes for sparse tries

---

## ğŸ“ Practice Checklist

- [ ] Understand the count less than strategy
- [ ] Implement count with proper bit logic  
- [ ] Handle the range with high+1 and low
- [ ] Order: count first, insert second
- [ ] Solve in < 35 minutes

<details>
<summary><strong>ğŸ§  Spaced Repetition</strong></summary>

- **Day 1:** Trace through count_less_than logic manually
- **Day 3:** Implement from scratch
- **Day 7:** Explain why limit_bit=1 means we count same_bit path
- **Day 14:** Solve similar counting problem

</details>

---

> **ğŸ’¡ Key Insight:** When limit bit is 1, any path giving XOR bit = 0 is guaranteed to produce a result < limit at that bit position. Count all such paths, then continue looking for XOR bit = 1.

> **ğŸ”— Related:** [Maximum XOR](5.2-Maximum-XOR.md) | [Bit Manipulation](../../15-Bit-Manipulation.md)
