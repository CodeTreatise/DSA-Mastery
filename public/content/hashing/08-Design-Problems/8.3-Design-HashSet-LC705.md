# Design HashSet (LeetCode 705)

> **Easy** | Design a HashSet without using any built-in hash table libraries. Implement add, remove, and contains operations.

This is a simplified version of HashMap - storing only keys without values. Same collision handling concepts apply.

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>Problem Signals</strong></summary>

**Keywords:**
- "Design a hash set"
- "Implement without built-in"
- "Membership testing"
- "O(1) add/remove/contains"

**Core concepts:**
- Hash function
- Collision handling
- Boolean membership (no values)

</details>

---

## ğŸ“‹ Problem Statement

**LeetCode 705:** [Design HashSet](https://leetcode.com/problems/design-hashset/)

```
Design a HashSet without using any built-in hash table libraries.

Implement MyHashSet class:
- void add(key) inserts key into HashSet
- bool contains(key) returns whether key exists
- void remove(key) removes key if present

Example:
MyHashSet myHashSet = new MyHashSet();
myHashSet.add(1);       // set = [1]
myHashSet.add(2);       // set = [1, 2]
myHashSet.contains(1);  // return true
myHashSet.contains(3);  // return false
myHashSet.add(2);       // set = [1, 2] (already exists)
myHashSet.contains(2);  // return true
myHashSet.remove(2);    // set = [1]
myHashSet.contains(2);  // return false

Constraints:
- 0 <= key <= 10^6
- At most 10^4 calls to add, remove, contains
```

---

## âœ… When to Use

- Need O(1) membership testing
- Key-only storage (no values)
- Deduplication
- Fast lookup without ordering

---

## âŒ When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need key-value pairs | HashSet stores keys only | HashMap |
| Need sorted iteration | Hash is unordered | TreeSet/BST |
| Small fixed range | Overkill | Boolean array |
| Need duplicates counted | Can't store count | HashMap or Counter |
| Need to iterate in order | Hash has no order | Linked list + hash |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, understand:**
- [What is Hashing](../01-Hash-Fundamentals/1.1-What-Is-Hashing.md)
- [Collision Handling](../01-Hash-Fundamentals/1.3-Collision-Handling.md)
- [Design HashMap (LC 706)](./8.2-Design-HashMap-LC706.md) - More general

**After mastering this:**
- [Hash Set Operations](../02-Hash-Map-Set/2.2-Hash-Set-Operations.md) - Using built-in sets
- [Contains Duplicate (LC 217)](https://leetcode.com/problems/contains-duplicate/) - Common application

**Relationship to HashMap:**
- HashSet is essentially HashMap where value is always `true`
- Same hash function and collision handling
- Simpler operations (no value management)

</details>

---

## ğŸ“ Solution Approaches

### Approach 1: Boolean Array (Naive but Fast)

For constraints where keys are bounded (0 to 10^6), we can use a simple boolean array.

```
Array of size 10^6 + 1:
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚ 0 â”‚ 1 â”‚ 2 â”‚ 3 â”‚ 4 â”‚ 5 â”‚ ... â”‚
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
â”‚ F â”‚ T â”‚ T â”‚ F â”‚ F â”‚ T â”‚ ... â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜

add(1): arr[1] = True
contains(1): return arr[1]  # True
remove(1): arr[1] = False
```

**Trade-off:** O(1) time, O(max_key) space

### Approach 2: Chaining (Recommended)

Similar to HashMap but buckets store keys only, not key-value pairs.

```
Hash Set with 1000 buckets:

add(1): bucket[1] = [1]
add(1001): bucket[1] = [1, 1001]  (1001 % 1000 = 1)
add(2): bucket[2] = [2]

Bucket Array:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 0   â”‚ []                                â”‚
â”‚ 1   â”‚ [1, 1001]  â† Same hash bucket     â”‚
â”‚ 2   â”‚ [2]                               â”‚
â”‚ ... â”‚                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’» Code Implementation

### Python - Approach 1: Boolean Array

```python
class MyHashSet:
    """
    HashSet using boolean array.
    
    Works well for bounded key range.
    O(1) all operations, O(max_key) space.
    """
    
    def __init__(self):
        # Key constraint: 0 <= key <= 10^6
        self.set = [False] * (10**6 + 1)
    
    def add(self, key: int) -> None:
        self.set[key] = True
    
    def remove(self, key: int) -> None:
        self.set[key] = False
    
    def contains(self, key: int) -> bool:
        return self.set[key]


# Simple but uses 10^6 booleans (~1MB memory)
```

### Python - Approach 2: Chaining with Lists

```python
class MyHashSet:
    """
    HashSet using chaining.
    
    More space-efficient for sparse key sets.
    O(n/k) average operations, O(k + n) space.
    """
    
    def __init__(self):
        self.size = 1000
        self.buckets = [[] for _ in range(self.size)]
    
    def _hash(self, key: int) -> int:
        return key % self.size
    
    def add(self, key: int) -> None:
        bucket_idx = self._hash(key)
        bucket = self.buckets[bucket_idx]
        
        # Check if already exists
        if key not in bucket:
            bucket.append(key)
    
    def remove(self, key: int) -> None:
        bucket_idx = self._hash(key)
        bucket = self.buckets[bucket_idx]
        
        try:
            bucket.remove(key)
        except ValueError:
            pass  # Key not found, do nothing
    
    def contains(self, key: int) -> bool:
        bucket_idx = self._hash(key)
        bucket = self.buckets[bucket_idx]
        return key in bucket


# Example trace:
# add(1): bucket[1] = [1]
# add(2): bucket[2] = [2]
# add(1001): bucket[1] = [1, 1001]
# contains(1): 1 in bucket[1] â†’ True
# remove(1001): bucket[1] = [1]
```

### Python - Using Linked List Buckets

```python
class ListNode:
    """Linked list node for chaining."""
    def __init__(self, key=-1, next=None):
        self.key = key
        self.next = next

class MyHashSet:
    """
    HashSet using linked list chaining.
    
    Each bucket has a dummy head for easier operations.
    """
    
    def __init__(self):
        self.size = 1000
        self.buckets = [ListNode() for _ in range(self.size)]
    
    def _hash(self, key: int) -> int:
        return key % self.size
    
    def _get_prev(self, key: int) -> ListNode:
        """Get node before the key (or end of list if not found)."""
        bucket_idx = self._hash(key)
        curr = self.buckets[bucket_idx]
        
        while curr.next:
            if curr.next.key == key:
                return curr  # Found: return previous node
            curr = curr.next
        
        return curr  # Not found: return last node
    
    def add(self, key: int) -> None:
        prev = self._get_prev(key)
        
        if prev.next is None:  # Key not found
            prev.next = ListNode(key)
        # If found, do nothing (already exists)
    
    def remove(self, key: int) -> None:
        prev = self._get_prev(key)
        
        if prev.next and prev.next.key == key:
            prev.next = prev.next.next
    
    def contains(self, key: int) -> bool:
        prev = self._get_prev(key)
        return prev.next is not None and prev.next.key == key
```

### Python - Binary Search Tree Buckets (Balanced)

```python
class BST:
    """Simplified BST for bucket storage."""
    
    class Node:
        def __init__(self, val):
            self.val = val
            self.left = None
            self.right = None
    
    def __init__(self):
        self.root = None
    
    def add(self, val):
        if not self.root:
            self.root = BST.Node(val)
            return
        
        curr = self.root
        while True:
            if val < curr.val:
                if not curr.left:
                    curr.left = BST.Node(val)
                    return
                curr = curr.left
            elif val > curr.val:
                if not curr.right:
                    curr.right = BST.Node(val)
                    return
                curr = curr.right
            else:
                return  # Already exists
    
    def contains(self, val):
        curr = self.root
        while curr:
            if val < curr.val:
                curr = curr.left
            elif val > curr.val:
                curr = curr.right
            else:
                return True
        return False
    
    def remove(self, val):
        # Simplified: just mark as removed or full BST delete
        # (Full implementation omitted for brevity)
        pass

class MyHashSet:
    """
    HashSet using BST buckets.
    
    O(log(n/k)) operations instead of O(n/k).
    """
    
    def __init__(self):
        self.size = 1000
        self.buckets = [BST() for _ in range(self.size)]
    
    def _hash(self, key: int) -> int:
        return key % self.size
    
    def add(self, key: int) -> None:
        self.buckets[self._hash(key)].add(key)
    
    def remove(self, key: int) -> None:
        self.buckets[self._hash(key)].remove(key)
    
    def contains(self, key: int) -> bool:
        return self.buckets[self._hash(key)].contains(key)
```

### JavaScript - Chaining with Arrays

```javascript
class MyHashSet {
    constructor() {
        this.size = 1000;
        this.buckets = Array.from({ length: this.size }, () => []);
    }
    
    _hash(key) {
        return key % this.size;
    }
    
    /**
     * Add key to set.
     * @param {number} key
     * @return {void}
     */
    add(key) {
        const bucket = this.buckets[this._hash(key)];
        if (!bucket.includes(key)) {
            bucket.push(key);
        }
    }
    
    /**
     * Remove key from set.
     * @param {number} key
     * @return {void}
     */
    remove(key) {
        const bucket = this.buckets[this._hash(key)];
        const idx = bucket.indexOf(key);
        if (idx !== -1) {
            bucket.splice(idx, 1);
        }
    }
    
    /**
     * Check if key exists.
     * @param {number} key
     * @return {boolean}
     */
    contains(key) {
        return this.buckets[this._hash(key)].includes(key);
    }
}
```

### JavaScript - Boolean Array

```javascript
class MyHashSet {
    constructor() {
        // For bounded keys, use boolean array
        this.set = new Array(1000001).fill(false);
    }
    
    add(key) {
        this.set[key] = true;
    }
    
    remove(key) {
        this.set[key] = false;
    }
    
    contains(key) {
        return this.set[key];
    }
}
```

---

## âš¡ Complexity Analysis

| Approach | Add | Contains | Remove | Space |
|----------|-----|----------|--------|-------|
| Boolean Array | O(1) | O(1) | O(1) | O(max_key) |
| Chaining (list) | O(n/k) avg | O(n/k) avg | O(n/k) avg | O(k + n) |
| Chaining (BST) | O(log(n/k)) avg | O(log(n/k)) avg | O(log(n/k)) avg | O(k + n) |

**Where:**
- n = number of stored keys
- k = number of buckets
- max_key = maximum possible key value

---

## ğŸ”„ Comparison: HashSet vs HashMap

| Aspect | HashSet | HashMap |
|--------|---------|---------|
| Stores | Keys only | Key-value pairs |
| add/put | Store key | Store (key, value) |
| contains/get | Return boolean | Return value or -1 |
| Use case | Membership | Association |
| Implementation | Simpler | Slightly more complex |

---

## âš ï¸ Common Mistakes

### 1. Adding Duplicates

```python
# âŒ WRONG: Not checking for duplicates
def add(self, key):
    bucket = self.buckets[self._hash(key)]
    bucket.append(key)  # May add duplicates!

# âœ… CORRECT: Check before adding
def add(self, key):
    bucket = self.buckets[self._hash(key)]
    if key not in bucket:
        bucket.append(key)
```

### 2. Error on Remove Non-Existent

```python
# âŒ WRONG: Crashes if key not found
def remove(self, key):
    bucket = self.buckets[self._hash(key)]
    bucket.remove(key)  # ValueError if not found!

# âœ… CORRECT: Handle gracefully
def remove(self, key):
    bucket = self.buckets[self._hash(key)]
    try:
        bucket.remove(key)
    except ValueError:
        pass  # Key not in set, that's OK
```

### 3. Wrong Contains Check

```python
# âŒ WRONG: Wrong bucket check
def contains(self, key):
    return key in self.buckets  # Checks bucket indices, not contents!

# âœ… CORRECT: Check in specific bucket
def contains(self, key):
    return key in self.buckets[self._hash(key)]
```

---

## ğŸ“ Practice Problems

| Problem | Difficulty | Key Focus |
|---------|------------|-----------|
| Design HashSet | ğŸŸ¢ Easy | This problem |
| Design HashMap | ğŸŸ¢ Easy | Add values |
| Two Sum | ğŸŸ¢ Easy | Use HashSet |
| Contains Duplicate | ğŸŸ¢ Easy | HashSet application |

**Related LeetCode:**
- [706. Design HashMap](https://leetcode.com/problems/design-hashmap/)
- [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement with array buckets
- **Day 3:** Implement with linked list buckets
- **Day 7:** Compare with HashMap implementation
- **Day 14:** Explain when to use each approach
- **Day 30:** < 8 min implementation

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>Communication Template</strong></summary>

**1. Clarify:**
> "Keys are bounded 0 to 10^6. Should I optimize for space or time?"

**2. Approach options:**
> "I could use a boolean array of size 10^6 for O(1) everything, or chaining for better space efficiency."

**3. Trade-off:**
> "Boolean array uses ~1MB but is fastest. Chaining uses O(n) space where n is actual stored elements."

</details>

**Company Frequency:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | â­â­â­ | Foundation |
| Microsoft | â­â­â­ | Basic design |

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Understand problem | 1 min |
| Design approach | 2 min |
| Implement | 5-7 min |
| Test | 2 min |
| **Total** | **10-12 min** |

---

> **ğŸ’¡ Key Insight:** HashSet is HashMap without values. The same collision handling applies. For bounded key ranges, a simple boolean array is the fastest solution.

> **ğŸ”— Related:** [Design HashMap](./8.2-Design-HashMap-LC706.md) | [Hash Fundamentals](../01-Hash-Fundamentals/1.1-What-Is-Hashing.md) | [Frequency Pattern](../03-Frequency-Pattern/3.1-Frequency-Overview.md)
