# 2.3 Expression Evaluation (LC 150)

> **Grokking Pattern:** #7 Stacks - Expression Parsing
>
> **Difficulty:** Medium | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê Classic Stack Problem

---

## Problem Statement

Evaluate the value of an arithmetic expression in **Reverse Polish Notation** (RPN).

Valid operators are `+`, `-`, `*`, and `/`. Each operand may be an integer or another expression.

**Note:** Division truncates toward zero.

```
Example 1:
Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9

Example 2:
Input: tokens = ["4","13","5","/","+"]
Output: 6
Explanation: (4 + (13 / 5)) = 4 + 2 = 6

Example 3:
Input: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
Output: 22
```

[LeetCode 150 - Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Evaluate expression"
- "Reverse Polish Notation" or "Postfix notation"
- Operators come after operands
- No parentheses needed (order is explicit)

**Key insight:**
In RPN, when we see an operator, we apply it to the two most recent operands.
This is LIFO behavior ‚Üí Stack!

```
["2", "1", "+"] 
Push 2, push 1
See +: pop 1 and 2, compute 2+1=3, push 3
Result: 3
```

</details>

---

## ‚úÖ When to Use This Approach

- Evaluating postfix (RPN) expressions
- Expression parsing problems
- Calculator implementations

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Infix expressions | Need Shunting-yard first | Two stacks |
| Prefix notation | Different processing order | Reverse + stack |
| Expression with functions | More complex parsing | Recursive descent |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md)
- Infix vs Postfix vs Prefix notation

**After mastering this:**
- [Basic Calculator](https://leetcode.com/problems/basic-calculator/) - LC 224
- [Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/) - LC 227
- [Parse Lisp Expression](https://leetcode.com/problems/parse-lisp-expression/) - LC 736

**Expression notations:**
- **Infix:** `2 + 3` (operators between operands)
- **Postfix (RPN):** `2 3 +` (operators after operands)
- **Prefix:** `+ 2 3` (operators before operands)

</details>

---

## üìê How It Works

### RPN Evaluation Algorithm

1. Initialize empty stack
2. For each token:
   - If number ‚Üí push to stack
   - If operator ‚Üí pop two operands, compute, push result
3. Final stack top = result

### Visual Walkthrough

```
Input: ["2", "1", "+", "3", "*"]
Expression: (2 + 1) * 3

Token "2": 
    Push 2
    Stack: [2]

Token "1": 
    Push 1
    Stack: [2, 1]

Token "+": 
    Pop 1 (b), Pop 2 (a)
    Compute a + b = 2 + 1 = 3
    Push 3
    Stack: [3]

Token "3": 
    Push 3
    Stack: [3, 3]

Token "*": 
    Pop 3 (b), Pop 3 (a)
    Compute a * b = 3 * 3 = 9
    Push 9
    Stack: [9]

Result: 9 ‚úì
```

### Important: Operand Order

For non-commutative operations (-, /), order matters!
```
Stack: [a, b]  (a pushed first, then b)
Pop b first, then a
Compute: a OP b (NOT b OP a)
```

---

## üíª Code Implementation

### Solution: Stack-Based Evaluation

**Python:**
```python
from typing import List

def eval_rpn(tokens: List[str]) -> int:
    """
    Evaluate Reverse Polish Notation expression.
    
    Pattern: Stack for expression evaluation
    Time: O(n), Space: O(n)
    
    Key: When operator found, pop two operands,
         compute, push result back.
    """
    stack = []
    operators = {'+', '-', '*', '/'}
    
    for token in tokens:
        if token in operators:
            # Pop operands (b first, then a)
            b = stack.pop()
            a = stack.pop()
            
            # Compute and push result
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            else:  # token == '/'
                # Truncate toward zero
                stack.append(int(a / b))
        else:
            # It's a number
            stack.append(int(token))
    
    return stack[0]


def eval_rpn_lambda(tokens: List[str]) -> int:
    """
    Using lambda for cleaner operator handling.
    """
    operations = {
        '+': lambda a, b: a + b,
        '-': lambda a, b: a - b,
        '*': lambda a, b: a * b,
        '/': lambda a, b: int(a / b)  # Truncate toward zero
    }
    
    stack = []
    
    for token in tokens:
        if token in operations:
            b = stack.pop()
            a = stack.pop()
            stack.append(operations[token](a, b))
        else:
            stack.append(int(token))
    
    return stack[0]
```

**JavaScript:**
```javascript
/**
 * Evaluate Reverse Polish Notation.
 * Pattern: Stack for expression evaluation
 * Time: O(n), Space: O(n)
 */
function evalRPN(tokens) {
    const stack = [];
    const operators = new Set(['+', '-', '*', '/']);
    
    for (const token of tokens) {
        if (operators.has(token)) {
            const b = stack.pop();
            const a = stack.pop();
            
            let result;
            switch (token) {
                case '+': result = a + b; break;
                case '-': result = a - b; break;
                case '*': result = a * b; break;
                case '/': result = Math.trunc(a / b); break;
            }
            stack.push(result);
        } else {
            stack.push(parseInt(token, 10));
        }
    }
    
    return stack[0];
}

// Using object for operations
function evalRPNObject(tokens) {
    const operations = {
        '+': (a, b) => a + b,
        '-': (a, b) => a - b,
        '*': (a, b) => a * b,
        '/': (a, b) => Math.trunc(a / b)
    };
    
    const stack = [];
    
    for (const token of tokens) {
        if (token in operations) {
            const b = stack.pop();
            const a = stack.pop();
            stack.push(operations[token](a, b));
        } else {
            stack.push(parseInt(token, 10));
        }
    }
    
    return stack[0];
}
```

---

## Bonus: Infix Expression Evaluation (LC 227)

For infix expressions like `"3+2*2"`, we need to handle operator precedence.

**Python:**
```python
def calculate(s: str) -> int:
    """
    Basic Calculator II (LC 227)
    Evaluate infix expression with +, -, *, /
    
    Time: O(n), Space: O(n)
    
    Strategy: Use stack, handle * and / immediately,
    defer + and - to the end.
    """
    stack = []
    num = 0
    prev_op = '+'  # Track previous operator
    
    for i, char in enumerate(s + '+'):  # Add '+' to trigger final calculation
        if char.isdigit():
            num = num * 10 + int(char)
        elif char in '+-*/':
            # Apply previous operator
            if prev_op == '+':
                stack.append(num)
            elif prev_op == '-':
                stack.append(-num)
            elif prev_op == '*':
                stack.append(stack.pop() * num)
            elif prev_op == '/':
                stack.append(int(stack.pop() / num))
            
            prev_op = char
            num = 0
    
    return sum(stack)


def calculate_with_parentheses(s: str) -> int:
    """
    Basic Calculator (LC 224)
    Handles +, -, and parentheses
    
    Strategy: Recursion or stack for nested expressions
    """
    def helper(s, idx):
        stack = []
        num = 0
        sign = 1  # 1 for +, -1 for -
        
        while idx < len(s):
            char = s[idx]
            
            if char.isdigit():
                num = num * 10 + int(char)
            elif char == '+':
                stack.append(sign * num)
                num = 0
                sign = 1
            elif char == '-':
                stack.append(sign * num)
                num = 0
                sign = -1
            elif char == '(':
                # Recursively evaluate inside parentheses
                num, idx = helper(s, idx + 1)
            elif char == ')':
                stack.append(sign * num)
                return sum(stack), idx
            
            idx += 1
        
        stack.append(sign * num)
        return sum(stack), idx
    
    result, _ = helper(s, 0)
    return result
```

---

## ‚ö° Complexity Analysis

| Aspect | Complexity | Notes |
|--------|------------|-------|
| Time |" O(n) "| Single pass through tokens |
| Space |" O(n) "| Stack can hold n/2 operands |

**Why O(n)?**
- Each token processed once
- Each push/pop is O(1)
- n tokens ‚Üí O(n) operations

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Infix with precedence | Need precedence handling | LC 227 |
| With parentheses | Need recursion or nested stack | LC 224 |
| Prefix notation | Process right to left | Custom |
| With variables | Need symbol table | Compiler design |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Operand Order

```python
# ‚ùå WRONG: Wrong order for subtraction/division
b = stack.pop()
a = stack.pop()
result = b - a  # Should be a - b!

# ‚úÖ CORRECT: First popped is second operand
b = stack.pop()  # b is the second operand
a = stack.pop()  # a is the first operand
result = a - b   # a OP b
```

### 2. Integer Division Truncation

```python
# ‚ùå WRONG: Python // rounds toward negative infinity
result = a // b  # -7 // 2 = -4 (wrong for this problem)

# ‚úÖ CORRECT: Truncate toward zero
result = int(a / b)  # int(-3.5) = -3 ‚úì
```

### 3. Not Handling Negative Numbers

```python
# ‚ùå WRONG: Only checks first character
if token[0].isdigit():

# ‚úÖ CORRECT: Handle negative numbers
if token not in '+-*/':  # or use try/except
    stack.append(int(token))
```

### 4. Missing Final Result

```python
# ‚ùå WRONG: May have empty stack
return stack.pop()

# ‚úÖ CORRECT: Return first (and only) element
return stack[0]
```

---

## üìù Practice Problems (Progressive)

### This Problem
- [ ] [Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/) - LC 150 ‚≠ê

### Related Problems
- [ ] [Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/) - LC 227
- [ ] [Basic Calculator](https://leetcode.com/problems/basic-calculator/) - LC 224
- [ ] [Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/) - LC 772 (Premium)
- [ ] [Parse Lisp Expression](https://leetcode.com/problems/parse-lisp-expression/) - LC 736

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement RPN evaluation
**Day 3:** Handle edge cases (division, negatives)
**Day 7:** Solve LC 227 (infix with precedence)
**Day 14:** Solve LC 224 (infix with parentheses)
**Day 21:** Compare all three calculator problems

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Clarify:**
> "So this is postfix notation where operators come after operands?"

**Explain the algorithm:**
> "I'll use a stack. When I see a number, I push it. When I see an operator, I pop two operands, apply the operator, and push the result back."

**Handle operand order:**
> "Important: for non-commutative operations like subtraction and division, the first popped value is the second operand. So if I pop b then a, I compute a minus b, not b minus a."

**Handle division:**
> "The problem says truncate toward zero. In Python, that's int(a/b), not a//b, because floor division rounds toward negative infinity."

**Follow-up: Infix expressions?**
> "For infix with precedence, I'd process * and / immediately while deferring + and -. For parentheses, I'd use recursion or a second stack."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Calculator problems |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May extend to infix |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Basic version |
| LinkedIn | ‚≠ê‚≠ê‚≠ê‚≠ê | Common there |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand RPN | 2-3 min | Know the notation |
| Explain approach | 2-3 min | Stack algorithm |
| Implement | 8-10 min | Handle operators |
| Test | 3-5 min | Division edge cases |
| Interview target | 18-22 min | Including explanation |

---

> **üí° Key Insight:** RPN eliminates ambiguity by making operator precedence explicit through position. The stack naturally handles this: when we see an operator, its operands are always the two most recent values on the stack. No parentheses or precedence rules needed!

---

## üîó Related

- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md) - Foundation
- [Valid Parentheses](./2.1-Valid-Parentheses.md) - Related matching pattern
- [Reverse Operations](./2.2-Reverse-Operations.md) - Stack reversal
