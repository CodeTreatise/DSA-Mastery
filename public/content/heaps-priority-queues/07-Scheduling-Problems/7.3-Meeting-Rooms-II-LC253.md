# 7.3 Meeting Rooms II (LC 253)

## Problem Statement

Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return the minimum number of conference rooms required.

```
Example 1:
Input: intervals = [[0,30],[5,10],[15,20]]
Output: 2
Explanation:
- Room 1: [0,30]
- Room 2: [5,10], then [15,20]

Example 2:
Input: intervals = [[7,10],[2,4]]
Output: 1
Explanation: Meetings don't overlap, one room is enough.
```

**Constraints:**
- 1 ‚â§ intervals.length ‚â§ 10‚Å¥
- 0 ‚â§ starti < endi ‚â§ 10‚Å∂

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Problem Type</strong></summary>

**Key signals:**
- "Minimum number of resources"
- "Overlapping intervals"
- "Meeting/room allocation"
- "Concurrent events"

**Why min-heap?**
- Track when each room becomes free
- For each meeting, check if earliest-freeing room is available
- If yes, reuse it (update end time)
- If no, add new room

**Alternative signals:**
- "Maximum overlapping at any point"
- "Peak concurrent usage"

</details>

---

## ‚úÖ When to Use This Approach

- Finding minimum resources for overlapping intervals
- Scheduling with limited resources
- Maximum concurrent events

## ‚ùå When NOT to Use

| Scenario | Alternative |
|----------|-------------|
| Just check if overlap exists | Meeting Rooms I (LC 252) - sort & compare |
| Merge overlapping intervals | Interval merge (LC 56) |
| Insert into intervals | Binary search |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this:**
- [Heap Fundamentals](../01-Heap-Fundamentals/1.1-What-Is-Heap.md)
- Interval sorting concepts
- Meeting Rooms I (LC 252)

**Related problems:**
- [Car Pooling (LC 1094)](https://leetcode.com/problems/car-pooling/)
- [My Calendar II (LC 731)](https://leetcode.com/problems/my-calendar-ii/)

</details>

---

## üìê Solution Approaches

### Approach 1: Min-Heap of End Times (Optimal)

**Intuition:**
```
Meetings: [[0,30], [5,10], [15,20]]
Sorted by start: same order

Time 0: Meeting [0,30] starts ‚Üí need 1 room
        Heap: [30]  (end time of room 1)

Time 5: Meeting [5,10] starts
        Earliest free room ends at 30 > 5 ‚Üí need new room
        Heap: [10, 30]  (2 rooms)

Time 15: Meeting [15,20] starts
         Earliest free room ends at 10 ‚â§ 15 ‚Üí reuse!
         Heap: [20, 30]  (still 2 rooms)

Answer: 2 rooms needed
```

**Python:**
```python
import heapq

def minMeetingRooms(intervals: list[list[int]]) -> int:
    """
    Min-heap approach.
    Time: O(n log n), Space: O(n)
    """
    if not intervals:
        return 0
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    # Min-heap of end times (when rooms become free)
    end_times = []
    heapq.heappush(end_times, intervals[0][1])
    
    for i in range(1, len(intervals)):
        start, end = intervals[i]
        
        # If earliest ending room is free, reuse it
        if start >= end_times[0]:
            heapq.heappop(end_times)  # Remove old end time
        
        # Add this meeting's end time (new or reused room)
        heapq.heappush(end_times, end)
    
    # Heap size = number of rooms
    return len(end_times)
```

**JavaScript:**
```javascript
function minMeetingRooms(intervals) {
    if (intervals.length === 0) return 0;
    
    // Sort by start time
    intervals.sort((a, b) => a[0] - b[0]);
    
    // Min-heap of end times
    const endTimes = new MinHeap();
    endTimes.push(intervals[0][1]);
    
    for (let i = 1; i < intervals.length; i++) {
        const [start, end] = intervals[i];
        
        // If earliest room is free, reuse it
        if (start >= endTimes.peek()) {
            endTimes.pop();
        }
        
        endTimes.push(end);
    }
    
    return endTimes.size();
}

// MinHeap implementation
class MinHeap {
    constructor() { this.heap = []; }
    
    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return min;
    }
    
    peek() { return this.heap[0]; }
    size() { return this.heap.length; }
    
    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.heap[parent] <= this.heap[i]) break;
            [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
            i = parent;
        }
    }
    
    _bubbleDown(i) {
        const n = this.heap.length;
        while (true) {
            let smallest = i;
            const left = 2 * i + 1, right = 2 * i + 2;
            if (left < n && this.heap[left] < this.heap[smallest]) smallest = left;
            if (right < n && this.heap[right] < this.heap[smallest]) smallest = right;
            if (smallest === i) break;
            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
            i = smallest;
        }
    }
}
```

### Approach 2: Two Arrays (Chronological Events)

**Intuition:**
- Separate start and end times
- Sort both
- Count concurrent meetings

```python
def minMeetingRooms_two_arrays(intervals: list[list[int]]) -> int:
    """
    Two pointers on sorted start/end arrays.
    Time: O(n log n), Space: O(n)
    """
    starts = sorted(i[0] for i in intervals)
    ends = sorted(i[1] for i in intervals)
    
    rooms = 0
    max_rooms = 0
    end_ptr = 0
    
    for start in starts:
        # New meeting starts
        rooms += 1
        
        # Check if any meeting ended before this start
        while end_ptr < len(ends) and ends[end_ptr] <= start:
            rooms -= 1
            end_ptr += 1
        
        max_rooms = max(max_rooms, rooms)
    
    return max_rooms
```

### Approach 3: Line Sweep (Event-Based)

```python
def minMeetingRooms_sweep(intervals: list[list[int]]) -> int:
    """
    Event-based line sweep.
    Time: O(n log n), Space: O(n)
    """
    events = []
    for start, end in intervals:
        events.append((start, 1))   # +1 at start
        events.append((end, -1))    # -1 at end
    
    # Sort by time, then by type (end before start if same time)
    events.sort(key=lambda x: (x[0], x[1]))
    
    rooms = 0
    max_rooms = 0
    
    for time, delta in events:
        rooms += delta
        max_rooms = max(max_rooms, rooms)
    
    return max_rooms
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Min-Heap |" O(n log n) "| O(n) | Sort + heap operations |
| Two Arrays |" O(n log n) "| O(n) | Two sorts |
| Line Sweep |" O(n log n) "| O(n) | One sort of events |

**Why all O(n log n)?**
- Sorting dominates in all approaches
- Heap operations: n * O(log n) = O(n log n)

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Check if possible with k rooms | Return boolean | Modified version |
| With room preferences | Assign specific rooms | Real scheduling |
| Car pooling with capacity | Each trip has passengers | LC 1094 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Comparison for Room Reuse

```python
# ‚ùå Wrong: Strict greater than
if start > end_times[0]:  # Misses when end == start

# ‚úÖ Correct: Can reuse if meeting ended
if start >= end_times[0]:  # [0,10] ends, [10,20] can reuse
```

### 2. Forgetting to Sort

```python
# ‚ùå Wrong: Processing in original order
for start, end in intervals:  # Must process by start time!

# ‚úÖ Correct: Sort first
intervals.sort(key=lambda x: x[0])
```

### 3. Modifying Heap Incorrectly

```python
# ‚ùå Wrong: Just push without checking reuse
heapq.heappush(end_times, end)

# ‚úÖ Correct: Pop-then-push for reuse
if start >= end_times[0]:
    heapq.heappop(end_times)
heapq.heappush(end_times, end)

# Or use heapreplace when reusing:
if start >= end_times[0]:
    heapq.heapreplace(end_times, end)
else:
    heapq.heappush(end_times, end)
```

### 4. Line Sweep: Wrong Tie-Breaking

```python
# ‚ùå Wrong: Start before end at same time
events.sort()  # (10, 1) before (10, -1) ‚Üí wrong count

# ‚úÖ Correct: End before start at same time
events.sort(key=lambda x: (x[0], x[1]))  # -1 before +1
```

---

## üìù Practice Problems

### This Problem
- [ ] [Meeting Rooms II (LC 253)](https://leetcode.com/problems/meeting-rooms-ii/) ‚≠ê

### Prerequisite
- [ ] [Meeting Rooms (LC 252)](https://leetcode.com/problems/meeting-rooms/)

### Similar Problems
- [ ] [Car Pooling (LC 1094)](https://leetcode.com/problems/car-pooling/)
- [ ] [My Calendar I (LC 729)](https://leetcode.com/problems/my-calendar-i/)
- [ ] [My Calendar II (LC 731)](https://leetcode.com/problems/my-calendar-ii/)
- [ ] [Employee Free Time (LC 759)](https://leetcode.com/problems/employee-free-time/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement heap approach
- **Day 3:** Implement line sweep approach
- **Day 7:** Solve Car Pooling
- **Day 14:** Solve without notes

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This Solution</strong></summary>

**Opening:**
"This is a resource allocation problem. I need to find how many rooms are needed for overlapping meetings."

**Approach:**
"I'll use a min-heap to track when each room becomes free. For each meeting (sorted by start time), I check if the earliest-freeing room is available. If yes, I reuse it; otherwise, I need a new room."

**Visualization:**
```
Meetings: [[0,30], [5,10], [15,20]]

Timeline:
Room 1: [=======0-30=======]
Room 2:    [5-10]   [15-20]
```

**Complexity:**
"Time is O(n log n) for sorting and heap operations. Space is O(n) for the heap in worst case when all meetings overlap."

**Edge cases:**
"Empty input returns 0. Single meeting returns 1. Non-overlapping meetings return 1."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Classic interview question |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Multiple variations |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand problem | 2-3 min |
| Heap solution | 15-20 min |
| Line sweep variant | 10-15 min |
| Edge cases | 5 min |

---

## üí° Key Insight

> **Think of each room as a resource that becomes free at some end time.** A min-heap of end times gives O(log n) access to the earliest-freeing room. If the new meeting starts after that room is free, reuse it; otherwise, allocate a new room. The heap size at the end is the answer.

---

## üîó Related

- **Previous:** [Task Scheduler](./7.2-Task-Scheduler-LC621.md)
- **Next:** [Reorganize String](./7.4-Reorganize-String-LC767.md)
- **Pattern:** [Scheduling Overview](./7.1-Task-Scheduler-Overview.md)
