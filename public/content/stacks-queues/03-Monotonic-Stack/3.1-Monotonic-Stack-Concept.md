# 3.1 Monotonic Stack - Pattern Overview

> **Grokking Pattern:** #8 Monotonic Stack
>
> **Priority:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê HIGH - Covers ~15% of stack interview problems
>
> **Key Insight:** Efficiently find the next/previous greater/smaller element in O(n)

---

## Definition

A **Monotonic Stack** is a stack that maintains its elements in either strictly increasing or strictly decreasing order. When a new element violates the monotonic property, we pop elements until the property is restored.

This pattern transforms O(n¬≤) brute force "find next greater/smaller" problems into elegant O(n) solutions.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- Finding the **next** or **previous** greater/smaller element
- Problems involving **spans** (how far can we extend?)
- **Histogram** or **skyline** type problems
- Temperature/stock price comparisons over days
- Problems asking for "first element that is greater/smaller"

**Keywords in problem statement:**
- "next greater element"
- "next smaller element"
- "previous greater element"
- "days until warmer"
- "stock span"
- "largest rectangle"
- "trapping rain water"

**The Monotonic Stack Signal:**
```
For each element, I need to find the nearest element 
that satisfies some comparison condition (>, <, >=, <=)
```

</details>

---

## ‚úÖ When to Use Monotonic Stack

| Scenario | Stack Type | Example |
|----------|------------|---------|
| Next Greater Element | Decreasing | Daily Temperatures |
| Next Smaller Element | Increasing | Next Smaller Element |
| Previous Greater Element | Decreasing | Stock Span |
| Previous Smaller Element | Increasing | Largest Rectangle |
| Maximum/Minimum in ranges | Depends | Sliding Window (with deque) |

**Use Monotonic Stack when:**
- Brute force would be O(n¬≤) nested loops
- Need to find relationships between elements based on order
- Processing elements left-to-right (or right-to-left) matters

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Finding k-th largest | Need all elements | Heap / QuickSelect |
| Global max/min only | Simpler approach | Single variable |
| Unsorted with random access | Different pattern | Binary Search Tree |
| Need actual distance, not element | May work | Modify to store indices |
| Finding ALL greater elements | Too many results | Different approach |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md)
- [Stack Operations](../01-Stack-Fundamentals/1.2-Stack-Operations.md)

**After mastering this:**
- [Next Greater Element I](./3.2-Next-Greater-Problems/01-Next-Greater-Element-I.md) - Foundation problem
- [Daily Temperatures](./3.2-Next-Greater-Problems/03-Daily-Temperatures.md) - Classic application
- [Largest Rectangle in Histogram](./3.3-Histogram-Problems/01-Largest-Rectangle.md) - Advanced
- [Monotonic Deque](../06-Monotonic-Deque/6.1-Monotonic-Deque-Concept.md) - Extension for sliding window

**Combines with:**
- Arrays for histogram problems
- Greedy for optimization (Remove K Digits)
- Dynamic Programming for some variations

</details>

---

## üìê How It Works

### Core Principle

The stack maintains a **monotonic property** - elements are always in sorted order (increasing or decreasing). When we encounter an element that would violate this property, we pop elements until the property can be maintained.

### Two Types of Monotonic Stacks

#### 1. Monotonically Decreasing Stack (for Next Greater Element)

Elements in the stack are in decreasing order from bottom to top.
When we find a larger element, we've found the "next greater" for popped elements.

```
Stack (decreasing): [8, 5, 3, 1]  (bottom to top)
                     ‚Üì
New element: 6

Pop 1 (6 > 1): Next greater of 1 is 6
Pop 3 (6 > 3): Next greater of 3 is 6
Pop 5 (6 > 5): Next greater of 5 is 6
Stop at 8 (6 < 8): Push 6

Stack after: [8, 6]
```

#### 2. Monotonically Increasing Stack (for Next Smaller Element)

Elements in the stack are in increasing order from bottom to top.
When we find a smaller element, we've found the "next smaller" for popped elements.

```
Stack (increasing): [1, 3, 5, 8]  (bottom to top)
                     ‚Üì
New element: 4

Pop 8 (4 < 8): Next smaller of 8 is 4
Pop 5 (4 < 5): Next smaller of 5 is 4
Stop at 3 (4 > 3): Push 4

Stack after: [1, 3, 4]
```

### Visual Walkthrough: Next Greater Element

```
Array: [2, 1, 2, 4, 3]
Goal: Find next greater element for each position

Step-by-step with decreasing stack (storing indices):

i=0: arr[0]=2
     Stack: []
     Push 0
     Stack: [0]

i=1: arr[1]=1
     1 < arr[stack.top()]=2, no pop
     Push 1
     Stack: [0, 1]

i=2: arr[2]=2
     2 > arr[1]=1, pop 1 ‚Üí result[1]=2
     2 = arr[0]=2, no pop (not strictly greater)
     Push 2
     Stack: [0, 2]

i=3: arr[3]=4
     4 > arr[2]=2, pop 2 ‚Üí result[2]=4
     4 > arr[0]=2, pop 0 ‚Üí result[0]=4
     Stack empty, push 3
     Stack: [3]

i=4: arr[4]=3
     3 < arr[3]=4, no pop
     Push 4
     Stack: [3, 4]

End: Remaining in stack have no next greater
     result[3]=-1, result[4]=-1

Result: [4, 2, 4, -1, -1]
```

### Decision Framework

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MONOTONIC STACK DECISION                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ  Q1: What am I looking for?                                 ‚îÇ
‚îÇ      ‚îú‚îÄ‚îÄ Next Greater  ‚Üí Decreasing stack, iterate L‚ÜíR     ‚îÇ
‚îÇ      ‚îú‚îÄ‚îÄ Next Smaller  ‚Üí Increasing stack, iterate L‚ÜíR     ‚îÇ
‚îÇ      ‚îú‚îÄ‚îÄ Prev Greater  ‚Üí Decreasing stack, iterate L‚ÜíR     ‚îÇ
‚îÇ      ‚îî‚îÄ‚îÄ Prev Smaller  ‚Üí Increasing stack, iterate L‚ÜíR     ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  Q2: What should I store in the stack?                      ‚îÇ
‚îÇ      ‚îú‚îÄ‚îÄ Need index for answer  ‚Üí Store indices             ‚îÇ
‚îÇ      ‚îî‚îÄ‚îÄ Need value only        ‚Üí Store values              ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  Q3: When do I record the answer?                           ‚îÇ
‚îÇ      ‚îú‚îÄ‚îÄ Next Greater/Smaller ‚Üí On POP (current is answer)  ‚îÇ
‚îÇ      ‚îî‚îÄ‚îÄ Prev Greater/Smaller ‚Üí On PUSH (top is answer)     ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üíª Code Implementation

### Template: Next Greater Element (Decreasing Stack)

**Python:**
```python
def next_greater_element(nums: list[int]) -> list[int]:
    """
    Find next greater element for each position.
    
    Pattern: Monotonic Decreasing Stack
    Time: O(n), Space: O(n)
    
    Returns: Array where result[i] = next greater element of nums[i], or -1
    """
    n = len(nums)
    result = [-1] * n  # Default: no greater element
    stack = []  # Store indices, not values
    
    for i in range(n):
        # Pop elements smaller than current
        # Current element is the "next greater" for popped elements
        while stack and nums[i] > nums[stack[-1]]:
            idx = stack.pop()
            result[idx] = nums[i]
        
        # Push current index
        stack.append(i)
    
    # Elements remaining in stack have no next greater
    return result


def next_greater_element_values(nums: list[int]) -> list[int]:
    """Alternative: iterate right to left, build answer immediately."""
    n = len(nums)
    result = [-1] * n
    stack = []  # Store values
    
    # Process from right to left
    for i in range(n - 1, -1, -1):
        # Pop elements smaller than or equal to current
        while stack and stack[-1] <= nums[i]:
            stack.pop()
        
        # Top of stack is next greater (if exists)
        if stack:
            result[i] = stack[-1]
        
        stack.append(nums[i])
    
    return result
```

**JavaScript:**
```javascript
/**
 * Find next greater element for each position.
 * Pattern: Monotonic Decreasing Stack
 * Time: O(n), Space: O(n)
 */
function nextGreaterElement(nums) {
    const n = nums.length;
    const result = new Array(n).fill(-1);
    const stack = []; // Store indices
    
    for (let i = 0; i < n; i++) {
        // Pop elements smaller than current
        while (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {
            const idx = stack.pop();
            result[idx] = nums[i];
        }
        stack.push(i);
    }
    
    return result;
}

// Alternative: Right to left traversal
function nextGreaterElementRTL(nums) {
    const n = nums.length;
    const result = new Array(n).fill(-1);
    const stack = []; // Store values
    
    for (let i = n - 1; i >= 0; i--) {
        while (stack.length > 0 && stack[stack.length - 1] <= nums[i]) {
            stack.pop();
        }
        if (stack.length > 0) {
            result[i] = stack[stack.length - 1];
        }
        stack.push(nums[i]);
    }
    
    return result;
}
```

### Template: Next Smaller Element (Increasing Stack)

**Python:**
```python
def next_smaller_element(nums: list[int]) -> list[int]:
    """
    Find next smaller element for each position.
    
    Pattern: Monotonic Increasing Stack
    Time: O(n), Space: O(n)
    """
    n = len(nums)
    result = [-1] * n
    stack = []  # Store indices
    
    for i in range(n):
        # Pop elements larger than current
        while stack and nums[i] < nums[stack[-1]]:
            idx = stack.pop()
            result[idx] = nums[i]
        
        stack.append(i)
    
    return result
```

### Template: Previous Greater Element

**Python:**
```python
def previous_greater_element(nums: list[int]) -> list[int]:
    """
    Find previous greater element for each position.
    
    Pattern: Monotonic Decreasing Stack
    Answer is recorded on PUSH (stack top is previous greater)
    Time: O(n), Space: O(n)
    """
    n = len(nums)
    result = [-1] * n
    stack = []  # Store indices
    
    for i in range(n):
        # Pop elements smaller than or equal to current
        while stack and nums[stack[-1]] <= nums[i]:
            stack.pop()
        
        # Stack top is previous greater element
        if stack:
            result[i] = nums[stack[-1]]
        
        stack.append(i)
    
    return result
```

**JavaScript:**
```javascript
function previousGreaterElement(nums) {
    const n = nums.length;
    const result = new Array(n).fill(-1);
    const stack = [];
    
    for (let i = 0; i < n; i++) {
        while (stack.length > 0 && nums[stack[stack.length - 1]] <= nums[i]) {
            stack.pop();
        }
        if (stack.length > 0) {
            result[i] = nums[stack[stack.length - 1]];
        }
        stack.push(i);
    }
    
    return result;
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Build result |" O(n) "| O(n) | Each element pushed/popped once |
| Per element |" O(1) amortized "| - | Max n pushes, max n pops total |

**Why O(n) and not O(n¬≤)?**

Even though we have a while loop inside a for loop, each element is:
- Pushed onto the stack **exactly once**
- Popped from the stack **at most once**

Total operations: 2n = O(n)

```
Think of it this way:
- n push operations total
- n pop operations total (maximum)
- 2n operations = O(n)
```

---

## üîÑ Variations

| Variation | Stack Type | Direction | Answer On |
|-----------|------------|-----------|-----------|
| Next Greater | Decreasing | L‚ÜíR | Pop |
| Next Smaller | Increasing | L‚ÜíR | Pop |
| Previous Greater | Decreasing | L‚ÜíR | Push |
| Previous Smaller | Increasing | L‚ÜíR | Push |
| Next Greater (circular) | Decreasing | 2x array or modulo | Pop |

### Common Problem Mappings

| Problem | Variation Needed |
|---------|------------------|
| Daily Temperatures | Next Greater (index difference) |
| Stock Span | Previous Greater (count of days) |
| Largest Rectangle | Previous Smaller + Next Smaller |
| Trapping Rain Water | Previous Greater + Next Greater (or two pointers) |
| Remove K Digits | Increasing stack (greedy) |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Stack Type

```python
# ‚ùå WRONG: Using increasing stack for next greater
def wrong_next_greater(nums):
    result = [-1] * len(nums)
    stack = []
    for i in range(len(nums)):
        while stack and nums[i] > nums[stack[-1]]:  # This logic is right
            # But if you're maintaining increasing stack, you'd pop when smaller
            pass
    # Confusing logic...

# ‚úÖ CORRECT: Decreasing stack for next greater
def next_greater(nums):
    result = [-1] * len(nums)
    stack = []  # Will be decreasing
    for i in range(len(nums)):
        while stack and nums[i] > nums[stack[-1]]:
            result[stack.pop()] = nums[i]
        stack.append(i)
    return result
```

### 2. Storing Values Instead of Indices

```python
# ‚ùå WRONG: Can't access original positions
stack.append(nums[i])
result[???] = nums[i]  # Lost the index!

# ‚úÖ CORRECT: Store indices
stack.append(i)
result[stack.pop()] = nums[i]  # Can access position
```

### 3. Forgetting Remaining Elements

```python
# ‚ùå WRONG: Not handling elements with no next greater
def incomplete(nums):
    result = []  # Wrong initialization
    stack = []
    for i in range(len(nums)):
        while stack and nums[i] > nums[stack[-1]]:
            # ... process
            pass
        stack.append(i)
    return result  # What about elements still in stack?

# ‚úÖ CORRECT: Initialize with default value
def complete(nums):
    result = [-1] * len(nums)  # Default: -1 (no greater)
    stack = []
    for i in range(len(nums)):
        while stack and nums[i] > nums[stack[-1]]:
            result[stack.pop()] = nums[i]
        stack.append(i)
    # Elements in stack already have -1
    return result
```

### 4. Strict vs Non-Strict Comparison

```python
# For "strictly greater" (not equal)
while stack and nums[i] > nums[stack[-1]]:  # Use >

# For "greater or equal"  
while stack and nums[i] >= nums[stack[-1]]:  # Use >=

# Common bug: using wrong comparison for the problem requirements
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)
- [ ] [Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/) - LC 496 ‚≠ê
- [ ] [Final Prices With Special Discount](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/) - LC 1475

### Medium (Apply variations)
- [ ] [Daily Temperatures](https://leetcode.com/problems/daily-temperatures/) - LC 739 ‚≠ê‚≠ê
- [ ] [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/) - LC 503
- [ ] [Online Stock Span](https://leetcode.com/problems/online-stock-span/) - LC 901
- [ ] [Remove K Digits](https://leetcode.com/problems/remove-k-digits/) - LC 402
- [ ] [132 Pattern](https://leetcode.com/problems/132-pattern/) - LC 456

### Hard (Master edge cases)
- [ ] [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/) - LC 84 ‚≠ê‚≠ê‚≠ê
- [ ] [Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/) - LC 85
- [ ] [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/) - LC 42 ‚≠ê‚≠ê‚≠ê

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement Next Greater Element from scratch
**Day 3:** Implement Previous Greater Element variant
**Day 7:** Solve Daily Temperatures without looking at notes
**Day 14:** Solve Stock Span problem
**Day 21:** Attempt Largest Rectangle in Histogram
**Day 30:** Review all variants, explain differences

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
> "I recognize this as a 'next greater element' pattern. I'll use a monotonic stack to achieve O(n) time instead of O(n¬≤) brute force."

**Explain the approach:**
> "I'll maintain a decreasing stack. When I find an element larger than the stack top, I've found the 'next greater' for those smaller elements."

**Complexity explanation:**
> "Time is O(n) because each element is pushed and popped at most once. Space is O(n) for the stack in the worst case."

**Common follow-ups:**
- "Can you solve it in O(1) space?" ‚Üí Usually not for this pattern
- "What if elements can be equal?" ‚Üí Clarify strict vs non-strict comparison
- "What about circular arrays?" ‚Üí Use modulo or iterate twice

</details>

**Company Focus:**

| Company | Frequency | Typical Problems |
|---------|-----------|------------------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Daily Temperatures, Stock Span |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Trapping Rain Water, Histogram |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | 132 Pattern, complex variations |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Next Greater Element, Remove K Digits |
| Bloomberg | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Stock-related problems |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn concept | 30-45 min | Understand both stack types |
| Implement template | 10-15 min | Next greater pattern |
| Solve Easy problem | 10-15 min | Next Greater Element I |
| Solve Medium problem | 20-30 min | Daily Temperatures |
| Solve Hard problem | 30-45 min | Largest Rectangle |
| Master all variants | 3-4 hours | All 4 variants + problems |

---

> **üí° Key Insight:** The monotonic stack works because we're exploiting the property that once we find a greater/smaller element, all the elements we pop will never need to be considered again for that direction. Each element is processed exactly once.

---

## üîó Related

- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md) - Foundation
- [Next Greater Element I](./3.2-Next-Greater-Problems/01-Next-Greater-Element-I.md) - First application
- [Daily Temperatures](./3.2-Next-Greater-Problems/03-Daily-Temperatures.md) - Classic problem
- [Monotonic Deque](../06-Monotonic-Deque/6.1-Monotonic-Deque-Concept.md) - Extension for sliding window
