# 1.6 - Complexity Analysis for Trees

> **Foundation:** Understanding time and space complexity for tree operations
>
> **Priority:** Essential for interview discussions

---

## Overview

Understanding tree complexity helps you:
1. Discuss trade-offs in interviews
2. Choose the right approach
3. Explain why your solution is efficient

---

## ðŸŽ¯ Key Variables

| Variable | Meaning | Range |
|----------|---------|-------|
| **n** | Number of nodes | Given |
| **h** | Height of tree | log n to n |
| **w** | Width (max nodes at any level) | 1 to n/2 |

### Height Bounds

| Tree Type | Height | Example |
|-----------|--------|---------|
| Balanced (AVL, Red-Black) |" O(log n) "| Guaranteed |
| Complete |" O(log n) "| Heap |
| Average random BST |" O(log n) "| Expected |
| Skewed |" O(n) "| Worst case |
| Perfect | âŒŠlogâ‚‚ nâŒ‹ | All levels full |

```
Balanced (h = log n):     Skewed (h = n):
        1                     1
       / \                     \
      2   3                     2
     / \ / \                     \
    4  5 6  7                     3
                                   \
                                    4
```

---

## ðŸ“ DFS Complexity

### Time Complexity

| Operation | Complexity | Reasoning |
|-----------|------------|-----------|
| Traversal |" O(n) "| Visit each node once |
| Search |" O(n) / O(h) "| All nodes / path to node |
| Insert |" O(1)* / O(h) "| After finding location |
| Delete |" O(1)* / O(h) "| After finding location |

*O(1) for the actual operation, O(h) to find the location

### Space Complexity

| Approach | Space | Reasoning |
|----------|-------|-----------|
| Recursive DFS |" O(h) "| Call stack depth |
| Iterative DFS |" O(h) "| Explicit stack |

```python
# Recursive: Space = O(h) for call stack
def dfs(node):
    if not node:
        return 0
    return 1 + max(dfs(node.left), dfs(node.right))

# Stack frame at each level of recursion
# Max frames = height of tree
```

---

## ðŸ“ BFS Complexity

### Time Complexity

| Operation | Complexity | Reasoning |
|-----------|------------|-----------|
| Level-order traversal |" O(n) "| Visit each node once |
| Find at depth d |" O(nodes at depth d) "| Specific level |

### Space Complexity

| Scenario | Space | Reasoning |
|----------|-------|-----------|
| Balanced tree |" O(n/2) = O(n) "| Bottom level has n/2 nodes |
| Skewed tree |" O(1) "| One node per level |
| Average |" O(w) "| Width of widest level |

```python
# BFS: Space = O(w) for queue
def bfs(root):
    queue = [root]  # At worst, holds entire bottom level
    while queue:
        node = queue.pop(0)
        if node.left: queue.append(node.left)
        if node.right: queue.append(node.right)
```

---

## âš¡ Comparison Table

| Tree Type | Height (h) | DFS Space | BFS Space |
|-----------|------------|-----------|-----------|
| Balanced |" O(log n) "| O(log n) |" O(n) "|
| Complete |" O(log n) "| O(log n) |" O(n) "|
| Skewed |" O(n) "| O(n) |" O(1) "|
| Perfect |" O(log n) "| O(log n) |" O(n/2) "|

**Key Insight:**
- DFS is better for skewed trees (O(n) vs O(n) but simpler)
- BFS is better when you need level information
- For most problems, DFS is preferred (simpler code)

---

## ðŸ“ Common Operation Complexities

### Basic Operations

| Operation | Time | Space |
|-----------|------|-------|
| Find max/min value |" O(n) "| O(h) |
| Calculate height |" O(n) "| O(h) |
| Count nodes |" O(n) "| O(h) |
| Check if balanced |" O(n) "| O(h) |
| Find path sum |" O(n) "| O(h) |

### Advanced Operations

| Operation | Time | Space |
|-----------|------|-------|
| LCA |" O(n) "| O(h) |
| Diameter |" O(n) "| O(h) |
| Serialize |" O(n) "| O(n) output |
| Construct from traversals |" O(n) "| O(n) |

### BST Operations (Balanced)

| Operation | Time | Space |
|-----------|------|-------|
| Search |" O(log n) "| O(log n) |
| Insert |" O(log n) "| O(log n) |
| Delete |" O(log n) "| O(log n) |
| Inorder (sorted) |" O(n) "| O(h) |

---

## ðŸ”„ Optimizing Tree Solutions

### Hash Map Optimization

```python
# O(nÂ²) - Linear search in each call
def build_tree(preorder, inorder):
    if not preorder:
        return None
    root = TreeNode(preorder[0])
    mid = inorder.index(preorder[0])  # O(n) each time!
    ...

# O(n) - Hash map for O(1) lookup
def build_tree_optimized(preorder, inorder):
    index_map = {v: i for i, v in enumerate(inorder)}  # O(n) once
    
    def build(pre_start, in_start, in_end):
        if in_start > in_end:
            return None
        root = TreeNode(preorder[pre_start])
        mid = index_map[preorder[pre_start]]  # O(1) lookup
        ...
```

### Early Termination

```python
# Without early termination - always O(n)
def has_path_sum(node, target):
    if not node:
        return False
    if not node.left and not node.right:
        return target == node.val
    return has_path_sum(node.left, target - node.val) or \
           has_path_sum(node.right, target - node.val)

# With early termination - can return early
def has_path_sum_optimized(node, target):
    if not node:
        return False
    if not node.left and not node.right:
        return target == node.val
    
    # Check left first
    if has_path_sum_optimized(node.left, target - node.val):
        return True  # Early return!
    
    return has_path_sum_optimized(node.right, target - node.val)
```

### Global Variable Pattern

```python
# Return value approach - works but complex
def diameter_complex(node):
    if not node:
        return (0, 0)  # (height, diameter)
    
    left_h, left_d = diameter_complex(node.left)
    right_h, right_d = diameter_complex(node.right)
    
    height = 1 + max(left_h, right_h)
    diameter = max(left_d, right_d, left_h + right_h)
    
    return (height, diameter)

# Global variable approach - cleaner
def diameter_clean(root):
    max_diameter = [0]
    
    def height(node):
        if not node:
            return 0
        left = height(node.left)
        right = height(node.right)
        max_diameter[0] = max(max_diameter[0], left + right)
        return 1 + max(left, right)
    
    height(root)
    return max_diameter[0]
```

---

## ðŸ“ Interview Discussion Template

### Complexity Discussion Format

```
Time Complexity: O(n)
- We visit each node exactly once
- At each node, we do O(1) work ["or O(k) for specific operation"]
- Total: n nodes * O(1) per node = O(n)

Space Complexity: O(h) where h is tree height
- Recursive call stack can go h levels deep
- For balanced tree: O(log n)
- For skewed tree: O(n)
- Can also say O(h) to cover both cases
```

### Example Discussion

> "My solution visits each node once, so time is O(n). The space is O(h) for the recursion stack, where h is the height. For a balanced tree this is O(log n), but in the worst case of a skewed tree, it could be O(n). If we're worried about stack overflow for very deep trees, we could convert to an iterative approach using an explicit stack."

---

## âš ï¸ Common Complexity Mistakes

### 1. Forgetting About Tree Shape

```python
# âŒ WRONG: "DFS is always O(log n) space"
# Space depends on tree HEIGHT, not just the algorithm

# âœ… CORRECT: "DFS is O(h) space, which is O(log n) for balanced 
#             trees and O(n) for skewed trees"
```

### 2. Confusing Node Count vs Height

```python
# âŒ WRONG: "We have n levels, so..."
# Trees have h levels, not n levels

# âœ… CORRECT: 
# - h = height (number of levels)
# - n = total nodes
# - For balanced tree: h â‰ˆ log n
# - For skewed tree: h â‰ˆ n
```

### 3. Missing Hidden Complexity

```python
# âŒ Looks like O(n) but actually O(nÂ²)
def serialize(node):
    if not node:
        return "null"
    # String concatenation creates new string each time!
    return str(node.val) + "," + serialize(node.left) + "," + serialize(node.right)

# âœ… Actually O(n) with list approach
def serialize(node):
    result = []
    def dfs(node):
        if not node:
            result.append("null")
            return
        result.append(str(node.val))
        dfs(node.left)
        dfs(node.right)
    dfs(root)
    return ",".join(result)
```

---

## ðŸ“Š Quick Reference Card

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              TREE COMPLEXITY CHEAT SHEET            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Variables:                                          â”‚
â”‚   n = number of nodes                               â”‚
â”‚   h = height (log n to n)                           â”‚
â”‚   w = width (1 to n/2)                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ DFS (recursive/iterative):                          â”‚
â”‚   Time: O(n) for traversal                          â”‚
â”‚   Space: O(h) for call stack                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ BFS (queue):                                        â”‚
â”‚   Time: O(n) for traversal                          â”‚
â”‚   Space: O(w) for queue                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ BST operations (balanced):                          â”‚
â”‚   Search/Insert/Delete: O(log n)                    â”‚
â”‚   Inorder traversal: O(n)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Common mistake:                                     â”‚
â”‚   Don't say O(log n) for all trees!                 â”‚
â”‚   Say O(h) and clarify based on tree type.          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn complexity basics | 20-30 min | Foundation |
| Practice explaining | 15 min | Interview prep |
| Master trade-offs | Ongoing | Build intuition |

---

> **ðŸ’¡ Key Insight:** For most tree problems, time is O(n) because you visit each node. The interesting discussion is usually about space: O(h) for DFS vs O(w) for BFS, and how h varies based on tree balance. Always clarify what h could be in different scenarios.

---

## ðŸ”— Related

- [Recursion on Trees](./1.4-Recursion-Trees.md)
- [DFS Concept](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
- [BFS Concept](../03-Tree-Traversals/3.2-BFS-Traversals/00-BFS-Concept.md)
