# 5.3 Sliding Window Median (LC 480)

## Problem Statement

Given an array of integers `nums` and an integer `k`, find the **median** of each sliding window of size `k`. Return an array of medians.

```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [1.0,-1.0,-1.0,3.0,5.0,6.0]

Window positions:              Median:
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7      -1
 1  3 [-1  -3  5] 3  6  7      -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
```

**LeetCode:** [480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>Pattern: Two Heaps + Lazy Deletion</strong></summary>

**Key signals:**
- "Sliding window" + "median"
- Need to add AND remove elements
- Maintain dynamic median

**Challenge vs LC 295:**
```
LC 295 (Find Median from Data Stream):
  - Only add elements
  - Never remove
  - Two heaps work perfectly

LC 480 (Sliding Window Median):
  - Add new element (window slides right)
  - Remove old element (window slides left)
  - Standard heaps don't support efficient removal!
```

**Solution: Lazy Deletion**
```
Instead of removing immediately:
1. Track what SHOULD be deleted (hash map)
2. Only delete when element reaches heap top
3. Rebalance after accounting for pending deletions
```

</details>

---

## ‚úÖ When to Use This Pattern

| Scenario | Approach |
|----------|----------|
| Sliding window median | Two heaps + lazy deletion |
| Fixed window statistics | Similar pattern |
| Need add + remove | Lazy deletion required |

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|---------------------|
| Stream (no removal) | Simple Two Heaps (LC 295) |
| Very small k | Brute force sort window |
| Need other statistics | Different approach |

---

## üìê Solution Approach

### Two Heaps with Lazy Deletion

```
Data Structures:
- max_heap: smaller half (negated for Python)
- min_heap: larger half
- to_remove: hash map tracking pending deletions

For each window position:
1. Add new element (entering window)
2. Mark old element for removal (leaving window)
3. Rebalance heaps (accounting for lazy deletions)
4. Clean up heap tops (remove lazy-deleted elements)
5. Calculate median

Key insight: We don't actually remove from middle of heap
- Just mark it
- Remove when it bubbles to top
```

### Balancing with Lazy Deletion

```
Balance rule (same as LC 295):
  len(max_heap) == len(min_heap) OR
  len(max_heap) == len(min_heap) + 1

But with lazy deletion, we track "effective" sizes:
  effective_max = len(max_heap) - pending_max_deletions
  effective_min = len(min_heap) - pending_min_deletions

Rebalance based on effective sizes, not actual sizes
```

### Walkthrough Example

```
nums = [1, 3, -1, -3, 5], k = 3

Initial: Add first k elements
  Add 1: max_heap = [-1], min_heap = []
  Add 3: max_heap = [-1], min_heap = [3]
  Add -1: max_heap = [-1, 1], min_heap = [3]
         Wait, need to rebalance...
         max_heap = [1], min_heap = [-1, 3]
         Hmm, that's wrong. Let me trace more carefully.

Actually, proper insertion:
  Add 1:
    Push to max_heap: max_heap = [-1]
    Move top of max to min: min_heap = [1]
    Balance: if len(max) < len(min), move min to max
    max_heap = [-1], min_heap = []
    
  Add 3:
    Push to max_heap: max_heap = [-3, -1]
    Move top of max to min: max_heap = [-1], min_heap = [3]
    Balance OK
    
  Add -1:
    Push to max_heap: max_heap = [-1, -1]
    Move top of max to min: max_heap = [-1], min_heap = [-1, 3]
    Oops, -1 should be in max (smaller half)
    
Better approach for this problem:
  Insert based on value comparison with heap tops
```

---

## üíª Code Implementation

### Complete Solution with Lazy Deletion

**Python:**
```python
import heapq
from collections import defaultdict

def medianSlidingWindow(nums: list[int], k: int) -> list[float]:
    """
    LC 480: Sliding Window Median
    
    Two Heaps + Lazy Deletion
    - max_heap: smaller half (negated)
    - min_heap: larger half
    - to_remove: track pending deletions
    
    Time: O(n log k)
    Space: O(k)
    """
    # max_heap stores negated values for max-heap behavior
    max_heap = []  # Smaller half
    min_heap = []  # Larger half
    to_remove = defaultdict(int)  # Pending deletions
    
    def add_num(num):
        """Add number to appropriate heap."""
        if not max_heap or num <= -max_heap[0]:
            heapq.heappush(max_heap, -num)
        else:
            heapq.heappush(min_heap, num)
    
    def remove_num(num):
        """Mark number for lazy deletion."""
        to_remove[num] += 1
    
    def balance():
        """
        Balance heaps so max_heap has equal or one more element.
        Accounts for pending deletions.
        """
        # Move from max to min if max has more than 1 extra
        while len(max_heap) > len(min_heap) + 1:
            moved = -heapq.heappop(max_heap)
            heapq.heappush(min_heap, moved)
        
        # Move from min to max if min has more
        while len(min_heap) > len(max_heap):
            moved = heapq.heappop(min_heap)
            heapq.heappush(max_heap, -moved)
    
    def cleanup(heap, is_max_heap):
        """Remove lazy-deleted elements from heap top."""
        while heap:
            top = -heap[0] if is_max_heap else heap[0]
            if to_remove[top] > 0:
                to_remove[top] -= 1
                heapq.heappop(heap)
            else:
                break
    
    def get_median():
        """Get median from two heaps."""
        if k % 2 == 1:
            return float(-max_heap[0])
        return (-max_heap[0] + min_heap[0]) / 2.0
    
    result = []
    
    # Initialize with first k elements
    for i in range(k):
        add_num(nums[i])
        balance()
    
    result.append(get_median())
    
    # Slide window
    for i in range(k, len(nums)):
        # Add new element (entering window)
        add_num(nums[i])
        
        # Remove old element (leaving window)
        remove_num(nums[i - k])
        
        # Balance and cleanup
        balance()
        cleanup(max_heap, True)
        cleanup(min_heap, False)
        balance()  # May need to rebalance after cleanup
        
        result.append(get_median())
    
    return result


# Example
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(medianSlidingWindow(nums, k))
# [1.0, -1.0, -1.0, 3.0, 5.0, 6.0]
```

### Cleaner Implementation

**Python:**
```python
import heapq
from collections import defaultdict

class MedianFinder:
    """
    Encapsulated Two Heaps with Lazy Deletion.
    """
    
    def __init__(self):
        self.max_heap = []  # Smaller half (negated)
        self.min_heap = []  # Larger half
        self.to_remove = defaultdict(int)
        self.max_size = 0  # Effective size of max_heap
        self.min_size = 0  # Effective size of min_heap
    
    def add(self, num: int) -> None:
        """Add number to heaps."""
        if not self.max_heap or num <= -self.max_heap[0]:
            heapq.heappush(self.max_heap, -num)
            self.max_size += 1
        else:
            heapq.heappush(self.min_heap, num)
            self.min_size += 1
        self._balance()
    
    def remove(self, num: int) -> None:
        """Mark number for lazy deletion."""
        self.to_remove[num] += 1
        
        # Update effective size
        if self.max_heap and num <= -self.max_heap[0]:
            self.max_size -= 1
        else:
            self.min_size -= 1
        
        self._balance()
        self._cleanup()
    
    def _balance(self) -> None:
        """Balance so max_heap has equal or one more."""
        while self.max_size > self.min_size + 1:
            moved = -heapq.heappop(self.max_heap)
            heapq.heappush(self.min_heap, moved)
            self.max_size -= 1
            self.min_size += 1
            self._cleanup_top(self.max_heap, True)
        
        while self.min_size > self.max_size:
            moved = heapq.heappop(self.min_heap)
            heapq.heappush(self.max_heap, -moved)
            self.min_size -= 1
            self.max_size += 1
            self._cleanup_top(self.min_heap, False)
    
    def _cleanup_top(self, heap, is_max_heap) -> None:
        """Remove lazy-deleted elements from top of specified heap."""
        while heap:
            top = -heap[0] if is_max_heap else heap[0]
            if self.to_remove[top] > 0:
                self.to_remove[top] -= 1
                heapq.heappop(heap)
            else:
                break
    
    def _cleanup(self) -> None:
        """Clean both heap tops."""
        self._cleanup_top(self.max_heap, True)
        self._cleanup_top(self.min_heap, False)
    
    def get_median(self, is_odd: bool) -> float:
        """Get current median."""
        self._cleanup()  # Ensure tops are valid
        if is_odd:
            return float(-self.max_heap[0])
        return (-self.max_heap[0] + self.min_heap[0]) / 2.0


def medianSlidingWindow(nums: list[int], k: int) -> list[float]:
    mf = MedianFinder()
    result = []
    is_odd = (k % 2 == 1)
    
    for i, num in enumerate(nums):
        mf.add(num)
        
        if i >= k:
            mf.remove(nums[i - k])
        
        if i >= k - 1:
            result.append(mf.get_median(is_odd))
    
    return result
```

### JavaScript Solution

**JavaScript:**
```javascript
function medianSlidingWindow(nums, k) {
    // Use sorted array for simplicity (O(k) per operation)
    // For interview, explain heap approach but implement simpler version
    
    const window = nums.slice(0, k).sort((a, b) => a - b);
    const result = [];
    
    const getMedian = () => {
        const mid = Math.floor(k / 2);
        if (k % 2 === 1) return window[mid];
        return (window[mid - 1] + window[mid]) / 2;
    };
    
    const insertSorted = (arr, val) => {
        let left = 0, right = arr.length;
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (arr[mid] < val) left = mid + 1;
            else right = mid;
        }
        arr.splice(left, 0, val);
    };
    
    const removeSorted = (arr, val) => {
        const idx = arr.indexOf(val);
        if (idx !== -1) arr.splice(idx, 1);
    };
    
    result.push(getMedian());
    
    for (let i = k; i < nums.length; i++) {
        removeSorted(window, nums[i - k]);
        insertSorted(window, nums[i]);
        result.push(getMedian());
    }
    
    return result;
}

// Note: This is O(nk) due to splice operations
// Heap solution with lazy deletion is O(n log k) but more complex
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Two Heaps + Lazy Deletion |" O(n log k) "| O(k) | Optimal |
| Sorted Array (splice) |" O(nk) "| O(k) | Simpler |
| Balanced BST |" O(n log k) "| O(k) | Alternative |
| Brute Force |" O(nk log k) "| O(k) | Sort each window |

**Why lazy deletion works:**
- We don't remove immediately (O(k) to find in heap)
- Mark for deletion, remove when at top
- Amortized: each element is removed at most once
- Total: O(n log k) for n elements

---

## üîÑ Variations

| Variation | Difference | Approach |
|-----------|------------|----------|
| Stream median | No removal | Simple Two Heaps (LC 295) |
| Window mode | Most frequent | Hash map + heap |
| Window max | Just maximum | Monotonic deque |
| Double-ended | Add/remove both ends | Indexed PQ |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Tracking Effective Sizes

```python
# ‚ùå Wrong: Using len(heap) for balance
while len(max_heap) > len(min_heap) + 1:
    # This doesn't account for pending deletions!

# ‚úÖ Correct: Track effective sizes separately
self.max_size = actual elements - pending deletions
while self.max_size > self.min_size + 1:
    ...
```

### 2. Forgetting to Cleanup Before Getting Median

```python
# ‚ùå Wrong: Getting median without cleanup
def get_median(self):
    return -self.max_heap[0]  # Top might be deleted!

# ‚úÖ Correct: Cleanup first
def get_median(self):
    self._cleanup()  # Remove deleted elements from top
    return -self.max_heap[0]
```

### 3. Wrong Heap Choice for Removal

```python
# ‚ùå Wrong: Assuming element is in max_heap
def remove(self, num):
    self.to_remove[num] += 1
    self.max_size -= 1  # Wrong if num is in min_heap!

# ‚úÖ Correct: Check which heap it belongs to
def remove(self, num):
    self.to_remove[num] += 1
    if self.max_heap and num <= -self.max_heap[0]:
        self.max_size -= 1
    else:
        self.min_size -= 1
```

### 4. Integer Overflow / Precision Issues

```python
# ‚ùå Potential issue: Integer median
return (max_heap[0] + min_heap[0]) // 2

# ‚úÖ Correct: Float division
return (-max_heap[0] + min_heap[0]) / 2.0
```

---

## üìù Related Practice Problems

### Easier
- [ ] [Find Median from Data Stream (LC 295)](https://leetcode.com/problems/find-median-from-data-stream/)
- [ ] [Sliding Window Maximum (LC 239)](https://leetcode.com/problems/sliding-window-maximum/)

### Similar
- [ ] [IPO (LC 502)](https://leetcode.com/problems/ipo/) - Two Heaps

### Harder
- [ ] [Smallest Range Covering Elements (LC 632)](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand lazy deletion concept
- **Day 3:** Implement basic version
- **Day 7:** Trace through example manually
- **Day 14:** Implement from scratch
- **Day 30:** Explain to someone else

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This Solution</strong></summary>

**Opening:**
"This extends the Two Heaps pattern from LC 295, but now we need to remove elements too. Standard heaps don't support efficient removal, so I'll use lazy deletion - mark elements for removal and actually delete when they reach the heap top."

**Explaining lazy deletion:**
"Instead of O(k) to find and remove from heap, I track pending deletions in a hash map. When an element reaches the top of either heap, I check if it's marked for deletion and remove it then. This amortizes to O(log k) per removal."

**Effective size tracking:**
"I track 'effective' sizes of each heap - actual size minus pending deletions. This is crucial for correct balancing."

**Complexity:**
"Each element is added once O(log k) and removed once O(log k) amortized. For n elements, that's O(n log k) total."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Hard favorite |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Asked frequently |
| Meta | ‚≠ê‚≠ê‚≠ê | May simplify |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Standard |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 5-7 min | Connect to LC 295 |
| Design solution | 10-12 min | Lazy deletion |
| Implement | 20-25 min | Many edge cases |
| Test | 5-7 min | Trace through |

**Interview target:** 40-45 minutes (hard problem)

---

## üí° Key Insight

> **Lazy deletion transforms O(k) removal into O(log k) amortized.** When you can't efficiently remove from a heap's middle, mark elements for deletion and only physically remove them when they bubble to the top. Track effective sizes (actual - pending) for correct balancing.

---

## üîó Related

- **Previous:** [Median from Stream (LC 295)](./5.2-Median-Stream-LC295.md)
- **Next:** [IPO (LC 502)](./5.4-IPO-LC502.md)
- **Pattern:** [Two Heaps Overview](./5.1-Two-Heaps-Overview.md)
- **Prerequisite:** [Top K Pattern](../04-Top-K-Pattern/4.1-Top-K-Overview.md)
