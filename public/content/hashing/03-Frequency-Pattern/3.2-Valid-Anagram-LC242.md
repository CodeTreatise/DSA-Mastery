# Valid Anagram (LeetCode 242)

> **The classic frequency counting problem - compare character frequencies of two strings.**

Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

An **anagram** is a word formed by rearranging the letters of a different word, using all the original letters exactly once.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem signals:**
- "Anagram" explicitly mentioned
- "Rearranging letters"
- Compare two strings/arrays for same content
- Order doesn't matter, only frequency

**This is a Frequency Counting problem:**
- Two strings are anagrams if they have identical character frequencies
- Count characters in both, compare counts

</details>

---

## ‚úÖ When to Use

- Comparing two collections for same elements
- Order doesn't matter (permutation check)
- Need O(n) time solution

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need to preserve order | Order matters | Direct comparison |
| Unicode with huge alphabet | O(alphabet) space | Sorting approach |
| Multiple string comparisons | Precompute signatures | Hash signature + caching |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- Hash map operations
- String iteration

**After mastering:**
- [Group Anagrams](../06-Grouping-Pattern/6.2-Group-Anagrams-LC49.md) - Group strings by anagram class
- [Find All Anagrams](../07-Sliding-Window-Hash/7.3-Find-Anagrams-LC438.md) - Sliding window variant

**Combines with:**
- Sliding window for substring anagram finding
- Sorting for multi-string comparison

</details>

---

## üìê How It Works

### Problem Examples

```
Example 1:
Input: s = "anagram", t = "nagaram"
Output: true

Example 2:
Input: s = "rat", t = "car"
Output: false
```

### Approach 1: Two Counters

```
s = "anagram"
t = "nagaram"

Count s: {a:3, n:1, g:1, r:1, m:1}
Count t: {n:1, a:3, g:1, r:1, m:1}

Same? Yes ‚Üí Anagram ‚úì
```

### Approach 2: Single Counter (Count Up, Count Down)

```
s = "anagram"
t = "nagaram"

Process s (count up):
  a:1 ‚Üí n:1 ‚Üí a:2 ‚Üí g:1 ‚Üí r:1 ‚Üí a:3 ‚Üí m:1
  {a:3, n:1, g:1, r:1, m:1}

Process t (count down):
  n:0 ‚Üí a:2 ‚Üí g:0 ‚Üí a:1 ‚Üí r:0 ‚Üí a:0 ‚Üí m:0
  {a:0, n:0, g:0, r:0, m:0}

All zeros? Yes ‚Üí Anagram ‚úì
```

### Approach 3: Sorting

```
s = "anagram" ‚Üí sorted: "aaagmnr"
t = "nagaram" ‚Üí sorted: "aaagmnr"

Same sorted string? Yes ‚Üí Anagram ‚úì

Time: O(n log n) - not optimal but simple
```

### Visualization

```
s = "listen"
t = "silent"

Frequency comparison:
    l: 1 == 1 ‚úì
    i: 1 == 1 ‚úì
    s: 1 == 1 ‚úì
    t: 1 == 1 ‚úì
    e: 1 == 1 ‚úì
    n: 1 == 1 ‚úì
    
All match ‚Üí Anagram!
```

---

## üíª Code Implementation

### Python - Counter Approach (Cleanest)

```python
from collections import Counter

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        """
        Check if t is an anagram of s using Counter.
        
        Time: O(n) where n = len(s)
        Space: O(1) for 26 lowercase letters
        """
        # Early exit: different lengths can't be anagrams
        if len(s) != len(t):
            return False
        
        return Counter(s) == Counter(t)
```

### Python - Single Counter (Space Efficient)

```python
from collections import Counter

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        """
        Count up for s, count down for t.
        If all zeros at end ‚Üí anagram.
        """
        if len(s) != len(t):
            return False
        
        freq = Counter(s)
        
        for char in t:
            if char not in freq:
                return False
            freq[char] -= 1
            if freq[char] == 0:
                del freq[char]  # Remove zero entries
        
        return len(freq) == 0
```

### Python - Array Approach (For Lowercase Only)

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        """
        Use array of 26 for lowercase letters.
        
        Time: O(n)
        Space: O(26) = O(1)
        """
        if len(s) != len(t):
            return False
        
        count = [0] * 26
        
        for i in range(len(s)):
            count[ord(s[i]) - ord('a')] += 1
            count[ord(t[i]) - ord('a')] -= 1
        
        return all(c == 0 for c in count)
```

### JavaScript - Map Approach

```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    // Early exit
    if (s.length !== t.length) return false;
    
    const freq = new Map();
    
    // Count characters in s
    for (const char of s) {
        freq.set(char, (freq.get(char) || 0) + 1);
    }
    
    // Subtract characters in t
    for (const char of t) {
        if (!freq.has(char)) return false;
        
        freq.set(char, freq.get(char) - 1);
        if (freq.get(char) === 0) {
            freq.delete(char);
        }
    }
    
    return freq.size === 0;
};
```

### JavaScript - Array Approach

```javascript
var isAnagram = function(s, t) {
    if (s.length !== t.length) return false;
    
    const count = new Array(26).fill(0);
    const aCode = 'a'.charCodeAt(0);
    
    for (let i = 0; i < s.length; i++) {
        count[s.charCodeAt(i) - aCode]++;
        count[t.charCodeAt(i) - aCode]--;
    }
    
    return count.every(c => c === 0);
};
```

### JavaScript - Sorting Approach

```javascript
var isAnagram = function(s, t) {
    if (s.length !== t.length) return false;
    
    return s.split('').sort().join('') === t.split('').sort().join('');
};
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Counter comparison | O(n) | O(1)* | *26 letters = constant |
| Single counter | O(n) | O(1)* | Slightly faster in practice |
| Array (26 slots) | O(n) | O(1) | Most efficient for lowercase |
| Sorting | O(n log n) | O(n) | Simple but slower |

**Why O(1) Space for Letters:**
- Only 26 lowercase English letters
- Maximum 26 entries in counter
- O(26) = O(1)

**Follow-up: What if Unicode?**
- Space becomes O(k) where k = unique characters
- Could be O(n) in worst case
- Sorting approach uses O(n) anyway

---

## üîÑ Variations

| Variation | Difference | Link |
|-----------|------------|------|
| Find All Anagrams | Sliding window over string | [LC 438](https://leetcode.com/problems/find-all-anagrams-in-a-string/) |
| Group Anagrams | Group strings by anagram class | [LC 49](https://leetcode.com/problems/group-anagrams/) |
| Valid Anagram (Unicode) | Allow any unicode | Same approach, more space |
| Minimum Deletions | Make anagram by removing chars | Different problem |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Checking Length First

```python
# ‚ùå INEFFICIENT: Counter comparison when lengths differ
def isAnagram(s, t):
    return Counter(s) == Counter(t)  # Builds counters even if lengths differ

# ‚úÖ BETTER: Early exit
def isAnagram(s, t):
    if len(s) != len(t):
        return False
    return Counter(s) == Counter(t)
```

### 2. Case Sensitivity Issues

```python
# ‚ùå WRONG: "Listen" and "Silent" return False
isAnagram("Listen", "Silent")  # False!

# ‚úÖ CORRECT: Normalize if case-insensitive needed
isAnagram(s.lower(), t.lower())
```

### 3. Forgetting Non-Letter Characters

```python
# For problems that include spaces/punctuation
# ‚ùå WRONG: "a b" and "ab " are not considered anagrams
isAnagram("a b", "ab ")  # False

# ‚úÖ CORRECT: Filter to letters only if needed
def isAnagram(s, t):
    s = ''.join(c.lower() for c in s if c.isalpha())
    t = ''.join(c.lower() for c in t if c.isalpha())
    return Counter(s) == Counter(t)
```

### 4. Wrong Array Index Calculation

```python
# ‚ùå WRONG: Index out of bounds for uppercase
count[ord(char) - ord('a')]  # 'A' - 'a' = -32!

# ‚úÖ CORRECT: Ensure lowercase or handle uppercase
count[ord(char.lower()) - ord('a')]
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Link | Notes |
|---------|------------|------|-------|
| Valid Anagram | üü¢ Easy | [LC 242](https://leetcode.com/problems/valid-anagram/) | This problem |
| Find All Anagrams | üü° Medium | [LC 438](https://leetcode.com/problems/find-all-anagrams-in-a-string/) | Sliding window |
| Group Anagrams | üü° Medium | [LC 49](https://leetcode.com/problems/group-anagrams/) | Grouping pattern |
| Permutation in String | üü° Medium | [LC 567](https://leetcode.com/problems/permutation-in-string/) | Similar to LC 438 |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve LC 242 with all three approaches
- **Day 3:** Solve LC 438 (sliding window extension)
- **Day 7:** Solve LC 49 (grouping extension)
- **Day 14:** Should solve LC 242 in < 3 minutes

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interview</strong></summary>

**Clarify:**
> "Are we only dealing with lowercase letters, or could there be uppercase, spaces, or unicode? Should comparisons be case-sensitive?"

**Approach:**
> "Two strings are anagrams if they have the same character frequencies. I'll count characters in both strings and compare. This is O(n) time and O(1) space for lowercase letters."

**Follow-up (Unicode):**
> "For unicode, the approach is the same but space becomes O(k) where k is the number of unique characters, potentially O(n) in the worst case."

**Alternative:**
> "I could also sort both strings and compare - O(n log n) time, O(n) space. The counter approach is more efficient."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common warm-up |
| Google | ‚≠ê‚≠ê‚≠ê | May ask Unicode follow-up |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Quick implementation expected |

---

## ‚è±Ô∏è Time Estimates

| Activity | Target Time |
|----------|-------------|
| Solution | 3-5 min |
| With follow-ups | 7-10 min |
| Expert level | < 3 min |

---

> **üí° Key Insight:** Anagrams have identical character frequencies. Counting transforms the problem from "is this a rearrangement?" to "do these counts match?" - a simple O(n) comparison.

> **üîó Related:** [Frequency Overview](./3.1-Frequency-Overview.md) | [Find All Anagrams](../07-Sliding-Window-Hash/7.3-Find-Anagrams-LC438.md) | [Group Anagrams](../06-Grouping-Pattern/6.2-Group-Anagrams-LC49.md)
