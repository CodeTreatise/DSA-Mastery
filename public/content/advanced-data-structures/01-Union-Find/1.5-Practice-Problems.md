# Union-Find Practice Problems

> **Curated problem set for mastering Union-Find patterns.**
>
> Problems organized by difficulty and pattern, with recommended solving order.

---

## ðŸ“Š Problem Categories

| Category | Count | Focus |
|----------|-------|-------|
| Connected Components | 3 | Basic counting |
| Cycle Detection | 2 | Graph validation |
| Dynamic Connectivity | 2 | Online queries |
| Advanced Applications | 3 | Grouping, weights |

---

## ðŸŸ¢ Easy/Warmup

### 1. Number of Provinces (LC 547)

**Category:** Connected Components  
**Time:** 15-20 min  
**Link:** [LeetCode 547](https://leetcode.com/problems/number-of-provinces/)

**Problem:** Given n cities and a connection matrix, count provinces (connected groups).

**Approach:**
```python
def findCircleNum(isConnected):
    n = len(isConnected)
    uf = UnionFind(n)
    
    for i in range(n):
        for j in range(i + 1, n):
            if isConnected[i][j]:
                uf.union(i, j)
    
    return uf.get_count()
```

**Key Pattern:** Basic component counting with adjacency matrix.

---

### 2. Graph Valid Tree (LC 261)

**Category:** Cycle Detection  
**Time:** 15-20 min  
**Link:** [LeetCode 261](https://leetcode.com/problems/graph-valid-tree/)

**Problem:** Given n nodes and edges, check if it forms a valid tree.

**Key Insight:** Valid tree = n-1 edges + no cycles + all connected.

```python
def validTree(n, edges):
    if len(edges) != n - 1:
        return False
    
    uf = UnionFind(n)
    for u, v in edges:
        if not uf.union(u, v):  # Cycle!
            return False
    
    return True  # n-1 edges + no cycle = all connected
```

---

## ðŸŸ¡ Medium

### 3. Redundant Connection (LC 684)

**Category:** Cycle Detection  
**Time:** 20-25 min  
**Link:** [LeetCode 684](https://leetcode.com/problems/redundant-connection/)

**Problem:** Find the edge that creates a cycle in what should be a tree.

**Pattern:** Union returns False when cycle is detected.

```python
def findRedundantConnection(edges):
    n = len(edges)
    uf = UnionFind(n + 1)  # 1-indexed
    
    for u, v in edges:
        if not uf.union(u, v):
            return [u, v]
    
    return []
```

---

### 4. Accounts Merge (LC 721)

**Category:** Grouping  
**Time:** 25-30 min  
**Link:** [LeetCode 721](https://leetcode.com/problems/accounts-merge/)

**Problem:** Merge accounts that share at least one email.

**Pattern:** Map emails to indices, union same-account emails, group by root.

**Key Steps:**
1. Assign unique index to each email
2. Union all emails in same account
3. Group emails by their root
4. Sort and format output

---

### 5. Number of Operations to Make Network Connected (LC 1319)

**Category:** Component Counting  
**Time:** 20-25 min  
**Link:** [LeetCode 1319](https://leetcode.com/problems/number-of-operations-to-make-network-connected/)

**Problem:** Min operations to connect all computers with n-1 cables.

**Key Insight:** Need (components - 1) cables. Have enough if edges â‰¥ n-1.

```python
def makeConnected(n, connections):
    if len(connections) < n - 1:
        return -1
    
    uf = UnionFind(n)
    for a, b in connections:
        uf.union(a, b)
    
    return uf.get_count() - 1
```

---

### 6. Most Stones Removed with Same Row or Column (LC 947)

**Category:** Component Counting  
**Time:** 25-30 min  
**Link:** [LeetCode 947](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/)

**Problem:** Max stones that can be removed (stones on same row/col are connected).

**Key Insight:** Can remove n - components stones.

**Approach:**
- Map each row to an index (offset to avoid collision with columns)
- Map each column to an index
- Union stone's row index with column index
- Count components, return n - components

---

### 7. Evaluate Division (LC 399)

**Category:** Weighted Union-Find  
**Time:** 30-35 min  
**Link:** [LeetCode 399](https://leetcode.com/problems/evaluate-division/)

**Problem:** Given equations a/b = k, evaluate queries x/y.

**Pattern:** Store weight = ratio to parent, query = weight_x / weight_y.

---

## ðŸ”´ Hard

### 8. Number of Islands II (LC 305)

**Category:** Dynamic Connectivity  
**Time:** 30-35 min  
**Link:** [LeetCode 305](https://leetcode.com/problems/number-of-islands-ii/)

**Problem:** Count islands after each land cell is added.

**Pattern:** Add land (++count), union with neighbors (--count per union).

**Key Points:**
- Handle duplicate positions
- 2D to 1D index conversion
- Check 4 neighbors

---

### 9. Smallest String With Swaps (LC 1202)

**Category:** Grouping + Sorting  
**Time:** 30-35 min  
**Link:** [LeetCode 1202](https://leetcode.com/problems/smallest-string-with-swaps/)

**Problem:** Can swap chars at pairs[i] positions. Return smallest string.

**Key Insight:** All indices in same component can be sorted among themselves.

```python
def smallestStringWithSwaps(s, pairs):
    n = len(s)
    uf = UnionFind(n)
    
    for i, j in pairs:
        uf.union(i, j)
    
    # Group indices by root
    groups = defaultdict(list)
    for i in range(n):
        groups[uf.find(i)].append(i)
    
    # Sort chars within each group
    result = list(s)
    for indices in groups.values():
        chars = sorted(result[i] for i in indices)
        for i, idx in enumerate(sorted(indices)):
            result[idx] = chars[i]
    
    return ''.join(result)
```

---

### 10. Regions Cut By Slashes (LC 959)

**Category:** Creative Union-Find  
**Time:** 35-40 min  
**Link:** [LeetCode 959](https://leetcode.com/problems/regions-cut-by-slashes/)

**Problem:** Grid of slashes/backslashes, count regions.

**Key Insight:** Divide each cell into 4 triangles, union based on cell content.

---

## ðŸ“‹ Recommended Study Order

### Week 1: Fundamentals

| Day | Problem | Pattern |
|-----|---------|---------|
| 1 | Number of Provinces | Basic components |
| 2 | Graph Valid Tree | Cycle detection |
| 3 | Redundant Connection | Find cycle edge |
| 3 | Review Day 1-2 | - |

### Week 2: Applications

| Day | Problem | Pattern |
|-----|---------|---------|
| 4 | Network Connected | Count + check |
| 5 | Most Stones Removed | Creative indexing |
| 6 | Accounts Merge | Grouping |
| 7 | Review Week 1-2 | - |

### Week 3: Advanced

| Day | Problem | Pattern |
|-----|---------|---------|
| 8 | Number of Islands II | Dynamic |
| 9 | Evaluate Division | Weighted |
| 10 | Smallest String Swaps | Sort groups |
| 11 | Regions Cut By Slashes | Creative |
| 12-14 | Mixed practice | All patterns |

---

## ðŸŽ¯ Pattern Quick Reference

| Pattern | When | Example |
|---------|------|---------|
| Basic Count | "How many groups?" | LC 547 |
| Cycle Detection | "Is there a cycle?" | LC 684 |
| Dynamic | "After each addition..." | LC 305 |
| Grouping | "Merge by property..." | LC 721 |
| Weighted | "Given ratios..." | LC 399 |
| Creative Mapping | Non-obvious unions | LC 947, 959 |

---

## â±ï¸ Target Times (Interview)

| Difficulty | Coding Time | Total Time |
|------------|-------------|------------|
| Easy | 10-15 min | 20-25 min |
| Medium | 15-20 min | 30-35 min |
| Hard | 20-25 min | 40-45 min |

---

## ðŸ§  Spaced Repetition Schedule

After solving each problem:

| Day | Activity |
|-----|----------|
| Day 1 | Solve and understand |
| Day 2 | Re-solve without hints |
| Day 4 | Explain approach verbally |
| Day 7 | Solve a similar problem |
| Day 14 | Re-solve original |
| Day 30 | Review if struggled |

---

> **ðŸ’¡ Key Insight:** Most Union-Find problems follow the pattern: (1) identify what elements to union, (2) determine when to union them, (3) extract the answer from the final structure. The creativity is in steps 1 and 2.

> **ðŸ”— Related:** [Union-Find Fundamentals](./1.1-Union-Find-Fundamentals.md) | [Optimizations](./1.3-Optimizations.md)
