# 1.1 Binary Search Tree Definition

## What is a Binary Search Tree?

A **Binary Search Tree (BST)** is a binary tree data structure where each node follows the **BST Property**: for every node, all values in its left subtree are **strictly less than** the node's value, and all values in its right subtree are **strictly greater than** the node's value.

```
        8           ‚Üê Root
       / \
      3   10        ‚Üê 3 < 8, 10 > 8 ‚úì
     / \    \
    1   6    14     ‚Üê 1 < 3, 6 > 3, 14 > 10 ‚úì
       / \   /
      4   7 13      ‚Üê 4 < 6, 7 > 6, 13 < 14 ‚úì
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify BST Problems</strong></summary>

**Look for these signals:**
- Problem mentions "binary search tree" explicitly
- Need O(log n) search, insert, or delete
- Data needs to stay sorted while allowing insertions
- Problem involves finding "k-th smallest/largest"
- Need predecessor/successor relationships

**Keywords in problem statement:**
- "BST", "binary search tree", "sorted tree"
- "search", "insert", "delete" with O(log n)
- "in-order traversal", "sorted order"
- "valid BST", "validate BST"
- "k-th smallest", "range sum"

</details>

---

## ‚úÖ When to Use BST

| Scenario | Why BST Works |
|----------|---------------|
| Dynamic sorted data | Maintains order through insertions/deletions |
| Range queries | Pruning makes range search efficient |
| Floor/ceiling queries |" O(log n) to find closest values "|
| Ordered iteration | Inorder traversal gives sorted sequence |
| Rank queries | Finding k-th element efficiently |

## ‚ùå When NOT to Use BST

| Scenario | Why Not | Better Alternative |
|----------|---------|-------------------|
| Frequent random access by index |" O(n) to reach index k "| Array |
| Fixed dataset, no insertions | Extra overhead | Sorted Array + Binary Search |
|" Need guaranteed O(log n) "| BST can degrade to O(n) | AVL/Red-Black Tree |
| Heavy duplicate handling | Standard BST doesn't handle well | Multiset or modified BST |
| Memory-constrained | Tree nodes have overhead | Array-based heap |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Binary Tree Basics](../../06-Trees/01-Tree-Fundamentals/1.1-Tree-Terminology.md) - Node structure, tree properties
- [Tree Traversals](../../06-Trees/03-Tree-Traversals/3.1-DFS-Traversals/) - Inorder, preorder, postorder
- [Binary Search](../../03-Sorting-Searching.md#binary-search) - The algorithm BST is based on
- [Recursion on Trees](../../06-Trees/01-Tree-Fundamentals/1.4-Recursion-Trees.md)

**After mastering this:**
- [BST Operations](../02-BST-Operations/) - Search, insert, delete
- [BST Validation](../03-BST-Validation/) - Verify BST property
- [Inorder Property](../04-Inorder-Property/) - K-th smallest, iterator

**Combines with:**
- DFS for most BST operations
- Divide & Conquer for construction
- Two Pointers (via inorder) for pair problems

</details>

---

## üìê How It Works

### The BST Property (Formal Definition)

For every node `N` in a BST:
1. **Left Subtree:** All nodes in `N.left` have values `< N.val`
2. **Right Subtree:** All nodes in `N.right` have values `> N.val`
3. Both subtrees must also be valid BSTs (recursive property)

### Why This Property Enables Binary Search

```
Looking for 7 in this BST:

        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13

Step 1: 7 < 8 ‚Üí Go LEFT
Step 2: 7 > 3 ‚Üí Go RIGHT
Step 3: 7 > 6 ‚Üí Go RIGHT
Step 4: 7 == 7 ‚Üí FOUND!

Only 4 comparisons for 8 nodes = O(log n)
```

### Visualization of BST Property

```
              50
            /    \
          30      70
         /  \    /  \
       20   40  60   80

Inorder: 20, 30, 40, 50, 60, 70, 80
         ‚Üë sorted! This is the KEY insight!
```

> **üí° Key Insight:** Inorder traversal of a BST always produces a sorted sequence. This is the foundation for many BST algorithms.

---

## üíª Code Implementation

### BST Node Definition

**Python:**
```python
class TreeNode:
    """BST Node - identical structure to binary tree node."""
    def __init__(self, val: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None):
        self.val = val
        self.left = left
        self.right = right

def is_bst_node(node: TreeNode, min_val: float, max_val: float) -> bool:
    """Check if a single node satisfies BST property within range."""
    if node is None:
        return True
    # Node value must be within valid range
    if node.val <= min_val or node.val >= max_val:
        return False
    return True
```

**JavaScript:**
```javascript
class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

function isBstNode(node, minVal, maxVal) {
    // Check if single node satisfies BST property within range
    if (node === null) return true;
    if (node.val <= minVal || node.val >= maxVal) return false;
    return true;
}
```

### Building a BST from Array

**Python:**
```python
def build_bst(values: list[int]) -> TreeNode:
    """Build BST by inserting values one by one.
    
    Time: O(n log n) average, O(n¬≤) worst case
    Space: O(n) for the tree
    """
    def insert(root: TreeNode, val: int) -> TreeNode:
        if root is None:
            return TreeNode(val)
        
        if val < root.val:
            root.left = insert(root.left, val)
        elif val > root.val:
            root.right = insert(root.right, val)
        # If val == root.val, we skip (no duplicates)
        
        return root
    
    root = None
    for val in values:
        root = insert(root, val)
    return root

# Example usage
values = [8, 3, 10, 1, 6, 14, 4, 7, 13]
root = build_bst(values)
# Creates the BST shown at the top
```

**JavaScript:**
```javascript
function buildBst(values) {
    // Build BST by inserting values one by one
    function insert(root, val) {
        if (root === null) return new TreeNode(val);
        
        if (val < root.val) {
            root.left = insert(root.left, val);
        } else if (val > root.val) {
            root.right = insert(root.right, val);
        }
        // If val === root.val, skip (no duplicates)
        
        return root;
    }
    
    let root = null;
    for (const val of values) {
        root = insert(root, val);
    }
    return root;
}
```

---

## ‚ö° Complexity Analysis

### BST Operations (Average vs Worst Case)

| Operation | Average Case | Worst Case | Worst Happens When |
|-----------|-------------|------------|-------------------|
| Search |" O(log n) "| O(n) | Skewed tree (sorted input) |
| Insert |" O(log n) "| O(n) | Skewed tree |
| Delete |" O(log n) "| O(n) | Skewed tree |
| Min/Max |" O(log n) "| O(n) | Skewed tree |
| Inorder |" O(n) "| O(n) | Always visits all nodes |

### Space Complexity

| Aspect | Complexity | Notes |
|--------|------------|-------|
| Storage |" O(n) "| One node per element |
| Recursive operations |" O(h) "| Stack depth = height |
| Balanced tree |" O(log n) stack "| Height is log n |
| Skewed tree |" O(n) stack "| Height is n |

**Why O(log n) average:**
- Balanced BST has height ‚âà log‚ÇÇ(n)
- Each operation follows ONE path from root to leaf
- Path length = height = O(log n)

**Why O(n) worst case:**
```
Inserting sorted data: [1, 2, 3, 4, 5]

    1
     \
      2
       \
        3
         \
          4
           \
            5

Height = n, not log n!
```

---

## üîÑ Variations

| Variation | Difference | Use Case |
|-----------|------------|----------|
| **AVL Tree** | Self-balancing, height diff ‚â§ 1 |" Guaranteed O(log n) "|
| **Red-Black Tree** | Self-balancing with colors | Standard library maps |
| **B-Tree** | Multiple keys per node | Databases, file systems |
| **Splay Tree** | Recently accessed at root | Caching patterns |
| **Treap** | BST + heap priority | Randomized balancing |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Confusing BST Property with Immediate Children Only

```
‚ùå WRONG understanding: Only check left < node < right

        5
       / \
      3   7
     / \
    1   6  ‚Üê This violates BST! 6 > 5 but in left subtree

‚úÖ CORRECT: ALL nodes in left subtree must be < node
```

### 2. Off-by-One with Equal Values

```python
# ‚ùå Wrong: Using <= allows duplicates in unexpected places
if val <= root.val:
    root.left = insert(root.left, val)

# ‚úÖ Correct: Standard BST has strictly less than
if val < root.val:
    root.left = insert(root.left, val)
elif val > root.val:
    root.right = insert(root.right, val)
# Equal values: decide strategy (skip, replace, or use count)
```

### 3. Forgetting BST Can Degrade to Linked List

```python
# ‚ùå Wrong assumption: "BST search is always O(log n)"
# Reality: Sorted input creates O(n) search

# ‚úÖ Correct: Use balanced BST or randomize input order
import random
values = [1, 2, 3, 4, 5, 6, 7]
random.shuffle(values)  # [4, 2, 6, 1, 3, 5, 7] - more balanced
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)
- [ ] [Search in a BST (LC 700)](https://leetcode.com/problems/search-in-a-binary-search-tree/) - Basic navigation
- [ ] [Range Sum of BST (LC 938)](https://leetcode.com/problems/range-sum-of-bst/) - Pruning with BST property

### Medium (Apply variations)
- [ ] [Validate BST (LC 98)](https://leetcode.com/problems/validate-binary-search-tree/) - Core BST validation
- [ ] [Kth Smallest Element (LC 230)](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) - Inorder property

### Hard (Master edge cases)
- [ ] [Recover BST (LC 99)](https://leetcode.com/problems/recover-binary-search-tree/) - Find swapped nodes

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

After learning BST definition:
- **Day 1:** Draw a BST from random numbers by hand
- **Day 3:** Explain BST property to someone (or rubber duck)
- **Day 7:** Implement BST insert from scratch
- **Day 14:** Solve LC 700 and LC 98 without hints
- **Day 30:** Teach the difference between BST and Binary Tree

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate BST in Interviews</strong></summary>

**When clarifying:**
- "Is this a BST or just a binary tree?" (Critical distinction!)
- "Are there duplicate values? How should I handle them?"
- "Is the BST balanced, or should I consider worst-case O(n)?"

**When explaining approach:**
- "Since this is a BST, I can use the ordering property to..."
- "BST gives us O(log n) search because we eliminate half the tree at each step"
- "The inorder traversal of a BST gives sorted order, so..."

**Red flags to avoid:**
- ‚ùå Treating BST like a regular binary tree (missing optimization)
- ‚ùå Not mentioning O(n) worst case
- ‚ùå Confusing BST property (subtree vs immediate child)

</details>

**Company Focus:**

| Company | Frequency | Common Problems |
|---------|-----------|-----------------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Validate BST, LCA in BST |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | BST operations, k-th smallest |
| Google | ‚≠ê‚≠ê‚≠ê | Often combined with other patterns |
| Meta | ‚≠ê‚≠ê‚≠ê | Inorder iterator, two sum in BST |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn definition | 15-20 min | Understand the property deeply |
| First BST problem | 15-20 min | LC 700 Search |
| Understand edge cases | 20-30 min | Skewed trees, duplicates |
| Master fundamentals | 2-3 hours | Multiple problems |

---

## üí° Key Insight

> **The BST property is really just binary search encoded into a tree structure.** Every left/right decision at a node is equivalent to one step of binary search. This is why BST operations are O(log n) when balanced.

---

## üîó Related

- **Next:** [1.2 BST Properties](./1.2-BST-Properties.md) - Min, max, height characteristics
- **Operations:** [BST Search](../02-BST-Operations/2.1-BST-Search-LC700.md)
- **Validation:** [Validate BST](../03-BST-Validation/3.1-Validate-BST-LC98.md)
- **General Trees:** [Tree Fundamentals](../../06-Trees/01-Tree-Fundamentals/)
