# Binary Indexed Tree (Fenwick Tree) Fundamentals

> **A simpler, space-efficient alternative to Segment Trees for prefix sum operations.**
>
> Half the code, half the memory, same O(log n) complexity for prefix sums.

---

## ðŸŽ¯ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem statement signals:**
- "Prefix sum with updates"
- "Range sum query with point updates"
- "Count of elements less than X"
- Similar to segment tree, but only needs prefix/suffix queries

**BIT vs Segment Tree:**
- BIT: Simpler, prefix queries only
- Segment Tree: More general, arbitrary range queries

</details>

---

## âœ… When to Use

| Scenario | Why BIT |
|----------|---------|
| Prefix sum + point update | Simpler than segment tree |
| Count inversions | Frequency-based prefix query |
| Range sum (via prefix) | sum[L,R] = prefix[R] - prefix[L-1] |
| 2D range sum | 2D BIT is simpler than 2D segment tree |

---

## âŒ When NOT to Use

| Scenario | Better Alternative |
|----------|-------------------|
| Range min/max | Segment Tree |
| Arbitrary range queries | Segment Tree |
| Range updates + range queries | Segment Tree with lazy |
| No updates | Simple prefix sum |

---

## ðŸ“ The Key Insight

### Lowbit (Least Significant Bit)

The magic of BIT is the **lowbit** function:

```python
def lowbit(x):
    return x & (-x)  # Returns rightmost set bit
```

**Examples:**
```
x = 12 = 1100 (binary)
-x = 0100 (two's complement)
x & -x = 0100 = 4

x = 6 = 0110
lowbit(6) = 2

x = 8 = 1000
lowbit(8) = 8
```

### Why This Works

BIT stores partial sums. Each index `i` stores the sum of elements in range `[i - lowbit(i) + 1, i]`.

```
Index:     1    2    3    4    5    6    7    8
lowbit:    1    2    1    4    1    2    1    8
Range:   [1,1][1,2][3,3][1,4][5,5][5,6][7,7][1,8]

Tree visualization:
                    8 (sum of 1-8)
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
           4               8
        â”Œâ”€â”€â”´â”€â”€â”         (already counted)
        2     4            
       â”Œâ”´â”   (already)
       1 2
```

---

## ðŸ’» Implementation

**Python:**
```python
class BIT:
    """
    Binary Indexed Tree (Fenwick Tree).
    
    1-indexed array for cleaner bit operations.
    
    Operations:
    - update(i, delta): Add delta to element i
    - prefix_sum(i): Sum of elements 1 to i
    - range_sum(l, r): Sum of elements l to r
    
    Time: O(log n) for all operations
    Space: O(n)
    """
    
    def __init__(self, n: int):
        """Initialize BIT of size n (1-indexed)."""
        self.n = n
        self.tree = [0] * (n + 1)  # 1-indexed
    
    def update(self, i: int, delta: int) -> None:
        """
        Add delta to element at index i.
        
        Walk up the tree, updating all affected nodes.
        """
        while i <= self.n:
            self.tree[i] += delta
            i += i & (-i)  # Move to parent
    
    def prefix_sum(self, i: int) -> int:
        """
        Return sum of elements from index 1 to i.
        
        Walk down the tree, accumulating partial sums.
        """
        total = 0
        while i > 0:
            total += self.tree[i]
            i -= i & (-i)  # Move to previous range
        return total
    
    def range_sum(self, l: int, r: int) -> int:
        """Return sum of elements from index l to r."""
        return self.prefix_sum(r) - self.prefix_sum(l - 1)


# Build BIT from array
def build_bit(arr):
    """Create BIT from 0-indexed array."""
    n = len(arr)
    bit = BIT(n)
    for i, val in enumerate(arr):
        bit.update(i + 1, val)  # Convert to 1-indexed
    return bit


# Example
arr = [1, 3, 5, 7, 9, 11]
bit = build_bit(arr)

print(bit.prefix_sum(3))   # 1+3+5 = 9
print(bit.prefix_sum(6))   # 1+3+5+7+9+11 = 36
print(bit.range_sum(2, 4)) # 3+5+7 = 15

bit.update(2, 10)          # arr[1] += 10, now [1, 13, 5, 7, 9, 11]
print(bit.prefix_sum(3))   # 1+13+5 = 19
```

**JavaScript:**
```javascript
class BIT {
    constructor(n) {
        this.n = n;
        this.tree = new Array(n + 1).fill(0);
    }
    
    update(i, delta) {
        while (i <= this.n) {
            this.tree[i] += delta;
            i += i & (-i);
        }
    }
    
    prefixSum(i) {
        let total = 0;
        while (i > 0) {
            total += this.tree[i];
            i -= i & (-i);
        }
        return total;
    }
    
    rangeSum(l, r) {
        return this.prefixSum(r) - this.prefixSum(l - 1);
    }
}

// Example
const arr = [1, 3, 5, 7, 9, 11];
const bit = new BIT(arr.length);
arr.forEach((val, i) => bit.update(i + 1, val));

console.log(bit.prefixSum(3));    // 9
console.log(bit.rangeSum(2, 4));  // 15
```

---

## ðŸ” Visualization

### Update Operation

```
Update index 3 with delta = 10

Path: 3 â†’ 4 â†’ 8 â†’ 16 â†’ ...

3 = 011  â†’ add delta to tree[3]
3 + lowbit(3) = 3 + 1 = 4

4 = 100  â†’ add delta to tree[4]
4 + lowbit(4) = 4 + 4 = 8

8 = 1000 â†’ add delta to tree[8]
8 + lowbit(8) = 8 + 8 = 16 (> n, stop)

Updated nodes: [3, 4, 8]
```

### Prefix Sum Operation

```
Prefix sum of index 7

Path: 7 â†’ 6 â†’ 4 â†’ 0

7 = 111  â†’ sum += tree[7] (covers [7,7])
7 - lowbit(7) = 7 - 1 = 6

6 = 110  â†’ sum += tree[6] (covers [5,6])
6 - lowbit(6) = 6 - 2 = 4

4 = 100  â†’ sum += tree[4] (covers [1,4])
4 - lowbit(4) = 4 - 4 = 0 (stop)

Total: tree[7] + tree[6] + tree[4] = elements [1,7]
```

---

## âš¡ Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| Build | O(n log n) | O(n) |
| Update | O(log n) | O(1) |
| Prefix Sum | O(log n) | O(1) |
| Range Sum | O(log n) | O(1) |

**Why O(log n)?**
- At most logâ‚‚(n) bits in any index
- Each operation traverses at most logâ‚‚(n) nodes

---

## ðŸ“Š BIT vs Segment Tree

| Aspect | BIT | Segment Tree |
|--------|-----|--------------|
| Space | n | 4n |
| Code complexity | ~20 lines | ~50 lines |
| Prefix queries | O(log n) | O(log n) |
| Arbitrary range | Need 2 calls | O(log n) |
| Range update | Possible | Easier |
| Range min/max | âŒ | âœ… |
| Debug difficulty | Medium | Easier |

**Rule of thumb:** Use BIT when you only need prefix operations. Use Segment Tree when you need arbitrary range queries or non-invertible operations (min/max).

---

## âš ï¸ Common Mistakes

### 1. Off-by-One (0 vs 1 indexed)

```python
# âŒ Wrong: Using 0-indexed
bit = BIT(n)
bit.update(0, val)  # 0 causes infinite loop!

# âœ… Correct: Use 1-indexed
bit = BIT(n)
bit.update(i + 1, val)  # Convert from 0-indexed
```

### 2. Confusion with Actual Values

```python
# âŒ Wrong: Thinking update sets the value
bit.update(3, 10)  # This ADDS 10, doesn't SET to 10!

# âœ… Correct: To set value, compute delta
old_val = bit.range_sum(3, 3)
bit.update(3, new_val - old_val)  # Add the difference
```

### 3. Wrong Range Sum

```python
# âŒ Wrong: Using wrong formula
def range_sum(l, r):
    return self.prefix_sum(r) - self.prefix_sum(l)  # Off by one!

# âœ… Correct
def range_sum(l, r):
    return self.prefix_sum(r) - self.prefix_sum(l - 1)
```

---

## ðŸ“ Practice Problems

| Problem | Difficulty | Key Insight |
|---------|------------|-------------|
| [Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/) | Medium | Basic BIT |
| [Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/) | Hard | Frequency BIT |
| [Reverse Pairs](https://leetcode.com/problems/reverse-pairs/) | Hard | Modified count |

---

## ðŸŽ¤ Interview Tips

**When to mention BIT:**
> "Since I only need prefix sums with point updates, I'll use a BIT which is simpler than a segment tree."

**Explaining the structure:**
> "Each index i stores the sum of a range ending at i. The range length is determined by the lowest set bit of i."

**Common follow-up - "Why not segment tree?":**
> "Segment tree would work too, but BIT uses less memory and has simpler code for prefix operations."

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Understand concept | 15 min |
| Implement from scratch | 10 min |
| Solve medium problem | 20 min |

---

> **ðŸ’¡ Key Insight:** BIT exploits binary representation brilliantly. The lowbit function naturally creates overlapping ranges that cover exactly the elements we need for any prefix sum, with O(log n) partial sums to combine.

> **ðŸ”— Related:** [BIT Operations â†’](./4.2-BIT-Operations.md) | [BIT vs Segment Tree](./4.3-BIT-vs-Segment-Tree.md)

---

**Next:** [BIT Operations â†’](./4.2-BIT-Operations.md)
