# First Unique Character in a String (LeetCode 387)

> **Count then find - a two-pass frequency pattern for locating unique elements.**

Given a string `s`, find the first non-repeating character in it and return its index. If it does not exist, return `-1`.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem signals:**
- "First" unique/non-repeating element
- Need to maintain original order
- Return position/index, not just value

**This is a two-pass frequency pattern:**
1. First pass: Count all frequencies
2. Second pass: Find first with count = 1

**Why two passes?**
- Can't know if character is unique until we've seen ALL characters
- Must preserve original order for "first"

</details>

---

## ‚úÖ When to Use

- Finding first/last element with specific frequency
- Need to preserve original order
- Frequency information needed before decision

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Streaming data (can't re-scan) | Need single pass | Queue + Map design |
| Don't need position, just value | Simpler | Single pass with early exit |
| Finding ANY unique, not first | Can optimize | Return as soon as freq=1 found |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- [Frequency Overview](./3.1-Frequency-Overview.md) - Counting pattern
- Hash map operations

**After mastering:**
- [First Unique in Stream](https://leetcode.com/problems/first-unique-character-in-a-string/) - Queue + Map design
- [Single Number](https://leetcode.com/problems/single-number/) - XOR approach for numbers

**Combines with:**
- Queue for streaming version
- LinkedHashMap for ordered unique tracking

</details>

---

## üìê How It Works

### Problem Examples

```
Example 1:
Input: s = "leetcode"
Output: 0
Explanation: 'l' is the first non-repeating character

Example 2:
Input: s = "loveleetcode"
Output: 2
Explanation: 'v' is the first non-repeating character

Example 3:
Input: s = "aabb"
Output: -1
Explanation: No non-repeating character exists
```

### Two-Pass Approach

```
s = "leetcode"

Pass 1: Count all characters
        l:1, e:3, t:1, c:1, o:1, d:1

Pass 2: Find first with count = 1
        index 0: 'l' ‚Üí count=1 ‚Üí FOUND!

Answer: 0
```

### Visualization

```
s = "loveleetcode"

Pass 1: Build frequency map
        l:2, o:2, v:1, e:4, t:1, c:1, d:1

Pass 2: Scan for first unique
        index 0: 'l' ‚Üí freq=2 ‚Üí skip
        index 1: 'o' ‚Üí freq=2 ‚Üí skip
        index 2: 'v' ‚Üí freq=1 ‚Üí FOUND!

Answer: 2
```

### Why Can't We Use Single Pass?

```
s = "abab"

Single pass attempt:
        index 0: 'a' seen first time ‚Üí maybe unique?
        index 1: 'b' seen first time ‚Üí maybe unique?
        index 2: 'a' again ‚Üí 'a' is NOT unique
        index 3: 'b' again ‚Üí 'b' is NOT unique

We can't know 'a' is not unique until we see it again later!
```

---

## üíª Code Implementation

### Python - Counter Approach

```python
from collections import Counter

class Solution:
    def firstUniqChar(self, s: str) -> int:
        """
        Find first non-repeating character using Counter.
        
        Time: O(n) - two passes through string
        Space: O(1) - at most 26 lowercase letters
        """
        # Pass 1: Count all characters
        freq = Counter(s)
        
        # Pass 2: Find first with count = 1
        for i, char in enumerate(s):
            if freq[char] == 1:
                return i
        
        return -1
```

### Python - OrderedDict Approach (Single Pass Variant)

```python
from collections import OrderedDict

class Solution:
    def firstUniqChar(self, s: str) -> int:
        """
        Track first occurrence with OrderedDict.
        Still O(n) but slightly more elegant for the logic.
        """
        seen = OrderedDict()  # char ‚Üí (first_index, count)
        
        for i, char in enumerate(s):
            if char in seen:
                seen[char] = (seen[char][0], seen[char][1] + 1)
            else:
                seen[char] = (i, 1)
        
        # Find first with count = 1
        for char, (idx, count) in seen.items():
            if count == 1:
                return idx
        
        return -1
```

### Python - Array Approach (Most Efficient)

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        """
        Use array of 26 for maximum efficiency.
        
        Time: O(n)
        Space: O(26) = O(1)
        """
        count = [0] * 26
        
        # Pass 1: Count frequencies
        for char in s:
            count[ord(char) - ord('a')] += 1
        
        # Pass 2: Find first unique
        for i, char in enumerate(s):
            if count[ord(char) - ord('a')] == 1:
                return i
        
        return -1
```

### JavaScript - Map Approach

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
    const freq = new Map();
    
    // Pass 1: Count all characters
    for (const char of s) {
        freq.set(char, (freq.get(char) || 0) + 1);
    }
    
    // Pass 2: Find first with count = 1
    for (let i = 0; i < s.length; i++) {
        if (freq.get(s[i]) === 1) {
            return i;
        }
    }
    
    return -1;
};
```

### JavaScript - Array Approach

```javascript
var firstUniqChar = function(s) {
    const count = new Array(26).fill(0);
    const aCode = 'a'.charCodeAt(0);
    
    // Pass 1: Count frequencies
    for (const char of s) {
        count[char.charCodeAt(0) - aCode]++;
    }
    
    // Pass 2: Find first unique
    for (let i = 0; i < s.length; i++) {
        if (count[s.charCodeAt(i) - aCode] === 1) {
            return i;
        }
    }
    
    return -1;
};
```

### JavaScript - indexOf/lastIndexOf Trick

```javascript
var firstUniqChar = function(s) {
    // Character is unique if its first and last occurrence are the same
    for (let i = 0; i < s.length; i++) {
        if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
            return i;
        }
    }
    return -1;
};
// Note: This is O(n¬≤) but interesting for understanding
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Counter/Map | O(n) | O(1)* | Two passes, *26 letters |
| Array (26) | O(n) | O(1) | Most cache-friendly |
| indexOf trick | O(n¬≤) | O(1) | Not recommended |

**Breakdown:**
- Pass 1 (counting): O(n)
- Pass 2 (finding): O(n) worst case
- Total: O(n) + O(n) = O(n)

**Space: O(1) because:**
- Only 26 lowercase English letters
- Maximum 26 entries regardless of string length

---

## üîÑ Variations

| Variation | Difference | Approach |
|-----------|------------|----------|
| First unique in stream | Characters arrive one at a time | Queue + Hash Map |
| Last unique character | Find last instead of first | Scan backwards |
| Kth unique character | Find kth non-repeating | Count uniques during pass 2 |
| All unique positions | Return all indices | Collect all with count=1 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Trying Single Pass Without Storage

```python
# ‚ùå WRONG: Single pass can't work for "first"
def firstUniqChar(s):
    for i, char in enumerate(s):
        if s.count(char) == 1:  # O(n) per character!
            return i
    return -1
# This is O(n¬≤)!

# ‚úÖ CORRECT: Two passes, O(n) total
freq = Counter(s)  # O(n)
for i, char in enumerate(s):  # O(n)
    if freq[char] == 1:
        return i
```

### 2. Returning Wrong Index

```python
# ‚ùå WRONG: Returning the character, not index
for char in s:
    if freq[char] == 1:
        return char  # Wrong type!

# ‚úÖ CORRECT: Return the index
for i, char in enumerate(s):
    if freq[char] == 1:
        return i
```

### 3. Not Handling No Unique Character

```python
# ‚ùå WRONG: No return statement for "not found"
def firstUniqChar(s):
    freq = Counter(s)
    for i, char in enumerate(s):
        if freq[char] == 1:
            return i
    # Falls off without return!

# ‚úÖ CORRECT: Explicit return -1
    return -1
```

### 4. Case Sensitivity

```python
# Problem states lowercase, but if uppercase possible:
# ‚ùå WRONG: "aAbB" - 'a' and 'A' counted separately
# ‚úÖ CORRECT: Normalize if needed
s = s.lower()
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Link | Notes |
|---------|------------|------|-------|
| First Unique Character | üü¢ Easy | [LC 387](https://leetcode.com/problems/first-unique-character-in-a-string/) | This problem |
| Single Number | üü¢ Easy | [LC 136](https://leetcode.com/problems/single-number/) | XOR variant |
| First Unique Number | üü° Medium | [LC 1429](https://leetcode.com/problems/first-unique-number/) | Streaming version |
| Sort Characters by Frequency | üü° Medium | [LC 451](https://leetcode.com/problems/sort-characters-by-frequency/) | Uses frequency |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve LC 387 with Counter approach
- **Day 3:** Solve with array approach
- **Day 7:** Solve LC 136 (Single Number) to see XOR trick
- **Day 14:** Try LC 1429 (streaming version)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interview</strong></summary>

**Clarify:**
> "Just to confirm - we're looking at lowercase English letters only? And we need the index, not the character itself?"

**Approach:**
> "I'll use two passes. First, count all character frequencies. Then, scan the string again and return the index of the first character with count 1. This is O(n) time and O(1) space since we have at most 26 letters."

**Why two passes:**
> "We need two passes because we can't know a character is unique until we've seen the entire string. The first 'a' might repeat later."

**Space optimization:**
> "I could use an array of 26 instead of a hash map for better cache locality, but the complexity is the same."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common easy problem |
| Google | ‚≠ê‚≠ê‚≠ê | May ask streaming follow-up |
| Bloomberg | ‚≠ê‚≠ê‚≠ê‚≠ê | Frequent in interviews |

---

## ‚è±Ô∏è Time Estimates

| Activity | Target Time |
|----------|-------------|
| Solution | 3-5 min |
| With follow-ups | 8-10 min |
| Expert level | < 3 min |

---

> **üí° Key Insight:** "First" requires seeing all elements first. The two-pass pattern (count everything, then scan for first match) is a common technique when you need global information before making local decisions.

> **üîó Related:** [Frequency Overview](./3.1-Frequency-Overview.md) | [Single Number](https://leetcode.com/problems/single-number/) | [Sort by Frequency](https://leetcode.com/problems/sort-characters-by-frequency/)
