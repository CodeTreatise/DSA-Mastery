# 5.2 Range Sum of BST (LC 938)

## Problem Statement

[LeetCode 938 - Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/)

Given the root of a BST and two integers `low` and `high`, return the sum of values of all nodes with a value in the inclusive range [low, high].

```
Input: root = [10,5,15,3,7,null,18], low = 7, high = 15
        10
       /  \
      5    15
     / \     \
    3   7    18

Output: 32 (7 + 10 + 15 = 32)
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a Range DFS problem:**
- BST with range query
- Sum (or count/collect) nodes in [low, high]
- Can prune subtrees outside range

**Keywords:**
- "sum of values in range"
- "between low and high"
- "BST" + "range query"

**Pattern:** DFS with pruning based on BST property.

</details>

---

## ‚úÖ When to Use

- Range-based aggregation on BST (sum, count, etc.)
- When BST structure allows pruning
- Values need to fall within [low, high]

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| General tree | No ordering |" Full traversal O(n) "|
| Range by index | BST orders by value | Inorder + slice |
| Frequent updates |" O(h+k) each time "| Segment tree |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
- [Range Problems Overview](./5.1-Range-Sum-Overview.md)
- Basic DFS traversal

**After mastering this:**
- [Trim BST (LC 669)](../03-BST-Validation/3.3-Trim-BST-LC669.md) - Modify tree based on range
- More complex range queries

**Combines with:**
- DFS traversal
- BST pruning

</details>

---

## üìê How It Works

### The Key Insight

```
BST property allows intelligent pruning:

        10
       /  \
      5    15
     / \     \
    3   7    18

For range [7, 15]:

At 10: 7 ‚â§ 10 ‚â§ 15 ‚Üí ADD 10, explore both
At 5:  5 < 7 ‚Üí Don't add, but check right (might have 7+)
At 3:  3 < 7 ‚Üí Don't add, don't check left (all smaller)
At 7:  7 ‚â§ 7 ‚â§ 15 ‚Üí ADD 7
At 15: 7 ‚â§ 15 ‚â§ 15 ‚Üí ADD 15, don't check right (all larger)
At 18: Not visited! (pruned)

Sum = 10 + 7 + 15 = 32
```

### Visualization

```
Range [7, 15]:

        10          ‚Üê In range: ADD (10)
       /  \
      5    15       ‚Üê 5 < 7: skip value, check right
     / \     \         15 in range: ADD (15), prune right
    3   7    18     ‚Üê 3 < 7: prune, 7 in range: ADD (7)
                       18 > 15: pruned (never visited!)

Visited: 10, 5, 3, 7, 15 (not 18)
Added: 10, 7, 15 = 32
```

---

## üíª Code Implementation

### Recursive (Clean)

**Python:**
```python
def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:
    """
    Sum all node values in [low, high].
    
    Time: O(h + k) where k = nodes in range
    Space: O(h) recursion stack
    
    Pattern: Range DFS with pruning
    """
    if not root:
        return 0
    
    # Current value in range?
    if root.val < low:
        # Too small: only right subtree might have values in range
        return self.rangeSumBST(root.right, low, high)
    
    if root.val > high:
        # Too large: only left subtree might have values in range
        return self.rangeSumBST(root.left, low, high)
    
    # In range: include current, explore both subtrees
    return (root.val + 
            self.rangeSumBST(root.left, low, high) +
            self.rangeSumBST(root.right, low, high))
```

**JavaScript:**
```javascript
var rangeSumBST = function(root, low, high) {
    // Range DFS with pruning
    if (!root) return 0;
    
    if (root.val < low) {
        // Too small, go right
        return rangeSumBST(root.right, low, high);
    }
    
    if (root.val > high) {
        // Too large, go left
        return rangeSumBST(root.left, low, high);
    }
    
    // In range
    return root.val + 
           rangeSumBST(root.left, low, high) + 
           rangeSumBST(root.right, low, high);
};
```

### Alternative: Single Pass with Conditionals

**Python:**
```python
def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:
    """Alternative formulation with explicit conditionals."""
    if not root:
        return 0
    
    total = 0
    
    # Add current if in range
    if low <= root.val <= high:
        total += root.val
    
    # Explore left if might have values in range
    if root.val > low:
        total += self.rangeSumBST(root.left, low, high)
    
    # Explore right if might have values in range
    if root.val < high:
        total += self.rangeSumBST(root.right, low, high)
    
    return total
```

### Iterative (Stack-based)

**Python:**
```python
def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:
    """
    Iterative DFS with explicit stack.
    
    Time: O(h + k), Space: O(h)
    """
    if not root:
        return 0
    
    total = 0
    stack = [root]
    
    while stack:
        node = stack.pop()
        
        if low <= node.val <= high:
            total += node.val
        
        # Prune intelligently
        if node.left and node.val > low:
            stack.append(node.left)
        
        if node.right and node.val < high:
            stack.append(node.right)
    
    return total
```

**JavaScript:**
```javascript
var rangeSumBST = function(root, low, high) {
    // Iterative with stack
    if (!root) return 0;
    
    let total = 0;
    const stack = [root];
    
    while (stack.length > 0) {
        const node = stack.pop();
        
        if (low <= node.val && node.val <= high) {
            total += node.val;
        }
        
        if (node.left && node.val > low) {
            stack.push(node.left);
        }
        
        if (node.right && node.val < high) {
            stack.push(node.right);
        }
    }
    
    return total;
};
```

### Iterative (Queue-based BFS)

**Python:**
```python
from collections import deque

def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:
    """BFS approach with pruning."""
    if not root:
        return 0
    
    total = 0
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        
        if low <= node.val <= high:
            total += node.val
        
        if node.left and node.val > low:
            queue.append(node.left)
        
        if node.right and node.val < high:
            queue.append(node.right)
    
    return total
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Best |" O(h) "| O(h) | No nodes in range |
| Average |" O(h + k) "| O(h) | k nodes in range |
| Worst |" O(n) "| O(h) | All nodes in range |

**Why O(h + k):**
- O(h): Navigate down to find first in-range node
- O(k): Visit exactly k nodes that are in range
- Pruning skips subtrees outside range

**Comparison with brute force:**
- Brute force: O(n) always
- Range DFS: O(h + k) ‚Äî much better when k << n

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **Range Count** | Count instead of sum | `count += 1` |
| **Range Collect** | Collect to list | `result.append(node.val)` |
| **Range Max/Min** | Track extreme in range | Update max/min variable |
| **Range Average** | Sum and count | Combine sum and count |

### Range Count

```python
def rangeCount(root: TreeNode, low: int, high: int) -> int:
    """Count nodes in [low, high]."""
    if not root:
        return 0
    
    if root.val < low:
        return rangeCount(root.right, low, high)
    if root.val > high:
        return rangeCount(root.left, low, high)
    
    return (1 + 
            rangeCount(root.left, low, high) + 
            rangeCount(root.right, low, high))
```

### Range Collect (Inorder for Sorted Output)

```python
def rangeCollect(root: TreeNode, low: int, high: int) -> list[int]:
    """Collect values in [low, high] in sorted order."""
    result = []
    
    def inorder(node):
        if not node:
            return
        
        if node.val > low:
            inorder(node.left)
        
        if low <= node.val <= high:
            result.append(node.val)
        
        if node.val < high:
            inorder(node.right)
    
    inorder(root)
    return result
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Pruning Correctly

```python
# ‚ùå Wrong: Always explores both subtrees (O(n) always)
def rangeSumBST(root, low, high):
    if not root:
        return 0
    
    total = 0
    if low <= root.val <= high:
        total += root.val
    
    # Explores EVERYTHING - no pruning!
    total += rangeSumBST(root.left, low, high)
    total += rangeSumBST(root.right, low, high)
    return total

# ‚úÖ Correct: Prune based on value
def rangeSumBST(root, low, high):
    if not root:
        return 0
    
    if root.val < low:
        return rangeSumBST(root.right, low, high)  # Prune left
    if root.val > high:
        return rangeSumBST(root.left, low, high)   # Prune right
    
    return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high)
```

### 2. Wrong Pruning Direction

```python
# ‚ùå Wrong: Goes left when value is too small (should go right!)
if root.val < low:
    return rangeSumBST(root.left, low, high)  # WRONG!

# ‚úÖ Correct: Go right to find larger values
if root.val < low:
    return rangeSumBST(root.right, low, high)
```

### 3. Off-by-One in Range Check

```python
# ‚ùå Wrong: Exclusive range (misses boundary values)
if low < root.val < high:  # Misses low and high!
    total += root.val

# ‚úÖ Correct: Inclusive range
if low <= root.val <= high:
    total += root.val
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn pattern)
- [ ] [Range Sum of BST (LC 938)](https://leetcode.com/problems/range-sum-of-bst/) - This problem

### Medium (Apply pattern)
- [ ] [Trim BST (LC 669)](https://leetcode.com/problems/trim-a-binary-search-tree/) - Modify tree by range
- [ ] [Closest BST Value II (LC 272)](https://leetcode.com/problems/closest-binary-search-tree-value-ii/) - K closest values

### Hard (Master)
- [ ] Build efficient data structure for frequent range queries

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement recursive solution
- **Day 3:** Implement iterative solution
- **Day 7:** Trace through with example
- **Day 14:** Apply to range count/collect
- **Day 30:** Solve without looking

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"I'll use DFS with pruning. Since this is a BST, I can skip entire subtrees that can't contain values in range. If current value is below low, I only need to check right. If above high, only check left."

**Key points:**
1. "BST ordering enables pruning"
2. "Time is O(h + k), not O(n)"
3. "K is the number of nodes actually in range"

**Common follow-ups:**
- "Can you do it iteratively?" ‚Üí Yes, with stack
- "What if this is called frequently?" ‚Üí Preprocess with range tree or segment tree

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Easy warm-up |
| Meta | ‚≠ê‚≠ê‚≠ê | Tests BST basics |
| Google | ‚≠ê‚≠ê | Often follow-up |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Common question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Clear requirements |
| Code recursive | 5-7 min | Short solution |
| Code iterative | 8-10 min | Stack-based |
| Discuss complexity | 2-3 min |" Explain O(h+k) "|
| Total interview time | 15-20 min | Easy difficulty |

---

## üí° Key Insight

> **BST turns O(n) traversal into O(h+k) range query.** By pruning subtrees outside [low, high], we only visit nodes that might be in range. This is the power of ordered data structures ‚Äî they enable intelligent search space reduction.

---

## üîó Related

- **Previous:** [Range Problems Overview](./5.1-Range-Sum-Overview.md)
- **Related:** [Trim BST (LC 669)](../03-BST-Validation/3.3-Trim-BST-LC669.md)
- **Foundation:** [BST Search (LC 700)](../02-BST-Operations/2.1-BST-Search-LC700.md)
- **Advanced:** Segment Trees for dynamic range queries
