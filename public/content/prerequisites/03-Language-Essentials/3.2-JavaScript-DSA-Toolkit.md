# 3.2 JavaScript DSA Toolkit

> **JavaScript's built-in data structures and idioms that every competitive solver must know â€” and the traps that catch even experienced developers.**
>
> â±ï¸ *Estimated reading: 25 minutes*

---

## ğŸ¯ Why This Matters

JavaScript is the world's most popular language, but its standard library is thinner than Python's for DSA. You need to know what's built-in, what's missing, and the critical workarounds.

| Feature | Python | JavaScript | Impact |
|---------|--------|------------|--------|
| Hash Map | `dict` | `Map` âœ… | Use `Map` over plain objects |
| Hash Set | `set` | `Set` âœ… | O(1) lookup |
| Heap | `heapq` âœ… | âŒ None | Must implement yourself |
| Deque | `collections.deque` | âŒ None | Use array (or implement) |
| Sorted Container | `bisect` | âŒ None | Must implement yourself |
| Memoization | `lru_cache` | Manual | Closures or Map-based |

---

## ğŸ“¦ 1. `Map` â€” Ordered Hash Map

### What It Does

Key-value store that accepts **any** type as key (not just strings) and preserves insertion order.

### Why Not Just Use `{}`?

| Feature | Plain Object `{}` | `Map` |
|---------|-------------------|-------|
| Key types | Strings/Symbols only | **Any type** (objects, arrays, functions) |
| Key order | Not guaranteed (mostly) | **Insertion order guaranteed** |
| Size | `Object.keys(obj).length` | `map.size` â€” O(1) |
| Iteration | `for...in` (includes prototype) | `for...of` â€” clean |
| Performance | Slower for frequent add/delete | **Optimized for frequent changes** |

### Code

```javascript
// Create and populate
const map = new Map();
map.set('key1', 'value1');
map.set(42, 'number key');     // Numbers as keys!
map.set([1,2], 'array key');   // Arrays as keys!

// Access
map.get('key1');         // 'value1'
map.has('key1');         // true
map.size;                // 3

// Delete
map.delete('key1');      // true (was found and deleted)

// Iterate (preserves insertion order!)
for (const [key, value] of map) {
    console.log(key, value);
}

// Convert to array
const entries = [...map];            // [[key1, val1], [key2, val2], ...]
const keys = [...map.keys()];
const values = [...map.values()];

// Initialize from array of pairs
const map2 = new Map([['a', 1], ['b', 2], ['c', 3]]);
```

### DSA Use Cases

| Problem | How Map Helps |
|---------|--------------|
| **Two Sum** (LC 1) | `map.set(num, index)` â€” store valueâ†’index |
| **LRU Cache** (LC 146) | Map preserves insertion order + `.delete()` + re-`.set()` |
| **Group Anagrams** (LC 49) | Sorted string as key |
| **Subarray Sum Equals K** (LC 560) | Prefix sum â†’ count map |
| **First Unique Character** (LC 387) | Character â†’ count map |

### LRU Cache with Map (LC 146)

```javascript
class LRUCache {
    constructor(capacity) {
        this.cap = capacity;
        this.cache = new Map();
    }

    get(key) {
        if (!this.cache.has(key)) return -1;
        const val = this.cache.get(key);
        // Move to end (most recently used)
        this.cache.delete(key);
        this.cache.set(key, val);
        return val;
    }

    put(key, value) {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        }
        this.cache.set(key, value);
        if (this.cache.size > this.cap) {
            // Delete FIRST key (least recently used)
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
    }
}
```

### âš ï¸ Pitfalls

```javascript
// âš ï¸ Object keys are coerced to strings
const obj = {};
obj[1] = 'one';
obj['1'] = 'string one';
console.log(obj[1]);      // 'string one' â€” key 1 was overwritten!

// âœ… Map keeps types separate
const map = new Map();
map.set(1, 'one');
map.set('1', 'string one');
map.get(1);               // 'one' â€” different key!
map.get('1');              // 'string one'
```

---

## ğŸ“¦ 2. `Set` â€” Hash Set

### What It Does

Collection of unique values with O(1) add, delete, and lookup.

### Code

```javascript
// Create
const set = new Set([1, 2, 3, 2, 1]);  // Set {1, 2, 3} â€” auto-deduped

// O(1) operations
set.add(4);           // Set {1, 2, 3, 4}
set.has(3);           // true
set.delete(2);        // true
set.size;             // 3

// Iterate
for (const val of set) {
    console.log(val);
}

// Convert to array
const arr = [...set];

// Set operations (manual â€” JS doesn't have built-in union/intersection)
const a = new Set([1, 2, 3]);
const b = new Set([2, 3, 4]);

// Union
const union = new Set([...a, ...b]);           // {1, 2, 3, 4}

// Intersection
const inter = new Set([...a].filter(x => b.has(x)));  // {2, 3}

// Difference
const diff = new Set([...a].filter(x => !b.has(x)));  // {1}
```

### DSA Use Cases

| Problem | How Set Helps |
|---------|--------------|
| **Contains Duplicate** (LC 217) | `new Set(nums).size !== nums.length` |
| **Longest Consecutive Sequence** (LC 128) | Set for O(1) lookup of neighbors |
| **Happy Number** (LC 202) | Detect cycles with seen set |
| **Valid Sudoku** (LC 36) | Track seen values per row/col/box |
| **Intersection of Two Arrays** (LC 349) | Set intersection |

### LC 128: Longest Consecutive Sequence

```javascript
function longestConsecutive(nums) {
    const set = new Set(nums);
    let maxLen = 0;

    for (const num of set) {
        // Only start counting from sequence starts
        if (!set.has(num - 1)) {
            let current = num;
            let len = 1;
            while (set.has(current + 1)) {
                current++;
                len++;
            }
            maxLen = Math.max(maxLen, len);
        }
    }
    return maxLen;
}
```

---

## ğŸ“¦ 3. `Math` Object â€” Essential Methods

### Code

```javascript
// Min / Max
Math.max(1, 2, 3);           // 3
Math.min(1, 2, 3);           // 1

// âš ï¸ With arrays â€” must spread
Math.max(...arr);             // Works
Math.max(arr);                // NaN â€” doesn't work!

// âš ï¸ Empty array gotcha
Math.max(...[]);              // -Infinity
Math.min(...[]);              // Infinity

// Rounding
Math.floor(3.8);              // 3
Math.ceil(3.2);               // 4
Math.round(3.5);              // 4
Math.trunc(-3.8);             // -3 (truncate toward zero)

// Binary search midpoint â€” ALWAYS use floor
const mid = Math.floor((left + right) / 2);
// Or: const mid = (left + right) >> 1;  // Bitwise floor (faster)

// Absolute value
Math.abs(-5);                 // 5

// Square root
Math.sqrt(16);                // 4

// Power
Math.pow(2, 10);              // 1024
// Or: 2 ** 10;               // 1024 (ES2016)

// Logarithms
Math.log2(1024);              // 10
Math.log10(1000);             // 3

// Random integer in range [min, max]
Math.floor(Math.random() * (max - min + 1)) + min;
```

### Infinity

```javascript
// Use for initializing min/max trackers
let minVal = Infinity;
let maxVal = -Infinity;

for (const num of nums) {
    minVal = Math.min(minVal, num);
    maxVal = Math.max(maxVal, num);
}

// Comparisons
Infinity > 1000000;            // true
-Infinity < -1000000;          // true
Infinity + 1 === Infinity;     // true
```

---

## ğŸ“¦ 4. String Operations for DSA

### `charCodeAt()` â€” Character â†’ Number

```javascript
// Get ASCII code
'a'.charCodeAt(0);             // 97
'z'.charCodeAt(0);             // 122
'A'.charCodeAt(0);             // 65

// Character frequency array (26 letters)
function charFrequency(s) {
    const freq = new Array(26).fill(0);
    for (const c of s) {
        freq[c.charCodeAt(0) - 97]++;  // 'a' = index 0
    }
    return freq;
}

// Check if two strings are anagrams
function isAnagram(s, t) {
    if (s.length !== t.length) return false;
    const freq = new Array(26).fill(0);
    for (let i = 0; i < s.length; i++) {
        freq[s.charCodeAt(i) - 97]++;
        freq[t.charCodeAt(i) - 97]--;
    }
    return freq.every(f => f === 0);
}
```

### `String.fromCharCode()` â€” Number â†’ Character

```javascript
String.fromCharCode(97);       // 'a'
String.fromCharCode(65);       // 'A'

// Generate 'a' to 'z'
const alphabet = Array.from({length: 26}, (_, i) => String.fromCharCode(97 + i));
```

### String Immutability

```javascript
// âš ï¸ Strings are IMMUTABLE in JavaScript
let s = "hello";
s[0] = 'H';                   // Silently fails!
console.log(s);                // "hello" â€” unchanged

// âœ… Convert to array, modify, convert back
const arr = s.split('');
arr[0] = 'H';
s = arr.join('');              // "Hello"

// âš ï¸ String concatenation in a loop is O(nÂ²)
// âŒ Slow
let result = '';
for (const c of chars) {
    result += c;               // Creates new string each time
}

// âœ… Fast â€” join array
const parts = [];
for (const c of chars) {
    parts.push(c);
}
const result2 = parts.join('');
```

---

## ğŸ“¦ 5. Array Techniques for DSA

### Destructuring Swap

```javascript
// Swap without temp variable
[arr[i], arr[j]] = [arr[j], arr[i]];

// Multiple assignment
const [first, second, ...rest] = [1, 2, 3, 4, 5];
// first=1, second=2, rest=[3,4,5]
```

### 2D Array Initialization

```javascript
// âœ… Correct â€” each row is a separate array
const grid = Array.from({length: rows}, () => new Array(cols).fill(0));

// âŒ WRONG â€” all rows share same reference!
const bad = new Array(rows).fill(new Array(cols).fill(0));
bad[0][0] = 1;  // Changes ALL rows!

// Alternative (also correct)
const grid2 = Array.from({length: rows}, () => Array(cols).fill(0));
```

### `Array.from()` Patterns

```javascript
// Create array with indices
Array.from({length: 5}, (_, i) => i);          // [0, 1, 2, 3, 4]

// Create 2D array
Array.from({length: 3}, () => []);              // [[], [], []]

// Create array from string
Array.from("hello");                            // ['h', 'e', 'l', 'l', 'o']

// Create range [start, end)
const range = (start, end) => Array.from({length: end - start}, (_, i) => start + i);
range(3, 7);                                    // [3, 4, 5, 6]
```

### Useful Array Methods

```javascript
// Fill with value
new Array(10).fill(0);                          // [0, 0, 0, ..., 0]
new Array(10).fill(false);                      // [false, false, ...]

// Find index of element
arr.indexOf(target);                            // First index, or -1
arr.lastIndexOf(target);                        // Last index, or -1

// Check if element exists
arr.includes(target);                           // true/false

// Reduce â€” sum, max, etc.
arr.reduce((sum, val) => sum + val, 0);         // Sum
arr.reduce((max, val) => Math.max(max, val), -Infinity);  // Max

// Flat â€” flatten nested arrays
[[1,2], [3,4], [5]].flat();                     // [1, 2, 3, 4, 5]
[[1,[2]], [3,[4]]].flat(Infinity);              // [1, 2, 3, 4]

// Slice vs Splice
arr.slice(1, 3);     // Returns new array [index 1, 2] â€” DOES NOT modify
arr.splice(1, 2);    // Removes 2 elements starting at index 1 â€” MODIFIES arr
```

---

## ğŸ“¦ 6. Missing Data Structures (Implement Yourself)

JavaScript lacks several critical DSA structures. Here are minimal implementations:

### Min-Heap (Priority Queue)

```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }

    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }

    pop() {
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._sinkDown(0);
        }
        return min;
    }

    peek() { return this.heap[0]; }
    size() { return this.heap.length; }

    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.heap[parent] <= this.heap[i]) break;
            [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
            i = parent;
        }
    }

    _sinkDown(i) {
        const n = this.heap.length;
        while (true) {
            let smallest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;
            if (left < n && this.heap[left] < this.heap[smallest]) smallest = left;
            if (right < n && this.heap[right] < this.heap[smallest]) smallest = right;
            if (smallest === i) break;
            [this.heap[smallest], this.heap[i]] = [this.heap[i], this.heap[smallest]];
            i = smallest;
        }
    }
}

// Usage
const heap = new MinHeap();
heap.push(5);
heap.push(1);
heap.push(3);
heap.pop();    // 1
heap.peek();   // 3
```

### Memoization Helper

```javascript
// Generic memoize function
function memoize(fn) {
    const cache = new Map();
    return function(...args) {
        const key = JSON.stringify(args);
        if (cache.has(key)) return cache.get(key);
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    };
}

// Usage â€” Fibonacci
const fib = memoize(function(n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
});

// For LeetCode DP â€” often use Map directly
function coinChange(coins, amount) {
    const memo = new Map();
    function dp(remaining) {
        if (remaining === 0) return 0;
        if (remaining < 0) return Infinity;
        if (memo.has(remaining)) return memo.get(remaining);

        let minCoins = Infinity;
        for (const coin of coins) {
            minCoins = Math.min(minCoins, dp(remaining - coin) + 1);
        }
        memo.set(remaining, minCoins);
        return minCoins;
    }
    const result = dp(amount);
    return result === Infinity ? -1 : result;
}
```

---

## ğŸ“¦ 7. Iteration Patterns

### `for...of` vs `for...in`

```javascript
// âœ… for...of â€” iterate VALUES (arrays, strings, maps, sets)
for (const val of [1, 2, 3]) { }
for (const char of "hello") { }
for (const [key, val] of map) { }

// âš ï¸ for...in â€” iterate KEYS (and prototype chain!)
// Only use for objects, NEVER for arrays
for (const key in obj) {
    if (obj.hasOwnProperty(key)) {  // Filter prototype
        console.log(key, obj[key]);
    }
}
```

### `entries()` â€” Get Index + Value

```javascript
// Like Python's enumerate()
const arr = ['a', 'b', 'c'];
for (const [i, val] of arr.entries()) {
    console.log(i, val);  // 0 'a', 1 'b', 2 'c'
}
```

---

## â±ï¸ Complexity Reference

| Operation | Time | Notes |
|-----------|------|-------|
| `Map.set/get/has/delete` | O(1) avg | Hash-based |
| `Set.add/has/delete` | O(1) avg | Hash-based |
| `Array.push/pop` | O(1) | End operations |
| `Array.shift/unshift` | O(n) | âŒ Start operations â€” avoid for BFS |
| `Array.splice` | O(n) | Middle operations |
| `Array.indexOf/includes` | O(n) | Linear scan |
| `Array.sort` | O(n log n) | âš ï¸ Lexicographic by default! |
| `String + concatenation` | O(n) per concat | âŒ In loop = O(nÂ²) |
| `Array.join('')` | O(n) | âœ… Use for string building |

---

## ğŸ“ Practice Checklist

| Problem | JS Feature to Practice | Difficulty |
|---------|----------------------|------------|
| [Two Sum (LC 1)](https://leetcode.com/problems/two-sum/) | Map | Easy |
| [Contains Duplicate (LC 217)](https://leetcode.com/problems/contains-duplicate/) | Set | Easy |
| [Valid Anagram (LC 242)](https://leetcode.com/problems/valid-anagram/) | charCodeAt, Array(26) | Easy |
| [Longest Consecutive (LC 128)](https://leetcode.com/problems/longest-consecutive-sequence/) | Set | Medium |
| [Group Anagrams (LC 49)](https://leetcode.com/problems/group-anagrams/) | Map | Medium |
| [LRU Cache (LC 146)](https://leetcode.com/problems/lru-cache/) | Map (ordered) | Medium |
| [Subarray Sum = K (LC 560)](https://leetcode.com/problems/subarray-sum-equals-k/) | Map (prefix sum) | Medium |
| [Top K Frequent (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/) | Map + custom heap | Medium |

---

> **ğŸ’¡ Key Insight:** JavaScript's biggest DSA gaps are heap and deque. Know how to implement a MinHeap from memory â€” it comes up in Top K, Dijkstra, and Merge K problems. For everything else, `Map` and `Set` are your best friends.

---

â† [3.1 Python DSA Toolkit](./3.1-Python-DSA-Toolkit.md) | **Next:** [3.3 Sorting Pitfalls](./3.3-Sorting-Pitfalls-Both-Languages.md) â†’
