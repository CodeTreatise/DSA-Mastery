# 3.1 Circular Linked List - Complete Guide

> **Variation:** Last node points back to first, forming a cycle
>
> â±ï¸ Estimated Learning Time: 30-45 minutes

---

## Overview

A **Circular Linked List** is a linked list where the last node points back to the first node instead of null, forming a continuous loop. This structure is useful when you need to cycle through elements repeatedly.

### Singly Circular Linked List

```
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â†“                               â”‚
   [1] â†’ [2] â†’ [3] â†’ [4] â†’ [5] â”€â”€â”€â”€â”€â”˜
    â†‘
   head
```

### Doubly Circular Linked List

```
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â†“                                       â”‚
   [1] â‡„ [2] â‡„ [3] â‡„ [4] â‡„ [5] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†‘                       â†“
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>When Circular Lists Are Useful</strong></summary>

| Signal | Why Circular? | Example |
|--------|---------------|---------|
| Need to cycle through repeatedly | Natural looping | Round-robin scheduler |
| No clear "beginning" or "end" | All nodes equal | Circular buffer |
| Continuous processing | Return to start | Music playlist repeat |
| Games with turns | Cycle through players | Multiplayer games |
| Circular queue | Efficient wrap-around | Task scheduling |

</details>

---

## âœ… When to Use Circular Linked List

- **Round-robin scheduling** - Each process gets fair time slice
- **Circular buffers** - Audio/video streaming
- **Multiplayer games** - Turn rotation
- **Repeating playlists** - Music/video loops
- **Josephus problem** - Elimination game algorithm
- **Clock/timer implementations** - Circular nature of time

---

## âŒ When NOT to Use

| Use Case | Why Not | Use Instead |
|----------|---------|-------------|
| Need clear termination | Infinite loop risk | Regular linked list |
| Simple linear data | Unnecessary complexity | Singly LL |
| Random access needed |" Still O(n) traversal "| Array or hash map |
| Memory is critical | Same as regular LL | Array |
| Rarely need cycling | Overhead not worth it | Regular LL |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Singly Linked List](../01-Singly-LL/1.1-Basics.md)
- [Doubly Linked List](../02-Doubly-LL/2.1-Doubly-LL-Complete.md)

**After mastering this:**
- Implement circular buffer
- Josephus problem solution
- Round-robin scheduler

**Related patterns:**
- [Cycle Detection](../04-Fast-Slow-Pointer/4.2-Cycle-Problems/01-Cycle-Detection.md) - Detect accidental cycles

</details>

---

## ğŸ“ How It Works

### Key Insight

In a circular list, there's no null terminator. The "last" node points to the "first":

```
Regular LL:    [1] â†’ [2] â†’ [3] â†’ null
Circular LL:   [1] â†’ [2] â†’ [3] â†’ (back to [1])
```

**Traversal difference:**
- Regular: `while current is not null`
- Circular: `while current is not head` (after first move)

---

## ğŸ’» Singly Circular Linked List

### Node Structure (Same as Singly LL)

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

### Complete Implementation

**Python:**

```python
class CircularLinkedList:
    """Singly Circular Linked List."""
    
    def __init__(self):
        self.head = None
        self.size = 0
    
    def __len__(self):
        return self.size
    
    def is_empty(self):
        return self.head is None
    
    def insert_at_head(self, val):
        """
        Insert at the beginning.
        Time: O(n) for singly circular (need to update tail.next)
        """
        new_node = ListNode(val)
        
        if self.is_empty():
            new_node.next = new_node  # Points to itself
            self.head = new_node
        else:
            # Find the tail (node pointing to head)
            tail = self.head
            while tail.next != self.head:
                tail = tail.next
            
            # Insert new node
            new_node.next = self.head
            tail.next = new_node  # Tail now points to new head
            self.head = new_node
        
        self.size += 1
    
    def insert_at_tail(self, val):
        """
        Insert at the end.
        Time: O(n) - need to find tail
        """
        new_node = ListNode(val)
        
        if self.is_empty():
            new_node.next = new_node
            self.head = new_node
        else:
            # Find tail
            tail = self.head
            while tail.next != self.head:
                tail = tail.next
            
            # Append new node
            tail.next = new_node
            new_node.next = self.head  # Complete the circle
        
        self.size += 1
    
    def delete_at_head(self):
        """
        Remove from beginning.
        Time: O(n) - need to update tail.next
        """
        if self.is_empty():
            raise IndexError("List is empty")
        
        val = self.head.val
        
        if self.size == 1:
            self.head = None
        else:
            # Find tail
            tail = self.head
            while tail.next != self.head:
                tail = tail.next
            
            # Skip head
            self.head = self.head.next
            tail.next = self.head  # Maintain circle
        
        self.size -= 1
        return val
    
    def delete_value(self, val):
        """
        Remove first occurrence of value.
        Time: O(n)
        """
        if self.is_empty():
            return False
        
        # Special case: head is the target
        if self.head.val == val:
            self.delete_at_head()
            return True
        
        # Find node before target
        prev = self.head
        current = self.head.next
        
        while current != self.head:
            if current.val == val:
                prev.next = current.next
                self.size -= 1
                return True
            prev = current
            current = current.next
        
        return False  # Not found
    
    def traverse(self):
        """
        Get all values in list.
        Time: O(n)
        """
        if self.is_empty():
            return []
        
        result = [self.head.val]
        current = self.head.next
        
        while current != self.head:
            result.append(current.val)
            current = current.next
        
        return result
    
    def search(self, val):
        """Find if value exists. Time: O(n)"""
        if self.is_empty():
            return False
        
        if self.head.val == val:
            return True
        
        current = self.head.next
        while current != self.head:
            if current.val == val:
                return True
            current = current.next
        
        return False
```

**JavaScript:**

```javascript
class CircularLinkedList {
    constructor() {
        this.head = null;
        this.size = 0;
    }
    
    isEmpty() {
        return this.head === null;
    }
    
    insertAtHead(val) {
        const newNode = new ListNode(val);
        
        if (this.isEmpty()) {
            newNode.next = newNode;
            this.head = newNode;
        } else {
            // Find tail
            let tail = this.head;
            while (tail.next !== this.head) {
                tail = tail.next;
            }
            
            newNode.next = this.head;
            tail.next = newNode;
            this.head = newNode;
        }
        this.size++;
    }
    
    insertAtTail(val) {
        const newNode = new ListNode(val);
        
        if (this.isEmpty()) {
            newNode.next = newNode;
            this.head = newNode;
        } else {
            let tail = this.head;
            while (tail.next !== this.head) {
                tail = tail.next;
            }
            tail.next = newNode;
            newNode.next = this.head;
        }
        this.size++;
    }
    
    traverse() {
        if (this.isEmpty()) return [];
        
        const result = [this.head.val];
        let current = this.head.next;
        
        while (current !== this.head) {
            result.push(current.val);
            current = current.next;
        }
        return result;
    }
}
```

---

## ğŸ’» Optimized Version with Tail Pointer

To avoid O(n) operations, maintain a tail pointer:

```python
class CircularLinkedListOptimized:
    """Circular LL with tail pointer for O(1) insertions."""
    
    def __init__(self):
        self.head = None
        self.tail = None  # â† Key optimization
        self.size = 0
    
    def is_empty(self):
        """Check if list is empty."""
        return self.head is None
    
    def insert_at_head(self, val):
        """O(1) with tail pointer."""
        new_node = ListNode(val)
        
        if self.is_empty():
            new_node.next = new_node
            self.head = self.tail = new_node
        else:
            new_node.next = self.head
            self.tail.next = new_node  # O(1) - no traversal!
            self.head = new_node
        
        self.size += 1
    
    def insert_at_tail(self, val):
        """O(1) with tail pointer."""
        new_node = ListNode(val)
        
        if self.is_empty():
            new_node.next = new_node
            self.head = self.tail = new_node
        else:
            new_node.next = self.head
            self.tail.next = new_node
            self.tail = new_node  # Update tail
        
        self.size += 1
    
    def delete_at_head(self):
        """O(1) with tail pointer."""
        if self.is_empty():
            raise IndexError("List is empty")
        
        val = self.head.val
        
        if self.size == 1:
            self.head = self.tail = None
        else:
            self.head = self.head.next
            self.tail.next = self.head  # Maintain circle
        
        self.size -= 1
        return val
```

---

## âš¡ Complexity Analysis

### Without Tail Pointer

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Insert at head |" O(n) "| O(1) | Need to find tail |
| Insert at tail |" O(n) "| O(1) | Need to find tail |
| Delete at head |" O(n) "| O(1) | Need to update tail |
| Delete at tail |" O(n) "| O(1) | Need to find prev |
| Search |" O(n) "| O(1) | Traverse until back to head |
| Traverse |" O(n) "| O(n) | Visit all nodes |

### With Tail Pointer

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Insert at head |" O(1) "| O(1) | tail.next = new |
| Insert at tail |" O(1) "| O(1) | Update tail |
| Delete at head |" O(1) "| O(1) | Update tail.next |
| Delete at tail |" O(n) "| O(1) | Need to find prev |

---

## ğŸ”„ Variations

| Type | Description | Use Case |
|------|-------------|----------|
| Singly Circular | One direction only | Simple cycling |
| Doubly Circular | Bidirectional | Complex navigation |
| With tail pointer |" O(1) head/tail ops "| High-performance |
| Header node | Dummy first node | Simplified edge cases |

---

## ğŸ“ Classic Problem: Josephus Problem

The Josephus problem is a famous application of circular lists:

**Problem:** N people stand in a circle. Starting from person 1, every k-th person is eliminated. Find the survivor.

```python
def josephus(n: int, k: int) -> int:
    """
    Find the survivor position in Josephus problem.
    
    Using circular linked list simulation.
    Time: O(n*k), Space: O(n)
    """
    # Create circular list of people (1 to n)
    head = ListNode(1)
    current = head
    for i in range(2, n + 1):
        current.next = ListNode(i)
        current = current.next
    current.next = head  # Make circular
    
    # Elimination process
    prev = current  # Last node
    current = head
    
    remaining = n
    while remaining > 1:
        # Move k-1 steps (to land on k-th person)
        for _ in range(k - 1):
            prev = current
            current = current.next
        
        # Eliminate current person
        prev.next = current.next
        current = current.next
        remaining -= 1
    
    return current.val  # Survivor


# Mathematical solution (O(n) time, O(1) space)
def josephus_math(n: int, k: int) -> int:
    """
    Mathematical formula for Josephus problem.
    J(n, k) = (J(n-1, k) + k) % n with J(1, k) = 0
    Returns 0-indexed position.
    """
    result = 0
    for i in range(2, n + 1):
        result = (result + k) % i
    return result + 1  # Convert to 1-indexed
```

---

## âš ï¸ Common Mistakes

### 1. Infinite Loop in Traversal

```python
# âŒ Wrong - infinite loop!
def traverse_bad(head):
    current = head
    while current:  # Never becomes null!
        print(current.val)
        current = current.next

# âœ… Correct - check if we're back to head
def traverse_good(head):
    if not head:
        return
    current = head
    while True:
        print(current.val)
        current = current.next
        if current == head:  # Stop when back to start
            break
```

### 2. Forgetting Single Node Case

```python
# âŒ Wrong - doesn't handle single node
def insert(self, val):
    new_node = ListNode(val)
    new_node.next = self.head
    # But what points to new_node if only one element?

# âœ… Correct - single node points to itself
def insert(self, val):
    new_node = ListNode(val)
    if self.is_empty():
        new_node.next = new_node  # Self-loop!
    else:
        # ... normal insertion
```

### 3. Deleting Last Node

```python
# âŒ Wrong - leaves dangling reference
def delete_last_node(self):
    if self.size == 1:
        self.head = self.head.next  # Points to itself!
    
# âœ… Correct - set to None
def delete_last_node(self):
    if self.size == 1:
        self.head = None
        self.tail = None  # If using tail pointer
```

---

## ğŸ“ Practice Problems

### Easy (Learn the concept)
- [ ] Implement circular linked list with all operations
- [ ] Convert regular linked list to circular

### Medium (Apply to problems)
- [ ] [Josephus Problem](https://practice.geeksforgeeks.org/problems/josephus-problem/) - GFG
- [ ] [Circular Queue Implementation](https://leetcode.com/problems/design-circular-queue/) - LC 622

### Related Cycle Problems
- [ ] [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) - LC 141
- [ ] [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) - LC 142

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement basic circular LL operations
- **Day 3:** Solve Josephus problem
- **Day 7:** Implement circular queue
- **Day 14:** Review traversal termination conditions
- **Day 30:** Re-implement with optimizations (tail pointer)

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>Interview Expectations</strong></summary>

**Circular LL is less common than other list types, but:**

1. Understanding helps with cycle detection problems
2. Josephus problem is a classic (rarely asked directly)
3. May appear in system design (circular buffer)

**When to suggest circular LL:**
- "Data needs to cycle repeatedly"
- "No clear beginning or end"
- "Round-robin or fair scheduling"

**Red flags:**
- Using circular when regular LL works
- Not handling the single-node case
- Infinite loops in traversal

</details>

**Company Focus:**

| Company | Focus | Notes |
|---------|-------|-------|
| Amazon | Cycle detection | More common |
| Google | Algorithm design | Josephus concept |
| Microsoft | Implementation | Basic operations |

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 10-15 min | Difference from regular LL |
| Implement basic ops | 20-30 min | Insert, delete, traverse |
| Add tail pointer | 10-15 min | Optimization |
| Josephus problem | 20-30 min | Classic application |

---

> **ğŸ’¡ Key Insight:** The main difference in circular lists is termination - you check `current != head` instead of `current != null`. With a tail pointer, head/tail operations become O(1).

---

## ğŸ”— Related

- [Singly Linked List](../01-Singly-LL/1.1-Basics.md) - Base structure
- [Doubly Linked List](../02-Doubly-LL/2.1-Doubly-LL-Complete.md) - Bidirectional variant
- [Cycle Detection](../04-Fast-Slow-Pointer/4.2-Cycle-Problems/01-Cycle-Detection.md) - Detecting accidental cycles
- [Design Circular Queue](https://leetcode.com/problems/design-circular-queue/) - Array-based circular structure
