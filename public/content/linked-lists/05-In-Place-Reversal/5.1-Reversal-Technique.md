# 5.1 In-Place Reversal Technique

> **Grokking Pattern #6** - Reverse a linked list or portion without extra space
>
> ‚è±Ô∏è Estimated Learning Time: 45-60 minutes

---

## Overview

The **In-Place Reversal** technique reverses the links between nodes in a linked list using only pointer manipulation. Instead of creating a new list, we change the direction of the `next` pointers. This is one of the most fundamental linked list operations and appears in countless interview problems.

**Core Insight:** We use three pointers (prev, current, next) to reverse links one at a time. Each node's `next` pointer changes from pointing forward to pointing backward.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Reverse a linked list" or "reverse portion of list"
- Need to change the order of nodes
- Problems involving "from end" or "backward" traversal
- Palindrome checking in linked lists
- Rearranging nodes (like reorder list)

**Keywords in problem statement:**
- "reverse", "reversed", "in reverse order"
- "from position m to n"
- "every k nodes", "groups of k"
- "palindrome", "same backward and forward"

**Problem patterns:**
| Pattern | Example Problem |
|---------|-----------------|
| Reverse entire list | Reverse Linked List (LC 206) |
| Reverse sub-list | Reverse Linked List II (LC 92) |
| Reverse in groups | Reverse Nodes in k-Group (LC 25) |
| Check palindrome | Palindrome Linked List (LC 234) |
| Reorder list | Reorder List (LC 143) |

</details>

---

## ‚úÖ When to Use

- **Reversing entire linked list** (iterative or recursive)
- **Reversing a portion** of the list (between positions)
- **Reversing in groups** of k nodes
- **Palindrome checking** (reverse second half, compare)
- **Rearranging nodes** (often combines with finding middle)
- When O(1) extra space is required

---

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need to preserve original list | Reversal modifies in-place | Copy to new list |
| Random access needed |" Still O(n) after reversal "| Use array |
| Doubly linked list | Can traverse backward already | Backward traversal |
| Printing in reverse only | Don't need to modify | Recursion/Stack |
| Tree structures | More complex relationships | Tree-specific algorithms |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Linked List Basics](../01-Singly-LL/1.1-Basics.md) - Node structure
- [Pointer manipulation](../01-Singly-LL/1.2-Operations.md) - Working with references
- [Traversal patterns](../01-Singly-LL/1.1-Basics.md) - Walking through list

**After mastering this:**
- [Reverse Entire List (LC 206)](./5.2-Reversal-Problems/01-Reverse-Entire-List.md)
- [Reverse Between (LC 92)](./5.2-Reversal-Problems/02-Reverse-Between.md)
- [Reverse K-Group (LC 25)](./5.2-Reversal-Problems/03-Reverse-K-Group.md)

**Combines with:**
- **Fast & Slow Pointer** for palindrome checking (find middle, reverse, compare)
- **Merge technique** for reorder list
- **Recursion** for elegant reversal solutions

</details>

---

## üìê How It Works

### The Three-Pointer Technique

We maintain three pointers:
1. **prev**: Points to the already-reversed portion (starts as null)
2. **current**: The node we're currently processing
3. **next**: Temporary storage for the next node (so we don't lose it)

### Step-by-Step Process

```
Original: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí null

Step 0 (Initial):
  prev = null
  curr = 1
  
  null   1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí null
   ‚Üë     ‚Üë
  prev  curr

Step 1:
  Save next: next = curr.next (next = 2)
  Reverse link: curr.next = prev
  Move prev: prev = curr
  Move curr: curr = next
  
  null ‚Üê 1    2 ‚Üí 3 ‚Üí 4 ‚Üí null
         ‚Üë    ‚Üë
        prev curr

Step 2:
  Save next: next = 3
  Reverse link: 2.next = 1
  Move pointers
  
  null ‚Üê 1 ‚Üê 2    3 ‚Üí 4 ‚Üí null
              ‚Üë    ‚Üë
            prev  curr

Step 3:
  null ‚Üê 1 ‚Üê 2 ‚Üê 3    4 ‚Üí null
                  ‚Üë    ‚Üë
                prev  curr

Step 4:
  null ‚Üê 1 ‚Üê 2 ‚Üê 3 ‚Üê 4    null
                      ‚Üë     ‚Üë
                    prev   curr

curr is null, we're done!
Return prev (new head = 4)

Result: 4 ‚Üí 3 ‚Üí 2 ‚Üí 1 ‚Üí null
```

### The Key Insight

Each iteration does 4 things:
1. **Save** the next node (before we lose it)
2. **Reverse** the current link (point backward instead of forward)
3. **Move prev** forward (current becomes new prev)
4. **Move current** forward (to saved next)

---

## üíª Code Implementation

### Iterative Reversal (Most Common in Interviews)

**Python:**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def reverse_list(head: ListNode) -> ListNode:
    """
    Reverse a singly linked list iteratively.
    
    Pattern: In-Place Reversal (Grokking #6)
    Time: O(n), Space: O(1)
    
    Uses three pointers: prev, current, next
    """
    prev = None
    current = head
    
    while current:
        # Save next node before we overwrite current.next
        next_node = current.next
        
        # Reverse the link
        current.next = prev
        
        # Move pointers forward
        prev = current
        current = next_node
    
    # prev is now the new head
    return prev
```

**JavaScript:**
```javascript
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

/**
 * Reverse a singly linked list iteratively.
 * Pattern: In-Place Reversal
 * Time: O(n), Space: O(1)
 */
function reverseList(head) {
    let prev = null;
    let current = head;
    
    while (current) {
        // Save next
        const nextNode = current.next;
        
        // Reverse link
        current.next = prev;
        
        // Move forward
        prev = current;
        current = nextNode;
    }
    
    return prev;
}
```

### Recursive Reversal

**Python:**
```python
def reverse_list_recursive(head: ListNode) -> ListNode:
    """
    Reverse a singly linked list recursively.
    
    Time: O(n), Space: O(n) - call stack
    
    Base case: empty list or single node
    Recursive: reverse rest, then fix links
    """
    # Base case: empty list or single node
    if not head or not head.next:
        return head
    
    # Recursively reverse the rest of the list
    # new_head will be the last node (new head after reversal)
    new_head = reverse_list_recursive(head.next)
    
    # Fix the links
    # head.next is the node after current head
    # We need that node to point back to head
    head.next.next = head
    head.next = None  # Prevent cycle
    
    return new_head


def reverse_list_recursive_verbose(head: ListNode) -> ListNode:
    """Same with detailed comments."""
    # Base case
    if not head or not head.next:
        return head
    
    # Example: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4
    # When processing node 1:
    #   head = 1
    #   head.next = 2
    #   After recursion: 4 ‚Üí 3 ‚Üí 2 ‚Üí null (new_head = 4)
    #   We need: 4 ‚Üí 3 ‚Üí 2 ‚Üí 1 ‚Üí null
    
    new_head = reverse_list_recursive_verbose(head.next)
    
    # head.next is 2, and 2.next should point to 1
    head.next.next = head  # 2 ‚Üí 1
    head.next = None       # 1 ‚Üí null (prevent 1 ‚Üî 2 cycle)
    
    return new_head
```

**JavaScript:**
```javascript
function reverseListRecursive(head) {
    // Base case
    if (!head || !head.next) {
        return head;
    }
    
    // Reverse the rest
    const newHead = reverseListRecursive(head.next);
    
    // Fix links
    head.next.next = head;
    head.next = null;
    
    return newHead;
}
```

### Reverse Between Positions (Sub-list Reversal)

**Python:**
```python
def reverse_between(head: ListNode, left: int, right: int) -> ListNode:
    """
    Reverse nodes from position left to right (1-indexed).
    
    Example: 1‚Üí2‚Üí3‚Üí4‚Üí5, left=2, right=4
    Result:  1‚Üí4‚Üí3‚Üí2‚Üí5
    
    Time: O(n), Space: O(1)
    """
    if not head or left == right:
        return head
    
    # Dummy node simplifies edge cases
    dummy = ListNode(0)
    dummy.next = head
    
    # Move to the node before left position
    prev = dummy
    for _ in range(left - 1):
        prev = prev.next
    
    # Start reversing from current position
    current = prev.next
    
    # Reverse (right - left) links
    for _ in range(right - left):
        # Node to move
        next_node = current.next
        
        # Remove next_node from its position
        current.next = next_node.next
        
        # Insert next_node at the beginning of reversed section
        next_node.next = prev.next
        prev.next = next_node
    
    return dummy.next
```

**JavaScript:**
```javascript
function reverseBetween(head, left, right) {
    if (!head || left === right) return head;
    
    const dummy = new ListNode(0);
    dummy.next = head;
    
    let prev = dummy;
    for (let i = 0; i < left - 1; i++) {
        prev = prev.next;
    }
    
    let current = prev.next;
    
    for (let i = 0; i < right - left; i++) {
        const nextNode = current.next;
        current.next = nextNode.next;
        nextNode.next = prev.next;
        prev.next = nextNode;
    }
    
    return dummy.next;
}
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Iterative |" O(n) "| O(1) | Optimal for interviews |
| Recursive |" O(n) "| O(n) | Call stack overhead |
| Reverse between |" O(n) "| O(1) | Single pass possible |
| Reverse k-group |" O(n) "| O(1) | Same, with k logic |

**Why Iterative is Preferred:**
- Same time complexity as recursive
- O(1) space vs O(n) for recursion
- No risk of stack overflow for long lists
- Easier to debug and trace

---

## üîÑ Variations

| Variation | Key Difference | LeetCode Problem |
|-----------|----------------|------------------|
| Entire list | Basic case | LC 206 |
| Between positions | Partial reversal | LC 92 |
| K-group | Fixed-size chunks | LC 25 |
| Alternate k | Every other group | Interview variant |
| Swap pairs | k=2 | LC 24 |

### Swap Nodes in Pairs

```python
def swap_pairs(head: ListNode) -> ListNode:
    """Swap every two adjacent nodes (k=2 special case)."""
    dummy = ListNode(0)
    dummy.next = head
    prev = dummy
    
    while prev.next and prev.next.next:
        first = prev.next
        second = prev.next.next
        
        # Swap
        first.next = second.next
        second.next = first
        prev.next = second
        
        # Move to next pair
        prev = first
    
    return dummy.next
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Save the Next Node

```python
# ‚ùå Wrong - loses the rest of the list!
while current:
    current.next = prev
    prev = current
    current = current.next  # current.next is now prev, not original next!

# ‚úÖ Correct - save next before modifying
while current:
    next_node = current.next  # Save first!
    current.next = prev
    prev = current
    current = next_node
```

### 2. Returning Wrong Node

```python
# ‚ùå Wrong - current is null at end
return current  # Returns None!

# ‚úÖ Correct - prev is the new head
return prev
```

### 3. Not Handling Edge Cases

```python
# ‚ùå Wrong - crashes on empty list
def reverse(head):
    prev = None
    current = head
    next_node = head.next  # Crash if head is None!

# ‚úÖ Correct - handle edge cases
def reverse(head):
    if not head or not head.next:
        return head
    # ... rest of code
```

### 4. Recursive: Forgetting to Break the Link

```python
# ‚ùå Wrong - creates cycle
def reverse_recursive(head):
    if not head or not head.next:
        return head
    new_head = reverse_recursive(head.next)
    head.next.next = head
    # Missing: head.next = None
    return new_head

# ‚úÖ Correct - break the forward link
def reverse_recursive(head):
    if not head or not head.next:
        return head
    new_head = reverse_recursive(head.next)
    head.next.next = head
    head.next = None  # Important!
    return new_head
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)
- [ ] [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) - LC 206 - Basic reversal

### Medium (Apply variations)
- [ ] [Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) - LC 92 - Sub-list reversal
- [ ] [Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/) - LC 24 - k=2 case
- [ ] [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/) - LC 234 - Combine with fast/slow
- [ ] [Reorder List](https://leetcode.com/problems/reorder-list/) - LC 143 - Find middle + reverse + merge

### Hard (Master the technique)
- [ ] [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/) - LC 25 - Full k-group reversal

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**After learning reversal:**
- **Day 1:** Solve LC 206 (basic reversal) iteratively AND recursively
- **Day 3:** Solve LC 92 (reverse between) - harder variation
- **Day 7:** Solve LC 234 (palindrome) - combines patterns
- **Day 14:** Solve LC 25 (k-group) - most complex
- **Day 30:** Solve LC 143 (reorder) - ultimate combination

**Mastery indicators:**
- [ ] Can write iterative reversal without thinking
- [ ] Understand why we need three pointers
- [ ] Can reverse between positions in one pass
- [ ] Can combine with fast/slow for palindrome

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**The 4-Step Communication Template:**

1. **Clarify** (1-2 min):
   - "Should I modify in-place or create a new list?"
   - "What should I return? New head?"
   - "Any constraints on space complexity?"

2. **Plan** (2-3 min):
   - "I'll use three pointers: prev, current, and next"
   - "In each iteration, I'll reverse one link and move forward"
   - "This gives O(n) time and O(1) space"

3. **Code** (10-15 min):
   - Draw the pointer diagram first
   - Write the loop carefully
   - Explain each line as you write

4. **Verify** (2-3 min):
   - Trace through: empty list, single node, two nodes, general case
   - Verify the return value

**What interviewers evaluate:**
- Do you understand pointer manipulation?
- Can you visualize the process?
- Do you handle edge cases?
- Can you extend to harder variations?

</details>

**Company Focus:**

| Company | Frequency | Typical Problems |
|---------|-----------|------------------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Basic reversal, k-group |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | All variations |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask for recursive |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard + edge cases |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn concept | 30-45 min | Understand three pointers |
| LC 206 (Easy) | 10-15 min | Should be quick |
| LC 92 (Medium) | 20-25 min | Tricky edge cases |
| LC 25 (Hard) | 30-40 min | Complex logic |
| Master pattern | 8-10 problems | Until automatic |

---

> **üí° Key Insight:** The order of operations matters! Always (1) save next, (2) reverse link, (3) move prev, (4) move current. If you forget step 1, you lose the rest of the list. Drawing the pointers before coding helps prevent mistakes.

---

## üîó Related

- [Reverse Entire List](./5.2-Reversal-Problems/01-Reverse-Entire-List.md)
- [Reverse Between](./5.2-Reversal-Problems/02-Reverse-Between.md)
- [Reverse K-Group](./5.2-Reversal-Problems/03-Reverse-K-Group.md)
- [Fast & Slow Pointer](../04-Fast-Slow-Pointer/4.1-Concept.md) - Combines for palindrome
