# 2.4 Representation Comparison

> **Choosing the right representation for your problem**
>
> â±ï¸ **Time:** 15-20 min | ğŸ“Š **Difficulty:** Intermediate | ğŸ¯ **Interview Frequency:** High (Trade-off Discussion)

---

## Overview

Choosing the right graph representation is a critical trade-off decision in interviews. This guide provides a decision framework based on problem constraints.

```
The Golden Rule:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   95% of interview problems â†’ Use ADJACENCY LIST              â”‚
â”‚   Dense graphs (E â‰ˆ VÂ²) â†’ Consider Adjacency Matrix           â”‚
â”‚   Edge-centric algorithms â†’ Keep Edge List                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>Quick Decision Framework</strong></summary>

**Ask yourself:**
1. What operations do I need most frequently?
2. Is the graph dense (E â‰ˆ VÂ²) or sparse (E << VÂ²)?
3. Does the problem give edges or an adjacency matrix?
4. Do I need O(1) edge existence check?

**Decision tree:**
```
Start
 â”‚
 â”œâ”€ Need to traverse neighbors? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Adjacency List
 â”‚
 â”œâ”€ Need O(1) edge check AND dense graph? â”€â”€â”€â”€â”€â”€â”€â†’ Adjacency Matrix
 â”‚
 â”œâ”€ Need to sort/iterate all edges? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Edge List
 â”‚
 â””â”€ Default (most problems) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Adjacency List
```

</details>

---

## ğŸ“Š Complete Comparison Table

### Space Complexity

| Representation | Space | Best For |
|----------------|-------|----------|
| **Adjacency Matrix** | O(VÂ²) | Dense graphs |
| **Adjacency List** | O(V + E) | Sparse graphs (most real graphs) |
| **Edge List** | O(E) | Minimal storage, edge-centric |

### Time Complexity

| Operation | Adj Matrix | Adj List | Edge List |
|-----------|------------|----------|-----------|
| **Add vertex** | O(VÂ²) | O(1) | O(1) |
| **Add edge** | O(1) | O(1) | O(1) |
| **Remove edge** | O(1) | O(degree) | O(E) |
| **Check edge exists** | â­ O(1) | O(degree) | O(E) |
| **Get all neighbors** | O(V) | â­ O(degree) | O(E) |
| **Iterate all edges** | O(VÂ²) | O(V + E) | â­ O(E) |
| **BFS/DFS traversal** | O(VÂ²) | â­ O(V + E) | O(V Ã— E) |
| **Find degree** | O(V) | â­ O(1) | O(E) |

---

## âœ… When to Use Each

### Adjacency Matrix

| Use When | Example |
|----------|---------|
| Dense graph (E â‰ˆ VÂ²) | Complete graph, small social network |
| Need O(1) edge check | "Is there a direct flight between A and B?" |
| Floyd-Warshall algorithm | All-pairs shortest path |
| Small V (â‰¤ 1000) | Memory isn't a constraint |
| Frequent edge updates | Adding/removing edges often |

### Adjacency List â­ (Default Choice)

| Use When | Example |
|----------|---------|
| BFS/DFS traversal | Most graph problems |
| Sparse graph | Road networks, social graphs |
| Need efficient neighbor iteration | "Find all friends of user" |
| V is large (10,000+) | Memory constraint |
| Most interview problems | Default assumption |

### Edge List

| Use When | Example |
|----------|---------|
| Kruskal's MST | Sort edges by weight |
| Bellman-Ford | Iterate all edges V-1 times |
| Problem gives edges as input | Convert to adj list first |
| Edge-centric algorithms | Focus on edges, not vertices |

---

## âŒ When NOT to Use Each

### Don't Use Adjacency Matrix When:
- V is large (> 1000): O(VÂ²) = 1,000,000+ memory
- Graph is sparse: Wasting space on zeros
- Need efficient traversal: O(V) to get neighbors

### Don't Use Edge List When:
- Need neighbor lookup: O(E) per query is slow
- BFS/DFS traversal: O(V Ã— E) instead of O(V + E)
- Checking if edge exists frequently

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Adjacency Matrix](./2.1-Adjacency-Matrix.md)
- [Adjacency List](./2.2-Adjacency-List.md)
- [Edge List](./2.3-Edge-List.md)

**After mastering this:**
- [BFS Pattern](../03-BFS-Pattern/3.1-BFS-Fundamentals.md)
- [DFS Pattern](../04-DFS-Pattern/4.1-DFS-Fundamentals.md)

**Apply knowledge to:**
- Every graph problem - choose representation first

</details>

---

## ğŸ“ Visual Comparison

```
Graph with 5 vertices, 6 edges:

    [0]â”€â”€â”€[1]â”€â”€â”€[2]
     â”‚ \   â”‚   /
     â”‚  \  â”‚  /
     â”‚   \ â”‚ /
    [3]   [4]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ADJACENCY MATRIX (5Ã—5 = 25 cells)
     0  1  2  3  4
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 0 â”‚ 0  1  0  1  1â”‚   Space: O(VÂ²) = O(25)
 1 â”‚ 1  0  1  0  1â”‚   For dense graph: efficient
 2 â”‚ 0  1  0  0  1â”‚   For sparse graph: wasteful
 3 â”‚ 1  0  0  0  0â”‚
 4 â”‚ 1  1  1  0  0â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ADJACENCY LIST (6 edges Ã— 2 = 12 entries)

 0 â†’ [1, 3, 4]                    Space: O(V + E) = O(5 + 6)
 1 â†’ [0, 2, 4]                    Only stores actual edges
 2 â†’ [1, 4]                       Efficient for traversal
 3 â†’ [0]
 4 â†’ [0, 1, 2]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EDGE LIST (6 tuples)

[(0,1), (0,3), (0,4), (1,2), (1,4), (2,4)]

Space: O(E) = O(6)
Most compact
Bad for neighbor lookup
```

---

## ğŸ’» Conversion Functions

**Python:**
```python
from collections import defaultdict

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Edge List â†’ Adjacency List
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def edges_to_adj_list(edges, directed=False, weighted=False):
    """
    Convert edge list to adjacency list.
    
    Time: O(E)
    Space: O(V + E)
    
    Args:
        edges: List of (u, v) or (u, v, weight)
        directed: If False, add both directions
        weighted: If True, edges have weights
    """
    adj = defaultdict(list)
    
    for edge in edges:
        if weighted:
            u, v, w = edge
            adj[u].append((v, w))
            if not directed:
                adj[v].append((u, w))
        else:
            u, v = edge
            adj[u].append(v)
            if not directed:
                adj[v].append(u)
    
    return dict(adj)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Adjacency List â†’ Edge List
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def adj_list_to_edges(adj, directed=False, weighted=False):
    """
    Convert adjacency list to edge list.
    
    Time: O(V + E)
    Space: O(E)
    """
    edges = []
    seen = set()
    
    for u in adj:
        for neighbor in adj[u]:
            if weighted:
                v, w = neighbor
                edge_key = (min(u, v), max(u, v)) if not directed else (u, v)
                if directed or edge_key not in seen:
                    edges.append((u, v, w))
                    seen.add(edge_key)
            else:
                v = neighbor
                edge_key = (min(u, v), max(u, v)) if not directed else (u, v)
                if directed or edge_key not in seen:
                    edges.append((u, v))
                    seen.add(edge_key)
    
    return edges


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Adjacency Matrix â†’ Adjacency List
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def matrix_to_adj_list(matrix, weighted=False):
    """
    Convert adjacency matrix to adjacency list.
    
    Time: O(VÂ²)
    Space: O(V + E)
    """
    n = len(matrix)
    adj = defaultdict(list)
    
    for i in range(n):
        for j in range(n):
            if matrix[i][j] != 0:  # Edge exists
                if weighted:
                    adj[i].append((j, matrix[i][j]))
                else:
                    adj[i].append(j)
    
    return dict(adj)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Adjacency List â†’ Adjacency Matrix  
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def adj_list_to_matrix(adj, n, weighted=False):
    """
    Convert adjacency list to adjacency matrix.
    
    Time: O(V + E)
    Space: O(VÂ²)
    """
    matrix = [[0] * n for _ in range(n)]
    
    for u in adj:
        for neighbor in adj[u]:
            if weighted:
                v, w = neighbor
                matrix[u][v] = w
            else:
                v = neighbor
                matrix[u][v] = 1
    
    return matrix


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Example Usage
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print("=== Conversion Examples ===\n")

# Start with edge list (common LeetCode input)
edges = [(0, 1), (0, 2), (1, 2), (2, 3)]
print(f"Edge List: {edges}")

# Convert to adjacency list for BFS/DFS
adj = edges_to_adj_list(edges, directed=False)
print(f"Adjacency List: {adj}")

# Convert to matrix for Floyd-Warshall
matrix = adj_list_to_matrix(adj, 4)
print(f"Adjacency Matrix:")
for row in matrix:
    print(f"  {row}")
```

**JavaScript:**
```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Edge List â†’ Adjacency List
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function edgesToAdjList(edges, directed = false, weighted = false) {
    const adj = new Map();
    
    for (const edge of edges) {
        let u, v, w;
        if (weighted) {
            [u, v, w] = edge;
        } else {
            [u, v] = edge;
        }
        
        if (!adj.has(u)) adj.set(u, []);
        if (!adj.has(v)) adj.set(v, []);
        
        if (weighted) {
            adj.get(u).push([v, w]);
            if (!directed) adj.get(v).push([u, w]);
        } else {
            adj.get(u).push(v);
            if (!directed) adj.get(v).push(u);
        }
    }
    
    return adj;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Adjacency Matrix â†’ Adjacency List
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function matrixToAdjList(matrix, weighted = false) {
    const n = matrix.length;
    const adj = new Map();
    
    for (let i = 0; i < n; i++) {
        adj.set(i, []);
        for (let j = 0; j < n; j++) {
            if (matrix[i][j] !== 0) {
                if (weighted) {
                    adj.get(i).push([j, matrix[i][j]]);
                } else {
                    adj.get(i).push(j);
                }
            }
        }
    }
    
    return adj;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Adjacency List â†’ Adjacency Matrix
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function adjListToMatrix(adj, n, weighted = false) {
    const matrix = Array(n).fill(null).map(() => Array(n).fill(0));
    
    for (const [u, neighbors] of adj) {
        for (const neighbor of neighbors) {
            if (weighted) {
                const [v, w] = neighbor;
                matrix[u][v] = w;
            } else {
                matrix[u][neighbor] = 1;
            }
        }
    }
    
    return matrix;
}

// Example
const edges = [[0, 1], [0, 2], [1, 2], [2, 3]];
console.log("Edge List:", edges);

const adj = edgesToAdjList(edges);
console.log("Adjacency List:", adj);
```

---

## âš¡ Complexity Summary

### Space Trade-offs

```
Graph with V vertices, E edges:

        Dense Graph              Sparse Graph
        (E â‰ˆ VÂ²)                 (E â‰ˆ V)
        
Matrix: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     Matrix: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
        O(VÂ²)                            O(VÂ²) WASTEFUL
        
List:   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     List:   â–ˆâ–ˆâ–ˆâ–ˆ
        O(V + E) â‰ˆ O(VÂ²)                 O(V + E) â‰ˆ O(V) EFFICIENT

Edge:   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ         Edge:   â–ˆâ–ˆ
        O(E) â‰ˆ O(VÂ²)                     O(E) â‰ˆ O(V) MOST COMPACT
```

### Performance Summary

| Graph Type | Best Representation | Why |
|------------|---------------------|-----|
| Sparse (E << VÂ²) | Adjacency List | O(V + E) space, O(degree) neighbors |
| Dense (E â‰ˆ VÂ²) | Adjacency Matrix | O(1) edge check, space similar |
| Edge processing | Edge List | Easy to sort/iterate edges |

---

## ğŸ”„ Interview Decision Framework

### Step-by-Step Process

```python
def choose_representation(problem):
    """
    Decision process to verbalize in interviews.
    """
    
    # Step 1: Check what input format is given
    if "edges = [[u, v], ...]":
        print("Input is edge list, will convert to adjacency list")
    elif "matrix[i][j] = 1":
        print("Input is adjacency matrix, may use directly")
    
    # Step 2: Check graph density
    if E_approximately_equals(V * V):
        print("Dense graph: consider adjacency matrix")
    else:
        print("Sparse graph: use adjacency list")
    
    # Step 3: Check required operations
    if need_O1_edge_check:
        print("Need O(1) edge check: adjacency matrix")
    elif need_traverse_neighbors:
        print("Need to traverse neighbors: adjacency list")
    elif need_sort_edges:
        print("Need to sort edges: keep edge list")
    
    # Default
    return "adjacency list"  # 95% of problems
```

---

## âš ï¸ Common Mistakes

### 1. Using Matrix for Large Sparse Graphs

```python
# âŒ Wrong: V = 10,000, E = 20,000 (sparse)
# Matrix uses 10,000 Ã— 10,000 = 100 MILLION cells!
matrix = [[0] * 10000 for _ in range(10000)]  # Memory limit exceeded

# âœ… Correct: Use adjacency list
adj = defaultdict(list)  # Only stores 20,000 edges
```

### 2. Using Edge List for BFS/DFS

```python
# âŒ Wrong: O(V Ã— E) traversal
def bfs_edge_list(edges, start):
    queue = [start]
    visited = {start}
    while queue:
        node = queue.pop(0)
        # O(E) scan for each node
        for u, v in edges:
            if u == node and v not in visited:
                visited.add(v)
                queue.append(v)

# âœ… Correct: Convert first, then O(V + E) traversal
def bfs_correct(edges, start):
    adj = edges_to_adj_list(edges)  # O(E) one-time
    queue = [start]
    visited = {start}
    while queue:
        node = queue.pop(0)
        for neighbor in adj[node]:  # O(degree) per node
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

### 3. Not Converting Input Format

```python
# âŒ Wrong: Trying to use edge list directly for traversal
edges = [[0,1], [0,2], [1,2]]
# "How do I get neighbors of node 0?"

# âœ… Correct: Convert immediately at start
def solve(edges, n):
    # FIRST: Convert to adjacency list
    adj = defaultdict(list)
    for u, v in edges:
        adj[u].append(v)
        adj[v].append(u)
    
    # NOW: Do BFS/DFS with efficient neighbor access
    # ...
```

---

## ğŸ“ Practice Problems

| Problem | Input Format | Best Representation |
|---------|--------------|---------------------|
| [Clone Graph](https://leetcode.com/problems/clone-graph/) | Node object | Adjacency List |
| [Course Schedule](https://leetcode.com/problems/course-schedule/) | Edge list | Convert to Adj List |
| [Number of Islands](https://leetcode.com/problems/number-of-islands/) | Grid (matrix) | Use grid directly |
| [Network Delay Time](https://leetcode.com/problems/network-delay-time/) | Weighted edges | Weighted Adj List |
| [Floyd-Warshall problems](https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/) | Edge list | Convert to Matrix |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Memorize complexity table
- **Day 3:** Practice conversion functions
- **Day 7:** Explain trade-offs out loud
- **Day 14:** Solve 3 problems, justify representation choice

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate This Decision</strong></summary>

**When asked about representation:**
> "For this problem, I'll use an adjacency list because:
> 1. The graph is sparse (E << VÂ²)
> 2. I need to efficiently iterate over neighbors for BFS
> 3. The input is an edge list, so I'll convert it first"

**When discussing trade-offs:**
> "Adjacency matrix would give us O(1) edge lookup, but since we're doing BFS and the graph is sparse, adjacency list is better because we only visit actual neighbors."

**Company Focus:**
| Company | What They Assess |
|---------|------------------|
| All | Ability to justify representation choice |
| Google | Trade-off discussion, alternative approaches |
| Amazon | Practical decision-making, efficiency |

</details>

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Memorize comparison table | 10-15 min |
| Implement conversion functions | 15-20 min |
| Practice decision framework | 10-15 min |
| **Total to master** | **35-50 min** |

---

> **ğŸ’¡ Key Insight:** Default to adjacency list (95% of problems). Only use matrix for dense graphs with O(1) edge checks, or edge list for edge-centric algorithms like Kruskal's.

> **ğŸ”— Related:** [BFS Fundamentals](../03-BFS-Pattern/3.1-BFS-Fundamentals.md) | [DFS Fundamentals](../04-DFS-Pattern/4.1-DFS-Fundamentals.md)

---

**Previous:** [â† 2.3 Edge List](./2.3-Edge-List.md)  
**Next:** [3.1 BFS Fundamentals â†’](../03-BFS-Pattern/3.1-BFS-Fundamentals.md)
