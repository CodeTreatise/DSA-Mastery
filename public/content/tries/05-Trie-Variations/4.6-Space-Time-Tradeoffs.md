# Space vs Time Trade-offs in Trie Implementations

> **Understanding when to use HashMap vs Array[26] and other memory optimization techniques.**

---

## üìã Overview

Trie implementation choices significantly impact performance:

| Implementation | Memory/Node | Lookup | Best For |
|----------------|-------------|--------|----------|
| HashMap | O(actual children) | O(1) avg | Sparse, Unicode |
| Array[26] | O(26) fixed | O(1) guaranteed | Dense, lowercase only |
| Array[128] | O(128) fixed | O(1) guaranteed | ASCII text |
| Compressed | O(1) + label | O(label length) | Long shared prefixes |

---

## 1Ô∏è‚É£ HashMap vs Array Comparison

### HashMap Implementation

**Python:**
```python
class TrieNodeHash:
    def __init__(self):
        self.children = {}  # Only stores actual children
        self.is_end = False

# Memory: 8 bytes per key-value pair + overhead
# Access: O(1) average, O(n) worst case
```

**JavaScript:**
```javascript
class TrieNodeHash {
    constructor() {
        this.children = new Map();
        this.is_end = false;
    }
}
```

### Array[26] Implementation

**Python:**
```python
class TrieNodeArray:
    def __init__(self):
        self.children = [None] * 26  # Always 26 slots
        self.is_end = False

# Memory: 26 √ó 8 bytes = 208 bytes per node (pointers)
# Access: O(1) guaranteed
```

**JavaScript:**
```javascript
class TrieNodeArray {
    constructor() {
        this.children = new Array(26).fill(null);
        this.is_end = false;
    }
}
```

---

## 2Ô∏è‚É£ When to Use Each

### Use HashMap When:

| Scenario | Reason |
|----------|--------|
| Large alphabet (Unicode) | Array[65536] is impractical |
| Sparse Trie | Most nodes have few children |
| Unknown character set | Flexible for any input |
| Memory-constrained + sparse data | Only stores what exists |

**Example: Emoji dictionary**
```python
# HashMap easily handles any Unicode
trie.insert("helloüëãworld")  # Works fine
```

### Use Array[26] When:

| Scenario | Reason |
|----------|--------|
| Lowercase English only | Exact fit |
| Dense Trie | Most letters used per level |
| Performance critical | No hash computation |
| LeetCode problems | Often specify lowercase only |

**Example: Word dictionary problem**
```python
# Array[26] is faster for known character set
idx = ord(char) - ord('a')  # Direct index calculation
```

---

## 3Ô∏è‚É£ Memory Analysis

### Real Memory Comparison

**Scenario:** Insert 10,000 words, average length 8, alphabet lowercase.

**HashMap Trie:**
```
- Nodes: ~30,000 (typical for English words)
- Per node: ~50 bytes (dict overhead + few entries)
- Total: ~1.5 MB
- Plus: Hash table resize overhead
```

**Array[26] Trie:**
```
- Nodes: ~30,000
- Per node: 208 bytes (26 pointers) + 1 byte (is_end)
- Total: ~6.3 MB
- But: No overhead, no resizing
```

**Verdict:** HashMap uses ~4x less memory for typical English text.

### When Array Wins

**Scenario:** Dense alphabet usage (all 26 letters at each level).

```
HashMap: ~50 bytes + 26√ó16 bytes = ~466 bytes per node
Array: 208 bytes per node

Array is 2x better for very dense tries!
```

---

## 4Ô∏è‚É£ Performance Analysis

### Lookup Speed

| Operation | HashMap | Array[26] |
|-----------|---------|-----------|
| Best case | O(1) | O(1) |
| Average | O(1) | O(1) |
| Worst case | O(n) hash collision | O(1) |
| Cache locality | Poor | Good |

**Cache locality matters:**
```python
# Array: Contiguous memory, cache-friendly
children = [None] * 26
# All 26 slots loaded together

# HashMap: Scattered memory, cache misses
children = {}
# Each entry at random memory location
```

### Insertion Speed

**HashMap:** Occasional resize (amortized O(1))
**Array:** Always O(1), no resize ever

---

## 5Ô∏è‚É£ Optimization Techniques

### Technique 1: Hybrid Approach

Use Array for first few levels, HashMap for deeper:

```python
class HybridTrieNode:
    ARRAY_DEPTH = 3  # Use array for first 3 levels
    
    def __init__(self, depth=0):
        self.depth = depth
        if depth < self.ARRAY_DEPTH:
            self.children = [None] * 26
        else:
            self.children = {}
        self.is_end = False
    
    def get_child(self, char):
        if self.depth < self.ARRAY_DEPTH:
            idx = ord(char) - ord('a')
            return self.children[idx]
        return self.children.get(char)
    
    def set_child(self, char, node):
        if self.depth < self.ARRAY_DEPTH:
            idx = ord(char) - ord('a')
            self.children[idx] = node
        else:
            self.children[char] = node
```

**Why?** First levels are densest (many words share common prefixes).

### Technique 2: Path Compression

Merge nodes with single children:

```python
class CompressedTrieNode:
    def __init__(self):
        self.label = ""  # Multiple characters
        self.children = {}
        self.is_end = False

# "testing" + "tests" becomes:
#
#        root
#         |
#       "test"
#        / \
#      "s" "ing"
```

**Savings:** Reduces node count significantly for similar words.

### Technique 3: Character Encoding

Map characters to smaller indices:

```python
class CustomEncodingTrie:
    def __init__(self, charset: str):
        self.char_to_idx = {c: i for i, c in enumerate(charset)}
        self.size = len(charset)
        self.root = {'children': [None] * self.size, 'is_end': False}
    
    def insert(self, word):
        node = self.root
        for char in word:
            idx = self.char_to_idx[char]
            if node['children'][idx] is None:
                node['children'][idx] = {
                    'children': [None] * self.size,
                    'is_end': False
                }
            node = node['children'][idx]
        node['is_end'] = True

# For DNA sequences: only 4 characters
dna_trie = CustomEncodingTrie("ACGT")
# Uses Array[4] instead of Array[26]!
```

---

## 6Ô∏è‚É£ Memory-Optimized Implementations

### Minimal Node (Bit Packing)

```python
class MinimalTrieNode:
    """
    Pack is_end and child count into single byte.
    """
    __slots__ = ['children', 'flags']  # No __dict__
    
    def __init__(self):
        self.children = {}  # Lazy: only non-null
        self.flags = 0      # Bit 0: is_end
    
    @property
    def is_end(self):
        return bool(self.flags & 1)
    
    @is_end.setter
    def is_end(self, value):
        if value:
            self.flags |= 1
        else:
            self.flags &= ~1
```

### Array of Nodes (Linear Trie)

```python
class LinearTrie:
    """
    Store all nodes in single array for cache efficiency.
    
    Node format: [is_end, child_0, child_1, ..., child_25]
    Each child is an index into the array, or -1.
    """
    
    def __init__(self):
        # Node 0 is root: [is_end, 26 child indices]
        self.nodes = [[False] + [-1] * 26]
    
    def insert(self, word):
        node_idx = 0
        for char in word:
            child_idx = ord(char) - ord('a')
            if self.nodes[node_idx][child_idx + 1] == -1:
                # Create new node
                new_idx = len(self.nodes)
                self.nodes.append([False] + [-1] * 26)
                self.nodes[node_idx][child_idx + 1] = new_idx
            node_idx = self.nodes[node_idx][child_idx + 1]
        self.nodes[node_idx][0] = True
```

---

## 7Ô∏è‚É£ Decision Guide

### Quick Decision Tree

```
Is alphabet size known and small (<= 128)?
‚îú‚îÄ‚îÄ Yes ‚Üí Is data dense (most letters used)?
‚îÇ         ‚îú‚îÄ‚îÄ Yes ‚Üí Use Array[size]
‚îÇ         ‚îî‚îÄ‚îÄ No  ‚Üí Use HashMap
‚îî‚îÄ‚îÄ No (Unicode/variable) ‚Üí Use HashMap

Is performance more critical than memory?
‚îú‚îÄ‚îÄ Yes ‚Üí Use Array (better cache)
‚îî‚îÄ‚îÄ No  ‚Üí Use HashMap (less memory)

Is the constraint lowercase English only?
‚îú‚îÄ‚îÄ Yes ‚Üí Use Array[26]
‚îî‚îÄ‚îÄ No  ‚Üí Evaluate based on actual charset
```

### LeetCode-Specific Advice

| Problem Type | Recommendation |
|--------------|----------------|
| "lowercase English" | Array[26] |
| "alphanumeric" | Array[62] or HashMap |
| Unicode/emoji | HashMap |
| Memory limit issues | Compressed/Radix |
| TLE issues | Array (faster cache) |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Index Calculation

```python
# ‚ùå Wrong: Assumes 'a' starts at 0
idx = ord(char)  # 'a' = 97, way out of bounds!

# ‚úÖ Correct: Normalize to 0-25
idx = ord(char) - ord('a')
```

### 2. Using Array for Mixed Case

```python
# ‚ùå Wrong: 'A' - 'a' = -32 (negative index!)
idx = ord(char) - ord('a')

# ‚úÖ Correct: Handle both cases
idx = ord(char.lower()) - ord('a')
# Or use Array[52] for both cases
```

### 3. Premature Optimization

```python
# ‚ùå Wrong: Complex optimization for small data
# Using compressed trie for 100 short words

# ‚úÖ Correct: Profile first!
# Simple HashMap trie handles millions of words fine
```

---

## üìù Practice Exercises

1. Implement HashMap Trie and Array[26] Trie, compare memory usage
2. Build a trie for DNA sequences (A, C, G, T) using Array[4]
3. Implement path compression for English dictionary
4. Measure cache performance difference with large wordlist

---

> **üí° Key Insight:** HashMap is almost always the right default choice. Only use Array[26] when you know the alphabet is fixed and dense, or when benchmark shows cache issues.

> **üîó Related:** [Trie Class Design](../01-Trie-Fundamentals/2.2-Trie-Class-Design.md) | [Trie Variations](4.5-Trie-Variations.md)
