# 6.2 Construct BST from Preorder Traversal (LC 1008)

## Problem Statement

[LeetCode 1008 - Construct Binary Search Tree from Preorder Traversal](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/)

Given an array of integers `preorder`, which represents the preorder traversal of a BST, construct the tree and return its root.

```
Input: preorder = [8, 5, 1, 7, 10, 12]

Output:
        8
       / \
      5   10
     / \    \
    1   7   12

Preorder: root ‚Üí left ‚Üí right
So 8 is root, then we need to figure out left vs right subtrees.
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a BST Construction from Traversal problem:**
- Given preorder sequence
- Need to reconstruct unique BST
- Use BST property to determine subtree boundaries

**Keywords:**
- "construct BST from preorder"
- "rebuild tree from traversal"
- "given preorder, build BST"

**Pattern:** Preorder gives root first. BST property determines left/right split.

</details>

---

## ‚úÖ When to Use

- Reconstructing BST from preorder
- Serialization/deserialization of BST
- When BST property can determine structure

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| General tree | Need two traversals | Use preorder + inorder |
| Inorder only | Can't determine structure | Need preorder or postorder too |
| Not a valid BST preorder | Won't work | Validate first |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
- [Tree Traversals](../../06-Trees/03-Tree-Traversals/)
- [Sorted Array to BST (LC 108)](./6.1-Sorted-Array-to-BST-LC108.md)

**After mastering this:**
- [Construct Tree from Traversals](../../06-Trees/) - General tree construction
- [Validate BST (LC 98)](../03-BST-Validation/3.1-Validate-BST-LC98.md)

**Combines with:**
- Range-based construction
- Monotonic stack

</details>

---

## üìê How It Works

### The Key Insight

```
Preorder: [8, 5, 1, 7, 10, 12]
           ‚Üë
          root

In preorder, first element is always root.

For BST: left subtree has values < root
         right subtree has values > root

So: 8 is root
    [5, 1, 7] are all < 8 ‚Üí left subtree
    [10, 12] are all > 8 ‚Üí right subtree
    
Recursively apply same logic!
```

### Visualization

```
preorder = [8, 5, 1, 7, 10, 12]

Step 1: Root = 8
        Find split: elements < 8 vs elements > 8
        Left: [5, 1, 7]
        Right: [10, 12]

Step 2: Left subtree from [5, 1, 7]
        Root = 5
        Left: [1] (< 5)
        Right: [7] (> 5)

Step 3: Right subtree from [10, 12]
        Root = 10
        Left: [] (none < 10)
        Right: [12] (> 10)

Result:
        8
       / \
      5   10
     / \    \
    1   7   12
```

---

## üíª Code Implementation

### Approach 1: Range-Based Recursion (Optimal)

**Python:**
```python
def bstFromPreorder(self, preorder: list[int]) -> Optional[TreeNode]:
    """
    Build BST using range constraints.
    
    Time: O(n) - each element processed once
    Space: O(h) - recursion stack
    
    Pattern: Each node must fall within [min, max] range.
    """
    self.index = 0
    
    def build(min_val: float, max_val: float) -> Optional[TreeNode]:
        # Base case: no more elements or current doesn't fit
        if self.index >= len(preorder):
            return None
        
        val = preorder[self.index]
        if val < min_val or val > max_val:
            return None
        
        # Create node and advance index
        self.index += 1
        node = TreeNode(val)
        
        # Left subtree: values in (min, val)
        node.left = build(min_val, val)
        
        # Right subtree: values in (val, max)
        node.right = build(val, max_val)
        
        return node
    
    return build(float('-inf'), float('inf'))
```

**JavaScript:**
```javascript
var bstFromPreorder = function(preorder) {
    // Range-based construction
    let index = 0;
    
    function build(minVal, maxVal) {
        if (index >= preorder.length) return null;
        
        const val = preorder[index];
        if (val < minVal || val > maxVal) return null;
        
        index++;
        const node = new TreeNode(val);
        
        node.left = build(minVal, val);
        node.right = build(val, maxVal);
        
        return node;
    }
    
    return build(-Infinity, Infinity);
};
```

### Approach 2: Find Split Point (Intuitive)

**Python:**
```python
def bstFromPreorder(self, preorder: list[int]) -> Optional[TreeNode]:
    """
    Find split point between left and right subtrees.
    
    Time: O(n¬≤) worst case (finding split each time)
    Space: O(h)
    """
    if not preorder:
        return None
    
    root = TreeNode(preorder[0])
    
    # Find split: first element greater than root
    split = 1
    while split < len(preorder) and preorder[split] < preorder[0]:
        split += 1
    
    # Left subtree: elements [1, split)
    root.left = self.bstFromPreorder(preorder[1:split])
    
    # Right subtree: elements [split, end)
    root.right = self.bstFromPreorder(preorder[split:])
    
    return root
```

### Approach 3: Monotonic Stack (Advanced)

**Python:**
```python
def bstFromPreorder(self, preorder: list[int]) -> Optional[TreeNode]:
    """
    Build BST using monotonic decreasing stack.
    
    Time: O(n), Space: O(n)
    
    Insight: As we traverse preorder, we either go left (smaller)
    or pop back up and go right (larger).
    """
    if not preorder:
        return None
    
    root = TreeNode(preorder[0])
    stack = [root]
    
    for val in preorder[1:]:
        node = TreeNode(val)
        
        if val < stack[-1].val:
            # Smaller: becomes left child of current
            stack[-1].left = node
        else:
            # Larger: pop until we find where it fits
            parent = None
            while stack and val > stack[-1].val:
                parent = stack.pop()
            parent.right = node
        
        stack.append(node)
    
    return root
```

**JavaScript:**
```javascript
var bstFromPreorder = function(preorder) {
    // Monotonic stack approach
    if (preorder.length === 0) return null;
    
    const root = new TreeNode(preorder[0]);
    const stack = [root];
    
    for (let i = 1; i < preorder.length; i++) {
        const val = preorder[i];
        const node = new TreeNode(val);
        
        if (val < stack[stack.length - 1].val) {
            stack[stack.length - 1].left = node;
        } else {
            let parent = null;
            while (stack.length && val > stack[stack.length - 1].val) {
                parent = stack.pop();
            }
            parent.right = node;
        }
        
        stack.push(node);
    }
    
    return root;
};
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Range-based |" O(n) "| O(h) | Optimal |
| Split point |" O(n¬≤) "| O(h) |" Finding split is O(n) "|
| Monotonic stack |" O(n) "| O(n) |" Iterative O(n) "|

**Why Range-Based is O(n):**
- Each element is processed exactly once
- Index advances linearly through array
- Range checks are O(1)

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **Postorder to BST** | Process right-to-left | Mirror logic |
| **Preorder + Inorder** | General tree | LC 105 |
| **Serialize/Deserialize BST** | Use preorder | LC 449 |
| **Verify valid preorder** | Check if possible | LC 255 |

### Postorder to BST

```python
def bstFromPostorder(postorder: list[int]) -> TreeNode:
    """Process from end, build right before left."""
    index = len(postorder) - 1
    
    def build(min_val, max_val):
        nonlocal index
        if index < 0:
            return None
        
        val = postorder[index]
        if val < min_val or val > max_val:
            return None
        
        index -= 1
        node = TreeNode(val)
        
        # Right first (since we're going backwards)
        node.right = build(val, max_val)
        node.left = build(min_val, val)
        
        return node
    
    return build(float('-inf'), float('inf'))
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Using Index Reference

```python
# ‚ùå Wrong: Slicing creates copies, index gets lost
def build(arr, min_val, max_val):
    if not arr or arr[0] < min_val or arr[0] > max_val:
        return None
    node = TreeNode(arr[0])
    node.left = build(arr[1:], min_val, arr[0])  # Loses position!
    # ...

# ‚úÖ Correct: Use shared index
self.index = 0
def build(min_val, max_val):
    val = preorder[self.index]  # Shared index
    self.index += 1
    # ...
```

### 2. Wrong Order for Range-Based

```python
# ‚ùå Wrong: Right before left
node.right = build(val, max_val)  # Consumes wrong elements!
node.left = build(min_val, val)

# ‚úÖ Correct: Left before right (matches preorder)
node.left = build(min_val, val)   # Left subtree comes first in preorder
node.right = build(val, max_val)
```

### 3. Not Returning None When Value Out of Range

```python
# ‚ùå Wrong: Creates node even when out of range
def build(min_val, max_val):
    val = preorder[self.index]
    self.index += 1  # Always advances!
    node = TreeNode(val)
    # ...

# ‚úÖ Correct: Check range BEFORE advancing index
def build(min_val, max_val):
    if self.index >= len(preorder):
        return None
    val = preorder[self.index]
    if val < min_val or val > max_val:
        return None  # Don't advance index!
    
    self.index += 1
    node = TreeNode(val)
    # ...
```

---

## üìù Practice Problems (Progressive)

### Easy (Build up)
- [ ] [Sorted Array to BST (LC 108)](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/) - Simpler construction

### Medium (Apply pattern)
- [ ] [Preorder to BST (LC 1008)](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/) - This problem
- [ ] [Serialize/Deserialize BST (LC 449)](https://leetcode.com/problems/serialize-and-deserialize-bst/) - Uses preorder
- [ ] [Verify Preorder BST (LC 255)](https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/) - Validation

### Hard (Master)
- [ ] [Construct from Pre+Inorder (LC 105)](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) - General tree

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand range-based approach
- **Day 3:** Implement from scratch
- **Day 7:** Implement monotonic stack version
- **Day 14:** Apply to serialize/deserialize
- **Day 30:** Compare with general tree construction

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"In preorder, the first element is always the root. For a BST, I know left subtree values must be smaller than root, right subtree values must be larger. I'll use a range constraint: as I traverse preorder, each node must fall within an allowed range based on its ancestors."

**Key points:**
1. "Preorder = root comes first"
2. "BST property tells us which elements go left vs right"
3. "Range constraints propagate down the tree"
4. "O(n) time because each element processed once"

**Common follow-up:**
"Why is range-based O(n) but split-finding O(n¬≤)?"
"Range-based uses a single pass with index. Split-finding scans the remaining array at each level, which compounds."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common BST question |
| Google | ‚≠ê‚≠ê‚≠ê | May ask for optimal |
| Meta | ‚≠ê‚≠ê‚≠ê | Tree construction |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Frequently asked |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 3-4 min | Preorder ‚Üí BST |
| Explain approach | 3-5 min | Range constraints |
| Code solution | 10-12 min | Range-based |
| Trace example | 3-5 min | Show correctness |
| Total interview time | 20-25 min | Medium difficulty |

---

## üí° Key Insight

> **BST property eliminates ambiguity.** Unlike general trees (which need two traversals), a BST's ordering constraint uniquely determines the structure from preorder alone. Each value's position is constrained by its ancestors' values.

---

## üîó Related

- **Previous:** [Sorted Array to BST (LC 108)](./6.1-Sorted-Array-to-BST-LC108.md)
- **Related:** [Validate BST (LC 98)](../03-BST-Validation/3.1-Validate-BST-LC98.md)
- **Uses:** Range-based DFS
- **Advanced:** [Construct Tree Pre+In (LC 105)](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
