# 7.1 Find Middle of Linked List (LC 876)

> **Grokking Pattern:** Fast & Slow Pointers
>
> **Difficulty:** Easy | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very High

---

## Problem Statement

Given the head of a singly linked list, return the **middle node** of the linked list.

If there are two middle nodes, return the **second middle** node.

```
Input:  1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5
Output: Node(3) (index 2)

Input:  1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6
Output: Node(4) (second middle)
```

[LeetCode 876 - Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- Need to find a position relative to list length
- Unknown list length (can't use array indexing)
- Want O(1) space solution

**Keywords in problem statement:**
- "middle", "halfway", "center"
- "without knowing length"

**This is the simplest fast & slow pointer problem:**
- Fast moves 2x, slow moves 1x
- When fast reaches end, slow is at middle

</details>

---

## ‚úÖ When to Use This Approach

- Finding middle of linked list
- As a step in other algorithms (merge sort, palindrome check)
- When you can't traverse twice or store length

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Array input | Direct indexing works | `arr[len/2]` |
| Know length | Simple math | Traverse to `length/2` |
| Need first middle | Different termination | Modified condition |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Linked List Basics](../01-Singly-LL/1.1-Basics.md)
- [Fast & Slow Concept](../04-Fast-Slow-Pointer/4.1-Concept.md)

**After mastering this:**
- [Palindrome Linked List](./7.4-Palindrome-Check.md) - Uses middle finding
- [Sort List](https://leetcode.com/problems/sort-list/) - LC 148
- [Reorder List](https://leetcode.com/problems/reorder-list/) - LC 143

**This is a building block for:**
- Splitting lists for merge sort
- Checking if list is palindrome
- Finding middle for reordering

</details>

---

## üìê How It Works

### The Key Insight

When fast pointer moves 2 steps for every 1 step slow takes:
- Fast covers 2x the distance
- When fast reaches end (2n steps), slow is at middle (n steps)

### Visualization - Odd Length

```
Start:  [1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí [5] ‚Üí null
         S
         F

Step 1: [1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí [5] ‚Üí null
               S
                     F

Step 2: [1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí [5] ‚Üí null
                     S
                                 F

F.next is null ‚Üí stop
S is at middle (3) ‚úì
```

### Visualization - Even Length

```
Start:  [1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí [5] ‚Üí [6] ‚Üí null
         S
         F

Step 1: [1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí [5] ‚Üí [6] ‚Üí null
               S
                     F

Step 2: [1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí [5] ‚Üí [6] ‚Üí null
                     S
                                 F

Step 3: [1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí [5] ‚Üí [6] ‚Üí null
                           S
                                             F‚Üínull

F is null ‚Üí stop
S is at second middle (4) ‚úì
```

---

## üíª Code Implementation

### Second Middle (LeetCode Default)

**Python:**

```python
def middle_node(head: ListNode) -> ListNode:
    """
    Find the middle node of a linked list.
    For even length, returns second middle.
    
    Pattern: Fast & Slow Pointers
    Time: O(n), Space: O(1)
    """
    slow = head
    fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow
```

**JavaScript:**

```javascript
function middleNode(head) {
    let slow = head;
    let fast = head;
    
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    return slow;
}
```

### First Middle (For Splitting Lists)

When splitting a list into two halves for merge sort, you often want the **first middle** to ensure equal or near-equal splits:

```python
def first_middle(head: ListNode) -> ListNode:
    """
    For even length, returns first middle.
    Useful for splitting lists equally.
    
    List: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí null
    First middle: 2 (to get [1,2] and [3,4])
    Second middle: 3
    """
    slow = head
    fast = head
    
    # Stop when fast.next.next is null (one step earlier)
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow
```

---

## ‚ö° Complexity Analysis

| Metric | Value | Explanation |
|--------|-------|-------------|
| Time |" O(n) "| Fast traverses at most n nodes |
| Space |" O(1) "| Only two pointers |

**Why O(n):**
- Fast pointer makes n/2 iterations (moves 2 each time)
- Slow pointer makes n/2 iterations (moves 1 each time)
- Total operations: O(n)

---

## üîÑ Variations

| Variation | Difference | Use Case |
|-----------|------------|----------|
| Second middle | Standard LC 876 | General |
| First middle | Stop one step earlier | List splitting |
| Middle with length | Return position too | When index needed |
| Middle of sublist | Given start/end | Partial list operations |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Termination for First vs Second Middle

```python
# For SECOND middle (LC default)
while fast and fast.next:  # ‚úì

# For FIRST middle (splitting)
while fast.next and fast.next.next:  # ‚úì
```

### 2. Not Handling Single Node

```python
# Single node: head is the middle
# Both conditions work correctly because:
# fast = head, fast.next = null ‚Üí loop doesn't run
# slow stays at head ‚Üí correct!
```

### 3. Off-By-One in Understanding

```
List: [1, 2, 3, 4, 5, 6]
Indices: 0  1  2  3  4  5

First middle = index 2 (value 3)
Second middle = index 3 (value 4)

LeetCode wants: second middle (index 3)
```

---

## üìù Practice Problems (Progressive)

### Easy (This problem)
- [ ] [Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) - LC 876 ‚≠ê
- [ ] [Delete the Middle Node of a Linked List](https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/) - LC 2095

### Medium (Uses middle finding)
- [ ] [Reorder List](https://leetcode.com/problems/reorder-list/) - LC 143
- [ ] [Sort List](https://leetcode.com/problems/sort-list/) - LC 148
- [ ] [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/) - LC 234

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement from scratch, test odd/even lengths
- **Day 3:** Implement first middle variant
- **Day 7:** Use in a larger problem (Sort List)
- **Day 14:** Explain why fast/slow works mathematically
- **Day 30:** Apply in Reorder List problem

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
> "I'll use the fast and slow pointer technique. Fast moves 2 steps while slow moves 1, so when fast reaches the end, slow is at the middle."

**Clarify which middle:**
> "For even-length lists, should I return the first or second middle? LeetCode returns the second."

**Complexity explanation:**
> "Time is O(n) since fast traverses at most n nodes. Space is O(1) with just two pointers."

**Common follow-ups:**
- "Can you do it in one pass?" ‚Üí This IS one pass
- "What if length is known?" ‚Üí Just traverse to n/2
- "First middle instead?" ‚Üí Adjust termination condition

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common warm-up |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Building block for harder problems |
| Google | ‚≠ê‚≠ê‚≠ê | May combine with other operations |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Classic interview question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand | 2-3 min | Simple concept |
| Implement | 3-5 min | Few lines of code |
| Test edge cases | 2-3 min | Single node, two nodes |
| Interview target | 5-10 min | Including explanation |

---

> **üí° Key Insight:** Fast & Slow works because of the 2:1 speed ratio. When fast completes the full distance, slow has covered exactly half. This principle extends to other problems like cycle detection.

---

## üîó Related

- [Fast & Slow Pointer Concept](../04-Fast-Slow-Pointer/4.1-Concept.md) - Pattern overview
- [Palindrome Check](./7.4-Palindrome-Check.md) - Uses this technique
- [Linked List Cycle](../04-Fast-Slow-Pointer/4.2-Cycle-Problems/01-Cycle-Detection.md) - Same pattern, different use
