# Top K Frequent Elements (LeetCode 347)

> **Frequency counting meets sorting - find the k most common elements efficiently.**

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.

**Follow-up:** Your algorithm's time complexity must be better than O(n log n).

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem signals:**
- "Top K", "K most frequent", "K largest/smallest"
- Ranking by frequency
- Output order doesn't matter (just the elements)

**This combines two patterns:**
1. **Frequency Counting** - Count occurrences with hash map
2. **Selection** - Find top K from frequencies

**Selection approaches:**
- Heap: O(n log k)
- Bucket Sort: O(n)
- QuickSelect: O(n) average

</details>

---

## ‚úÖ When to Use

- Finding top K elements by some criteria
- K is smaller than n (if k ‚âà n, just sort)
- Need better than O(n log n)

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need sorted output | Additional sorting needed | Sort after finding |
| k ‚âà n | Overhead not worth it | Simple sorting |
| Streaming data | Can't recount | Streaming algorithm |
| Exact k-th element | Different problem | QuickSelect |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- [Frequency Counting](./3.1-Frequency-Overview.md)
- [Heap/Priority Queue](../../08-Heaps-Priority-Queues/01-Heap-Fundamentals/1.1-What-Is-Heap.md)
- Bucket Sort concept

**After mastering:**
- [Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/) - Alphabetical tiebreaker
- [Kth Largest Element](https://leetcode.com/problems/kth-largest-element-in-an-array/) - QuickSelect
- [Sort Characters by Frequency](https://leetcode.com/problems/sort-characters-by-frequency/)

**Combines with:**
- Heap for efficient selection
- Bucket Sort for O(n) solution

</details>

---

## üìê How It Works

### Problem Examples

```
Example 1:
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2] (or [2,1] - order doesn't matter)

Example 2:
Input: nums = [1], k = 1
Output: [1]
```

### Approach 1: Heap (O(n log k))

```
nums = [1,1,1,2,2,3], k = 2

Step 1: Count frequencies
        {1:3, 2:2, 3:1}

Step 2: Use min-heap of size k
        Process (1,3): heap = [(3,1)]
        Process (2,2): heap = [(2,2), (3,1)]
        Process (3,1): heap = [(2,2), (3,1)] (1<2, don't add)

Step 3: Extract elements from heap
        Result: [1, 2]
```

### Approach 2: Bucket Sort (O(n))

```
nums = [1,1,1,2,2,3], k = 2

Step 1: Count frequencies
        {1:3, 2:2, 3:1}

Step 2: Create buckets by frequency
        bucket[1] = [3]     (frequency 1)
        bucket[2] = [2]     (frequency 2)
        bucket[3] = [1]     (frequency 3)

Step 3: Collect from highest frequency
        Start at bucket[3]: [1]
        Move to bucket[2]: [1, 2]
        Got k=2 elements, done!

Result: [1, 2]
```

### Visualization: Bucket Sort Approach

```
nums = [1,1,1,2,2,3], k = 2
n = 6 (max possible frequency)

Frequencies: {1:3, 2:2, 3:1}

Buckets (index = frequency):
‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 0 ‚îÇ 1 ‚îÇ 2 ‚îÇ 3 ‚îÇ 4 ‚îÇ 5 ‚îÇ 6 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚î§
‚îÇ - ‚îÇ[3]‚îÇ[2]‚îÇ[1]‚îÇ - ‚îÇ - ‚îÇ - ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò

Scan right to left (high to low frequency):
bucket[6]: empty
bucket[5]: empty
bucket[4]: empty
bucket[3]: [1] ‚Üí add to result
bucket[2]: [2] ‚Üí add to result
Result has k=2 elements, done!

Answer: [1, 2]
```

---

## üíª Code Implementation

### Python - Bucket Sort (O(n))

```python
from collections import Counter
from typing import List

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        """
        Find k most frequent elements using bucket sort.
        
        Time: O(n) - counting + bucket creation + collection
        Space: O(n) - frequency map + buckets
        """
        # Step 1: Count frequencies
        freq = Counter(nums)
        
        # Step 2: Create buckets (index = frequency)
        # Max frequency is at most n (if all elements are same)
        n = len(nums)
        buckets = [[] for _ in range(n + 1)]
        
        for num, count in freq.items():
            buckets[count].append(num)
        
        # Step 3: Collect k elements from highest frequency
        result = []
        for i in range(n, 0, -1):  # Scan from high to low
            for num in buckets[i]:
                result.append(num)
                if len(result) == k:
                    return result
        
        return result
```

### Python - Heap (O(n log k))

```python
import heapq
from collections import Counter
from typing import List

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        """
        Find k most frequent using min-heap of size k.
        
        Time: O(n log k)
        Space: O(n + k)
        """
        # Count frequencies
        freq = Counter(nums)
        
        # Use min-heap of size k
        # Keep k largest by removing smallest when heap > k
        return heapq.nlargest(k, freq.keys(), key=freq.get)
    
    def topKFrequent_manual_heap(self, nums: List[int], k: int) -> List[int]:
        """Manual heap implementation for understanding."""
        freq = Counter(nums)
        
        # Min-heap: (frequency, number)
        min_heap = []
        
        for num, count in freq.items():
            heapq.heappush(min_heap, (count, num))
            
            # Keep only k largest
            if len(min_heap) > k:
                heapq.heappop(min_heap)
        
        return [num for count, num in min_heap]
```

### Python - Counter.most_common (Pythonic)

```python
from collections import Counter
from typing import List

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        """
        Most Pythonic solution using Counter.most_common().
        
        Time: O(n log n) - Counter uses sorting internally
        Space: O(n)
        """
        return [num for num, count in Counter(nums).most_common(k)]
```

### JavaScript - Bucket Sort

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function(nums, k) {
    // Step 1: Count frequencies
    const freq = new Map();
    for (const num of nums) {
        freq.set(num, (freq.get(num) || 0) + 1);
    }
    
    // Step 2: Create buckets (index = frequency)
    const n = nums.length;
    const buckets = Array.from({ length: n + 1 }, () => []);
    
    for (const [num, count] of freq) {
        buckets[count].push(num);
    }
    
    // Step 3: Collect k elements from highest frequency
    const result = [];
    for (let i = n; i > 0 && result.length < k; i--) {
        for (const num of buckets[i]) {
            result.push(num);
            if (result.length === k) return result;
        }
    }
    
    return result;
};
```

### JavaScript - Heap Approach

```javascript
var topKFrequent = function(nums, k) {
    // Count frequencies
    const freq = new Map();
    for (const num of nums) {
        freq.set(num, (freq.get(num) || 0) + 1);
    }
    
    // Sort by frequency and take top k
    return [...freq.entries()]
        .sort((a, b) => b[1] - a[1])
        .slice(0, k)
        .map(([num]) => num);
};
```

### JavaScript - With Custom Min-Heap

```javascript
class MinHeap {
    constructor(compareFn) {
        this.heap = [];
        this.compare = compareFn || ((a, b) => a - b);
    }
    
    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        if (this.heap.length === 0) return undefined;
        const top = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return top;
    }
    
    peek() { return this.heap[0]; }
    size() { return this.heap.length; }
    
    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.compare(this.heap[parent], this.heap[i]) <= 0) break;
            [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
            i = parent;
        }
    }
    
    _bubbleDown(i) {
        while (true) {
            let smallest = i;
            const left = 2 * i + 1, right = 2 * i + 2;
            if (left < this.heap.length && this.compare(this.heap[left], this.heap[smallest]) < 0) smallest = left;
            if (right < this.heap.length && this.compare(this.heap[right], this.heap[smallest]) < 0) smallest = right;
            if (smallest === i) break;
            [this.heap[smallest], this.heap[i]] = [this.heap[i], this.heap[smallest]];
            i = smallest;
        }
    }
}

var topKFrequent = function(nums, k) {
    const freq = new Map();
    for (const num of nums) {
        freq.set(num, (freq.get(num) || 0) + 1);
    }
    
    // Min-heap by frequency
    const minHeap = new MinHeap((a, b) => a[1] - b[1]);
    
    for (const [num, count] of freq) {
        minHeap.push([num, count]);
        if (minHeap.size() > k) {
            minHeap.pop();
        }
    }
    
    return minHeap.heap.map(([num]) => num);
};
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Bucket Sort | O(n) | O(n) | Best for this problem |
| Heap (size k) | O(n log k) | O(n + k) | Good when k << n |
| Sort all | O(n log n) | O(n) | Simple but slower |
| QuickSelect | O(n) avg | O(n) | Alternative O(n) |

**Bucket Sort Analysis:**
- Counting: O(n)
- Bucket creation: O(unique elements) ‚â§ O(n)
- Collection: O(n) in worst case
- Total: O(n)

**Heap Analysis:**
- Counting: O(n)
- Heap operations: O(unique √ó log k)
- Total: O(n log k) when unique ‚âà n

---

## üîÑ Variations

| Variation | Difference | Link |
|-----------|------------|------|
| Top K Frequent Words | Alphabetical tiebreaker | [LC 692](https://leetcode.com/problems/top-k-frequent-words/) |
| Kth Largest Element | Single element, not k elements | [LC 215](https://leetcode.com/problems/kth-largest-element-in-an-array/) |
| Sort by Frequency | Full sort, not just top k | [LC 451](https://leetcode.com/problems/sort-characters-by-frequency/) |
| K Closest Points | Distance-based ranking | [LC 973](https://leetcode.com/problems/k-closest-points-to-origin/) |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Wrong Heap Type

```python
# ‚ùå WRONG: Max-heap removes largest, keeping smallest
# We want to keep k LARGEST frequencies!

# ‚úÖ CORRECT: Use min-heap of size k
# Pop smallest, keeping k largest
heap = []
for num, count in freq.items():
    heapq.heappush(heap, (count, num))  # Min-heap by count
    if len(heap) > k:
        heapq.heappop(heap)  # Remove smallest
```

### 2. Not Handling Ties in Top K Words

```python
# For LC 692 (words), ties are broken alphabetically
# ‚ùå WRONG: Just sort by frequency
# ‚úÖ CORRECT: Sort by (-freq, word) for tie-breaking
```

### 3. Off-by-One in Bucket Sort

```python
# ‚ùå WRONG: Buckets of size n
buckets = [[] for _ in range(n)]  # Indices 0 to n-1

# ‚úÖ CORRECT: Buckets of size n+1 (frequency can be n)
buckets = [[] for _ in range(n + 1)]  # Indices 0 to n
```

### 4. Returning Frequencies Instead of Elements

```python
# ‚ùå WRONG: Return (count, num) pairs
return heapq.nlargest(k, freq.items(), key=lambda x: x[1])

# ‚úÖ CORRECT: Return just the numbers
return [num for num, count in heapq.nlargest(k, freq.items(), key=lambda x: x[1])]
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Link | Notes |
|---------|------------|------|-------|
| Top K Frequent Elements | üü° Medium | [LC 347](https://leetcode.com/problems/top-k-frequent-elements/) | This problem |
| Top K Frequent Words | üü° Medium | [LC 692](https://leetcode.com/problems/top-k-frequent-words/) | Tie-breaking |
| Kth Largest Element | üü° Medium | [LC 215](https://leetcode.com/problems/kth-largest-element-in-an-array/) | QuickSelect |
| Sort Characters by Frequency | üü° Medium | [LC 451](https://leetcode.com/problems/sort-characters-by-frequency/) | Build result string |
| K Closest Points | üü° Medium | [LC 973](https://leetcode.com/problems/k-closest-points-to-origin/) | Distance ranking |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve LC 347 with bucket sort
- **Day 3:** Solve with heap approach
- **Day 7:** Solve LC 692 (words with tie-breaking)
- **Day 14:** Solve LC 215 with QuickSelect
- **Day 30:** Should implement bucket sort in < 5 min

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interview</strong></summary>

**Clarify:**
> "Are all inputs valid? Is k always ‚â§ number of unique elements? Can I return elements in any order?"

**Approach options:**
> "I see three approaches:
> 1. Sort by frequency: O(n log n) - simple but doesn't meet follow-up
> 2. Heap of size k: O(n log k) - better when k is small
> 3. Bucket sort: O(n) - optimal, uses frequency as bucket index"

**Explain bucket sort:**
> "Since frequency ranges from 1 to n, I can create n+1 buckets. Each bucket[i] holds elements with frequency i. Then I scan from highest bucket to get top k."

**Trade-offs:**
> "Bucket sort is O(n) but uses O(n) space for buckets. Heap is O(n log k) but more space efficient when there are many unique elements."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Often asks follow-up |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Expects O(n) solution |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Common Top K problem |

---

## ‚è±Ô∏è Time Estimates

| Activity | Target Time |
|----------|-------------|
| Heap solution | 10-12 min |
| Bucket sort solution | 8-10 min |
| With complexity discussion | 15 min |

---

> **üí° Key Insight:** Bucket sort achieves O(n) because frequencies are bounded by n. Using frequency as array index lets us "sort" without comparison, avoiding O(n log n).

> **üîó Related:** [Frequency Overview](./3.1-Frequency-Overview.md) | [Heap Patterns](../../08-Heaps-Priority-Queues/04-Top-K-Pattern/4.1-Top-K-Overview.md) | [Kth Largest](https://leetcode.com/problems/kth-largest-element-in-an-array/)
