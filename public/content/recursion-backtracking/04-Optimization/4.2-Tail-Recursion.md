# 4.2 Tail Recursion

> **Stack-Safe Recursion Through Tail Call Optimization**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê - Understanding matters more than implementation  
> **Prerequisites:** [1.1 Recursion Basics](../01-Recursion/1.1-Recursion-Basics.md)

---

## Overview

**Tail Recursion** is when the recursive call is the **last operation** in the function. This allows compilers/interpreters to optimize the recursion into a loop, preventing stack overflow.

```
Regular recursion:     return n * factorial(n-1)  ‚Üê Must wait for result
Tail recursion:        return factorial(n-1, n*acc)  ‚Üê Nothing after call
```

The key insight: **If there's nothing to do after the recursive call, we don't need to keep the stack frame.**

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Tail Recursion</strong></summary>

**Look for these signals:**
- Deep recursion that might cause stack overflow
- Accumulator pattern possible (carry result forward)
- Language supports Tail Call Optimization (TCO)
- Converting recursion to iteration style

**Tail call definition:**
```python
# TAIL CALL - recursive call is the LAST thing
def tail_func(n, acc):
    return tail_func(n-1, n*acc)  # ‚úÖ Nothing after return

# NOT TAIL CALL - operations after recursive call
def regular_func(n):
    return n * regular_func(n-1)  # ‚ùå Multiplication happens AFTER
```

**Languages with TCO:**
| Language | TCO Support |
|----------|-------------|
| Scheme/Lisp | ‚úÖ Guaranteed |
| Scala | ‚úÖ With @tailrec |
| JavaScript | ‚ö†Ô∏è Only Safari (ES6 spec, rarely implemented) |
| Python | ‚ùå Not supported |
| Java | ‚ùå Not supported |

</details>

---

## ‚úÖ When to Use

- **Functional languages** (Scheme, Haskell, Scala) - TCO is guaranteed
- **Preventing stack overflow** - Deep recursion becomes safe
- **Educational purposes** - Understanding recursion deeply
- **Manual optimization** - Even without TCO, the pattern helps convert to loops
- **Scala with @tailrec** - Compiler enforces and optimizes

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Python/Java/Most languages | Iteration | No TCO support |
| Multiple recursive calls | Memoization | Can't tail-optimize tree recursion |
| Need return values from subcalls | Regular recursion | Tail recursion accumulates forward |
| Simple problems | Regular recursion | Premature optimization |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Recursion Basics](../01-Recursion/1.1-Recursion-Basics.md)
- [Recursion Patterns](../01-Recursion/1.2-Recursion-Patterns.md)

**After mastering this:**
- [Memoization](./4.1-Memoization.md) - Different optimization
- [Iteration Conversion](../../00-Prerequisites.md) - Manual loop conversion

**Combines with:**
- Accumulator pattern
- Continuation-passing style (advanced)
- Trampoline technique (workaround for no TCO)

</details>

---

## üìê How It Works

### Regular vs Tail Recursion

```
REGULAR RECURSION - factorial(4):

Call Stack:
  factorial(4) ‚Üí waiting for factorial(3) * 4
    factorial(3) ‚Üí waiting for factorial(2) * 3
      factorial(2) ‚Üí waiting for factorial(1) * 2
        factorial(1) ‚Üí returns 1
      returns 1 * 2 = 2
    returns 2 * 3 = 6
  returns 6 * 4 = 24

Stack depth: 4 frames (grows with n)


TAIL RECURSION - factorial(4, acc=1):

With TCO:
  factorial(4, 1) ‚Üí factorial(3, 4)    [reuses same frame]
  factorial(3, 4) ‚Üí factorial(2, 12)   [reuses same frame]
  factorial(2, 12) ‚Üí factorial(1, 24)  [reuses same frame]
  factorial(1, 24) ‚Üí returns 24

Stack depth: 1 frame (constant!)
```

### The Accumulator Pattern

```
Key transformation:
- Regular: compute AFTER recursive call returns
- Tail: compute BEFORE recursive call, pass result as parameter

factorial(n):
  if n <= 1: return 1
  return n * factorial(n-1)     ‚Üê Compute after

factorial_tail(n, acc=1):
  if n <= 1: return acc         ‚Üê Return accumulator
  return factorial_tail(n-1, n*acc)  ‚Üê Compute before, pass forward
```

### Visualization

```
Regular factorial(4):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ factorial(4)                    ‚îÇ
‚îÇ   ‚îî‚îÄ 4 * factorial(3)          ‚îÇ
‚îÇ         ‚îî‚îÄ 3 * factorial(2)    ‚îÇ
‚îÇ               ‚îî‚îÄ 2 * factorial(1)
‚îÇ                     ‚îî‚îÄ 1       ‚îÇ
‚îÇ               ‚îî‚îÄ 2 * 1 = 2     ‚îÇ
‚îÇ         ‚îî‚îÄ 3 * 2 = 6           ‚îÇ
‚îÇ   ‚îî‚îÄ 4 * 6 = 24                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Work done on the way UP (unwinding)


Tail factorial(4, 1):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ factorial(4, 1)                 ‚îÇ
‚îÇ   ‚Üí factorial(3, 4)    [4*1]   ‚îÇ
‚îÇ   ‚Üí factorial(2, 12)   [3*4]   ‚îÇ
‚îÇ   ‚Üí factorial(1, 24)   [2*12]  ‚îÇ
‚îÇ   ‚Üí return 24                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Work done on the way DOWN (no unwinding needed)
```

---

## üíª Code Implementation

### Example 1: Factorial

**Regular Recursion:**
```python
def factorial(n: int) -> int:
    """
    Standard factorial - NOT tail recursive.
    Stack grows to O(n).
    """
    if n <= 1:
        return 1
    return n * factorial(n - 1)  # Work after recursive call
```

**Tail Recursive:**
```python
def factorial_tail(n: int, acc: int = 1) -> int:
    """
    Tail recursive factorial with accumulator.
    
    acc carries the running product forward.
    In languages with TCO, stack is O(1).
    """
    if n <= 1:
        return acc
    return factorial_tail(n - 1, n * acc)  # Nothing after call


# Both give same result
print(factorial(5))       # 120
print(factorial_tail(5))  # 120
```

**JavaScript:**
```javascript
// Regular
function factorial(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

// Tail recursive
function factorialTail(n, acc = 1) {
    if (n <= 1) return acc;
    return factorialTail(n - 1, n * acc);
}

console.log(factorialTail(5)); // 120
```

---

### Example 2: Sum of Array

**Regular:**
```python
def sum_array(arr: list[int]) -> int:
    """Non-tail recursive sum."""
    if not arr:
        return 0
    return arr[0] + sum_array(arr[1:])  # Addition after call
```

**Tail Recursive:**
```python
def sum_array_tail(arr: list[int], acc: int = 0) -> int:
    """Tail recursive sum with accumulator."""
    if not arr:
        return acc
    return sum_array_tail(arr[1:], acc + arr[0])


print(sum_array_tail([1, 2, 3, 4, 5]))  # 15
```

```javascript
function sumArrayTail(arr, acc = 0) {
    if (arr.length === 0) return acc;
    return sumArrayTail(arr.slice(1), acc + arr[0]);
}

console.log(sumArrayTail([1, 2, 3, 4, 5])); // 15
```

---

### Example 3: Fibonacci (Two Accumulators)

**Regular (Exponential):**
```python
def fib(n: int) -> int:
    """O(2^n) - tree recursion, not tail recursive."""
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)
```

**Tail Recursive:**
```python
def fib_tail(n: int, a: int = 0, b: int = 1) -> int:
    """
    Tail recursive Fibonacci with two accumulators.
    
    a = fib(current), b = fib(current + 1)
    Time: O(n), Space: O(1) with TCO
    """
    if n == 0:
        return a
    if n == 1:
        return b
    return fib_tail(n - 1, b, a + b)


print(fib_tail(10))  # 55
print(fib_tail(50))  # 12586269025
```

```javascript
function fibTail(n, a = 0, b = 1) {
    if (n === 0) return a;
    if (n === 1) return b;
    return fibTail(n - 1, b, a + b);
}

console.log(fibTail(50)); // 12586269025
```

---

### Example 4: Reverse a List

```python
def reverse_tail(arr: list, acc: list = None) -> list:
    """Tail recursive list reversal.
    
    Note: arr[1:] creates a new list each call, making this O(n¬≤) overall.
    In practice, use index-based approach for O(n).
    """
    if acc is None:
        acc = []
    
    if not arr:
        return acc
    
    return reverse_tail(arr[1:], [arr[0]] + acc)


# More efficient: index-based (O(n) time)
def reverse_tail_efficient(arr: list, i: int = 0, acc: list = None) -> list:
    if acc is None:
        acc = []
    if i >= len(arr):
        return acc
    return reverse_tail_efficient(arr, i + 1, [arr[i]] + acc)


print(reverse_tail([1, 2, 3, 4, 5]))  # [5, 4, 3, 2, 1]
```

```javascript
function reverseTail(arr, acc = []) {
    if (arr.length === 0) return acc;
    return reverseTail(arr.slice(1), [arr[0], ...acc]);
}

console.log(reverseTail([1, 2, 3, 4, 5])); // [5, 4, 3, 2, 1]
```

---

## üíª Converting to Iteration

Since Python/JS don't optimize tail calls, convert to loops:

```python
# Tail recursive (conceptual)
def factorial_tail(n, acc=1):
    if n <= 1:
        return acc
    return factorial_tail(n - 1, n * acc)

# Converted to loop (practical)
def factorial_iterative(n):
    acc = 1
    while n > 1:
        acc = n * acc
        n = n - 1
    return acc


# The transformation is mechanical:
# 1. Parameters become loop variables
# 2. Recursive call becomes loop iteration
# 3. Base case becomes loop exit
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Regular recursion |" O(n) "| O(n) | Stack grows linearly |
| Tail recursion (with TCO) |" O(n) "| O(1) | Stack reused |
| Tail recursion (no TCO) |" O(n) "| O(n) | Still grows stack |
| Iterative |" O(n) "| O(1) | Always optimal |

**Key insight:** Tail recursion only saves space if the language supports TCO!

---

## üîÑ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| **Single accumulator** | Carry one value forward | Sum, factorial, length |
| **Multiple accumulators** | Carry multiple values | Fibonacci, partition |
| **List accumulator** | Build result list | Reverse, filter, map |
| **Trampoline** | Workaround for no TCO | Python/JS deep recursion |

### Trampoline Technique (Advanced)

For languages without TCO, trampolining simulates it:

```python
def trampoline(fn):
    """Execute tail-recursive function without stack growth."""
    while callable(fn):
        fn = fn()
    return fn


def factorial_trampoline(n, acc=1):
    if n <= 1:
        return acc
    return lambda: factorial_trampoline(n - 1, n * acc)


# Usage
result = trampoline(factorial_trampoline(1000))
print(result)  # Works without stack overflow!
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Operations After Recursive Call

‚ùå **Not tail recursive:**
```python
def factorial(n, acc=1):
    if n <= 1:
        return acc
    result = factorial(n - 1, n * acc)
    return result  # Even this is fine, BUT:
    
def factorial_bad(n):
    if n <= 1:
        return 1
    return n * factorial_bad(n - 1)  # ‚ùå Multiplication AFTER call
```

‚úÖ **Tail recursive:**
```python
def factorial(n, acc=1):
    if n <= 1:
        return acc
    return factorial(n - 1, n * acc)  # ‚úÖ Call is the LAST thing
```

### 2. Forgetting Base Case Returns Accumulator

‚ùå **Wrong:**
```python
def sum_tail(arr, acc=0):
    if not arr:
        return 0  # ‚ùå Throws away accumulated work!
```

‚úÖ **Correct:**
```python
def sum_tail(arr, acc=0):
    if not arr:
        return acc  # ‚úÖ Return the accumulated result
```

### 3. Assuming Python Has TCO

‚ùå **Wrong assumption:**
```python
# This WILL cause RecursionError for large n in Python!
def deep_recursion(n, acc=0):
    if n == 0:
        return acc
    return deep_recursion(n - 1, acc + 1)

deep_recursion(10000)  # RecursionError!
```

‚úÖ **Solution for Python:**
```python
import sys
sys.setrecursionlimit(20000)  # Hack, not recommended

# Better: Convert to iteration
def deep_iteration(n):
    acc = 0
    while n > 0:
        acc += 1
        n -= 1
    return acc
```

---

## üìù Practice Problems

### Easy (Understand the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Fibonacci Number | Two accumulators | [LC 509](https://leetcode.com/problems/fibonacci-number/) |
| Climbing Stairs | Same as Fibonacci | [LC 70](https://leetcode.com/problems/climbing-stairs/) |
| Reverse String | List accumulator | [LC 344](https://leetcode.com/problems/reverse-string/) |

### Medium (Apply the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Power of Two | Tail recursive check | [LC 231](https://leetcode.com/problems/power-of-two/) |
| Sum of Two Integers | Bit manipulation + recursion | [LC 371](https://leetcode.com/problems/sum-of-two-integers/) |

### Practice Conversions

Convert these to tail recursive form:
1. `sum(n) = 1 + 2 + ... + n`
2. `gcd(a, b)` (Euclidean algorithm - already tail recursive!)
3. `reverse(string)`
4. `contains(list, target)`

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: Understand factorial conversion
- Day 3: Practice Fibonacci with two accumulators
- Day 5: Convert sum/reverse to tail recursive

**Week 2:**
- Day 8: Implement trampoline
- Day 10: Convert 3 problems to iterative
- Day 14: Review, understand when to use

**Key Questions:**
1. Is this recursive call the LAST operation?
2. What should my accumulator(s) store?
3. Does my language support TCO?

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**When to mention tail recursion:**
> "I could write this as tail recursive, which would allow tail call optimization in languages like Scala. Since we're using Python/Java, I'll write it iteratively for the same O(1) space."

**Showing understanding:**
> "The key difference is that tail recursion does all the work on the way DOWN (using an accumulator), while regular recursion does work on the way UP (after the recursive call returns)."

**If asked "Can you optimize the space?":**
> "This recursive solution uses O(n) stack space. I can convert it to tail recursive form, and then to an iterative loop for O(1) space."

**Company Focus:**

| Company | Tail Recursion Relevance |
|---------|-------------------------|
| Google | Understanding valued, rarely practical |
| Amazon | Convert to iteration preferred |
| Meta | Know the concept |
| Functional shops | Highly valued (Scala, Haskell) |

**Key interview insight:**
> Interviewers care more that you understand WHY tail recursion matters (stack space, optimization) than that you can write it. Always mention that Python/Java don't support TCO and offer iteration instead.

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 30-45 min | Visualization helps |
| Convert factorial/sum | 10-15 min | Basic pattern |
| Fibonacci with 2 accumulators | 20-30 min | Trickier |
| Trampoline implementation | 30-45 min | Advanced |
| Master pattern | 1 week | Practice conversions |

---

## üí° Key Insight

> **Tail Recursion = Iteration in Disguise**
>
> The accumulator pattern transforms "compute on the way up" to "compute on the way down":
> - Regular: `return n * f(n-1)` ‚Üí needs stack to remember n
> - Tail: `return f(n-1, n*acc)` ‚Üí passes result forward, stack unneeded
>
> In languages without TCO (Python, Java), just write iteration directly. The pattern is still useful for understanding recursion deeply.

---

## üîó Related

- [Recursion Basics](../01-Recursion/1.1-Recursion-Basics.md) - Foundation
- [Memoization](./4.1-Memoization.md) - Different optimization strategy
- [Dynamic Programming](../../11-Dynamic-Programming.md) - Bottom-up iteration
- [Striver - Recursion Series](https://www.youtube.com/@takeUforward) - Video explanations
