# Prefix Matching Pattern

> **Find the shortest/longest prefix in the dictionary that matches a word - used for word replacement, IP routing, and dictionary-based transformations.**

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Replace word with its shortest dictionary prefix"
- "Find longest prefix match"
- "Dictionary root/stem matching"
- "IP routing longest prefix match"

**Classic problems:**
- LC 648: Replace Words (shortest prefix)
- LC 720: Longest Word in Dictionary
- IP routing tables (longest prefix)

</details>

---

## ‚úÖ When to Use

| Scenario | Application |
|----------|-------------|
| **Word replacement** | Replace derivatives with roots |
| **IP routing** | Longest prefix match for routing |
| **Stemming** | Find word stems |
| **Autocorrect** | Match closest dictionary prefix |

---

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|-------------------|
| **Exact match only** | Basic search() |
| **All words with prefix** | Collect pattern |
| **Suffix matching** | Suffix trie or reverse |
| **Substring matching** | Different algorithms |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Trie basics](../01-Trie-Fundamentals/1.1-What-Is-Trie.md) - Structure
- [StartsWith](../02-Trie-Operations/3.3-StartsWith-Prefix.md) - Prefix checking

**After mastering this:**
- IP routing implementations
- Stemming algorithms

**Combines with:**
- Sentence processing
- Text normalization

</details>

---

## üìê How It Works

### Shortest Prefix Match

Find the first (shortest) dictionary word that is a prefix of the input.

```
Dictionary: ["cat", "cater", "cattle"]
Input: "catering"

Traversing "catering":
  'c' ‚Üí exists
  'a' ‚Üí exists
  't' ‚Üí exists, is_end=True ("cat") ‚Üí FOUND! Return "cat"

Result: "cat" (shortest prefix)
```

### Longest Prefix Match

Find the longest dictionary word that is a prefix of the input.

```
Dictionary: ["cat", "cater", "cattle"]
Input: "catering"

Traversing "catering":
  'c' ‚Üí exists
  'a' ‚Üí exists
  't' ‚Üí is_end ("cat"), continue
  'e' ‚Üí exists
  'r' ‚Üí is_end ("cater"), continue
  'i' ‚Üí NOT exists, stop

Last match: "cater" (longest prefix)
```

---

## üíª Code Implementation

### Shortest Prefix (LC 648: Replace Words)

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.word = None


class Solution:
    """
    LC 648: Replace Words
    
    Given dictionary of roots and a sentence, replace each word
    with its shortest root that is a prefix.
    """
    
    def replaceWords(self, dictionary: list[str], sentence: str) -> str:
        """
        Time: O(d √ó l + s √ó w) where:
            d = dictionary size, l = avg root length
            s = sentence words, w = avg word length
        Space: O(d √ó l) for trie
        """
        # Build trie from dictionary
        root = self._build_trie(dictionary)
        
        # Replace each word in sentence
        words = sentence.split()
        result = []
        
        for word in words:
            replacement = self._find_shortest_prefix(root, word)
            result.append(replacement if replacement else word)
        
        return ' '.join(result)
    
    def _build_trie(self, words: list[str]) -> TrieNode:
        """Build trie from word list."""
        root = TrieNode()
        for word in words:
            node = root
            for char in word:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
            node.word = word
        return root
    
    def _find_shortest_prefix(self, root: TrieNode, word: str) -> str:
        """
        Find shortest dictionary prefix of word.
        Returns None if no prefix found.
        """
        node = root
        
        for char in word:
            # No path forward - no prefix exists
            if char not in node.children:
                return None
            
            node = node.children[char]
            
            # Found a word - this is the shortest prefix!
            if node.word is not None:
                return node.word
        
        # Reached end of word, check if it's in dictionary
        return node.word


# Usage:
# sol = Solution()
# dict = ["cat", "bat", "rat"]
# sentence = "the cattle was rattled by the battery"
# print(sol.replaceWords(dict, sentence))
# Output: "the cat was rat by the bat"
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = new Map();
        this.word = null;
    }
}

class Solution {
    replaceWords(dictionary, sentence) {
        const root = this._buildTrie(dictionary);
        
        return sentence.split(' ')
            .map(word => this._findShortestPrefix(root, word) || word)
            .join(' ');
    }
    
    _buildTrie(words) {
        const root = new TrieNode();
        for (const word of words) {
            let node = root;
            for (const char of word) {
                if (!node.children.has(char)) {
                    node.children.set(char, new TrieNode());
                }
                node = node.children.get(char);
            }
            node.word = word;
        }
        return root;
    }
    
    _findShortestPrefix(root, word) {
        let node = root;
        
        for (const char of word) {
            if (!node.children.has(char)) {
                return null;
            }
            
            node = node.children.get(char);
            
            if (node.word !== null) {
                return node.word;  // Shortest prefix found
            }
        }
        
        return node.word;
    }
}
```

---

### Longest Prefix Match

**Python:**
```python
class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def find_longest_prefix(self, word: str) -> str:
        """
        Find longest dictionary word that is a prefix of word.
        
        Time: O(m) where m = len(word)
        Space: O(1)
        """
        node = self.root
        longest = None
        
        for char in word:
            if char not in node.children:
                break  # Can't continue
            
            node = node.children[char]
            
            if node.word is not None:
                longest = node.word  # Update longest match
        
        return longest


# Usage for LC 720: Longest Word in Dictionary
class Solution:
    def longestWord(self, words: list[str]) -> str:
        """
        Find longest word that can be built one character at a time.
        Each prefix must also be in dictionary.
        """
        # Build trie
        root = TrieNode()
        for word in words:
            node = root
            for char in word:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
            node.word = word
        
        # DFS to find longest word with all prefixes valid
        result = ""
        
        def dfs(node: TrieNode) -> None:
            nonlocal result
            
            for char in sorted(node.children.keys()):  # Lexicographic order
                child = node.children[char]
                
                # Only continue if this is end of a word (valid prefix chain)
                if child.word is not None:
                    if len(child.word) > len(result):
                        result = child.word
                    dfs(child)
        
        dfs(root)
        return result
```

---

### IP Routing (Longest Prefix Match)

**Python:**
```python
class IPRouter:
    """
    IP routing using longest prefix match.
    
    Simplified for illustration - real IP uses bit-level tries.
    """
    
    def __init__(self):
        self.root = TrieNode()
    
    def add_route(self, prefix: str, next_hop: str) -> None:
        """Add routing rule: prefix -> next_hop."""
        node = self.root
        for char in prefix:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.route = next_hop
    
    def lookup(self, ip: str) -> str:
        """Find next hop for IP using longest prefix match."""
        node = self.root
        best_match = None
        
        for char in ip:
            if char not in node.children:
                break
            
            node = node.children[char]
            
            if hasattr(node, 'route') and node.route:
                best_match = node.route
        
        return best_match


# Usage:
# router = IPRouter()
# router.add_route("192.168", "Gateway A")
# router.add_route("192.168.1", "Gateway B")
# router.add_route("192.168.1.10", "Gateway C")
# 
# router.lookup("192.168.1.100")  # "Gateway B" (longest match)
# router.lookup("192.168.1.10")   # "Gateway C" (exact match)
# router.lookup("192.168.2.50")   # "Gateway A" (best available)
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| **Build trie** | O(n √ó l) | O(n √ó l) | n words, avg length l |
| **Shortest prefix** | O(m) | O(1) | m = word length |
| **Longest prefix** | O(m) | O(1) | Same |
| **Replace all words** | O(n √ó l + s √ó w) | O(n √ó l) | s sentences words |

---

## üîÑ Variations

| Variation | Difference | Use Case |
|-----------|------------|----------|
| **Shortest prefix** | Return first match | Root replacement |
| **Longest prefix** | Track best match | IP routing |
| **All matching prefixes** | Collect all | Multiple matches |
| **Prefix with score** | Best scoring | Weighted matching |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Shortest vs Longest Confusion

**Shortest (return immediately):**
```python
if node.word:
    return node.word  # First match = shortest
```

**Longest (keep tracking):**
```python
if node.word:
    longest = node.word  # Update but continue
# Return longest at the end
```

### 2. Not Handling No Match

**‚ùå Wrong:**
```python
def find_prefix(self, word):
    # Always returns something, even if no match
    return self._traverse(word).word
```

**‚úÖ Correct:**
```python
def find_prefix(self, word):
    result = self._find_prefix_impl(word)
    return result if result else word  # Fallback to original
```

---

## üìù Practice Problems

### Medium (Apply pattern)
- [ ] [Replace Words](https://leetcode.com/problems/replace-words/) - LC 648 ‚≠ê
- [ ] [Longest Word in Dictionary](https://leetcode.com/problems/longest-word-in-dictionary/) - LC 720

### Related
- [ ] [Implement Trie](https://leetcode.com/problems/implement-trie-prefix-tree/) - LC 208
- [ ] [Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/) - LC 14

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement shortest prefix match
- **Day 3:** Implement longest prefix match
- **Day 7:** Solve LC 648
- **Day 14:** Implement IP routing example
- **Day 30:** Explain both patterns without reference

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Discuss in Interviews</strong></summary>

**For shortest prefix:**
> "I traverse the word character by character through the trie. The moment I hit a node marked as a word end, that's the shortest prefix - I return immediately."

**For longest prefix:**
> "Similar traversal, but instead of returning on first match, I track the longest match seen so far and continue until I can't follow the path anymore."

**Trade-off discussion:**
> "Trie gives us O(m) per lookup compared to O(n √ó m) checking against all dictionary words. The trade-off is O(n √ó l) space for the trie."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand pattern | 10-15 min | This file |
| Implement shortest | 15 min | LC 648 |
| Implement longest | 15 min | LC 720 |
| Full problem | 25-30 min | With edge cases |

---

> **üí° Key Insight:** Shortest prefix returns on first word match. Longest prefix tracks the best match and keeps going until the path ends. Same traversal, different return logic.

> **üîó Related:** [StartsWith](../02-Trie-Operations/3.3-StartsWith-Prefix.md) | [Search](../02-Trie-Operations/3.2-Search-Operation.md) | [Word Collection](./4.3-Collect-All-Words.md)
