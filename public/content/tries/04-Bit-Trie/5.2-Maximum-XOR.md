# LC 421: Maximum XOR of Two Numbers in an Array

> **The definitive Bit Trie problem. Find the maximum XOR of any two numbers in an array using greedy bit selection.**

---

## üìã Problem Statement

**LeetCode 421 - Medium**

Given an integer array `nums`, return the maximum result of `nums[i] XOR nums[j]`, where `0 <= i <= j < n`.

```
Input: nums = [3, 10, 5, 25, 2, 8]
Output: 28
Explanation: Maximum XOR is 5 ^ 25 = 28
```

**Constraints:**
- 1 <= nums.length <= 2 √ó 10^5
- 0 <= nums[i] <= 2^31 - 1

---

## üéØ Pattern Recognition

**Pattern:** Bit Trie (Binary Trie)

**Key insight:** For each number, we want to find another number that differs in as many bits as possible, prioritizing the most significant bits.

**Why Bit Trie?**
- Brute force is O(n¬≤) - checking all pairs
- Bit Trie allows O(log max_num) lookup for optimal XOR partner

---

## üìê Approaches

### Approach 1: Brute Force (TLE)

Check all pairs - O(n¬≤), won't pass.

### Approach 2: Bit Trie (Optimal)

1. Insert all numbers into Bit Trie
2. For each number, query for maximum XOR
3. Track global maximum

**Time:** O(n √ó max_bits)
**Space:** O(n √ó max_bits)

### Approach 3: Bit-by-Bit with HashSet

For each bit position, check if setting that bit is achievable.

**Time:** O(n √ó max_bits)  
**Space:** O(n)

---

## üíª Solution

### Solution 1: Bit Trie

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = [None, None]  # [0-bit, 1-bit]


class Solution:
    """
    Build Bit Trie and query for max XOR.
    
    Time: O(n √ó 31) = O(n)
    Space: O(n √ó 31) = O(n)
    """
    
    def findMaximumXOR(self, nums: list[int]) -> int:
        if len(nums) < 2:
            return 0
        
        # Calculate max bits needed
        max_num = max(nums)
        max_bits = max_num.bit_length() if max_num > 0 else 1
        
        # Build Trie
        root = TrieNode()
        
        def insert(num: int) -> None:
            node = root
            for i in range(max_bits - 1, -1, -1):
                bit = (num >> i) & 1
                if node.children[bit] is None:
                    node.children[bit] = TrieNode()
                node = node.children[bit]
        
        def get_max_xor(num: int) -> int:
            node = root
            xor_val = 0
            for i in range(max_bits - 1, -1, -1):
                bit = (num >> i) & 1
                opposite = 1 - bit
                
                if node.children[opposite] is not None:
                    xor_val |= (1 << i)
                    node = node.children[opposite]
                else:
                    node = node.children[bit]
            return xor_val
        
        # Insert all numbers
        for num in nums:
            insert(num)
        
        # Find max XOR
        max_xor = 0
        for num in nums:
            max_xor = max(max_xor, get_max_xor(num))
        
        return max_xor


# Test
sol = Solution()
print(sol.findMaximumXOR([3, 10, 5, 25, 2, 8]))  # 28
print(sol.findMaximumXOR([14, 70, 53, 83, 49, 91, 36, 80, 92, 51, 66, 70]))  # 127
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = [null, null];
    }
}

function findMaximumXOR(nums) {
    if (nums.length < 2) return 0;
    
    const maxNum = Math.max(...nums);
    const maxBits = maxNum > 0 ? Math.floor(Math.log2(maxNum)) + 1 : 1;
    
    const root = new TrieNode();
    
    function insert(num) {
        let node = root;
        for (let i = maxBits - 1; i >= 0; i--) {
            const bit = (num >> i) & 1;
            if (node.children[bit] === null) {
                node.children[bit] = new TrieNode();
            }
            node = node.children[bit];
        }
    }
    
    function getMaxXor(num) {
        let node = root;
        let xorVal = 0;
        for (let i = maxBits - 1; i >= 0; i--) {
            const bit = (num >> i) & 1;
            const opposite = 1 - bit;
            
            if (node.children[opposite] !== null) {
                xorVal |= (1 << i);
                node = node.children[opposite];
            } else {
                node = node.children[bit];
            }
        }
        return xorVal;
    }
    
    // Insert all numbers
    for (const num of nums) {
        insert(num);
    }
    
    // Find max XOR
    let maxXor = 0;
    for (const num of nums) {
        maxXor = Math.max(maxXor, getMaxXor(num));
    }
    
    return maxXor;
}
```

---

### Solution 2: HashSet Approach (Alternative)

**Python:**
```python
class Solution:
    """
    For each bit position, check if that bit can be 1 in the result.
    Uses property: if a ^ b = c, then a ^ c = b
    
    Time: O(n √ó 31)
    Space: O(n)
    """
    
    def findMaximumXOR(self, nums: list[int]) -> int:
        max_num = max(nums)
        max_bits = max_num.bit_length() if max_num > 0 else 1
        
        max_xor = 0
        
        # Try to set each bit from MSB to LSB
        for i in range(max_bits - 1, -1, -1):
            # Candidate XOR with this bit set
            candidate = max_xor | (1 << i)
            
            # Get all prefixes up to bit i
            prefixes = set()
            for num in nums:
                prefixes.add(num >> i)
            
            # Check if candidate is achievable
            # If a ^ b = candidate, then a ^ candidate = b
            for prefix in prefixes:
                if (prefix ^ (candidate >> i)) in prefixes:
                    max_xor = candidate
                    break
        
        return max_xor
```

---

### Solution 3: Optimized Bit Trie (One Pass)

**Python:**
```python
class Solution:
    """
    Insert and query in single pass for slight optimization.
    """
    
    def findMaximumXOR(self, nums: list[int]) -> int:
        max_bits = max(nums).bit_length() if max(nums) > 0 else 1
        
        root = {'children': [None, None]}
        max_xor = 0
        
        for num in nums:
            # Query for max XOR with numbers inserted so far
            node = root
            xor_val = 0
            
            for i in range(max_bits - 1, -1, -1):
                bit = (num >> i) & 1
                opposite = 1 - bit
                
                if node['children'][opposite] is not None:
                    xor_val |= (1 << i)
                    node = node['children'][opposite]
                elif node['children'][bit] is not None:
                    node = node['children'][bit]
                else:
                    break
            
            max_xor = max(max_xor, xor_val)
            
            # Insert current number
            node = root
            for i in range(max_bits - 1, -1, -1):
                bit = (num >> i) & 1
                if node['children'][bit] is None:
                    node['children'][bit] = {'children': [None, None]}
                node = node['children'][bit]
        
        return max_xor
```

---

## üîç Walkthrough

```
nums = [3, 10, 5, 25, 2, 8]

Binary representations (5 bits):
3  = 00011
10 = 01010
5  = 00101
25 = 11001
2  = 00010
8  = 01000

Trie after inserting all:

              root
            /      \
           0        1
          / \        \
         0   1        1
        / \   \        \
       0   1   0        0
      / \   \   \        \
     1   0   1   0        0
     |   |   |   |        |
    [3] [2] [5][10]      [25]
    
Query for 5 (00101):
- Bit 4: 5 has 0, want 1 ‚Üí GO 1 ‚úì (found path to 25!)
  Result so far: 1xxxx
- Bit 3: 5 has 0, want 1 ‚Üí GO 1 ‚úì
  Result: 11xxx
- Bit 2: 5 has 1, want 0 ‚Üí GO 0 ‚úì
  Result: 110xx
- Bit 1: 5 has 0, want 1 ‚Üí no 1, GO 0
  Result: 1100x
- Bit 0: 5 has 1, want 0 ‚Üí GO 0 (only option)
  Result: 11001

Found partner: 25
XOR = 5 ^ 25 = 00101 ^ 11001 = 11100 = 28
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space |
|----------|------|-------|
| Brute Force | O(n¬≤) | O(1) |
| Bit Trie | O(n √ó max_bits) | O(n √ó max_bits) |
| HashSet | O(n √ó max_bits) | O(n) |

**For typical constraints:**
- n = 2√ó10^5, max_bits = 31
- Bit Trie: ~6.2 million operations ‚úì
- Brute Force: 4√ó10^10 operations ‚úó

---

## ‚ö†Ô∏è Edge Cases

| Case | Handling |
|------|----------|
| Single element | Return 0 (can XOR with itself) |
| All same numbers | Return 0 |
| Power of 2s | XOR of two gives interesting results |
| Large numbers | Use 31 bits for non-negative |

---

## üé§ Interview Tips

**Opening statement:**
"To maximize XOR, I want to find pairs with different bits, especially in the most significant positions. A Bit Trie lets me greedily find the best partner for each number."

**Explain the greedy strategy:**
"At each bit position from MSB to LSB, I try to go the opposite way in the Trie. If I have a 0, I want to find a 1. This maximizes the XOR result."

**Complexity discussion:**
"Building and querying the Trie is O(n √ó 31), which is effectively O(n). Space is also O(n √ó 31) for storing all paths."

**Follow-ups:**
- "What if numbers can be added/removed?" ‚Üí Add count field
- "Maximum XOR subarray?" ‚Üí Use prefix XOR + Bit Trie

---

## üìù Practice Checklist

- [ ] Solve in < 25 minutes
- [ ] Trace through with small example
- [ ] Implement Bit Trie from scratch
- [ ] Know HashSet alternative
- [ ] Handle edge cases

<details>
<summary><strong>üß† Spaced Repetition</strong></summary>

- **Day 1:** Implement Bit Trie insert + query
- **Day 3:** Solve without looking at solution
- **Day 7:** Explain the greedy strategy out loud
- **Day 14:** Solve Maximum XOR with Element constraint

</details>

---

> **üí° Key Insight:** XOR gives 1 when bits differ. To maximize XOR, greedily pick the opposite bit at each position, starting from the most significant bit (because 1 in MSB beats all lower bits combined).

> **üîó Related:** [Bit Trie Fundamentals](5.1-Bit-Trie-Fundamentals.md) | [Maximum XOR With Element](5.3-Max-XOR-With-Element.md)
