# 5.2 - Path Sum II (LC 113)

> **Grokking Pattern:** #11 Tree DFS (Path Collection)
>
> **Difficulty:** Medium | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê Common

---

## Problem Statement

Given the `root` of a binary tree and an integer `targetSum`, return **all root-to-leaf paths** where the sum of the node values in the path equals `targetSum`.

```
Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1

Output: [[5,4,11,2], [5,8,4,5]]
```

[LeetCode 113 - Path Sum II](https://leetcode.com/problems/path-sum-ii/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "All paths" with certain property
- "Find all root-to-leaf paths"
- Need to return the actual paths, not just boolean

**Key insight:**
This is Path Sum I + **backtracking**. We track the current path, and when we find a valid leaf, we add a **copy** of the path to results.

</details>

---

## ‚úÖ When to Use

- Finding all paths with a property
- Need to return actual paths (not just count)
- Root-to-leaf path collection

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Just check existence | Don't need all paths | Path Sum I |
| Any path (not root-to-leaf) | Different constraint | Path Sum III |
| Just count paths | Don't need paths themselves | Counter |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Path Sum](./5.1-Path-Sum.md) - Simpler version
- [Backtracking Basics](../../02-Recursion-Backtracking/02-Backtracking/2.1-Backtracking-Basics.md)

**After mastering this:**
- [Path Sum III](https://leetcode.com/problems/path-sum-iii/) - Any path
- [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) - All paths as strings

</details>

---

## üìê How It Works

### Backtracking Pattern

```
              5          path = [5], remaining = 17
             / \
            4   8        path = [5,4], remaining = 13
           /
          11             path = [5,4,11], remaining = 2
         /  \
        7    2           path = [5,4,11,2], remaining = 0 ‚úì
        
At valid leaf: add COPY of path to result
Then BACKTRACK: remove 2, try sibling 7
path = [5,4,11,7], remaining = -5 ‚úó
```

### Why Copy the Path

```python
# ‚ùå WRONG: Adding reference
result.append(path)  # All entries point to same list!

# ‚úÖ CORRECT: Add copy
result.append(path[:])  # or list(path) or path.copy()
```

---

## üíª Code Implementation

### Solution 1: DFS with Backtracking

**Python:**
```python
from typing import Optional, List

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def path_sum(root: Optional[TreeNode], target_sum: int) -> List[List[int]]:
    """
    Find all root-to-leaf paths with target sum.
    
    Use backtracking: add to path, recurse, remove from path.
    Time: O(n¬≤) worst, Space: O(n)
    """
    result = []
    
    def dfs(node, remaining, path):
        if not node:
            return
        
        # Add current node to path
        path.append(node.val)
        remaining -= node.val
        
        # Check if leaf with valid sum
        if not node.left and not node.right:
            if remaining == 0:
                result.append(path[:])  # Add COPY!
        else:
            # Continue DFS
            dfs(node.left, remaining, path)
            dfs(node.right, remaining, path)
        
        # Backtrack: remove current node
        path.pop()
    
    dfs(root, target_sum, [])
    return result
```

**JavaScript:**
```javascript
function pathSum(root, targetSum) {
    const result = [];
    
    function dfs(node, remaining, path) {
        if (!node) return;
        
        path.push(node.val);
        remaining -= node.val;
        
        if (!node.left && !node.right) {
            if (remaining === 0) {
                result.push([...path]);  // Copy!
            }
        } else {
            dfs(node.left, remaining, path);
            dfs(node.right, remaining, path);
        }
        
        path.pop();  // Backtrack
    }
    
    dfs(root, targetSum, []);
    return result;
}
```

### Solution 2: Without Explicit Backtrack (New Path Each Call)

**Python:**
```python
def path_sum_v2(root: Optional[TreeNode], target_sum: int) -> List[List[int]]:
    """
    Alternative: Create new path at each call.
    
    Simpler but uses more memory (O(n log n) for balanced tree).
    """
    result = []
    
    def dfs(node, remaining, path):
        if not node:
            return
        
        # Create new path with current node
        new_path = path + [node.val]
        new_remaining = remaining - node.val
        
        if not node.left and not node.right:
            if new_remaining == 0:
                result.append(new_path)  # Already a new list
        else:
            dfs(node.left, new_remaining, new_path)
            dfs(node.right, new_remaining, new_path)
    
    dfs(root, target_sum, [])
    return result
```

### Solution 3: Iterative with Stack

**Python:**
```python
def path_sum_iterative(root: Optional[TreeNode], target_sum: int) -> List[List[int]]:
    """
    Iterative DFS with stack.
    
    Store (node, remaining, path) tuples.
    """
    if not root:
        return []
    
    result = []
    stack = [(root, target_sum - root.val, [root.val])]
    
    while stack:
        node, remaining, path = stack.pop()
        
        # Check if leaf
        if not node.left and not node.right:
            if remaining == 0:
                result.append(path)
            continue
        
        if node.right:
            stack.append((
                node.right,
                remaining - node.right.val,
                path + [node.right.val]
            ))
        if node.left:
            stack.append((
                node.left,
                remaining - node.left.val,
                path + [node.left.val]
            ))
    
    return result
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Backtracking |" O(n¬≤) "| O(n) |" Copying path takes O(n) each time "|
| New Path |" O(n¬≤) "| O(n log n) | Creating new lists |
| Iterative |" O(n¬≤) "| O(n log n) | Storing paths |

**Why O(n¬≤)?**
- We visit n nodes
- Copying a path can take O(n) in worst case
- Total: O(n) * O(n) = O(n¬≤)

**Note:** For a balanced tree with k valid paths, total output size is O(k * log n), which affects space.

---

## üîÑ Variations

| Variation | Difference | LeetCode |
|-----------|------------|----------|
| Path Sum I | Just return boolean | LC 112 |
| Path Sum III | Any contiguous path | LC 437 |
| Binary Tree Paths | All paths as strings | LC 257 |
| Sum Root to Leaf Numbers | Paths as numbers | LC 129 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Copy Path

```python
# ‚ùå WRONG: All results point to same list
if remaining == 0:
    result.append(path)  # Just appends reference

# After backtracking, path changes, corrupting result!

# ‚úÖ CORRECT: Copy the path
result.append(path[:])
# or: result.append(list(path))
# or: result.append(path.copy())
```

### 2. Not Backtracking

```python
# ‚ùå WRONG: Path keeps growing
def dfs(node, remaining, path):
    path.append(node.val)
    if is_leaf and remaining == 0:
        result.append(path[:])
    dfs(node.left, remaining - node.val, path)
    dfs(node.right, remaining - node.val, path)
    # Missing: path.pop()!

# ‚úÖ CORRECT: Always backtrack
def dfs(node, remaining, path):
    path.append(node.val)
    # ... process ...
    path.pop()  # Backtrack!
```

### 3. Wrong Base Case

```python
# ‚ùå WRONG: Checking at null
def dfs(node, remaining, path):
    if not node:
        if remaining == 0:  # Null is not a leaf!
            result.append(path[:])
        return

# ‚úÖ CORRECT: Check at leaf
def dfs(node, remaining, path):
    if not node:
        return
    
    path.append(node.val)
    remaining -= node.val
    
    if not node.left and not node.right:  # Check at leaf
        if remaining == 0:
            result.append(path[:])
```

---

## üìù Practice Problems

### This Problem
- [ ] [Path Sum II](https://leetcode.com/problems/path-sum-ii/) - LC 113

### Related Problems
- [ ] [Path Sum](https://leetcode.com/problems/path-sum/) - LC 112
- [ ] [Path Sum III](https://leetcode.com/problems/path-sum-iii/) - LC 437
- [ ] [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) - LC 257
- [ ] [Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/) - LC 129

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Backtracking solution
**Day 3:** Explain why we need path.copy()
**Day 7:** Iterative version
**Day 14:** Solve Path Sum III (harder)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Explaining approach:**
> "I'll use DFS with backtracking. I'll maintain a current path, add nodes as I go down, and when I find a valid leaf, add a copy of the path to results. Then I backtrack by removing the node."

**Why copy:**
> "I need to copy the path because the same list object is being modified throughout the recursion. Without copying, all results would reference the same (empty) list at the end."

**Alternative discussion:**
> "I could create a new path list at each recursive call, which avoids explicit backtracking. But that uses more memory - O(path_length) for each node visited."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common follow-up |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Tests backtracking |
| Google | ‚≠ê‚≠ê‚≠ê | May ask optimization |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Classic question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Backtracking solution | 10-12 min | Include path copy |
| Iterative version | 12-15 min | If asked |
| Explain backtracking | 3 min | Common interview topic |

---

> **üí° Key Insight:** This is the classic tree backtracking problem. The pattern is: add to path ‚Üí recurse ‚Üí copy at valid leaf ‚Üí pop from path. Always remember to copy the path when adding to results, or you'll have a list of empty lists at the end!

---

## üîó Related

- [Path Sum](./5.1-Path-Sum.md)
- [Maximum Path Sum](./5.3-Maximum-Path-Sum.md)
- [Backtracking Template](../../02-Recursion-Backtracking/02-Backtracking/2.2-Backtracking-Template.md)
