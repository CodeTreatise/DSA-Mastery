# 1.3 Stack Implementation

> **Foundation Reference** | Low-Level Implementation Details

---

## Overview

This file covers how stacks are implemented internally and when you might need to implement your own. For interview purposes, using built-in lists is almost always preferred.

---

## üéØ Implementation Options

### Option 1: Dynamic Array (Recommended)

The default choice in Python (list) and JavaScript (Array).

**Advantages:**
- O(1) amortized push/pop
- Cache-friendly (contiguous memory)
- Built-in, no implementation needed

**Disadvantages:**
- Occasional O(n) resizing
- May over-allocate memory

### Option 2: Linked List

Each node points to the one below it.

**Advantages:**
- True O(1) push/pop (no resizing)
- Precise memory usage

**Disadvantages:**
- Cache-unfriendly
- More memory per element (pointer overhead)
- More complex implementation

### Option 3: Fixed-Size Array

Pre-allocated array with top pointer.

**Advantages:**
- No dynamic allocation
- Predictable memory

**Disadvantages:**
- Fixed capacity
- Stack overflow if full

---

## ‚úÖ When to Implement Your Own Stack

- Embedded systems with memory constraints
- Fixed capacity requirements
- Need additional operations (getMin, etc.)
- Learning purposes

---

## ‚ùå When to Use Built-in

- Interview coding (always)
- Production code (almost always)
- Rapid prototyping

---

## ÔøΩ Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Stack Basics](./1.1-Stack-Basics.md) - Conceptual foundation
- [Stack Operations](./1.2-Stack-Operations.md) - How to use stacks
- Basic data structures (arrays, linked lists)

**After mastering this:**
- [Min Stack](../04-Design-Problems/4.1-Min-Stack.md) - Custom implementation
- [Queue Using Stacks](../04-Design-Problems/4.2-Queue-Using-Stacks.md) - Data structure design

**Related concepts:**
- Dynamic arrays and amortized analysis
- Linked list implementation
- Memory management

</details>

---

## ÔøΩüíª Implementation Variants

### Dynamic Array Implementation (Standard)

**Python:**
```python
class ArrayStack:
    """
    Stack using dynamic array.
    This is essentially what Python's list does.
    """
    
    def __init__(self, initial_capacity=10):
        self._array = [None] * initial_capacity
        self._capacity = initial_capacity
        self._size = 0
    
    def push(self, item):
        """Add item to top. Resize if needed."""
        if self._size == self._capacity:
            self._resize(self._capacity * 2)
        self._array[self._size] = item
        self._size += 1
    
    def pop(self):
        """Remove and return top."""
        if self._size == 0:
            raise IndexError("pop from empty stack")
        self._size -= 1
        item = self._array[self._size]
        self._array[self._size] = None  # Help garbage collection
        # Shrink if too empty
        if self._size > 0 and self._size == self._capacity // 4:
            self._resize(self._capacity // 2)
        return item
    
    def peek(self):
        """Return top without removing."""
        if self._size == 0:
            raise IndexError("peek from empty stack")
        return self._array[self._size - 1]
    
    def is_empty(self):
        return self._size == 0
    
    def size(self):
        return self._size
    
    def _resize(self, new_capacity):
        """Resize internal array."""
        new_array = [None] * new_capacity
        for i in range(self._size):
            new_array[i] = self._array[i]
        self._array = new_array
        self._capacity = new_capacity
```

**JavaScript:**
```javascript
class ArrayStack {
    constructor(initialCapacity = 10) {
        this.array = new Array(initialCapacity);
        this.capacity = initialCapacity;
        this._size = 0;
    }
    
    push(item) {
        if (this._size === this.capacity) {
            this._resize(this.capacity * 2);
        }
        this.array[this._size] = item;
        this._size++;
    }
    
    pop() {
        if (this._size === 0) {
            throw new Error("pop from empty stack");
        }
        this._size--;
        const item = this.array[this._size];
        this.array[this._size] = undefined;
        
        if (this._size > 0 && this._size === Math.floor(this.capacity / 4)) {
            this._resize(Math.floor(this.capacity / 2));
        }
        return item;
    }
    
    peek() {
        if (this._size === 0) {
            throw new Error("peek from empty stack");
        }
        return this.array[this._size - 1];
    }
    
    isEmpty() {
        return this._size === 0;
    }
    
    size() {
        return this._size;
    }
    
    _resize(newCapacity) {
        const newArray = new Array(newCapacity);
        for (let i = 0; i < this._size; i++) {
            newArray[i] = this.array[i];
        }
        this.array = newArray;
        this.capacity = newCapacity;
    }
}
```

---

### Linked List Implementation

**Python:**
```python
class Node:
    """Node for linked list stack."""
    def __init__(self, value, next_node=None):
        self.value = value
        self.next = next_node


class LinkedStack:
    """
    Stack using singly linked list.
    True O(1) for all operations (no resizing).
    """
    
    def __init__(self):
        self._top = None
        self._size = 0
    
    def push(self, item):
        """Add item to top. O(1)."""
        new_node = Node(item, self._top)
        self._top = new_node
        self._size += 1
    
    def pop(self):
        """Remove and return top. O(1)."""
        if self._top is None:
            raise IndexError("pop from empty stack")
        value = self._top.value
        self._top = self._top.next
        self._size -= 1
        return value
    
    def peek(self):
        """Return top without removing. O(1)."""
        if self._top is None:
            raise IndexError("peek from empty stack")
        return self._top.value
    
    def is_empty(self):
        return self._top is None
    
    def size(self):
        return self._size


# Visual representation
# Push 1, 2, 3:
#
#   TOP ‚Üí [3] ‚Üí [2] ‚Üí [1] ‚Üí None
#
# Pop returns 3, stack becomes:
#   TOP ‚Üí [2] ‚Üí [1] ‚Üí None
```

**JavaScript:**
```javascript
class Node {
    constructor(value, next = null) {
        this.value = value;
        this.next = next;
    }
}

class LinkedStack {
    constructor() {
        this.top = null;
        this._size = 0;
    }
    
    push(item) {
        this.top = new Node(item, this.top);
        this._size++;
    }
    
    pop() {
        if (this.top === null) {
            throw new Error("pop from empty stack");
        }
        const value = this.top.value;
        this.top = this.top.next;
        this._size--;
        return value;
    }
    
    peek() {
        if (this.top === null) {
            throw new Error("peek from empty stack");
        }
        return this.top.value;
    }
    
    isEmpty() {
        return this.top === null;
    }
    
    size() {
        return this._size;
    }
}
```

---

### Fixed-Size Array Implementation

**Python:**
```python
class FixedStack:
    """
    Stack with fixed maximum capacity.
    Useful when memory is constrained.
    """
    
    def __init__(self, capacity):
        self._array = [None] * capacity
        self._capacity = capacity
        self._top = -1  # -1 indicates empty
    
    def push(self, item):
        """Add item. Raises if full."""
        if self._top == self._capacity - 1:
            raise OverflowError("stack is full")
        self._top += 1
        self._array[self._top] = item
    
    def pop(self):
        """Remove and return top. Raises if empty."""
        if self._top == -1:
            raise IndexError("pop from empty stack")
        item = self._array[self._top]
        self._array[self._top] = None
        self._top -= 1
        return item
    
    def peek(self):
        """Return top without removing."""
        if self._top == -1:
            raise IndexError("peek from empty stack")
        return self._array[self._top]
    
    def is_empty(self):
        return self._top == -1
    
    def is_full(self):
        return self._top == self._capacity - 1
    
    def size(self):
        return self._top + 1
```

---

## ‚ö° Complexity Comparison

| Operation | Dynamic Array | Linked List | Fixed Array |
|-----------|---------------|-------------|-------------|
| Push |" O(1)* "| O(1) |" O(1) "|
| Pop |" O(1)* "| O(1) |" O(1) "|
| Peek |" O(1) "| O(1) |" O(1) "|
| Space per element | ~8-16 bytes | ~24-32 bytes | ~8-16 bytes |
| Cache performance | Excellent | Poor | Excellent |

*Amortized O(1) due to occasional resizing

---

## üîÑ Comparison: When to Use What

| Implementation | Best For | Avoid When |
|----------------|----------|------------|
| Dynamic Array | General purpose, interviews |" Need strict O(1) guarantee "|
| Linked List |" Strict O(1), memory-conscious "| Need cache efficiency |
| Fixed Array | Embedded systems, known max | Capacity unknown |

---

## ‚ö†Ô∏è Common Implementation Mistakes

### 1. Not Handling Resize

```python
# ‚ùå WRONG: No resize handling
def push(self, item):
    self.array[self.size] = item  # IndexError when full!
    self.size += 1

# ‚úÖ CORRECT: Check and resize
def push(self, item):
    if self.size == len(self.array):
        self._resize(len(self.array) * 2)
    self.array[self.size] = item
    self.size += 1
```

### 2. Memory Leak in Pop

```python
# ‚ùå WRONG: Old reference kept
def pop(self):
    self.size -= 1
    return self.array[self.size]  # Element still referenced!

# ‚úÖ CORRECT: Clear reference
def pop(self):
    self.size -= 1
    item = self.array[self.size]
    self.array[self.size] = None  # Allow garbage collection
    return item
```

### 3. Linked List: Lost Pointer

```python
# ‚ùå WRONG: Lose the chain
def push(self, item):
    self.top = Node(item)  # Lost previous top!

# ‚úÖ CORRECT: Link to previous
def push(self, item):
    self.top = Node(item, self.top)  # Chain preserved
```

---

## üìù Practice Problems

| Problem | Difficulty | Implementation Concept |
|---------|------------|------------------------|
| [Min Stack](https://leetcode.com/problems/min-stack/) | Medium | Auxiliary data structure |
| [Design Circular Queue](https://leetcode.com/problems/design-circular-queue/) | Medium | Fixed-size array |
| [LRU Cache](https://leetcode.com/problems/lru-cache/) | Medium | Custom data structure |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Understand the three implementation approaches
**Day 3:** Implement LinkedStack from scratch
**Day 7:** Implement FixedStack with overflow handling
**Day 14:** Explain trade-offs without notes
**Day 21:** Use implementation knowledge in Min Stack

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand approaches | 15 min | Read and compare |
| Implement from scratch | 20-30 min | Each variant |
| Memorize trade-offs | 10 min | For interviews |

---

## üé§ Interview Note

**Never implement your own stack in interviews unless specifically asked.**

```python
# In interviews, just use:
stack = []
stack.append(x)  # push
stack.pop()      # pop
stack[-1]        # peek
```

Focus on solving the problem, not reimplementing data structures.

---

> **üí° Key Insight:** Understanding implementation helps you reason about performance, but in practice (and interviews), use built-in data structures. Python's list and JavaScript's Array are highly optimized stack implementations.

---

## üîó Related

- [Stack Basics](./1.1-Stack-Basics.md) - Conceptual overview
- [Stack Operations](./1.2-Stack-Operations.md) - Operation patterns
- [Min Stack](../04-Design-Problems/4.1-Min-Stack.md) - Extended implementation
