# 4.3 Kth Largest Element in a Stream (LC 703)

## Problem Statement

Design a class to find the **kth largest element in a stream**. Note that it is the kth largest element in sorted order, not the kth distinct element.

```
KthLargest class:
‚îú‚îÄ‚îÄ __init__(k, nums) - Initialize with k and initial stream
‚îú‚îÄ‚îÄ add(val) - Add new element, return kth largest
```

**Example:**
```
KthLargest kthLargest = KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // returns 4  (stream: [2,3,4,5,8], 3rd largest = 4)
kthLargest.add(5);   // returns 5  (stream: [2,3,4,5,5,8], 3rd largest = 5)
kthLargest.add(10);  // returns 5  (stream: [2,3,4,5,5,8,10], 3rd largest = 5)
kthLargest.add(9);   // returns 8  (stream: [2,3,4,5,5,8,9,10], 3rd largest = 8)
kthLargest.add(4);   // returns 8  (stream: [2,3,4,4,5,5,8,9,10], 3rd largest = 8)
```

**LeetCode:** [703. Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>Pattern: Top K with Streaming Data</strong></summary>

**Key signals:**
- "Kth largest in stream"
- "Add elements dynamically"
- "Return K-th element after each add"

**Pattern insight:**
```
Maintain min-heap of size K

Heap root = Kth largest
Why min-heap? Because root is smallest of K largest = Kth largest!

Add operation:
- If heap.size < K: just push
- If new > root: replace root (new element is in top K)
- Else: ignore (not in top K)
```

**Difference from LC 215:**
- LC 215: One-time query, static array
- LC 703: Multiple queries, streaming data

</details>

---

## ‚úÖ When to Use This Pattern

| Scenario | Approach |
|----------|----------|
| Stream of elements | Min-heap of size K |
| Multiple queries | Keep heap maintained |
| New elements arrive |" O(log K) per add "|

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|---------------------|
| Static array, single query |" QuickSelect O(n) "|
| Very small K | Just track K values manually |
| Need all K elements sorted | Sort K elements after extraction |

---

## üìê Solution Approach

### The Min-Heap Strategy

```
Keep min-heap of K largest elements

Initial: nums = [4, 5, 8, 2], K = 3

Step 1: Build heap from nums
  Add 4: heap = [4]
  Add 5: heap = [4, 5]
  Add 8: heap = [4, 5, 8]
  Add 2: heap.size = K, and 2 < heap[0]=4, ignore
  
  Final: heap = [4, 5, 8] (sorted view: 4 at root)
  Kth largest = heap[0] = 4

Step 2: add(3)
  3 < heap[0]=4, ignore (3 not in top 3)
  Return heap[0] = 4

Step 3: add(5)
  5 > heap[0]=4, replace!
  heap = [5, 5, 8]
  Return heap[0] = 5

Step 4: add(10)
  10 > heap[0]=5, replace!
  heap = [5, 8, 10]
  Return heap[0] = 5

Step 5: add(9)
  9 > heap[0]=5, replace!
  heap = [8, 9, 10]
  Return heap[0] = 8
```

### Why This Works

```
Invariant: Heap contains exactly the K largest elements

Proof:
- When heap.size = K, root is smallest of K largest
- New element > root means it's in top K
- Replace removes previous Kth largest (now K+1th)
- New element < root means at least K elements are larger
  ‚Üí It can never be in top K, safe to ignore
```

---

## üíª Code Implementation

### Python Solution

**Python:**
```python
import heapq

class KthLargest:
    """
    LC 703: Kth Largest Element in a Stream
    
    Pattern: Maintain min-heap of size K
    - Heap root = Kth largest
    - O(log K) per add operation
    
    Time: O(n log K) init, O(log K) per add
    Space: O(K)
    """
    
    def __init__(self, k: int, nums: list[int]):
        self.k = k
        self.heap = []
        
        # Initialize heap with nums
        for num in nums:
            self._add_to_heap(num)
    
    def _add_to_heap(self, val: int) -> None:
        """Add value to heap, maintain size K."""
        if len(self.heap) < self.k:
            heapq.heappush(self.heap, val)
        elif val > self.heap[0]:
            heapq.heapreplace(self.heap, val)
    
    def add(self, val: int) -> int:
        """
        Add new value and return Kth largest.
        
        Time: O(log K)
        """
        self._add_to_heap(val)
        return self.heap[0]


# Example usage
kth = KthLargest(3, [4, 5, 8, 2])
print(kth.add(3))   # 4
print(kth.add(5))   # 5
print(kth.add(10))  # 5
print(kth.add(9))   # 8
print(kth.add(4))   # 8
```

### Alternative: Using heappushpop

**Python:**
```python
import heapq

class KthLargestV2:
    """
    Alternative using heappushpop for cleaner code.
    """
    
    def __init__(self, k: int, nums: list[int]):
        self.k = k
        # Initialize heap with first k elements
        self.heap = nums[:k]
        heapq.heapify(self.heap)
        
        # Process remaining elements
        for num in nums[k:]:
            if num > self.heap[0]:
                heapq.heapreplace(self.heap, num)
    
    def add(self, val: int) -> int:
        if len(self.heap) < self.k:
            heapq.heappush(self.heap, val)
        elif val > self.heap[0]:
            heapq.heapreplace(self.heap, val)
        
        return self.heap[0]
```

### JavaScript Solution

**JavaScript:**
```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    size() { return this.heap.length; }
    peek() { return this.heap[0]; }
    
    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return min;
    }
    
    replace(val) {
        const min = this.heap[0];
        this.heap[0] = val;
        this._bubbleDown(0);
        return min;
    }
    
    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.heap[parent] <= this.heap[i]) break;
            [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
            i = parent;
        }
    }
    
    _bubbleDown(i) {
        const n = this.heap.length;
        while (true) {
            let smallest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;
            if (left < n && this.heap[left] < this.heap[smallest]) smallest = left;
            if (right < n && this.heap[right] < this.heap[smallest]) smallest = right;
            if (smallest === i) break;
            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
            i = smallest;
        }
    }
}


class KthLargest {
    constructor(k, nums) {
        this.k = k;
        this.heap = new MinHeap();
        
        for (const num of nums) {
            this._addToHeap(num);
        }
    }
    
    _addToHeap(val) {
        if (this.heap.size() < this.k) {
            this.heap.push(val);
        } else if (val > this.heap.peek()) {
            this.heap.replace(val);
        }
    }
    
    add(val) {
        this._addToHeap(val);
        return this.heap.peek();
    }
}

// Usage
const kth = new KthLargest(3, [4, 5, 8, 2]);
console.log(kth.add(3));   // 4
console.log(kth.add(5));   // 5
console.log(kth.add(10));  // 5
console.log(kth.add(9));   // 8
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| __init__ |" O(n log K) "| O(K) | Process n elements |
| add |" O(log K) "| O(1) | Heap operations |
| Total for m adds |" O((n+m) log K) "| O(K) | n initial + m adds |

**Comparison with alternatives:**

| Approach | Init | Add | Space |
|----------|------|-----|-------|
| Min-heap size K ‚≠ê |" O(n log K) "| O(log K) |" O(K) "|
| Sorted array |" O(n log n) "| O(n) |" O(n) "|
| Unsorted array |" O(n) "| O(n) |" O(n) "|
| Full heap |" O(n) "| O(log n) |" O(n) "|

**Why min-heap of size K is optimal:**
- Only store K elements (space efficient)
- Each add is O(log K), not O(log n)
- No need to track elements outside top K

---

## üîÑ Variations

| Variation | Change | Problem |
|-----------|--------|---------|
| Kth smallest | Use max-heap of size K | Similar logic |
| Dynamic K | Track multiple K values | Use multiple heaps |
| With deletion | Need indexed heap | More complex |
| Median instead | Two heaps (see LC 295) | Different pattern |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Max-Heap Instead of Min-Heap

```python
# ‚ùå Wrong: Max-heap doesn't give Kth largest directly
max_heap = []
for num in nums:
    heapq.heappush(max_heap, -num)  # Max-heap
# Pop K times? But that's O(K log n) per query!

# ‚úÖ Correct: Min-heap of size K
# Root is smallest of K largest = Kth largest
min_heap = []
for num in nums:
    if len(min_heap) < k:
        heapq.heappush(min_heap, num)
    elif num > min_heap[0]:
        heapq.heapreplace(min_heap, num)
```

### 2. Not Handling Initial Size < K

```python
# ‚ùå Wrong: Assumes heap always has K elements
def add(self, val):
    heapq.heapreplace(self.heap, val)  # Fails if heap.size < k!
    return self.heap[0]

# ‚úÖ Correct: Check size first
def add(self, val):
    if len(self.heap) < self.k:
        heapq.heappush(self.heap, val)
    elif val > self.heap[0]:
        heapq.heapreplace(self.heap, val)
    return self.heap[0]
```

### 3. Ignoring Edge Case: val == heap[0]

```python
# ‚ùå Subtly wrong: What if val equals heap[0]?
if val > self.heap[0]:
    heapq.heapreplace(self.heap, val)

# Actually this is CORRECT! If val == heap[0], 
# replacing with same value changes nothing.
# But some think they need >= instead of >

# The > is correct because:
# If val == root, we already have K elements >= val
# Adding another equal value doesn't change Kth largest
```

### 4. Returning Wrong Value When Heap Not Full

```python
# ‚ùå Wrong: What to return when heap.size < k?
def add(self, val):
    heapq.heappush(self.heap, val)
    return self.heap[0]  # Wrong if heap.size < k

# Based on problem constraints:
# "It is guaranteed that there will be at least k elements 
#  in the array when you search for the kth element"
# So after first add, heap should have k elements
```

---

## üìù Related Practice Problems

### Easy
- [ ] [Last Stone Weight (LC 1046)](https://leetcode.com/problems/last-stone-weight/)

### Medium
- [ ] [Kth Largest Element in an Array (LC 215)](https://leetcode.com/problems/kth-largest-element-in-an-array/)
- [ ] [Top K Frequent Elements (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/)

### Hard
- [ ] [Find Median from Data Stream (LC 295)](https://leetcode.com/problems/find-median-from-data-stream/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement solution, trace through example
- **Day 3:** Explain why min-heap (not max-heap)
- **Day 7:** Implement without looking
- **Day 14:** Solve LC 295 (extends this pattern)
- **Day 30:** Compare LC 703 vs LC 215 approaches

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This Solution</strong></summary>

**Opening statement:**
"For streaming Kth largest, I'll maintain a min-heap of size K. The key insight is that the root of this heap is always the Kth largest element - it's the smallest among the K largest."

**Explaining the invariant:**
"The invariant is: heap contains exactly the K largest elements seen so far. When a new element arrives, if it's larger than the root, it deserves to be in the top K, so I replace the root. If smaller, it can never be in the top K."

**Complexity discussion:**
"Each add is O(log K), not O(log n), because the heap size is bounded by K. This is optimal for streaming - we only track what we need."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Streaming focus |
| Google | ‚≠ê‚≠ê‚≠ê | May ask variations |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Standard question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 3-5 min | Read examples |
| Design solution | 5-7 min | Heap size K |
| Implement | 10-12 min | With edge cases |
| Test | 3-5 min | Trace through |

**Interview target:** 20-25 minutes total

---

## üí° Key Insight

> **For streaming Kth largest, use a min-heap of size K.** The heap root is always the Kth largest because it's the smallest of the K largest elements. This gives O(log K) per add and O(K) space - optimal for unbounded streams.

---

## üîó Related

- **Previous:** [Kth Largest in Array (LC 215)](./4.2-Kth-Largest-LC215.md)
- **Next:** [Top K Frequent Elements (LC 347)](./4.4-Top-K-Frequent-LC347.md)
- **Pattern:** [Top K Overview](./4.1-Top-K-Overview.md)
- **Extended:** [Find Median from Stream (LC 295)](../05-Two-Heaps-Pattern/5.2-Median-Stream-LC295.md)
