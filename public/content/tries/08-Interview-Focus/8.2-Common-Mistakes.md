# Trie Common Mistakes & Edge Cases

> **Compilation of frequent errors when implementing Tries and how to avoid them.**

---

## ðŸš¨ Top 10 Mistakes

### 1. Confusing Search vs StartsWith

```python
# âŒ WRONG: Returns True for prefix
def search(self, word):
    node = self.root
    for char in word:
        if char not in node.children:
            return False
        node = node.children[char]
    return True  # Wrong! "app" returns True for dictionary ["apple"]

# âœ… CORRECT: Check is_end
def search(self, word):
    node = self.root
    for char in word:
        if char not in node.children:
            return False
        node = node.children[char]
    return node.is_end  # Correct! Only True if word was inserted
```

**Rule:** `search()` needs `is_end` check, `startsWith()` doesn't.

---

### 2. Wrong Index for Array[26]

```python
# âŒ WRONG: Assumes 'a' = 0
idx = ord(char)  # 'a' = 97, causes index out of bounds!

# âœ… CORRECT: Normalize to 0-25
idx = ord(char) - ord('a')  # 'a' = 0, 'z' = 25
```

**Edge case:** Mixed case input
```python
# âŒ WRONG: 'A' - 'a' = -32 (negative!)
idx = ord('A') - ord('a')

# âœ… CORRECT: Normalize case first
idx = ord(char.lower()) - ord('a')
```

---

### 3. Bit Trie: Wrong Bit Order

```python
# âŒ WRONG: LSB first (loses max XOR property)
for i in range(32):
    bit = (num >> i) & 1

# âœ… CORRECT: MSB first (greedy works)
for i in range(31, -1, -1):  # Start from bit 31
    bit = (num >> i) & 1
```

**Why:** MSB (bit 31) contributes 2^31 to XOR. Getting a 1 there beats any combination of lower bits.

---

### 4. Forgetting to Create Root

```python
# âŒ WRONG: Root is None
class Trie:
    def __init__(self):
        pass  # Forgot to create root!

# âœ… CORRECT: Initialize root
class Trie:
    def __init__(self):
        self.root = TrieNode()  # Always create root
```

---

### 5. Word Search II: Duplicate Results

```python
# âŒ WRONG: Same word added multiple times
def backtrack(self, board, i, j, node, result):
    if node.is_end:
        result.append(some_word)  # May add duplicates!

# âœ… CORRECT: Mark as found
def backtrack(self, board, i, j, node, result):
    if node.word:  # Store word at end node
        result.append(node.word)
        node.word = None  # Prevent duplicates
```

---

### 6. Not Handling Empty Input

```python
# âŒ WRONG: Crashes on empty string
def search(self, word):
    for char in word:  # Loop doesn't run
        ...
    return node.is_end  # What is node? Still root!

# âœ… CORRECT: Handle empty explicitly or let loop handle
def search(self, word):
    if not word:
        return self.root.is_end  # "" might be a valid word
    # ... rest of implementation
```

---

### 7. Modifying During Iteration

```python
# âŒ WRONG: Modifying dict while iterating
for char in node.children:
    if should_delete(node.children[char]):
        del node.children[char]  # RuntimeError!

# âœ… CORRECT: Collect then modify
to_delete = [char for char in node.children if should_delete(node.children[char])]
for char in to_delete:
    del node.children[char]
```

---

### 8. Wildcard: Forgetting to Continue After '.'

```python
# âŒ WRONG: Only checking first matching child
def search(self, node, word, idx):
    if word[idx] == '.':
        if node.children:
            return self.search(list(node.children.values())[0], word, idx + 1)
        return False  # Only checks ONE child!

# âœ… CORRECT: Try ALL children
def search(self, node, word, idx):
    if word[idx] == '.':
        for child in node.children.values():
            if self.search(child, word, idx + 1):
                return True
        return False
```

---

### 9. Bit Trie: Empty Trie Edge Case

```python
# âŒ WRONG: Crashes on empty Trie
def get_max_xor(self, num):
    node = self.root
    for i in range(31, -1, -1):
        bit = (num >> i) & 1
        node = node.children[1 - bit]  # NullPointerException if empty!

# âœ… CORRECT: Check for empty Trie
def get_max_xor(self, num):
    if not self.root.children[0] and not self.root.children[1]:
        return -1  # or 0, or raise exception
    
    node = self.root
    # ... rest
```

---

### 10. Delete: Breaking Other Words

```python
# âŒ WRONG: Deleting nodes that are prefixes of other words
def delete(self, word):
    node = self._traverse(word)
    node.is_end = False  # Correct
    # But also removing nodes... might break other words!

# âœ… CORRECT: Only remove if node has no children and not end of another word
def delete(self, word):
    self._delete_helper(self.root, word, 0)

def _delete_helper(self, node, word, idx):
    if idx == len(word):
        node.is_end = False
        return len(node.children) == 0  # Can delete if no children
    
    char = word[idx]
    if self._delete_helper(node.children[char], word, idx + 1):
        del node.children[char]
        return not node.is_end and len(node.children) == 0
    return False
```

---

## ðŸ” Edge Cases Checklist

### Input Edge Cases

| Case | Expected Behavior |
|------|-------------------|
| Empty string "" | May be valid word if inserted |
| Single character "a" | Normal processing |
| Very long word (10^4 chars) | O(m) time, may need stack space |
| All same character "aaaa" | Single path in Trie |
| Unicode characters | Use HashMap (not Array[26]) |

### Query Edge Cases

| Case | Expected Behavior |
|------|-------------------|
| Word not in Trie | Return False |
| Prefix exists but not word | search() = False, startsWith() = True |
| Word is prefix of another | Both should work independently |
| Query longer than any word | Return False (runs out of nodes) |

### Structure Edge Cases

| Case | Handling |
|------|----------|
| Empty Trie | Return False/default |
| Single word Trie | Normal processing |
| Delete last word | Trie becomes empty |
| Insert duplicate | Update (don't double-insert) |

---

## ðŸ§ª Test Cases to Always Try

```python
# Basic functionality
trie.insert("apple")
assert trie.search("apple") == True
assert trie.search("app") == False
assert trie.startsWith("app") == True

# Edge: prefix vs word
trie.insert("app")
assert trie.search("app") == True  # Now it's a word too

# Edge: empty string
trie.insert("")
assert trie.search("") == True

# Edge: single character
trie.insert("a")
assert trie.search("a") == True
assert trie.startsWith("a") == True

# Edge: not found
assert trie.search("banana") == False
assert trie.startsWith("ban") == False
```

---

## ðŸ“Š Debugging Strategies

### 1. Print Trie Structure

```python
def print_trie(node, prefix=""):
    if node.is_end:
        print(f"Word: {prefix}")
    for char, child in node.children.items():
        print_trie(child, prefix + char)
```

### 2. Trace Path During Search

```python
def search_debug(self, word):
    node = self.root
    path = []
    for char in word:
        if char not in node.children:
            print(f"Failed at: {''.join(path)}, missing: {char}")
            return False
        node = node.children[char]
        path.append(char)
    print(f"Path: {''.join(path)}, is_end: {node.is_end}")
    return node.is_end
```

### 3. Validate Trie Invariants

```python
def validate_trie(node, path=""):
    """Check Trie integrity."""
    errors = []
    
    # Check children references
    for char, child in node.children.items():
        if child is None:
            errors.append(f"None child at {path + char}")
        errors.extend(validate_trie(child, path + char))
    
    return errors
```

---

## ðŸŽ¤ Interview Tips

**When stuck:**
1. Draw the Trie for a small example
2. Trace your algorithm step-by-step
3. Check the is_end condition
4. Verify bit order for Bit Trie

**Before submitting:**
1. Test empty input
2. Test single character
3. Test word that is prefix of another
4. Test word not in dictionary

---

> **ðŸ’¡ Key Insight:** Most Trie bugs come from confusing prefixes with words (is_end check) or off-by-one errors in bit manipulation. Always trace through with a small example before coding.
