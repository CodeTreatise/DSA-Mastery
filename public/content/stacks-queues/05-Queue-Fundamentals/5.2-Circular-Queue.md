# 5.2 Circular Queue (LC 622)

> **Grokking Pattern:** Queue Design
>
> **Difficulty:** Medium | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê Common Design Problem

---

## Problem Statement

Design your implementation of a circular queue. The circular queue is a linear data structure that follows FIFO and the last position is connected back to the first position to make a circle.

Implement the `MyCircularQueue` class:
- `MyCircularQueue(k)` - Initializes queue with size k
- `boolean enQueue(int value)` - Inserts element, returns true if successful
- `boolean deQueue()` - Deletes element, returns true if successful  
- `int Front()` - Gets front element, returns -1 if empty
- `int Rear()` - Gets rear element, returns -1 if empty
- `boolean isEmpty()` - Checks if queue is empty
- `boolean isFull()` - Checks if queue is full

[LeetCode 622 - Design Circular Queue](https://leetcode.com/problems/design-circular-queue/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- Fixed-size queue requirement
- Need to reuse space from dequeued elements
- Bounded buffer scenarios
- Ring buffer or circular buffer mentions

**Key insight:**
Instead of shifting elements on dequeue (O(n)), use two pointers that wrap around using modulo arithmetic.

</details>

---

## ‚úÖ When to Use Circular Queue

- Fixed-size buffer requirements
- Memory-constrained environments
- Producer-consumer with bounded capacity
- Streaming data with fixed window

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Variable size needed | Fixed capacity | Regular deque |
| Need to see all elements | Only front/rear exposed | Array |
| Unbounded growth | Will reject new elements | Dynamic queue |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Queue Basics](./5.1-Queue-Basics.md)
- Modulo arithmetic

**After mastering this:**
- [Design Circular Deque](https://leetcode.com/problems/design-circular-deque/) - LC 641
- Producer-consumer patterns
- Ring buffer implementations

</details>

---

## üìê How It Works

### The Circular Concept

```
Linear Queue Problem:
[_, _, 3, 4, 5]  ‚Üê Wasted space at front after dequeues
      ‚Üë     ‚Üë
    front  rear

Circular Queue Solution:
Indices wrap around: (index + 1) % capacity

Array: [6, 7, 3, 4, 5]  ‚Üê Reused front space!
           ‚Üë        ‚Üë
         rear     front

Visual as circle:
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    [3] ‚îÇ    0    ‚îÇ [6]  ‚Üê new elements wrap
        ‚îÇ         ‚îÇ
    [4] ‚îÇ    1    ‚îÇ [7]
        ‚îÇ         ‚îÇ
    [5] ‚îÇ    2    ‚îÇ [_]
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        front=2, rear=1
```

### Pointer Management

```
Initial: front=0, rear=-1, count=0, capacity=5

enQueue(1): 
    rear = (rear + 1) % 5 = 0
    array[0] = 1
    count = 1
    Array: [1, _, _, _, _]
           ‚Üë
         f=0, r=0

enQueue(2):
    rear = (0 + 1) % 5 = 1
    array[1] = 2
    count = 2
    Array: [1, 2, _, _, _]
           ‚Üë  ‚Üë
          f=0 r=1

deQueue():
    front = (0 + 1) % 5 = 1
    count = 1
    Array: [_, 2, _, _, _]  (1 is logically removed)
              ‚Üë
           f=1, r=1

enQueue(3), enQueue(4), enQueue(5), enQueue(6):
    Array: [6, 2, 3, 4, 5]  (6 wraps to index 0!)
           ‚Üë
           r=0, f=1
```

---

## üíª Code Implementation

### Solution: Array with Two Pointers

**Python:**
```python
class MyCircularQueue:
    """
    Circular Queue using array with front/rear pointers.
    
    Time: O(1) all operations
    Space: O(k) for storage
    
    Key: Use modulo to wrap indices around.
    """
    
    def __init__(self, k: int):
        self.capacity = k
        self.queue = [None] * k
        self.front = 0
        self.rear = -1
        self.count = 0
    
    def enQueue(self, value: int) -> bool:
        """Insert element at rear. Return False if full."""
        if self.isFull():
            return False
        
        # Move rear forward with wraparound
        self.rear = (self.rear + 1) % self.capacity
        self.queue[self.rear] = value
        self.count += 1
        return True
    
    def deQueue(self) -> bool:
        """Remove element from front. Return False if empty."""
        if self.isEmpty():
            return False
        
        # Move front forward with wraparound
        self.front = (self.front + 1) % self.capacity
        self.count -= 1
        return True
    
    def Front(self) -> int:
        """Get front element. Return -1 if empty."""
        if self.isEmpty():
            return -1
        return self.queue[self.front]
    
    def Rear(self) -> int:
        """Get rear element. Return -1 if empty."""
        if self.isEmpty():
            return -1
        return self.queue[self.rear]
    
    def isEmpty(self) -> bool:
        """Check if queue is empty."""
        return self.count == 0
    
    def isFull(self) -> bool:
        """Check if queue is full."""
        return self.count == self.capacity


# Alternative: Without count variable (using sentinel)
class MyCircularQueueAlt:
    """
    Alternative using k+1 size array.
    Empty: front == rear
    Full: (rear + 1) % size == front
    """
    
    def __init__(self, k: int):
        self.capacity = k + 1  # One extra slot as sentinel
        self.queue = [None] * self.capacity
        self.front = 0
        self.rear = 0
    
    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.queue[self.rear] = value
        self.rear = (self.rear + 1) % self.capacity
        return True
    
    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        return True
    
    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[self.front]
    
    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[(self.rear - 1 + self.capacity) % self.capacity]
    
    def isEmpty(self) -> bool:
        return self.front == self.rear
    
    def isFull(self) -> bool:
        return (self.rear + 1) % self.capacity == self.front
```

**JavaScript:**
```javascript
class MyCircularQueue {
    /**
     * Circular Queue using array with front/rear pointers.
     * Time: O(1) all operations
     * Space: O(k)
     */
    constructor(k) {
        this.capacity = k;
        this.queue = new Array(k).fill(null);
        this.front = 0;
        this.rear = -1;
        this.count = 0;
    }
    
    enQueue(value) {
        if (this.isFull()) {
            return false;
        }
        this.rear = (this.rear + 1) % this.capacity;
        this.queue[this.rear] = value;
        this.count++;
        return true;
    }
    
    deQueue() {
        if (this.isEmpty()) {
            return false;
        }
        this.front = (this.front + 1) % this.capacity;
        this.count--;
        return true;
    }
    
    Front() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.queue[this.front];
    }
    
    Rear() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.queue[this.rear];
    }
    
    isEmpty() {
        return this.count === 0;
    }
    
    isFull() {
        return this.count === this.capacity;
    }
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| enQueue |" O(1) "| O(1) |
| deQueue |" O(1) "| O(1) |
| Front |" O(1) "| O(1) |
| Rear |" O(1) "| O(1) |
| isEmpty |" O(1) "| O(1) |
| isFull |" O(1) "| O(1) |
| Overall storage | - |" O(k) "|

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Circular Deque | Add front, remove rear too | LC 641 |
| Thread-safe | Add locks | Producer-consumer |
| Resizable | Grow when full | Dynamic circular |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Rear Index for Last Element

```python
# ‚ùå WRONG: rear points past the last element
def Rear(self):
    return self.queue[self.rear]  # If rear is next insert position!

# ‚úÖ CORRECT: Depends on your convention
# If rear = last element position: self.queue[self.rear]
# If rear = next insert position: self.queue[(self.rear - 1 + cap) % cap]
```

### 2. Forgetting Modulo for Wraparound

```python
# ‚ùå WRONG: Index out of bounds
self.rear = self.rear + 1  # Can exceed capacity!

# ‚úÖ CORRECT: Always use modulo
self.rear = (self.rear + 1) % self.capacity
```

### 3. Confusing Empty vs Full

```python
# ‚ùå WRONG: Same condition for empty and full
# If front == rear, is it empty or full?

# ‚úÖ CORRECT: Use count variable
def isEmpty(self): return self.count == 0
def isFull(self): return self.count == self.capacity

# Or use k+1 size array (one slot always empty)
def isEmpty(self): return self.front == self.rear
def isFull(self): return (self.rear + 1) % self.size == self.front
```

### 4. Negative Modulo in Rear Calculation

```python
# ‚ùå WRONG: Can produce negative index
rear_index = (self.rear - 1) % self.capacity  # -1 % 5 = -1 in some languages

# ‚úÖ CORRECT: Add capacity before modulo
rear_index = (self.rear - 1 + self.capacity) % self.capacity
```

---

## üìù Practice Problems (Progressive)

### This Problem
- [ ] [Design Circular Queue](https://leetcode.com/problems/design-circular-queue/) - LC 622 ‚≠ê

### Related Problems
- [ ] [Design Circular Deque](https://leetcode.com/problems/design-circular-deque/) - LC 641
- [ ] [Design Front Middle Back Queue](https://leetcode.com/problems/design-front-middle-back-queue/) - LC 1670
- [ ] [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) - LC 232

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement with count variable
**Day 3:** Implement with sentinel (k+1 size)
**Day 7:** Handle all edge cases
**Day 14:** Solve Circular Deque (LC 641)
**Day 21:** Implement without looking at notes

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Explain the motivation:**
> "A regular queue wastes space when elements are dequeued from the front. A circular queue reuses that space by wrapping the rear pointer back to the beginning."

**Describe the approach:**
> "I'll use an array with front and rear pointers. Both advance using modulo arithmetic to wrap around. I'll track count to distinguish empty from full."

**Handle ambiguity:**
> "There are two conventions: rear can point to the last element or the next insert position. I'll use [your choice] and maintain count to track size."

**Discuss trade-offs:**
> "The count variable approach uses one extra int but makes logic clearer. The k+1 size approach wastes one array slot but doesn't need count."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common design |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | System design |
| Google | ‚≠ê‚≠ê‚≠ê | Variant problems |
| Bloomberg | ‚≠ê‚≠ê‚≠ê | Trading systems |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 5-10 min | Circular wraparound |
| Explain approach | 3-5 min | Modulo, pointers |
| Implement | 12-15 min | All methods |
| Test | 3-5 min | Edge cases |
| Interview target | 22-28 min | Including explanation |

---

> **üí° Key Insight:** The circular queue's magic is in `(index + 1) % capacity`. This simple formula makes the array "circular" - when the pointer reaches the end, it wraps back to the beginning. Combined with a count or sentinel approach to distinguish empty from full, we achieve O(1) operations with fixed memory.

---

## üîó Related

- [Queue Basics](./5.1-Queue-Basics.md) - Foundation concepts
- [Deque](./5.3-Deque.md) - Double-ended variant
- [Queue Using Stacks](../04-Design-Problems/4.2-Queue-Using-Stacks.md) - Alternative implementation
