# 1.6 Recursion on Strings

> **Recursive Techniques for String Processing**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê - Palindromes, reversals, string generation  
> **Prerequisites:** [1.5 Recursion on Arrays](./1.5-Recursion-On-Arrays.md)

---

## Overview

String recursion follows similar patterns to array recursion:
- **First character + rest:** Process char by char
- **Two-pointer:** Converge from ends
- **Divide and conquer:** Split in middle
- **Generation:** Build all possible strings

Strings are immutable in most languages, so we often work with indices or character arrays.

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Recursion on Strings</strong></summary>

**Good candidates:**
- Palindrome checking/generation
- String reversal
- Generating all substrings/permutations
- Recursive parsing

**Keywords:**
- "palindrome", "reverse", "permutations"
- "all possible strings", "generate"

</details>

---

## ‚úÖ When to Use

- **Palindrome problems** - Natural two-pointer recursion
- **String generation** - All permutations, combinations
- **Nested structures** - Parsing parentheses, expressions
- **Pattern matching** - Simple regex, wildcards

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Simple traversal | for loop | Simpler |
| Large strings | Iteration | Stack overflow |
| Complex pattern matching | KMP, regex | More efficient |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Recursion on Arrays](./1.5-Recursion-On-Arrays.md)
- [Thinking Recursively](./1.3-Thinking-Process.md)

**After mastering this:**
- [String Backtracking](../02-Backtracking/2.3-Core-Patterns/04-String-Backtracking.md)
- String DP problems

</details>

---

## üìê Common String Recursion Problems

### 1. Reverse String

```python
def reverse_string(s: str) -> str:
    """
    Reverse string recursively.
    
    Pattern: reverse(rest) + first
    Time: O(n¬≤) - string concatenation
    Space: O(n) - call stack
    """
    # Base case
    if len(s) <= 1:
        return s
    
    # Recursive case
    return reverse_string(s[1:]) + s[0]


# More efficient: use character array
def reverse_string_array(chars: list[str], left: int = 0, right: int = None):
    """
    Reverse in-place using two pointers.
    
    Time: O(n), Space: O(n) stack
    """
    if right is None:
        right = len(chars) - 1
    
    if left >= right:
        return
    
    # Swap
    chars[left], chars[right] = chars[right], chars[left]
    
    # Recurse on inner portion
    reverse_string_array(chars, left + 1, right - 1)
```

```javascript
function reverseString(s) {
    if (s.length <= 1) return s;
    return reverseString(s.slice(1)) + s[0];
}

function reverseStringArray(chars, left = 0, right = chars.length - 1) {
    if (left >= right) return;
    [chars[left], chars[right]] = [chars[right], chars[left]];
    reverseStringArray(chars, left + 1, right - 1);
}
```

---

### 2. Check Palindrome

```python
def is_palindrome(s: str) -> bool:
    """
    Check if string is palindrome.
    
    Pattern: Compare ends, check middle
    Time: O(n), Space: O(n) stack
    """
    # Base case: empty or single char
    if len(s) <= 1:
        return True
    
    # Check ends match
    if s[0] != s[-1]:
        return False
    
    # Check middle
    return is_palindrome(s[1:-1])


# With indices (more efficient)
def is_palindrome_idx(s: str, left: int = 0, right: int = None) -> bool:
    """Palindrome check with indices."""
    if right is None:
        right = len(s) - 1
    
    if left >= right:
        return True
    
    if s[left] != s[right]:
        return False
    
    return is_palindrome_idx(s, left + 1, right - 1)


# Ignoring non-alphanumeric (interview version)
def is_palindrome_clean(s: str, left: int = 0, right: int = None) -> bool:
    """Palindrome ignoring spaces and case."""
    if right is None:
        right = len(s) - 1
    
    # Skip non-alphanumeric
    while left < right and not s[left].isalnum():
        left += 1
    while left < right and not s[right].isalnum():
        right -= 1
    
    if left >= right:
        return True
    
    if s[left].lower() != s[right].lower():
        return False
    
    return is_palindrome_clean(s, left + 1, right - 1)
```

```javascript
function isPalindrome(s) {
    if (s.length <= 1) return true;
    if (s[0] !== s[s.length - 1]) return false;
    return isPalindrome(s.slice(1, -1));
}

function isPalindromeIdx(s, left = 0, right = s.length - 1) {
    if (left >= right) return true;
    if (s[left] !== s[right]) return false;
    return isPalindromeIdx(s, left + 1, right - 1);
}
```

---

### 3. Count Occurrences

```python
def count_char(s: str, char: str, index: int = 0) -> int:
    """
    Count occurrences of character in string.
    
    Time: O(n), Space: O(n)
    """
    if index == len(s):
        return 0
    
    count = 1 if s[index] == char else 0
    return count + count_char(s, char, index + 1)


def count_substring(s: str, sub: str) -> int:
    """Count non-overlapping occurrences of substring."""
    if len(s) < len(sub):
        return 0
    
    if s[:len(sub)] == sub:
        return 1 + count_substring(s[len(sub):], sub)
    else:
        return count_substring(s[1:], sub)
```

```javascript
function countChar(s, char, index = 0) {
    if (index === s.length) return 0;
    const count = s[index] === char ? 1 : 0;
    return count + countChar(s, char, index + 1);
}
```

---

### 4. Remove Character

```python
def remove_char(s: str, char: str) -> str:
    """
    Remove all occurrences of character.
    
    Time: O(n¬≤) due to concatenation
    Space: O(n)
    """
    if not s:
        return ""
    
    rest = remove_char(s[1:], char)
    
    if s[0] == char:
        return rest
    else:
        return s[0] + rest


def remove_duplicates(s: str) -> str:
    """Remove consecutive duplicate characters."""
    if len(s) <= 1:
        return s
    
    if s[0] == s[1]:
        return remove_duplicates(s[1:])
    else:
        return s[0] + remove_duplicates(s[1:])
```

```javascript
function removeChar(s, char) {
    if (!s) return "";
    const rest = removeChar(s.slice(1), char);
    return s[0] === char ? rest : s[0] + rest;
}

function removeDuplicates(s) {
    if (s.length <= 1) return s;
    if (s[0] === s[1]) return removeDuplicates(s.slice(1));
    return s[0] + removeDuplicates(s.slice(1));
}
```

---

### 5. Generate All Substrings

```python
def all_substrings(s: str) -> list[str]:
    """
    Generate all non-empty substrings.
    
    Time: O(n¬≥) - n¬≤ substrings, O(n) each
    Space: O(n¬≤) for result
    """
    result = []
    
    def generate(start: int, end: int):
        if start == len(s):
            return
        if end > len(s):
            generate(start + 1, start + 2)
            return
        
        result.append(s[start:end])
        generate(start, end + 1)
    
    generate(0, 1)
    return result


# Example
print(all_substrings("abc"))
# ['a', 'ab', 'abc', 'b', 'bc', 'c']
```

---

### 6. String Permutations

```python
def permutations(s: str) -> list[str]:
    """
    Generate all permutations of string.
    
    Time: O(n! * n), Space: O(n)
    """
    # Base case
    if len(s) <= 1:
        return [s]
    
    result = []
    
    for i, char in enumerate(s):
        # Remove char at position i
        remaining = s[:i] + s[i+1:]
        
        # Get permutations of remaining
        for perm in permutations(remaining):
            result.append(char + perm)
    
    return result


# With backtracking (more efficient)
def permutations_backtrack(s: str) -> list[str]:
    """Permutations using backtracking."""
    result = []
    chars = list(s)
    
    def backtrack(start: int):
        if start == len(chars):
            result.append(''.join(chars))
            return
        
        for i in range(start, len(chars)):
            chars[start], chars[i] = chars[i], chars[start]
            backtrack(start + 1)
            chars[start], chars[i] = chars[i], chars[start]
    
    backtrack(0)
    return result


# Example
print(permutations("abc"))
# ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']
```

```javascript
function permutations(s) {
    if (s.length <= 1) return [s];
    
    const result = [];
    for (let i = 0; i < s.length; i++) {
        const char = s[i];
        const remaining = s.slice(0, i) + s.slice(i + 1);
        
        for (const perm of permutations(remaining)) {
            result.push(char + perm);
        }
    }
    return result;
}
```

---

## üíª Code: Practical Interview Examples

### Check if String is Valid Number

```python
def is_numeric(s: str, index: int = 0, has_digit: bool = False) -> bool:
    """
    Check if string represents valid integer.
    Allows optional leading +/- sign.
    """
    if index == len(s):
        return has_digit  # Must have at least one digit
    
    char = s[index]
    
    # First char can be sign
    if index == 0 and char in '+-':
        return is_numeric(s, 1, False)
    
    if char.isdigit():
        return is_numeric(s, index + 1, True)
    
    return False
```

### Decode String (LC 394 simplified)

```python
def decode_string(s: str) -> str:
    """
    Decode string like "3[a2[c]]" ‚Üí "accaccacc"
    
    Simplified version for demonstration.
    """
    def helper(index: int):
        result = []
        num = 0
        
        while index < len(s):
            char = s[index]
            
            if char.isdigit():
                num = num * 10 + int(char)
            elif char == '[':
                # Recursively decode inner part
                decoded, index = helper(index + 1)
                result.append(decoded * num)
                num = 0
            elif char == ']':
                return ''.join(result), index
            else:
                result.append(char)
            
            index += 1
        
        return ''.join(result), index
    
    return helper(0)[0]
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Reverse (concat) |" O(n¬≤) "| O(n) |" String concat is O(n) "|
| Reverse (array) |" O(n) "| O(n) | In-place swap |
| Palindrome |" O(n) "| O(n) | Two-pointer |
| Permutations |" O(n! * n) "| O(n) | n! results |
| All substrings |" O(n¬≥) "| O(n¬≤) | n¬≤ substrings |

**String immutability costs:**
```python
s = s + char  # O(n) - creates new string
```
Use `list` and `''.join()` for efficiency.

---

## üîÑ Variations

| Pattern | Description | Example |
|---------|-------------|---------|
| **Two-pointer** | Compare from ends | Palindrome |
| **Build up** | Construct character by character | Remove, filter |
| **Generate all** | All permutations/combinations | Permutations |
| **Parse** | Process structured strings | Decode, parse |

---

## ‚ö†Ô∏è Common Mistakes

### 1. String Concatenation in Loop

‚ùå **Wrong:** O(n¬≤) due to repeated concatenation
```python
def build_string(chars):
    result = ""
    for c in chars:
        result += c  # Creates new string each time!
    return result
```

‚úÖ **Correct:** O(n) with list
```python
def build_string(chars):
    result = []
    for c in chars:
        result.append(c)
    return ''.join(result)
```

### 2. Wrong Slicing for Palindrome

‚ùå **Wrong:**
```python
def is_palindrome(s):
    if len(s) <= 1: return True
    return s[0] == s[-1] and is_palindrome(s[1:-2])  # Wrong slice!
```

‚úÖ **Correct:**
```python
def is_palindrome(s):
    if len(s) <= 1: return True
    return s[0] == s[-1] and is_palindrome(s[1:-1])  # Correct: 1 to -1
```

### 3. Forgetting Empty String Base Case

‚ùå **Wrong:**
```python
def reverse(s):
    return reverse(s[1:]) + s[0]  # No base case!
```

‚úÖ **Correct:**
```python
def reverse(s):
    if not s:  # or len(s) <= 1
        return s
    return reverse(s[1:]) + s[0]
```

---

## üìù Practice Problems

### Easy (Learn the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Reverse String | Two-pointer recursion | [LC 344](https://leetcode.com/problems/reverse-string/) |
| Valid Palindrome | Clean + check | [LC 125](https://leetcode.com/problems/valid-palindrome/) |

### Medium (Apply pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Palindrome Partitioning | All partitions | [LC 131](https://leetcode.com/problems/palindrome-partitioning/) |
| Decode String | Recursive parsing | [LC 394](https://leetcode.com/problems/decode-string/) |
| Letter Combinations | String generation | [LC 17](https://leetcode.com/problems/letter-combinations-of-a-phone-number/) |
| Permutations | All orderings | [LC 46](https://leetcode.com/problems/permutations/) |

### Hard (Master pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Regular Expression Matching | Recursive matching | [LC 10](https://leetcode.com/problems/regular-expression-matching/) |
| Wildcard Matching | Pattern matching | [LC 44](https://leetcode.com/problems/wildcard-matching/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: Reverse string (both ways)
- Day 2: Palindrome check (with indices)
- Day 3: LC 344, LC 125
- Day 5: String permutations

**Week 2:**
- LC 17 (Letter Combinations)
- LC 394 (Decode String)
- LC 131 (Palindrome Partitioning)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**For palindrome:**
> "I'll use a two-pointer approach recursively, comparing characters from both ends and moving inward."

**For permutations:**
> "I'll fix each character at the first position, then recursively generate permutations of the remaining characters."

**When asked about efficiency:**
> "Strings are immutable, so I'll work with a character array to avoid O(n) concatenation at each step."

**Common follow-ups:**
- "What if string has duplicates?" ‚Üí Skip duplicate characters in permutations
- "Can you do it iteratively?" ‚Üí Yes, using a stack

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand patterns | 20-30 min | With examples |
| Implement reverse, palindrome | 15-20 min | Basic |
| Implement permutations | 20-30 min | More complex |
| Solve 4 problems | 60-90 min | Application |

---

## üí° Key Insight

> **Strings are immutable‚Äîplan for it:**
>
> In most languages, `s + char` creates a new string. For recursive string building:
> 1. Use a **list of characters** and `join()` at the end
> 2. Pass **indices** instead of slicing
> 3. Use **StringBuilder** (Java) or equivalent
>
> This can improve O(n¬≤) to O(n) for many operations.

---

## üîó Related

- [Recursion on Arrays](./1.5-Recursion-On-Arrays.md) - Similar techniques
- [String Backtracking](../02-Backtracking/2.3-Core-Patterns/04-String-Backtracking.md) - Advanced string generation
- [Palindrome Problems](../../01-Arrays-Strings.md) - More string problems
