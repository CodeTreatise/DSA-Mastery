# Segment Tree Practice Problems

> **Curated problems for mastering Segment Trees.**
>
> From basic range queries to advanced applications.

---

## ðŸ“Š Problem Overview

| Category | Count | Difficulty Range |
|----------|-------|------------------|
| Basic Range Query | 2 | Easy-Medium |
| Range with Updates | 2 | Medium |
| Advanced Applications | 3 | Medium-Hard |

---

## ðŸŸ¢ Easy/Medium: Basic Range Query

### 1. Range Sum Query - Mutable (LC 307)

**Link:** [LeetCode 307](https://leetcode.com/problems/range-sum-query-mutable/)

**Problem:** Given array, support `update(index, val)` and `sumRange(left, right)`.

**Key Points:**
- Classic segment tree application
- Point update, range query
- No lazy propagation needed

**Template:**
```python
class NumArray:
    def __init__(self, nums):
        self.n = len(nums)
        self.tree = [0] * (4 * self.n)
        self._build(nums, 1, 0, self.n - 1)
    
    def update(self, index, val):
        self._update(1, 0, self.n - 1, index, val)
    
    def sumRange(self, left, right):
        return self._query(1, 0, self.n - 1, left, right)
```

**Time Target:** 20-25 min

---

### 2. Range Minimum Query

**Problem:** Given array, answer `minRange(left, right)` efficiently.

**Key Difference from Sum:**
```python
# Merge function
def merge(a, b):
    return min(a, b)

# Identity
identity = float('inf')

# Query no-overlap case
if R < start or end < L:
    return float('inf')  # Not 0!
```

---

## ðŸŸ¡ Medium: Range with Updates

### 3. Corporate Flight Bookings (LC 1109)

**Link:** [LeetCode 1109](https://leetcode.com/problems/corporate-flight-bookings/)

**Problem:** n flights, bookings = [[first, last, seats], ...]. Return seats per flight.

**Approach 1: Difference Array (simpler)**
```python
def corpFlightBookings(bookings, n):
    diff = [0] * (n + 1)
    for first, last, seats in bookings:
        diff[first - 1] += seats
        diff[last] -= seats
    
    result = []
    current = 0
    for i in range(n):
        current += diff[i]
        result.append(current)
    return result
```

**Approach 2: Segment Tree with Lazy (overkill but good practice)**
- Range add update
- Point query for each flight

---

### 4. My Calendar I (LC 729)

**Link:** [LeetCode 729](https://leetcode.com/problems/my-calendar-i/)

**Problem:** Implement calendar that checks for conflicts when booking.

**Key Insight:** Track booked intervals, check for overlap.

**Segment Tree Approach:**
- Range update: mark [start, end) as booked
- Range query: check if any in [start, end) is booked

```python
def book(self, start, end):
    if self.query(start, end - 1) > 0:
        return False  # Conflict
    self.update(start, end - 1, 1)
    return True
```

---

## ðŸ”´ Hard: Advanced Applications

### 5. Count of Smaller Numbers After Self (LC 315)

**Link:** [LeetCode 315](https://leetcode.com/problems/count-of-smaller-numbers-after-self/)

**Problem:** For each nums[i], count elements to its right that are smaller.

**Key Insight:** Process right to left, use segment tree as frequency counter.

```python
def countSmaller(nums):
    # Coordinate compression
    sorted_nums = sorted(set(nums))
    rank = {v: i for i, v in enumerate(sorted_nums)}
    
    n = len(sorted_nums)
    tree = SegmentTree(n)  # Count tree
    result = []
    
    for num in reversed(nums):
        r = rank[num]
        # Count elements with rank < r (smaller elements)
        count = tree.query(0, r - 1)
        result.append(count)
        # Add current element to tree
        tree.update(r, tree.point_query(r) + 1)
    
    return result[::-1]
```

**Time:** O(n log n)

---

### 6. Count of Range Sum (LC 327)

**Link:** [LeetCode 327](https://leetcode.com/problems/count-of-range-sum/)

**Problem:** Count subarray sums in range [lower, upper].

**Key Insight:** 
- Subarray sum = prefix[j] - prefix[i] for i < j
- For each j, count prefix[i] where prefix[j] - upper â‰¤ prefix[i] â‰¤ prefix[j] - lower

**Approach:** Merge sort or segment tree with coordinate compression.

---

### 7. Falling Squares (LC 699)

**Link:** [LeetCode 699](https://leetcode.com/problems/falling-squares/)

**Problem:** Squares fall on x-axis. For each, report max height so far.

**Key Operations:**
- Range max query: What's the max height in interval [left, right)?
- Range set update: Set height of [left, right) to new value

```python
def fallingSquares(positions):
    # Coordinate compression for large coordinates
    coords = set()
    for left, size in positions:
        coords.add(left)
        coords.add(left + size)
    sorted_coords = sorted(coords)
    idx = {v: i for i, v in enumerate(sorted_coords)}
    
    n = len(sorted_coords)
    tree = LazySegmentTree(n, "max")
    
    result = []
    max_height = 0
    
    for left, size in positions:
        l, r = idx[left], idx[left + size] - 1
        
        # Get current max height in landing zone
        base = tree.query(l, r)
        
        # New height after square lands
        new_height = base + size
        
        # Update range to new height
        tree.range_update(l, r, new_height)
        
        # Track global max
        max_height = max(max_height, new_height)
        result.append(max_height)
    
    return result
```

---

## ðŸ“‹ Study Plan

### Week 1: Foundation

| Day | Problem | Focus |
|-----|---------|-------|
| 1-2 | Range Sum Query Mutable | Basic implementation |
| 3 | Range Minimum Query | Different merge function |
| 4-5 | Corporate Flight Bookings | Range updates |

### Week 2: Advanced

| Day | Problem | Focus |
|-----|---------|-------|
| 6-7 | Count Smaller After Self | Creative indexing |
| 8-9 | Falling Squares | Lazy propagation |
| 10 | Review all problems | Consolidation |

---

## ðŸŽ¯ Pattern Quick Reference

| Problem Type | Key Technique |
|--------------|---------------|
| Range sum + point update | Basic segment tree |
| Range min/max + point update | Change merge function |
| Range update + point/range query | Lazy propagation |
| Count elements in range | Frequency segment tree |
| Max height problems | Range max with lazy |

---

## â±ï¸ Target Times

| Difficulty | Coding | Total |
|------------|--------|-------|
| Medium | 25-30 min | 35-40 min |
| Hard | 35-40 min | 50-55 min |

---

## ðŸ§  Spaced Repetition

| Day | Activity |
|-----|----------|
| Day 1 | Solve with reference |
| Day 3 | Implement from scratch |
| Day 7 | Solve similar problem |
| Day 14 | Full re-implementation |

---

## ðŸ“ Template Code

### Basic Segment Tree

```python
class SegmentTree:
    def __init__(self, arr):
        self.n = len(arr)
        self.tree = [0] * (4 * self.n)
        self._build(arr, 1, 0, self.n - 1)
    
    def _build(self, arr, node, s, e):
        if s == e:
            self.tree[node] = arr[s]
        else:
            m = (s + e) // 2
            self._build(arr, 2*node, s, m)
            self._build(arr, 2*node+1, m+1, e)
            self.tree[node] = self.tree[2*node] + self.tree[2*node+1]
    
    def update(self, idx, val):
        self._update(1, 0, self.n-1, idx, val)
    
    def _update(self, node, s, e, idx, val):
        if s == e:
            self.tree[node] = val
        else:
            m = (s + e) // 2
            if idx <= m:
                self._update(2*node, s, m, idx, val)
            else:
                self._update(2*node+1, m+1, e, idx, val)
            self.tree[node] = self.tree[2*node] + self.tree[2*node+1]
    
    def query(self, l, r):
        return self._query(1, 0, self.n-1, l, r)
    
    def _query(self, node, s, e, l, r):
        if r < s or e < l: return 0
        if l <= s and e <= r: return self.tree[node]
        m = (s + e) // 2
        return self._query(2*node, s, m, l, r) + self._query(2*node+1, m+1, e, l, r)
```

---

> **ðŸ’¡ Key Insight:** Segment tree problems often require creative problem reformulation. "Count smaller elements" becomes "range frequency query". "Max height after drops" becomes "range max with range set". Practice seeing these transformations.

> **ðŸ”— Related:** [Segment Tree Fundamentals](./3.1-Segment-Tree-Fundamentals.md) | [Fenwick Tree](../04-Fenwick-Tree/4.1-BIT-Fundamentals.md)
