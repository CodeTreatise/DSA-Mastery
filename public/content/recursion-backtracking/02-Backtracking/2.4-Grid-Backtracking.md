# 2.4 Grid Backtracking

> **Backtracking on 2D Grids: Word Search, Path Finding, Islands**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - Word Search is a FAANG favorite  
> **Prerequisites:** [2.2 Backtracking Template](./2.2-Backtracking-Template.md)

---

## Overview

**Grid Backtracking** applies the backtracking template to 2D matrices:
- **Word Search** - Find word path in grid
- **Path Finding** - All paths from source to destination
- **Island Problems** - Explore connected regions
- **Maze Solving** - Find paths with constraints

The key difference: **4-directional movement** (up, down, left, right) and **in-place marking** for visited cells.

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Grid Backtracking</strong></summary>

**Look for these signals:**
- "Find word/path in **2D grid**"
- "All **paths** from source to destination"
- "**Explore** connected cells"
- Need to **undo** cell visits (unlike simple DFS)

**Keywords in problem statement:**
- "word search", "find path", "all paths"
- "grid", "matrix", "board"
- "connected", "adjacent"

**Grid backtracking vs Grid DFS:**
- **DFS:** Mark visited permanently, don't undo
- **Backtracking:** Mark visited, explore, then UNMARK

</details>

---

## ‚úÖ When to Use Grid Backtracking

- **Word Search** - Check if word exists in grid
- **All paths** - Find every path from A to B
- **Constraint exploration** - Paths with specific properties
- **Combination with constraints** - Robot paths, unique paths

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Shortest path | BFS | Backtracking doesn't guarantee shortest |
| Connected components | Simple DFS | No need to undo |
| Count islands | DFS/BFS flood fill | Simpler |
| Single path existence | DFS | Stop at first |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Backtracking Template](./2.2-Backtracking-Template.md)
- [Core Patterns](./2.3-Core-Patterns/) - Subsets, Permutations

**After mastering this:**
- [Classic Problems](./2.5-Classic-Problems.md) - N-Queens, Sudoku
- Graph Algorithms - DFS/BFS

**Related concepts:**
- Grid DFS/BFS
- Flood Fill
- Matrix traversal

</details>

---

## üìê Grid Backtracking Template

```python
def grid_backtrack(grid, start_row, start_col):
    """Generic grid backtracking template."""
    rows, cols = len(grid), len(grid[0])
    
    # 4 directions: up, down, left, right
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    def is_valid(row, col):
        return 0 <= row < rows and 0 <= col < cols
    
    def backtrack(row, col, state):
        # Base case: reached goal or invalid
        if is_goal(row, col, state):
            return True  # or save solution
        
        # Mark visited (CHOOSE)
        original = grid[row][col]
        grid[row][col] = '#'  # or use visited set
        
        # Try all 4 directions
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            if is_valid(new_row, new_col) and grid[new_row][new_col] != '#':
                if backtrack(new_row, new_col, next_state):
                    return True  # Found solution
        
        # Unmark visited (UNCHOOSE)
        grid[row][col] = original
        
        return False
    
    return backtrack(start_row, start_col, initial_state)
```

---

## üíª Problem 1: Word Search

### Problem Statement
Given an m*n grid and a word, return true if the word exists in the grid.

```
board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCCED" ‚Üí true
word = "SEE" ‚Üí true  
word = "ABCB" ‚Üí false (can't reuse cell)
```

### How It Works

```
Find "SEE":

['A','B','C','E']    Start at 'S' (1,0) or (2,0) or (1,3)
['S','F','C','S']    
['A','D','E','E']    

From S(1,3):
  ‚Üí E(2,3): matches 'E' (index 1)
    ‚Üí E(2,2): matches 'E' (index 2)
      ‚Üí All matched! Return true
```

### Code

```python
def exist(board: list[list[str]], word: str) -> bool:
    """
    Check if word exists in grid using backtracking.
    
    Time: O(M * N * 4^L) where L = len(word)
    Space: O(L) for recursion
    """
    if not board or not board[0] or not word:
        return False
    
    rows, cols = len(board), len(board[0])
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    def backtrack(row: int, col: int, index: int) -> bool:
        # Base case: found all characters
        if index == len(word):
            return True
        
        # Bounds check
        if not (0 <= row < rows and 0 <= col < cols):
            return False
        
        # Character mismatch or already visited
        if board[row][col] != word[index]:
            return False
        
        # CHOOSE: mark as visited
        original = board[row][col]
        board[row][col] = '#'
        
        # EXPLORE: try all 4 directions
        for dr, dc in directions:
            if backtrack(row + dr, col + dc, index + 1):
                return True
        
        # UNCHOOSE: restore cell
        board[row][col] = original
        
        return False
    
    # Try starting from each cell
    for i in range(rows):
        for j in range(cols):
            if backtrack(i, j, 0):
                return True
    
    return False


# Example
board = [
    ['A','B','C','E'],
    ['S','F','C','S'],
    ['A','D','E','E']
]
print(exist(board, "ABCCED"))  # True
print(exist(board, "SEE"))     # True
print(exist(board, "ABCB"))    # False
```

```javascript
function exist(board, word) {
    if (!board || !board[0] || !word) return false;
    
    const rows = board.length;
    const cols = board[0].length;
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    
    function backtrack(row, col, index) {
        if (index === word.length) return true;
        
        if (row < 0 || row >= rows || col < 0 || col >= cols) {
            return false;
        }
        
        if (board[row][col] !== word[index]) return false;
        
        // CHOOSE
        const original = board[row][col];
        board[row][col] = '#';
        
        // EXPLORE
        for (const [dr, dc] of directions) {
            if (backtrack(row + dr, col + dc, index + 1)) {
                return true;
            }
        }
        
        // UNCHOOSE
        board[row][col] = original;
        
        return false;
    }
    
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (backtrack(i, j, 0)) return true;
        }
    }
    
    return false;
}
```

---

## üíª Problem 2: All Paths from Source to Target

### Problem Statement
Find all paths from top-left (0,0) to bottom-right (m-1, n-1).

```
grid = [
  [1, 1, 1],
  [1, 0, 1],  (0 = blocked)
  [1, 1, 1]
]
Output: All valid paths from (0,0) to (2,2)
```

### Code

```python
def all_paths_grid(grid: list[list[int]]) -> list[list[tuple]]:
    """
    Find all paths from top-left to bottom-right.
    
    Time: O(4^(M*N)) worst case
    Space: O(M*N) for path
    """
    if not grid or not grid[0] or grid[0][0] == 0:
        return []
    
    rows, cols = len(grid), len(grid[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
    result = []
    
    def backtrack(row: int, col: int, path: list):
        # Base case: reached destination
        if row == rows - 1 and col == cols - 1:
            result.append(path[:])
            return
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            # Valid, not blocked, not visited
            if (0 <= new_row < rows and 
                0 <= new_col < cols and
                grid[new_row][new_col] == 1):
                
                # CHOOSE
                grid[new_row][new_col] = 2  # Mark visited
                path.append((new_row, new_col))
                
                # EXPLORE
                backtrack(new_row, new_col, path)
                
                # UNCHOOSE
                path.pop()
                grid[new_row][new_col] = 1
    
    grid[0][0] = 2  # Mark start as visited
    backtrack(0, 0, [(0, 0)])
    grid[0][0] = 1  # Restore
    
    return result
```

---

## üíª Problem 3: Unique Paths III (Walk Every Empty Cell)

### Problem Statement
Find paths that walk over every non-obstacle cell exactly once.

```
grid = [
  [1, 0, 0, 0],
  [0, 0, 0, 0],
  [0, 0, 2, -1]  (1=start, 2=end, 0=empty, -1=obstacle)
]
```

### Code

```python
def unique_paths_iii(grid: list[list[int]]) -> int:
    """
    Count paths that visit every empty cell exactly once.
    
    Time: O(4^(M*N)), Space: O(M*N)
    """
    rows, cols = len(grid), len(grid[0])
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    # Find start, end, and count empty cells
    start = end = None
    empty_count = 0
    
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 1:
                start = (i, j)
            elif grid[i][j] == 2:
                end = (i, j)
                empty_count += 1  # End counts as empty
            elif grid[i][j] == 0:
                empty_count += 1
    
    count = 0
    
    def backtrack(row: int, col: int, remaining: int):
        nonlocal count
        
        # Reached end
        if (row, col) == end:
            if remaining == 0:  # Visited all cells
                count += 1
            return
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            if (0 <= new_row < rows and 
                0 <= new_col < cols and
                grid[new_row][new_col] >= 0):  # Not obstacle, not visited
                
                # CHOOSE
                original = grid[new_row][new_col]
                grid[new_row][new_col] = -2  # Mark visited
                
                # EXPLORE
                backtrack(new_row, new_col, remaining - 1)
                
                # UNCHOOSE
                grid[new_row][new_col] = original
    
    grid[start[0]][start[1]] = -2  # Mark start visited
    backtrack(start[0], start[1], empty_count)
    
    return count
```

```javascript
function uniquePathsIII(grid) {
    const rows = grid.length;
    const cols = grid[0].length;
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    
    let start, end;
    let emptyCount = 0;
    
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] === 1) start = [i, j];
            else if (grid[i][j] === 2) { end = [i, j]; emptyCount++; }
            else if (grid[i][j] === 0) emptyCount++;
        }
    }
    
    let count = 0;
    
    function backtrack(row, col, remaining) {
        if (row === end[0] && col === end[1]) {
            if (remaining === 0) count++;
            return;
        }
        
        for (const [dr, dc] of directions) {
            const newRow = row + dr;
            const newCol = col + dc;
            
            if (newRow >= 0 && newRow < rows && 
                newCol >= 0 && newCol < cols &&
                grid[newRow][newCol] >= 0) {
                
                const original = grid[newRow][newCol];
                grid[newRow][newCol] = -2;
                backtrack(newRow, newCol, remaining - 1);
                grid[newRow][newCol] = original;
            }
        }
    }
    
    grid[start[0]][start[1]] = -2;
    backtrack(start[0], start[1], emptyCount);
    
    return count;
}
```

---

## ‚ö° Complexity Analysis

| Problem | Time | Space | Notes |
|---------|------|-------|-------|
| Word Search |" O(M*N*4^L) "| O(L) | L = word length |
| All Paths |" O(4^(M*N)) "| O(M*N) | Exponential worst case |
| Unique Paths III |" O(4^(M*N)) "| O(M*N) | Visit all cells |

**Why 4^L for Word Search?**
- At each cell, up to 4 choices
- Word length L ‚Üí maximum L recursive calls
- Total: O(M*N) starting positions * O(4^L) per start

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| **Word Search** | Match sequence | LC 79 |
| **Word Search II** | Multiple words (Trie) | LC 212 |
| **All Paths** | Find all paths | LC 980 |
| **Robot Cleaner** | Unknown grid | LC 489 |
| **Minesweeper** | Reveal cells | LC 529 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Restore Grid

‚ùå **Wrong:**
```python
def backtrack(row, col):
    grid[row][col] = '#'  # Mark visited
    for dr, dc in directions:
        backtrack(row + dr, col + dc)
    # Forgot to restore!
```

‚úÖ **Correct:**
```python
def backtrack(row, col):
    original = grid[row][col]
    grid[row][col] = '#'
    for dr, dc in directions:
        backtrack(row + dr, col + dc)
    grid[row][col] = original  # MUST restore
```

### 2. Wrong Order of Checks

‚ùå **Wrong:**
```python
def backtrack(row, col, index):
    if board[row][col] != word[index]:  # Access before bounds check!
        return False
    if row < 0 or row >= rows:
        return False
```

‚úÖ **Correct:**
```python
def backtrack(row, col, index):
    if row < 0 or row >= rows or col < 0 or col >= cols:
        return False  # Bounds check FIRST
    if board[row][col] != word[index]:
        return False
```

### 3. Not Marking Start Cell

‚ùå **Wrong:**
```python
def backtrack(row, col, path):
    if row == end[0] and col == end[1]:
        result.append(path[:])
        return
    for dr, dc in directions:
        # May revisit start cell!
```

‚úÖ **Correct:**
```python
grid[start[0]][start[1]] = '#'  # Mark start before recursing
backtrack(start[0], start[1], [start])
```

---

## üìù Practice Problems

### Medium (Learn the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Word Search | Basic grid backtracking | [LC 79](https://leetcode.com/problems/word-search/) |
| Unique Paths III | Visit all cells | [LC 980](https://leetcode.com/problems/unique-paths-iii/) |
| Path with Maximum Gold | Collect gold | [LC 1219](https://leetcode.com/problems/path-with-maximum-gold/) |

### Hard (Master the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Word Search II | Trie + backtracking | [LC 212](https://leetcode.com/problems/word-search-ii/) |
| Robot Room Cleaner | Unknown grid | [LC 489](https://leetcode.com/problems/robot-room-cleaner/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: Word Search (LC 79)
- Day 3: Trace through examples
- Day 5: Unique Paths III (LC 980)

**Week 2:**
- Day 8: Path with Maximum Gold
- Day 10: Word Search II (Trie optimization)
- Day 14: Review and time yourself

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Opening for Word Search:**
> "I'll use backtracking on the grid. Starting from each cell, I'll try to match the word character by character, exploring all 4 directions and backtracking when there's a mismatch."

**Explaining the marking:**
> "I mark cells as visited in-place by replacing the character with a special marker. After exploring, I restore the original character to allow other paths to use this cell."

**Complexity discussion:**
> "Time is O(M*N*4^L) where L is word length. Each starting position can branch 4 ways for L steps. Space is O(L) for the recursion stack."

**Company Focus:**

| Company | Grid Problems |
|---------|---------------|
| Google | Word Search II, Robot Cleaner |
| Amazon | Word Search, Path Finding |
| Meta | Grid backtracking variants |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand pattern | 20-30 min | With visualization |
| Word Search | 25-35 min | First attempt |
| Unique Paths III | 30-40 min | Counting variation |
| Word Search II | 45-60 min | Trie optimization |

---

## üí° Key Insight

> **Grid backtracking is just backtracking with 4 directions:**
>
> The template is the same:
> 1. **CHOOSE:** Mark cell as visited (change value or use set)
> 2. **EXPLORE:** Try all 4 directions recursively
> 3. **UNCHOOSE:** Restore cell's original value
>
> The key difference from regular DFS: you MUST restore the cell after exploring to allow other paths to use it.

---

## üîó Related

- [Backtracking Template](./2.2-Backtracking-Template.md) - Foundation
- [Classic Problems](./2.5-Classic-Problems.md) - N-Queens, Sudoku
- [String Backtracking](./2.3-Core-Patterns/04-String-Backtracking.md) - Non-grid backtracking
- [Graph DFS/BFS](../../10-Graphs.md) - Related techniques
