# 7.3 Union-Find Applications

> **Real-world patterns: connectivity, cycles, MST, and more**
>
> ðŸŽ¯ **Master these patterns to handle any Union-Find problem**

---

## Overview

Union-Find appears in several distinct problem patterns:

| Pattern | Example | Key Operation |
|---------|---------|---------------|
| **Connectivity queries** | Number of provinces | Count after unions |
| **Cycle detection** | Redundant connection | Union returns false |
| **Kruskal's MST** | Min cost to connect | Sort edges + union |
| **Grid problems** | Number of islands | 2D to 1D mapping |
| **Dynamic connectivity** | Online queries | Multiple union/find |

---

## Pattern 1: Count Connected Components

### Problem Type
Given nodes and edges, count distinct groups.

### Template

```python
def count_components(n: int, edges: list) -> int:
    """Count connected components using Union-Find."""
    uf = UnionFind(n)
    
    for u, v in edges:
        uf.union(u, v)
    
    return uf.count
```

### Example: Number of Provinces (LC 547)

```python
def findCircleNum(isConnected: list[list[int]]) -> int:
    """
    Given adjacency matrix, count connected components (provinces).
    """
    n = len(isConnected)
    uf = UnionFind(n)
    
    for i in range(n):
        for j in range(i + 1, n):  # Upper triangle only
            if isConnected[i][j] == 1:
                uf.union(i, j)
    
    return uf.count
```

---

## Pattern 2: Cycle Detection (Undirected Graph)

### Problem Type
Find edge that creates a cycle, or detect if cycle exists.

### Key Insight
If `union(u, v)` returns `False`, u and v are already connected â†’ adding edge creates cycle.

### Template

```python
def find_redundant_connection(edges: list) -> list:
    """Find edge that creates a cycle."""
    n = len(edges)
    uf = UnionFind(n + 1)  # Often 1-indexed
    
    for u, v in edges:
        if not uf.union(u, v):
            return [u, v]  # This edge forms a cycle!
    
    return []
```

### Example: Redundant Connection (LC 684)

```python
def findRedundantConnection(edges: list[list[int]]) -> list[int]:
    """
    Tree with one extra edge. Find the edge that creates cycle.
    """
    uf = UnionFind(len(edges) + 1)
    
    for u, v in edges:
        if uf.connected(u, v):
            return [u, v]
        uf.union(u, v)
    
    return []
```

---

## Pattern 3: Kruskal's MST

### Problem Type
Find minimum cost to connect all nodes.

### Key Insight
Sort edges by weight, add edge only if it connects different components.

### Template

```python
def kruskal_mst(n: int, edges: list) -> int:
    """
    edges = [(weight, u, v), ...]
    Returns total weight of MST, or -1 if not possible.
    """
    edges.sort()  # Sort by weight
    uf = UnionFind(n)
    total_weight = 0
    edges_used = 0
    
    for weight, u, v in edges:
        if uf.union(u, v):  # Only add if connects new component
            total_weight += weight
            edges_used += 1
            if edges_used == n - 1:  # MST complete
                break
    
    return total_weight if edges_used == n - 1 else -1
```

### Example: Min Cost to Connect All Points (LC 1584)

```python
def minCostConnectPoints(points: list[list[int]]) -> int:
    """
    Minimum cost to connect all points where cost = Manhattan distance.
    """
    n = len(points)
    
    # Build all edges with Manhattan distance
    edges = []
    for i in range(n):
        for j in range(i + 1, n):
            dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])
            edges.append((dist, i, j))
    
    # Kruskal's algorithm
    edges.sort()
    uf = UnionFind(n)
    total_cost = 0
    
    for cost, u, v in edges:
        if uf.union(u, v):
            total_cost += cost
            if uf.count == 1:  # All connected
                break
    
    return total_cost
```

---

## Pattern 4: Grid Problems

### Problem Type
2D grid connectivity - islands, regions, etc.

### Key Insight
Map 2D coordinates to 1D index: `id = row * cols + col`

### Template

```python
def num_islands_union_find(grid: list[list[str]]) -> int:
    """Number of islands using Union-Find."""
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    
    def get_id(r, c):
        return r * cols + c
    
    uf = UnionFind(rows * cols)
    water_count = 0
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '0':
                water_count += 1
            else:
                # Union with right and down neighbors (avoid double-counting)
                if c + 1 < cols and grid[r][c + 1] == '1':
                    uf.union(get_id(r, c), get_id(r, c + 1))
                if r + 1 < rows and grid[r + 1][c] == '1':
                    uf.union(get_id(r, c), get_id(r + 1, c))
    
    return uf.count - water_count
```

---

## Pattern 5: Accounts Merge (Equivalence Classes)

### Problem Type
Merge groups that share a common element.

### Key Insight
Union elements that belong together, then group by root.

### Example: Accounts Merge (LC 721)

```python
from collections import defaultdict

def accountsMerge(accounts: list[list[str]]) -> list[list[str]]:
    """
    Merge accounts that share an email.
    accounts[i] = [name, email1, email2, ...]
    """
    email_to_id = {}
    email_to_name = {}
    
    # Assign IDs to emails
    id_counter = 0
    for account in accounts:
        name = account[0]
        for email in account[1:]:
            if email not in email_to_id:
                email_to_id[email] = id_counter
                email_to_name[email] = name
                id_counter += 1
    
    # Union emails in same account
    uf = UnionFind(id_counter)
    for account in accounts:
        first_id = email_to_id[account[1]]
        for email in account[2:]:
            uf.union(first_id, email_to_id[email])
    
    # Group emails by root
    root_to_emails = defaultdict(list)
    for email, id in email_to_id.items():
        root = uf.find(id)
        root_to_emails[root].append(email)
    
    # Build result
    result = []
    for root, emails in root_to_emails.items():
        emails.sort()
        # Get name from any email (they're all same person)
        name = email_to_name[emails[0]]
        result.append([name] + emails)
    
    return result
```

---

## ðŸ’» Complete Union-Find Template

```python
class UnionFind:
    """Production-ready Union-Find with all optimizations."""
    
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.size = [1] * n
        self.count = n
    
    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x: int, y: int) -> bool:
        root_x, root_y = self.find(x), self.find(y)
        if root_x == root_y:
            return False
        
        # Union by rank
        if self.rank[root_x] < self.rank[root_y]:
            root_x, root_y = root_y, root_x
        
        self.parent[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        
        if self.rank[root_x] == self.rank[root_y]:
            self.rank[root_x] += 1
        
        self.count -= 1
        return True
    
    def connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)
    
    def get_size(self, x: int) -> int:
        return self.size[self.find(x)]
    
    def get_count(self) -> int:
        return self.count
```

**JavaScript:**
```javascript
class UnionFind {
    constructor(n) {
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.rank = new Array(n).fill(0);
        this.size = new Array(n).fill(1);
        this.count = n;
    }
    
    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
    }
    
    union(x, y) {
        let rootX = this.find(x), rootY = this.find(y);
        if (rootX === rootY) return false;
        
        if (this.rank[rootX] < this.rank[rootY]) {
            [rootX, rootY] = [rootY, rootX];
        }
        
        this.parent[rootY] = rootX;
        this.size[rootX] += this.size[rootY];
        
        if (this.rank[rootX] === this.rank[rootY]) {
            this.rank[rootX]++;
        }
        
        this.count--;
        return true;
    }
    
    connected(x, y) { return this.find(x) === this.find(y); }
    getSize(x) { return this.size[this.find(x)]; }
    getCount() { return this.count; }
}
```

---

## ðŸ“ Practice Problems (Progressive)

### Easy/Medium (Learn the patterns)
- [ ] [Number of Provinces](https://leetcode.com/problems/number-of-provinces/) - LC 547
- [ ] [Redundant Connection](https://leetcode.com/problems/redundant-connection/) - LC 684
- [ ] [Number of Islands II](https://leetcode.com/problems/number-of-islands-ii/) - LC 305

### Medium (Apply variations)
- [ ] [Accounts Merge](https://leetcode.com/problems/accounts-merge/) - LC 721
- [ ] [Satisfiability of Equality](https://leetcode.com/problems/satisfiability-of-equality-equations/) - LC 990
- [ ] [Min Cost to Connect All Points](https://leetcode.com/problems/min-cost-to-connect-all-points/) - LC 1584

### Hard (Master edge cases)
- [ ] [Largest Component Size by Factor](https://leetcode.com/problems/largest-component-size-by-common-factor/) - LC 952
- [ ] [Smallest String With Swaps](https://leetcode.com/problems/smallest-string-with-swaps/) - LC 1202

---

## ðŸŽ¤ Interview Context

**When to suggest Union-Find:**
> "Since we need to answer multiple connectivity queries while adding edges, Union-Find is ideal here - it gives us nearly O(1) amortized per operation."

**Comparing to DFS:**
> "If this were a static graph with a single query, I'd use DFS. But with dynamic edge additions and multiple queries, Union-Find is more efficient."

---

> **ðŸ’¡ Key Insight:** Union-Find shines when you need to track connectivity that changes over time. The key patterns are: count components, detect cycles, and build MST.

---

**Next:** [Practice: Number of Provinces â†’](./7.4-UF-Practice/01-Number-Of-Provinces-LC547.md)
