# 1.6 - Linear Time Sorting

> **Breaking the O(n log n) Barrier**  
> **Interview Value:** â­â­â­ - Know for specific cases  
> **Key Insight:** Non-comparison sorts can be O(n)

---

## Overview

Comparison-based sorting has a lower bound of **O(n log n)**. However, by using additional information about the data (integers, fixed range, etc.), we can sort in **O(n)** time.

| Algorithm | When to Use | Time | Space |
|-----------|-------------|------|-------|
| **Counting Sort** | Small integer range |" O(n + k) "| O(k) |
| **Radix Sort** | Fixed-length integers |" O(d * (n + k)) "| O(n + k) |
| **Bucket Sort** | Uniformly distributed data |" O(n) avg "| O(n) |

---

## ðŸŽ¯ Pattern Recognition

<details>
<summary><strong>When to Use Linear Time Sorts</strong></summary>

**Keywords:**
- "Integers in range [0, k]"
- "Sort digits" or "sort by digit"
- "Uniformly distributed"
- "Sort in O(n)"
- "Frequency count"

**Decision tree:**
```
Is data numeric with small range?
â”œâ”€â”€ Yes, range k < n â†’ Counting Sort
â”œâ”€â”€ Yes, large range but fixed digits â†’ Radix Sort
â”œâ”€â”€ Yes, uniformly distributed â†’ Bucket Sort
â””â”€â”€ No â†’ Comparison sort (Quick/Merge)
```

</details>

---

## 1. Counting Sort

### âœ… When to Use

- Integers in a small, known range [0, k]
- k is O(n) or smaller
- Need stable sort

### âŒ When NOT to Use

| Situation | Why | Alternative |
|-----------|-----|-------------|
| Large range (k >> n) |" O(k) space wasted "| Radix Sort |
| Negative numbers | Needs offset | Modified version |
| Non-integers | Can't count | Comparison sort |
| Unknown range | Can't allocate | Comparison sort |

---

### ðŸ“ How Counting Sort Works

```
Array: [4, 2, 2, 8, 3, 3, 1]  Range: 0-8

Step 1: Count occurrences
Count: [0, 1, 2, 2, 1, 0, 0, 0, 1]
Index:  0  1  2  3  4  5  6  7  8

Step 2: Cumulative sum (for positioning)
Count: [0, 1, 3, 5, 6, 6, 6, 6, 7]
       "1 appears before index 1"
       "2 appears before index 3"
       etc.

Step 3: Place elements in output (right to left for stability)
Original: [4, 2, 2, 8, 3, 3, 1]
                            â†‘
         1 goes to index count[1]-1 = 0
         
Output: [1, _, 2, 2, 3, 3, 4, 8]
```

### ðŸ’» Code Implementation

**Python:**
```python
def counting_sort(arr: list[int]) -> list[int]:
    """
    Counting Sort - for integers in range [0, max].
    
    Time: O(n + k) where k is the range
    Space: O(k) for count array
    Stable: Yes (with right-to-left placement)
    """
    if not arr:
        return arr
    
    # Find range
    max_val = max(arr)
    min_val = min(arr)
    range_size = max_val - min_val + 1
    
    # Count occurrences (offset for negative numbers)
    count = [0] * range_size
    for num in arr:
        count[num - min_val] += 1
    
    # Cumulative count
    for i in range(1, range_size):
        count[i] += count[i - 1]
    
    # Build output array (right to left for stability)
    output = [0] * len(arr)
    for num in reversed(arr):
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1
    
    return output


# Example
arr = [4, 2, 2, 8, 3, 3, 1]
print(counting_sort(arr))  # [1, 2, 2, 3, 3, 4, 8]
```

**JavaScript:**
```javascript
function countingSort(arr) {
    if (arr.length === 0) return arr;
    
    const maxVal = Math.max(...arr);
    const minVal = Math.min(...arr);
    const rangeSize = maxVal - minVal + 1;
    
    // Count occurrences
    const count = new Array(rangeSize).fill(0);
    for (const num of arr) {
        count[num - minVal]++;
    }
    
    // Cumulative count
    for (let i = 1; i < rangeSize; i++) {
        count[i] += count[i - 1];
    }
    
    // Build output (right to left for stability)
    const output = new Array(arr.length);
    for (let i = arr.length - 1; i >= 0; i--) {
        output[count[arr[i] - minVal] - 1] = arr[i];
        count[arr[i] - minVal]--;
    }
    
    return output;
}
```

---

### Simple Version (When Order Within Same Value Doesn't Matter)

```python
def counting_sort_simple(arr: list[int]) -> list[int]:
    """Simple version - just count and output."""
    if not arr:
        return arr
    
    max_val = max(arr)
    count = [0] * (max_val + 1)
    
    for num in arr:
        count[num] += 1
    
    result = []
    for num, freq in enumerate(count):
        result.extend([num] * freq)
    
    return result
```

---

## 2. Radix Sort

### âœ… When to Use

- Integers with fixed number of digits
- Range is large but digit range is small
- Need stable sort

### âŒ When NOT to Use

| Situation | Why | Alternative |
|-----------|-----|-------------|
| Variable-length data | Needs padding | Comparison sort |
| Floating-point numbers | Complex handling | Comparison sort |
| Few elements, large digits | Overhead not worth it | Quick Sort |

---

### ðŸ“ How Radix Sort Works

**LSD (Least Significant Digit) - Most Common:**

```
Array: [170, 45, 75, 90, 802, 24, 2, 66]

Sort by 1s place (using counting sort):
[170, 90, 802, 2, 24, 45, 75, 66]

Sort by 10s place:
[802, 2, 24, 45, 66, 170, 75, 90]

Sort by 100s place:
[2, 24, 45, 66, 75, 90, 170, 802]

Done! Each digit sort is O(n + k), k = 10 for decimal
Total: O(d * (n + k)) where d = number of digits
```

### ðŸ’» Code Implementation

**Python:**
```python
def radix_sort(arr: list[int]) -> list[int]:
    """
    Radix Sort (LSD) - sort by each digit from least to most significant.
    
    Time: O(d * (n + k)) where d = digits, k = base (10)
    Space: O(n + k)
    Stable: Yes
    """
    if not arr:
        return arr
    
    # Handle negative numbers by separating
    negatives = [-x for x in arr if x < 0]
    positives = [x for x in arr if x >= 0]
    
    def radix_sort_positive(nums: list[int]) -> list[int]:
        if not nums:
            return nums
        
        max_val = max(nums)
        exp = 1  # Current digit position
        
        while max_val // exp > 0:
            nums = counting_sort_by_digit(nums, exp)
            exp *= 10
        
        return nums
    
    def counting_sort_by_digit(nums: list[int], exp: int) -> list[int]:
        """Counting sort based on digit at position exp."""
        n = len(nums)
        output = [0] * n
        count = [0] * 10
        
        # Count occurrences of each digit
        for num in nums:
            digit = (num // exp) % 10
            count[digit] += 1
        
        # Cumulative count
        for i in range(1, 10):
            count[i] += count[i - 1]
        
        # Build output (right to left for stability)
        for i in range(n - 1, -1, -1):
            digit = (nums[i] // exp) % 10
            output[count[digit] - 1] = nums[i]
            count[digit] -= 1
        
        return output
    
    # Sort positives and negatives separately
    sorted_positives = radix_sort_positive(positives)
    sorted_negatives = [-x for x in reversed(radix_sort_positive(negatives))]
    
    return sorted_negatives + sorted_positives


# Example
arr = [170, 45, 75, 90, 802, 24, 2, 66]
print(radix_sort(arr))  # [2, 24, 45, 66, 75, 90, 170, 802]

# With negatives
arr2 = [170, -45, 75, -90, 802, 24, 2, -66]
print(radix_sort(arr2))  # [-90, -66, -45, 2, 24, 75, 170, 802]
```

**JavaScript:**
```javascript
function radixSort(arr) {
    if (arr.length === 0) return arr;
    
    const maxVal = Math.max(...arr);
    let exp = 1;
    
    while (Math.floor(maxVal / exp) > 0) {
        arr = countingSortByDigit(arr, exp);
        exp *= 10;
    }
    
    return arr;
}

function countingSortByDigit(arr, exp) {
    const n = arr.length;
    const output = new Array(n);
    const count = new Array(10).fill(0);
    
    for (const num of arr) {
        const digit = Math.floor(num / exp) % 10;
        count[digit]++;
    }
    
    for (let i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }
    
    for (let i = n - 1; i >= 0; i--) {
        const digit = Math.floor(arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }
    
    return output;
}
```

---

## 3. Bucket Sort

### âœ… When to Use

- Data is uniformly distributed
- Data is floating-point numbers
- Know the approximate range

### âŒ When NOT to Use

| Situation | Why | Alternative |
|-----------|-----|-------------|
| Clustered data | Unbalanced buckets | Comparison sort |
| Unknown distribution | Can't choose buckets | Comparison sort |
| Small dataset | Overhead not worth it | Insertion sort |

---

### ðŸ“ How Bucket Sort Works

```
Array: [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]
Range: [0, 1)

Create 10 buckets for [0, 0.1), [0.1, 0.2), ..., [0.9, 1.0)

Distribute:
Bucket 0: []
Bucket 1: [0.17, 0.12]
Bucket 2: [0.26, 0.21, 0.23]
Bucket 3: [0.39]
Bucket 4: []
Bucket 5: []
Bucket 6: [0.68]
Bucket 7: [0.78, 0.72]
Bucket 8: []
Bucket 9: [0.94]

Sort each bucket (insertion sort for small buckets):
Bucket 1: [0.12, 0.17]
Bucket 2: [0.21, 0.23, 0.26]
...

Concatenate: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]
```

### ðŸ’» Code Implementation

**Python:**
```python
def bucket_sort(arr: list[float]) -> list[float]:
    """
    Bucket Sort - for uniformly distributed floating-point numbers.
    
    Time: O(n) average (with uniform distribution)
    Space: O(n)
    Stable: Depends on bucket sort
    """
    if not arr:
        return arr
    
    n = len(arr)
    min_val, max_val = min(arr), max(arr)
    
    # Handle edge case where all elements are the same
    if min_val == max_val:
        return arr
    
    # Create n buckets
    buckets = [[] for _ in range(n)]
    
    # Distribute elements into buckets
    for num in arr:
        # Map number to bucket index
        idx = int((num - min_val) / (max_val - min_val + 1e-9) * n)
        idx = min(idx, n - 1)  # Handle edge case
        buckets[idx].append(num)
    
    # Sort each bucket (insertion sort for small buckets)
    for bucket in buckets:
        bucket.sort()  # Or use insertion_sort for O(n) if buckets are small
    
    # Concatenate buckets
    result = []
    for bucket in buckets:
        result.extend(bucket)
    
    return result


# Example
arr = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]
print(bucket_sort(arr))
# [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]
```

**JavaScript:**
```javascript
function bucketSort(arr) {
    if (arr.length === 0) return arr;
    
    const n = arr.length;
    const minVal = Math.min(...arr);
    const maxVal = Math.max(...arr);
    
    if (minVal === maxVal) return arr;
    
    // Create buckets
    const buckets = Array.from({length: n}, () => []);
    
    // Distribute elements
    for (const num of arr) {
        let idx = Math.floor((num - minVal) / (maxVal - minVal + 1e-9) * n);
        idx = Math.min(idx, n - 1);
        buckets[idx].push(num);
    }
    
    // Sort each bucket
    for (const bucket of buckets) {
        bucket.sort((a, b) => a - b);
    }
    
    // Concatenate
    return buckets.flat();
}
```

---

## âš¡ Complexity Comparison

| Algorithm | Time | Space | Stable | Use Case |
|-----------|------|-------|--------|----------|
| Counting |" O(n + k) "| O(k) | âœ… | Small integer range |
| Radix |" O(d(n + k)) "| O(n + k) | âœ… | Fixed-digit integers |
| Bucket |" O(n) avg "| O(n) | Depends | Uniform distribution |

**When each beats O(n log n):**
- **Counting Sort:** k < n log n (range smaller than n log n)
- **Radix Sort:** d * k < n log n (digits * base < n log n)
- **Bucket Sort:** Uniform distribution with small buckets

---

## âš ï¸ Common Mistakes

### 1. Counting Sort: Forgetting to Handle Negatives

âŒ **Wrong:**
```python
count = [0] * (max_val + 1)  # Only works for non-negative!
```

âœ… **Correct:**
```python
min_val = min(arr)
count = [0] * (max_val - min_val + 1)
for num in arr:
    count[num - min_val] += 1
```

### 2. Radix Sort: Wrong Digit Extraction

âŒ **Wrong:**
```python
digit = num % 10 ** exp  # Wrong!
```

âœ… **Correct:**
```python
digit = (num // exp) % 10
```

### 3. Bucket Sort: Not Handling Edge Cases

âŒ **Wrong:**
```python
idx = int((num - min_val) / (max_val - min_val) * n)  # Division by zero if all same!
```

âœ… **Correct:**
```python
if min_val == max_val:
    return arr
idx = int((num - min_val) / (max_val - min_val + 1e-9) * n)
idx = min(idx, n - 1)
```

---

## ðŸ“ Practice Problems

### Easy

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Sort Array by Increasing Frequency | Counting | [LC 1636](https://leetcode.com/problems/sort-array-by-increasing-frequency/) |
| Maximum Gap | Bucket sort idea | [LC 164](https://leetcode.com/problems/maximum-gap/) |

### Medium

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Sort an Array | Can use Radix | [LC 912](https://leetcode.com/problems/sort-an-array/) |
| H-Index | Counting sort | [LC 274](https://leetcode.com/problems/h-index/) |
| Top K Frequent Elements | Bucket sort | [LC 347](https://leetcode.com/problems/top-k-frequent-elements/) |

### Hard

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Maximum Gap | Pigeonhole principle | [LC 164](https://leetcode.com/problems/maximum-gap/) |

<details>
<summary><strong>ðŸ§  Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement Counting Sort
- Understand cumulative count for stability

**Day 3:** Implement Radix Sort
- LSD approach with counting sort per digit

**Day 7:** LC 347 Top K Frequent
- Use bucket sort optimization

**Day 14:** LC 164 Maximum Gap
- Apply bucket sort concept

</details>

---

## ðŸŽ¤ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**When to mention linear time sorts:**
> "Since the input is integers in the range [0, k] where k is small, I can use Counting Sort for O(n + k) time instead of O(n log n)."

**Explaining the trade-off:**
> "Linear time sorts avoid the O(n log n) comparison lower bound by using extra information about the data. The trade-off is they require specific input characteristics."

**Common interview scenarios:**
1. **Frequency counting problems** â†’ Counting Sort concept
2. **Sorting integers with limited range** â†’ Counting Sort
3. **Finding maximum gap** â†’ Bucket Sort pigeonhole

**Company Focus:**

| Company | Focus |
|---------|-------|
| Google |" Know when O(n) is possible "|
| Amazon | LC 347 bucket sort optimization |
| Meta | Frequency counting problems |

</details>

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand Counting Sort | 15-20 min | Key concept |
| Implement Counting Sort | 15-20 min | Stable version |
| Understand Radix Sort | 20-25 min | Uses Counting Sort |
| Implement Radix Sort | 25-30 min | Handle negatives |
| Bucket Sort concept | 15-20 min | Distribution-based |

---

## ðŸ’¡ Key Insight

> **Linear time sorting is possible when we don't compare elements:**
>
> | Sort | Key Insight |" O(n) When "|
> |------|-------------|-----------|
> | Counting | Count occurrences |" Range k = O(n) "|
> | Radix | Sort digit by digit |" d * k = O(n) "|
> | Bucket | Distribute by value | Uniform distribution |
>
> **When to mention in interviews:**
> - "Since integers are in range [0, k] where k is small..."
> - "Since data is uniformly distributed..."
> - "We can avoid the O(n log n) lower bound..."

---

## ðŸ”— Related

- [Sorting Basics](./1.1-Sorting-Basics.md) - Algorithm overview
- [Quick Sort](./1.4-Quick-Sort.md) - Comparison sort alternative
- [Merge Sort](./1.3-Merge-Sort.md) - Comparison sort alternative
