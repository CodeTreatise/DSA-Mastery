# 8.2 - Construct Binary Tree from Inorder and Postorder Traversal (LC 106)

> **Grokking Pattern:** #11 Tree DFS (Construction Pattern)
>
> **Difficulty:** Medium | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê Common

---

## Problem Statement

Given two integer arrays `inorder` and `postorder` where:
- `inorder` is the inorder traversal of a binary tree
- `postorder` is the postorder traversal of the same tree

Construct and return the binary tree.

```
Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]

Output:
    3
   / \
  9  20
    /  \
   15   7
```

**Explanation:**
- Inorder: [9, 3, 15, 20, 7] ‚Üí Left subtree, root, right subtree
- Postorder: [9, 15, 7, 20, 3] ‚Üí Left subtree, right subtree, root (root is LAST)

[LeetCode 106 - Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Construct tree" from traversals
- Given inorder AND postorder
- Need original tree structure

**Key insight:**
- **Postorder last element** = root of current subtree
- **Inorder** = tells us which nodes are left vs right of root

Same as preorder + inorder, but root comes from END of postorder instead of start.

</details>

---

## ‚úÖ When to Use

- Reconstructing tree from traversals
- Given inorder + postorder
- Need exact tree structure

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Preorder + inorder | Root from start of preorder | LC 105 |
| Only one traversal | Can't determine structure | Need two |
| Serialized format | Different parsing | Deserialize (LC 297) |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Inorder Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/01-Inorder-Traversal.md)
- [Postorder Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/03-Postorder-Traversal.md)
- [Construct from Preorder + Inorder](./8.1-Construct-Preorder-Inorder.md)

**After mastering this:**
- [Construct from Preorder + Postorder](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) - LC 889
- [Serialize and Deserialize](./8.3-Serialize-Deserialize.md)

</details>

---

## üìê How It Works

### The Algorithm

```
Inorder:   [9, 3, 15, 20, 7]
            ‚Üë  ‚Üë   ‚Üë
           left root right
           sub      subtree
           tree

Postorder: [9, 15, 7, 20, 3]
                          ‚Üë
                         root (LAST element)
```

**Steps:**
1. Take **last** element of postorder ‚Üí this is the root
2. Find this element in inorder
3. Everything left of it in inorder = left subtree
4. Everything right of it in inorder = right subtree
5. **Important:** Build RIGHT subtree first, then left (reverse of postorder)

### Key Difference from Preorder + Inorder

| Preorder + Inorder | Inorder + Postorder |
|-------------------|---------------------|
| Root at START of preorder | Root at END of postorder |
| Build LEFT first | Build RIGHT first |
| Move index forward | Move index backward |

### Visualization

```
Step 1: postorder[-1] = 3 is root
        inorder index of 3 = 1
        
        Left subtree: inorder[0:1] = [9]
        Right subtree: inorder[2:5] = [15, 20, 7]
        
Step 2: RIGHT subtree first (postorder order is left-right-root,
        so we read backwards: root-right-left)
        
        postorder = [9, 15, 7, 20, 3]
                              ‚Üë
        Next root (from end working backwards) = 20
        
Step 3: Continue until tree is built

Final tree:
    3
   / \
  9  20
    /  \
   15   7
```

---

## üíª Code Implementation

### Solution 1: Hash Map with Reverse Index (Recommended)

**Python:**
```python
from typing import Optional, List

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def build_tree(inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
    """
    Construct binary tree from inorder and postorder traversals.
    
    Key insight:
    - Postorder last = root
    - Inorder splits into left/right subtrees
    - Build RIGHT subtree first (reverse of postorder order)
    
    Time: O(n), Space: O(n)
    """
    # Map value -> index in inorder for O(1) lookup
    inorder_map = {val: idx for idx, val in enumerate(inorder)}
    
    postorder_idx = [len(postorder) - 1]  # Start from end
    
    def build(left, right):
        """Build subtree from inorder[left:right+1]"""
        if left > right:
            return None
        
        # Root is current element in postorder (working backwards)
        root_val = postorder[postorder_idx[0]]
        postorder_idx[0] -= 1  # Move backwards
        
        root = TreeNode(root_val)
        
        # Find root position in inorder
        mid = inorder_map[root_val]
        
        # Build RIGHT subtree FIRST (reverse of postorder order)
        root.right = build(mid + 1, right)
        # Then build left subtree
        root.left = build(left, mid - 1)
        
        return root
    
    return build(0, len(inorder) - 1)
```

**JavaScript:**
```javascript
function buildTree(inorder, postorder) {
    // Map value -> index for O(1) lookup
    const inorderMap = new Map();
    inorder.forEach((val, idx) => inorderMap.set(val, idx));
    
    let postorderIdx = postorder.length - 1;
    
    function build(left, right) {
        if (left > right) return null;
        
        // Root is from end of postorder, working backwards
        const rootVal = postorder[postorderIdx--];
        const root = new TreeNode(rootVal);
        
        // Split point in inorder
        const mid = inorderMap.get(rootVal);
        
        // Build RIGHT first, then left
        root.right = build(mid + 1, right);
        root.left = build(left, mid - 1);
        
        return root;
    }
    
    return build(0, inorder.length - 1);
}
```

### Solution 2: Slice-Based (Clearer but O(n¬≤))

**Python:**
```python
def build_tree_slices(inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
    """
    Clearer logic using array slices.
    Less efficient due to copying.
    """
    if not inorder or not postorder:
        return None
    
    # Root is LAST element of postorder
    root_val = postorder[-1]
    root = TreeNode(root_val)
    
    # Find root in inorder
    mid = inorder.index(root_val)
    
    # Left subtree
    root.left = build_tree_slices(
        inorder[:mid],              # Left part of inorder
        postorder[:mid]             # First 'mid' elements of postorder
    )
    
    # Right subtree
    root.right = build_tree_slices(
        inorder[mid+1:],            # Right part of inorder
        postorder[mid:-1]           # After left subtree, before root
    )
    
    return root
```

### Solution 3: Class-Based (LeetCode Style)

**Python:**
```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        self.inorder_map = {val: idx for idx, val in enumerate(inorder)}
        self.post_idx = len(postorder) - 1
        self.postorder = postorder
        
        def build(left, right):
            if left > right:
                return None
            
            root_val = self.postorder[self.post_idx]
            self.post_idx -= 1
            
            root = TreeNode(root_val)
            mid = self.inorder_map[root_val]
            
            # RIGHT first, then LEFT
            root.right = build(mid + 1, right)
            root.left = build(left, mid - 1)
            
            return root
        
        return build(0, len(inorder) - 1)
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Hash Map (indices) |" O(n) "| O(n) | Best approach |
| Slicing |" O(n¬≤) "| O(n¬≤) | Creates copies |

---

## üîÑ Variations

| Variation | Difference | LeetCode |
|-----------|------------|----------|
| Preorder + Inorder | Root from preorder start | LC 105 |
| Preorder + Postorder | Only works for full trees | LC 889 |
| BST from preorder | Use BST property | LC 1008 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Order of Recursive Calls

```python
# ‚ùå WRONG: Building left before right
root.left = build(left, mid - 1)   # Wrong! Consumes wrong postorder elements
root.right = build(mid + 1, right)

# ‚úÖ CORRECT: Right first, then left (reverse of postorder)
root.right = build(mid + 1, right)
root.left = build(left, mid - 1)
```

**Why?** Postorder is Left-Right-Root. Reading from end gives Root-Right-Left.

### 2. Forgetting to Move Index Backwards

```python
# ‚ùå WRONG: Moving forward like preorder
postorder_idx[0] += 1

# ‚úÖ CORRECT: Moving backwards from end
postorder_idx[0] -= 1
```

### 3. Confusing with Preorder Version

| Preorder + Inorder | Inorder + Postorder |
|-------------------|---------------------|
| `preorder_idx = [0]` | `postorder_idx = [len-1]` |
| `idx += 1` | `idx -= 1` |
| Build LEFT first | Build RIGHT first |

### 4. Wrong Slice Boundaries

```python
# For slicing version:
# Left subtree has 'mid' nodes
# Postorder: [left_subtree][right_subtree][root]

# ‚ùå WRONG
postorder[:mid+1]  # Includes one too many

# ‚úÖ CORRECT
postorder[:mid]    # Exactly 'mid' nodes for left
```

---

## üìù Practice Problems

### This Problem
- [ ] [Construct from Inorder and Postorder](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) - LC 106

### Related Construction Problems
- [ ] [Construct from Preorder and Inorder](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) - LC 105 (Do this first!)
- [ ] [Construct from Preorder and Postorder](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) - LC 889
- [ ] [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) - LC 297

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Compare with preorder+inorder version
**Day 3:** Implement - focus on right-first order
**Day 7:** Do both LC 105 and LC 106 back to back
**Day 14:** Explain why order of recursive calls matters

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Explaining the difference:**
> "This is similar to preorder+inorder, but with two key differences: the root comes from the END of postorder instead of the start, and I need to build the right subtree FIRST because postorder is Left-Right-Root, so reading backwards gives Root-Right-Left."

**The algorithm:**
> "I take the last postorder element as root, find it in inorder to split left/right, then recursively build right subtree first, then left. I use a hash map for O(1) lookup."

**Common follow-up:**
> "Why can't we reconstruct from just preorder and postorder? Because without inorder, we can't determine where left subtree ends and right begins - unless the tree is a full binary tree."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Asked with LC 105 |
| Meta | ‚≠ê‚≠ê‚≠ê | Sometimes appears |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand differences | 3-5 min | vs preorder version |
| Implement solution | 10-15 min | Similar structure |
| Explain trade-offs | 2-3 min | Why right first |

---

> **üí° Key Insight:** The key difference from preorder+inorder is that we read postorder backwards (getting Root-Right-Left order), so we must build the right subtree before the left. This ensures we consume postorder elements in the correct order.

---

## üîó Related

- [Construct from Preorder + Inorder](./8.1-Construct-Preorder-Inorder.md)
- [Inorder Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/01-Inorder-Traversal.md)
- [Postorder Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/03-Postorder-Traversal.md)
