# Hash Functions

> **A hash function converts any input into a fixed-size integer, determining where data is stored in a hash table.**

The quality of a hash function directly impacts hash table performance. A good hash function distributes keys uniformly, minimizes collisions, and computes quickly.

---

## üéØ Pattern Recognition

<details>
<summary><strong>Understanding Hash Functions</strong></summary>

**What a hash function does:**
- Takes any key (string, number, object)
- Returns a fixed-size integer (hash code)
- Same input ‚Üí always same output (deterministic)
- Different inputs ‚Üí ideally different outputs

**Why this matters for interviews:**
- Understanding enables custom hash keys (like in Group Anagrams)
- Explains why certain operations are O(1)
- Helps when designing data structures

</details>

---

## ‚úÖ Properties of Good Hash Functions

1. **Deterministic**: Same input ‚Üí same output, always
2. **Uniform Distribution**: Spreads keys evenly across buckets
3. **Fast Computation**: O(1) or O(key length) at most
4. **Avalanche Effect**: Small input change ‚Üí big hash change
5. **Minimize Collisions**: Different keys rarely get same hash

## ‚ùå Signs of Bad Hash Functions

| Problem | Example | Consequence |
|---------|---------|-------------|
| Clustering | All hashes end in 0 | Many collisions |
| Predictable patterns | Sequential inputs ‚Üí sequential outputs | Easy to exploit |
| Slow computation | Complex calculation | Defeats O(1) purpose |
| Not deterministic | Random component | Can't find stored data |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- [What Is Hashing](./1.1-What-Is-Hashing.md)
- Basic modular arithmetic

**After this, learn:**
- [Collision Handling](./1.3-Collision-Handling.md)
- [Load Factor](./1.4-Load-Factor.md)
- [Rolling Hash (Rabin-Karp)](../09-String-Hashing/9.1-Rolling-Hash-Overview.md)

**Used in:**
- All hash table implementations
- Cryptography (SHA, MD5)
- Data integrity checking
- Caching systems

</details>

---

## üìê How It Works

### The Hash Function Pipeline

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Key      ‚îÇ ‚Üí‚Üí‚Üí ‚îÇ Hash Function‚îÇ ‚Üí‚Üí‚Üí ‚îÇ  Hash Code  ‚îÇ ‚Üí‚Üí‚Üí ‚îÇ  Index   ‚îÇ
‚îÇ  "hello"    ‚îÇ     ‚îÇ   h(key)     ‚îÇ     ‚îÇ  2314829103 ‚îÇ     ‚îÇ    3     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                                  ‚Üì
                                         index = hash_code % table_size
```

### Common Hash Function Techniques

#### 1. Division Method (Simple but effective)

```python
def division_hash(key: int, table_size: int) -> int:
    """
    Simple division method.
    Best when table_size is a prime number.
    """
    return key % table_size
```

#### 2. Multiplication Method

```python
import math

def multiplication_hash(key: int, table_size: int) -> int:
    """
    Multiplication method using golden ratio.
    Less sensitive to table_size choice.
    """
    A = (math.sqrt(5) - 1) / 2  # Golden ratio ‚âà 0.618
    return int(table_size * ((key * A) % 1))
```

#### 3. Polynomial Rolling Hash (for strings)

```python
def polynomial_hash(s: str, base: int = 31, mod: int = 10**9 + 7) -> int:
    """
    Polynomial hash for strings.
    Treats string as a polynomial with character values as coefficients.
    
    h("abc") = a*31^2 + b*31^1 + c*31^0
    """
    hash_value = 0
    for char in s:
        hash_value = (hash_value * base + ord(char)) % mod
    return hash_value
```

### Visualization: String Hashing

```
String: "cat"
Base: 31

Step-by-step polynomial hash:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Char   ‚îÇ ASCII ‚îÇ Running Hash                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 'c'    ‚îÇ  99   ‚îÇ 0 * 31 + 99 = 99                 ‚îÇ
‚îÇ 'a'    ‚îÇ  97   ‚îÇ 99 * 31 + 97 = 3166              ‚îÇ
‚îÇ 't'    ‚îÇ 116   ‚îÇ 3166 * 31 + 116 = 98262          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

hash("cat") = 98262

Convert to index (table size = 100):
index = 98262 % 100 = 62
```

### Why Prime Numbers?

```
Table size: 10 (not prime)
Keys: 20, 30, 40, 50, 60, 70, 80, 90, 100

All hash to: 0, 0, 0, 0, 0, 0, 0, 0, 0
‚Üí All collisions!

Table size: 11 (prime)
Keys: 20, 30, 40, 50, 60, 70, 80, 90, 100

Hash to: 9, 8, 7, 6, 5, 4, 3, 2, 1
‚Üí Perfect distribution!
```

---

## üíª Code Implementation

### Python - Various Hash Functions

```python
class HashFunctions:
    """Collection of hash function implementations."""
    
    @staticmethod
    def simple_string_hash(s: str, table_size: int) -> int:
        """Sum of ASCII values - simple but poor distribution."""
        return sum(ord(c) for c in s) % table_size
    
    @staticmethod
    def polynomial_hash(s: str, base: int = 31, mod: int = 10**9 + 7) -> int:
        """
        Polynomial rolling hash - good distribution for strings.
        Common in competitive programming and Rabin-Karp.
        """
        h = 0
        for c in s:
            h = (h * base + ord(c)) % mod
        return h
    
    @staticmethod
    def djb2_hash(s: str) -> int:
        """
        DJB2 algorithm - fast and good distribution.
        Used in many real-world applications.
        """
        h = 5381
        for c in s:
            h = ((h << 5) + h) + ord(c)  # h * 33 + c
        return h & 0xFFFFFFFF  # Keep as 32-bit
    
    @staticmethod
    def fnv1a_hash(s: str) -> int:
        """
        FNV-1a hash - simple and effective.
        Better avalanche effect than DJB2.
        """
        FNV_PRIME = 0x01000193
        FNV_OFFSET = 0x811c9dc5
        
        h = FNV_OFFSET
        for c in s:
            h ^= ord(c)
            h = (h * FNV_PRIME) & 0xFFFFFFFF
        return h


# Usage
hf = HashFunctions()
print(hf.polynomial_hash("hello"))  # Large integer
print(hf.djb2_hash("hello"))        # Different hash
```

### Python - Using Built-in hash()

```python
# Python's built-in hash() function
print(hash("hello"))      # Integer hash
print(hash(42))           # Integers hash to themselves (mostly)
print(hash((1, 2, 3)))    # Tuples are hashable

# Important: hash() is randomized between sessions (security)
# For consistent hashing, use hashlib

import hashlib

def consistent_hash(s: str) -> int:
    """SHA-256 based hash - consistent across sessions."""
    return int(hashlib.sha256(s.encode()).hexdigest(), 16)

# Custom __hash__ for objects
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __hash__(self):
        return hash((self.x, self.y))  # Tuple of attributes
    
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

# Now Point can be used as dict key
p = Point(1, 2)
d = {p: "origin"}
```

### JavaScript - Hash Functions

```javascript
class HashFunctions {
    /**
     * Simple string hash - sum of char codes.
     */
    static simpleHash(s, tableSize) {
        let hash = 0;
        for (const char of s) {
            hash += char.charCodeAt(0);
        }
        return hash % tableSize;
    }
    
    /**
     * Polynomial rolling hash - better distribution.
     */
    static polynomialHash(s, base = 31, mod = 1e9 + 7) {
        let hash = 0;
        for (const char of s) {
            hash = (hash * base + char.charCodeAt(0)) % mod;
        }
        return hash;
    }
    
    /**
     * DJB2 hash - fast and effective.
     */
    static djb2Hash(s) {
        let hash = 5381;
        for (const char of s) {
            hash = ((hash << 5) + hash) + char.charCodeAt(0);
        }
        return hash >>> 0;  // Convert to unsigned 32-bit
    }
    
    /**
     * Hash for arrays (convert to string key).
     */
    static arrayHash(arr) {
        return arr.join(',');  // Simple approach for small arrays
    }
}

// Usage
console.log(HashFunctions.polynomialHash("hello"));
console.log(HashFunctions.djb2Hash("hello"));
```

### Creating Custom Hash Keys

```python
# Interview pattern: Creating hash keys for grouping

def group_anagrams(strs):
    """
    Group anagrams using sorted string as hash key.
    Time: O(n * k log k) where k is max string length
    """
    groups = {}
    for s in strs:
        key = tuple(sorted(s))  # Anagrams have same sorted form
        if key not in groups:
            groups[key] = []
        groups[key].append(s)
    return list(groups.values())

def group_anagrams_count(strs):
    """
    Better: Use character count as hash key.
    Time: O(n * k)
    """
    groups = {}
    for s in strs:
        # Count characters - anagrams have same counts
        count = [0] * 26
        for c in s:
            count[ord(c) - ord('a')] += 1
        key = tuple(count)  # Immutable for dict key
        if key not in groups:
            groups[key] = []
        groups[key].append(s)
    return list(groups.values())
```

---

## ‚ö° Complexity Analysis

| Hash Function | Time | Quality | Use Case |
|--------------|------|---------|----------|
| Sum of chars | O(n) | Poor | Never use |
| Polynomial | O(n) | Good | Strings, rolling |
| DJB2 | O(n) | Good | General purpose |
| FNV-1a | O(n) | Very Good | Security-sensitive |
| SHA-256 | O(n) | Excellent | Cryptographic |

**Space:** All O(1) - just storing the hash value

**Note:** n = length of key (string length)

---

## üîÑ Hash Function Types

| Type | Purpose | Example |
|------|---------|---------|
| Division | Simple indexing | key % size |
| Multiplication | Better distribution | floor(size * (key * A % 1)) |
| Polynomial | Strings | a‚ÇÄ + a‚ÇÅb + a‚ÇÇb¬≤ + ... |
| Rolling | Substring matching | Rabin-Karp algorithm |
| Cryptographic | Security | SHA-256, MD5 |
| Perfect | No collisions | Compile-time generated |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Poor Choice of Base/Modulus

```python
# ‚ùå WRONG: Base is power of 2
hash_val = 0
for c in s:
    hash_val = hash_val * 32 + ord(c)  # 32 = 2^5, loses bits!

# ‚úÖ CORRECT: Use prime base
hash_val = 0
for c in s:
    hash_val = hash_val * 31 + ord(c)  # 31 is prime
```

### 2. Not Using Modular Arithmetic

```python
# ‚ùå WRONG: Integer overflow in some languages
hash_val = hash_val * 31 + ord(c)  # Can overflow in C++/Java

# ‚úÖ CORRECT: Apply modulo
MOD = 10**9 + 7
hash_val = (hash_val * 31 + ord(c)) % MOD
```

### 3. Mutable Objects as Keys

```python
# ‚ùå WRONG: Lists are mutable, not hashable
d = {[1, 2, 3]: "value"}  # TypeError!

# ‚úÖ CORRECT: Convert to tuple
d = {(1, 2, 3): "value"}  # Works!
d = {tuple([1, 2, 3]): "value"}  # Also works
```

### 4. Ignoring Hash Collisions for Comparison

```python
# ‚ùå WRONG: Assuming same hash = same value
if hash(a) == hash(b):
    print("a equals b")  # NOT necessarily true!

# ‚úÖ CORRECT: Always verify after hash match
if hash(a) == hash(b) and a == b:
    print("a equals b")  # Now we're sure
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Hash Concept | Link |
|---------|------------|--------------|------|
| Design HashMap | üü¢ Easy | Basic hash function | [LC 706](https://leetcode.com/problems/design-hashmap/) |
| Group Anagrams | üü° Medium | Custom hash key | [LC 49](https://leetcode.com/problems/group-anagrams/) |
| Encode/Decode TinyURL | üü° Medium | Hash for shortening | [LC 535](https://leetcode.com/problems/encode-and-decode-tinyurl/) |
| Repeated DNA Sequences | üü° Medium | Rolling hash | [LC 187](https://leetcode.com/problems/repeated-dna-sequences/) |
| Longest Duplicate Substring | üî¥ Hard | Binary search + hash | [LC 1044](https://leetcode.com/problems/longest-duplicate-substring/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement polynomial hash
- **Day 3:** Solve LC 49 with custom hash key
- **Day 7:** Implement DJB2, compare with polynomial
- **Day 14:** Study Rabin-Karp rolling hash
- **Day 30:** Explain hash function properties

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Hash Functions in Interviews</strong></summary>

**Rarely asked to implement from scratch, but:**
- "How would you create a key for grouping anagrams?"
- "Why is O(1) lookup average, not guaranteed?"
- "What makes a good hash function?"

**Key points to mention:**
- Deterministic, uniform distribution
- Prime numbers for table size
- Trade-off: speed vs. distribution quality

**Follow-up discussions:**
- Collision handling (chaining vs. probing)
- Load factor and resizing
- When to use cryptographic hash

</details>

**Company Focus:**

| Company | Deep Hash Knowledge | Notes |
|---------|-------------------|-------|
| Google | Sometimes | System design |
| Meta | Rarely | Focus on usage |
| Amazon | System design | Distributed hashing |
| Startups | Implementation | May ask from scratch |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand hash function concepts | 20 min |
| Implement polynomial hash | 10 min |
| Learn DJB2/FNV-1a | 15 min |
| Practice custom hash keys | 30 min |

---

> **üí° Key Insight:** A hash function's job is to convert any key into an array index. The quality of distribution directly affects performance - more uniform = fewer collisions = faster O(1) operations.

> **üîó Related:** [What Is Hashing](./1.1-What-Is-Hashing.md) | [Collision Handling](./1.3-Collision-Handling.md) | [Rolling Hash](../09-String-Hashing/9.1-Rolling-Hash-Overview.md)
