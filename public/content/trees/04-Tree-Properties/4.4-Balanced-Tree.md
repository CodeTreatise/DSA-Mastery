# 4.4 - Balanced Binary Tree (LC 110)

> **Grokking Pattern:** #11 Tree DFS (Postorder + Early Termination)
>
> **Difficulty:** Easy | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very Common

---

## Problem Statement

Given a binary tree, determine if it is **height-balanced**.

A **height-balanced** binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

```
Input: root = [3,9,20,null,null,15,7]
        3
       / \
      9   20
         /  \
        15   7

Output: true
```

```
Input: root = [1,2,2,3,3,null,null,4,4]
        1
       / \
      2   2
     / \
    3   3
   / \
  4   4

Output: false (left subtree height = 3, right = 1, diff = 2)
```

[LeetCode 110 - Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Height-balanced" or "AVL property"
- Check if heights differ by at most 1
- Check condition at EVERY node

**Key insight:**
This combines height calculation with validation. We can:
1. **Naive:** Calculate height separately for each node ‚Üí O(n¬≤)
2. **Optimal:** Calculate height and check balance in one pass ‚Üí O(n)

Use **-1** as a sentinel to indicate "unbalanced subtree found."

</details>

---

## ‚úÖ When to Use

- Validating tree balance property
- Checking AVL invariant
- Any "all nodes must satisfy condition" problem

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Just need max height | No validation needed | Max Depth |
| Need to rebalance | Different operation | AVL rotations |
| BST property check | Different condition | BST validation |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Maximum Depth](./4.1-Maximum-Depth.md)
- [Postorder Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/03-Postorder-Traversal.md)

**After mastering this:**
- [Validate BST](../../07-Binary-Search-Trees/validate-bst.md)
- AVL Tree rotations

**Pattern connection:**
- Early termination optimization
- Sentinel value (-1) for failure

</details>

---

## üìê How It Works

### Balance Condition

```
For EVERY node in the tree:
|height(left) - height(right)| <= 1

If any node violates this, tree is unbalanced.
```

### Naive vs Optimal

```
Naive O(n¬≤):
For each node:
    left_height = getHeight(left)    # O(n) each
    right_height = getHeight(right)  # O(n) each
    check |left - right| <= 1

Optimal O(n):
Single pass:
    Calculate height AND check balance together
    If unbalanced found anywhere, propagate -1
```

### Visualization

```
Balanced:
        3           heights: left=1, right=2
       / \          diff = |1-2| = 1 ‚â§ 1 ‚úì
      9   20        
         /  \       For every node, diff ‚â§ 1
        15   7      

Unbalanced:
        1           heights: left=3, right=1
       / \          diff = |3-1| = 2 > 1 ‚úó
      2   2
     / \
    3   3
   / \
  4   4
```

---

## üíª Code Implementation

### Solution 1: Optimal - O(n) with Sentinel

**Python:**
```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def is_balanced(root: Optional[TreeNode]) -> bool:
    """
    Check if tree is height-balanced.
    
    Key: Return -1 as sentinel for "unbalanced."
    Time: O(n), Space: O(h)
    """
    def check_height(node):
        """Returns height if balanced, -1 if not."""
        if not node:
            return 0
        
        # Get left height
        left_height = check_height(node.left)
        if left_height == -1:  # Early termination
            return -1
        
        # Get right height
        right_height = check_height(node.right)
        if right_height == -1:  # Early termination
            return -1
        
        # Check balance at current node
        if abs(left_height - right_height) > 1:
            return -1  # Unbalanced!
        
        # Return height for parent
        return 1 + max(left_height, right_height)
    
    return check_height(root) != -1
```

**JavaScript:**
```javascript
function isBalanced(root) {
    function checkHeight(node) {
        if (!node) return 0;
        
        const leftHeight = checkHeight(node.left);
        if (leftHeight === -1) return -1;
        
        const rightHeight = checkHeight(node.right);
        if (rightHeight === -1) return -1;
        
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        
        return 1 + Math.max(leftHeight, rightHeight);
    }
    
    return checkHeight(root) !== -1;
}
```

### Solution 2: Naive - O(n¬≤) (For Comparison)

**Python:**
```python
def is_balanced_naive(root: Optional[TreeNode]) -> bool:
    """
    Naive approach: O(n¬≤) - calculate height at each node.
    
    NOT recommended, but good to understand why it's slow.
    """
    def height(node):
        if not node:
            return 0
        return 1 + max(height(node.left), height(node.right))
    
    if not root:
        return True
    
    # Check current node
    left_height = height(root.left)
    right_height = height(root.right)
    
    if abs(left_height - right_height) > 1:
        return False
    
    # Recursively check children
    return is_balanced_naive(root.left) and is_balanced_naive(root.right)
```

### Solution 3: Return Tuple (Alternative to Sentinel)

**Python:**
```python
def is_balanced_tuple(root: Optional[TreeNode]) -> bool:
    """
    Alternative: Return (is_balanced, height) tuple.
    More explicit than sentinel value.
    """
    def check(node):
        """Returns (is_balanced, height)"""
        if not node:
            return (True, 0)
        
        left_balanced, left_height = check(node.left)
        if not left_balanced:
            return (False, 0)  # Early exit
        
        right_balanced, right_height = check(node.right)
        if not right_balanced:
            return (False, 0)  # Early exit
        
        is_balanced = abs(left_height - right_height) <= 1
        height = 1 + max(left_height, right_height)
        
        return (is_balanced, height)
    
    balanced, _ = check(root)
    return balanced
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Optimal (sentinel) |" O(n) "| O(h) | Single pass |
| Naive |" O(n¬≤) "| O(h) | Height recalculated |
| Tuple return |" O(n) "| O(h) | More explicit |

**Why naive is O(n¬≤):**
- For each of n nodes, we calculate height ‚Üí O(n)
- Total: O(n) * O(n) = O(n¬≤)

**Why optimal is O(n):**
- Each node visited exactly once
- Height and balance checked together

---

## üîÑ Variations

| Variation | Difference | Notes |
|-----------|------------|-------|
| Check if AVL | Same as balanced | AVL = balanced BST |
| Weight-balanced | # nodes instead of height | Different formula |
| Nearly balanced | Allow diff ‚â§ k | Generalized |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Naive O(n¬≤) Approach

```python
# ‚ùå SLOW: Recalculating height for each node
def is_balanced(root):
    if not root:
        return True
    left_h = height(root.left)   # O(n) each time
    right_h = height(root.right)  # O(n) each time
    return abs(left_h - right_h) <= 1 and \
           is_balanced(root.left) and is_balanced(root.right)

# ‚úÖ FAST: Single pass with sentinel
def check_height(node):
    if not node:
        return 0
    left = check_height(node.left)
    if left == -1:
        return -1  # Propagate failure
    # ... rest of logic
```

### 2. Not Checking Every Node

```python
# ‚ùå WRONG: Only checking root
def is_balanced(root):
    if not root:
        return True
    return abs(height(root.left) - height(root.right)) <= 1

# This misses imbalance in subtrees!

# ‚úÖ CORRECT: The recursive check handles all nodes
# When we return -1, it propagates up from any unbalanced node
```

### 3. Wrong Balance Condition

```python
# ‚ùå WRONG: Using < instead of <=
if abs(left_height - right_height) < 1:  # Wrong!
    return height
# This only allows diff of 0, rejecting valid trees

# ‚úÖ CORRECT: Diff of 0 or 1 is okay
if abs(left_height - right_height) > 1:
    return -1  # Only reject if diff > 1
```

---

## üìù Practice Problems

### This Problem
- [ ] [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/) - LC 110

### Related Concepts
- [ ] [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) - LC 104
- [ ] [Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/) - LC 111
- [ ] [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) - LC 543

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement optimal with sentinel
**Day 3:** Explain O(n) vs O(n¬≤) difference
**Day 7:** Implement without looking
**Day 14:** Solve related height problems

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Starting the problem:**
> "A balanced tree means every node's left and right subtrees differ in height by at most 1. I'll check this with a single DFS pass."

**Explaining optimization:**
> "The naive approach recalculates height at each node, making it O(n¬≤). I can optimize to O(n) by combining height calculation with balance checking, using -1 as a sentinel for 'unbalanced.'"

**Discussing sentinel:**
> "I return -1 to indicate an unbalanced subtree was found. This allows early termination - once we find any imbalance, we propagate -1 up without further computation."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê |" Often asks O(n) solution "|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask about AVL |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Classic interview question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Recognize pattern | 1-2 min | Height + validation |
| Naive solution | 5 min | Start here if stuck |
| Optimal solution | 8-10 min | With explanation |

---

> **üí° Key Insight:** The sentinel pattern (-1 for failure) is powerful for tree problems. It allows you to: (1) combine computation with validation, (2) enable early termination, and (3) maintain O(n) complexity. Use it whenever you need to check a condition at every node.

---

## üîó Related

- [Maximum Depth](./4.1-Maximum-Depth.md)
- [Diameter of Binary Tree](./4.3-Diameter-of-Tree.md)
- [Validate BST](../../07-Binary-Search-Trees/validate-bst.md)
