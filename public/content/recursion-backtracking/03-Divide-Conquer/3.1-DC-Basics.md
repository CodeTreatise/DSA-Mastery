# 3.1 Divide and Conquer Basics

> **Breaking Problems Into Subproblems**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê - Merge Sort, Quick Sort, Binary Search  
> **Prerequisites:** [1.1-1.3 Recursion Fundamentals](../01-Recursion/1.1-Recursion-Basics.md)

---

## Overview

**Divide and Conquer (D&C)** is an algorithm design paradigm:
1. **Divide:** Break the problem into smaller subproblems
2. **Conquer:** Solve subproblems recursively
3. **Combine:** Merge subproblem solutions into final solution

Classic examples: Merge Sort, Quick Sort, Binary Search, Karatsuba Multiplication.

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Divide and Conquer</strong></summary>

**Look for these signals:**
- Problem can be **split** into independent subproblems
- Subproblems are **same type** as original
- Solutions can be **combined efficiently**
- Often involves **halving** the input

**Keywords in problem statement:**
- "sorted array", "merge", "split"
- "find median", "kth element"
- "maximum subarray", "closest pair"

**D&C characteristics:**
- O(log n) or O(n log n) complexity
- Recursive structure
- Independent subproblems (unlike DP)

</details>

---

## ‚úÖ When to Use Divide and Conquer

- **Sorting:** Merge sort, Quick sort
- **Searching:** Binary search, finding kth element
- **Optimization:** Maximum subarray (Kadane's can be D&C)
- **Computational geometry:** Closest pair of points
- **Mathematical:** Large number multiplication

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Overlapping subproblems | Dynamic Programming | DP caches results |
| Sequential dependency | Linear scan | Can't parallelize |
| Simple iteration | Loops | Less overhead |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Recursion Basics](../01-Recursion/1.1-Recursion-Basics.md)
- [Recursion Patterns](../01-Recursion/1.2-Recursion-Patterns.md)

**After mastering this:**
- [Classic D&C Problems](./3.2-Classic-DC-Problems.md)
- Advanced: FFT, Strassen's Matrix Multiplication

**Related concepts:**
- Binary recursion
- Master theorem for complexity
- Parallel algorithms

</details>

---

## üìê The D&C Template

```python
def divide_and_conquer(problem):
    """Generic divide and conquer template."""
    
    # Base case: problem is small enough to solve directly
    if is_base_case(problem):
        return solve_directly(problem)
    
    # DIVIDE: split into subproblems
    left_problem, right_problem = divide(problem)
    
    # CONQUER: solve subproblems recursively
    left_result = divide_and_conquer(left_problem)
    right_result = divide_and_conquer(right_problem)
    
    # COMBINE: merge results
    return combine(left_result, right_result)
```

---

## üíª Classic Example: Merge Sort

```python
def merge_sort(arr: list) -> list:
    """
    Sort array using divide and conquer.
    
    Time: O(n log n), Space: O(n)
    """
    # Base case
    if len(arr) <= 1:
        return arr
    
    # DIVIDE
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    
    # CONQUER
    left_sorted = merge_sort(left)
    right_sorted = merge_sort(right)
    
    # COMBINE
    return merge(left_sorted, right_sorted)


def merge(left: list, right: list) -> list:
    """Merge two sorted arrays."""
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result


# Visualization:
#
# [38, 27, 43, 3, 9, 82, 10]
#         /              \
#   [38, 27, 43]     [3, 9, 82, 10]
#      /    \            /       \
#  [38]  [27, 43]    [3, 9]   [82, 10]
#         /   \       /  \      /   \
#       [27] [43]   [3]  [9]  [82]  [10]
#
# Merge up:
#       [27, 43]    [3, 9]   [10, 82]
#   [27, 38, 43]    [3, 9, 10, 82]
#        [3, 9, 10, 27, 38, 43, 82]
```

```javascript
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result.push(left[i++]);
        } else {
            result.push(right[j++]);
        }
    }
    
    return [...result, ...left.slice(i), ...right.slice(j)];
}
```

---

## üíª Classic Example: Quick Sort

```python
def quick_sort(arr: list) -> list:
    """
    Sort array using quick sort.
    
    Time: O(n log n) average, O(n¬≤) worst
    Space: O(log n) for recursion
    """
    if len(arr) <= 1:
        return arr
    
    # DIVIDE: choose pivot and partition
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    # CONQUER and COMBINE
    return quick_sort(left) + middle + quick_sort(right)


# In-place version
def quick_sort_inplace(arr: list, lo: int = 0, hi: int = None) -> None:
    """In-place quick sort."""
    if hi is None:
        hi = len(arr) - 1
    
    if lo < hi:
        # DIVIDE: partition and get pivot index
        pivot_idx = partition(arr, lo, hi)
        
        # CONQUER
        quick_sort_inplace(arr, lo, pivot_idx - 1)
        quick_sort_inplace(arr, pivot_idx + 1, hi)


def partition(arr: list, lo: int, hi: int) -> int:
    """Lomuto partition scheme."""
    pivot = arr[hi]
    i = lo - 1
    
    for j in range(lo, hi):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[hi] = arr[hi], arr[i + 1]
    return i + 1
```

```javascript
function quickSort(arr) {
    if (arr.length <= 1) return arr;
    
    const pivot = arr[Math.floor(arr.length / 2)];
    const left = arr.filter(x => x < pivot);
    const middle = arr.filter(x => x === pivot);
    const right = arr.filter(x => x > pivot);
    
    return [...quickSort(left), ...middle, ...quickSort(right)];
}
```

---

## üíª Classic Example: Binary Search

```python
def binary_search(arr: list, target: int, lo: int = 0, hi: int = None) -> int:
    """
    Binary search using D&C.
    
    Time: O(log n), Space: O(log n) for recursion
    """
    if hi is None:
        hi = len(arr) - 1
    
    # Base case: not found
    if lo > hi:
        return -1
    
    # DIVIDE: check middle
    mid = (lo + hi) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        # CONQUER: search right half
        return binary_search(arr, target, mid + 1, hi)
    else:
        # CONQUER: search left half
        return binary_search(arr, target, lo, mid - 1)
```

---

## ‚ö° Complexity Analysis

### Master Theorem

For recurrences of the form: `T(n) = aT(n/b) + O(n^d)`

| Case | Condition | Complexity |
|------|-----------|------------|
| 1 | d < log_b(a) |" O(n^(log_b(a))) "|
| 2 | d = log_b(a) |" O(n^d * log n) "|
| 3 | d > log_b(a) |" O(n^d) "|

**Common D&C Complexities:**

| Algorithm | Recurrence | Result |
|-----------|------------|--------|
| Merge Sort |" T(n) = 2T(n/2) + O(n) "| O(n log n) |
| Binary Search |" T(n) = T(n/2) + O(1) "| O(log n) |
| Quick Sort (avg) |" T(n) = 2T(n/2) + O(n) "| O(n log n) |
| Strassen |" T(n) = 7T(n/2) + O(n¬≤) "| O(n^2.81) |

---

## üîÑ Variations

| Pattern | Split | Example |
|---------|-------|---------|
| **Binary split** | Halve input | Merge sort |
| **Pivot partition** | Around pivot | Quick sort |
| **By property** | Based on condition | Quick select |
| **Multi-way** | k parts | External sorting |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Handling Base Case

‚ùå **Wrong:**
```python
def merge_sort(arr):
    mid = len(arr) // 2  # Crashes on empty!
    ...
```

‚úÖ **Correct:**
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    ...
```

### 2. Incorrect Midpoint Calculation

‚ùå **Wrong (overflow in some languages):**
```python
mid = (lo + hi) / 2
```

‚úÖ **Correct:**
```python
mid = lo + (hi - lo) // 2
```

### 3. Forgetting to Combine

‚ùå **Wrong:**
```python
def sort(arr):
    left = sort(arr[:mid])
    right = sort(arr[mid:])
    # Forgot to return merged result!
```

‚úÖ **Correct:**
```python
def sort(arr):
    left = sort(arr[:mid])
    right = sort(arr[mid:])
    return merge(left, right)
```

---

## üìù Practice Problems

### Easy (Learn the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Binary Search | Basic D&C | [LC 704](https://leetcode.com/problems/binary-search/) |
| Merge Sorted Array | Merge step | [LC 88](https://leetcode.com/problems/merge-sorted-array/) |

### Medium (Apply pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Sort an Array | Implement merge/quick | [LC 912](https://leetcode.com/problems/sort-an-array/) |
| Kth Largest Element | Quick select | [LC 215](https://leetcode.com/problems/kth-largest-element-in-an-array/) |
| Maximum Subarray | D&C approach | [LC 53](https://leetcode.com/problems/maximum-subarray/) |
| Search in Rotated Array | Modified binary search | [LC 33](https://leetcode.com/problems/search-in-rotated-sorted-array/) |

### Hard (Master pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Median of Two Sorted Arrays | Complex D&C | [LC 4](https://leetcode.com/problems/median-of-two-sorted-arrays/) |
| Merge k Sorted Lists | D&C merging | [LC 23](https://leetcode.com/problems/merge-k-sorted-lists/) |
| Count of Smaller Numbers After Self | Merge sort variant | [LC 315](https://leetcode.com/problems/count-of-smaller-numbers-after-self/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: Implement merge sort from scratch
- Day 2: Implement quick sort (both versions)
- Day 3: Binary search variations
- Day 5: LC 215 (Kth Largest)

**Week 2:**
- Day 8: LC 53 (Maximum Subarray - D&C way)
- Day 10: LC 23 (Merge k Sorted Lists)
- Day 14: Review, analyze complexities

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Opening statement:**
> "I'll use divide and conquer here. I'll split the problem in half, solve each half recursively, and then combine the results."

**Explaining merge sort:**
> "I split the array in half, recursively sort each half, and merge the sorted halves. Time is O(n log n) because we have log n levels and O(n) work at each level."

**Explaining quick sort:**
> "I pick a pivot, partition elements around it, and recursively sort the partitions. Average O(n log n), worst O(n¬≤) if pivot choice is bad."

**Company Focus:**

| Company | D&C Focus |
|---------|-----------|
| Google | Complex D&C, median problems |
| Amazon | Sorting, searching |
| Meta | Merge k lists, counting inversions |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand D&C concept | 20-30 min | With examples |
| Implement merge sort | 25-35 min | From scratch |
| Implement quick sort | 30-40 min | Both versions |
| Solve 3 Medium problems | 60-90 min | Apply pattern |

---

## üí° Key Insight

> **Divide and Conquer vs Dynamic Programming:**
>
> | Aspect | D&C | DP |
> |--------|-----|-----|
> | Subproblems | Independent | Overlapping |
> | Approach | Top-down only | Top-down or bottom-up |
> | Example | Merge Sort | Fibonacci |
>
> If you see the same subproblem being solved multiple times, switch to DP with memoization!

---

## üîó Related

- [Recursion Basics](../01-Recursion/1.1-Recursion-Basics.md) - Foundation
- [Classic D&C Problems](./3.2-Classic-DC-Problems.md) - More examples
- [Memoization](../04-Optimization/4.1-Memoization.md) - When D&C has overlap
