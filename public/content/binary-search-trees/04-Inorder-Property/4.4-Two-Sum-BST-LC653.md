# 4.4 Two Sum IV - Input is a BST (LC 653)

## Problem Statement

[LeetCode 653 - Two Sum IV - Input is a BST](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/)

Given the root of a BST and a target, return `true` if there exist two nodes such that their sum equals the target.

```
Input: root = [5,3,6,2,4,null,7], k = 9
        5
       / \
      3   6
     / \   \
    2   4   7

Output: true (2 + 7 = 9)
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a Two Pointers on BST problem:**
- Classic two-sum but on a BST
- Can use BST's sorted property
- Two pointers from both ends of sorted sequence

**Keywords:**
- "two sum", "pair sum"
- "BST" + "target sum"
- "find two nodes"

**Pattern:** Convert BST problem to sorted array problem using inorder property.

</details>

---

## ‚úÖ When to Use

- Two-sum variants on BST
- Pair-finding problems on ordered data
- When BST structure enables sorted access

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Need all pairs | Two-pointer finds one pair | Full enumeration |
| Unsorted tree | No two-pointer advantage | Hash set |
| Allow same node twice | Need distinct nodes | Different approach |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Two Pointers Pattern](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md)
- [BST Iterator (LC 173)](./4.2-BST-Iterator-LC173.md) - Controlled traversal
- [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md) - Inorder = sorted

**After mastering this:**
- More complex BST pair problems
- K-sum variants on BST

**Combines with:**
- Two-pointer technique
- BST iterator pattern
- Hash set approach

</details>

---

## üìê How It Works

### Approach 1: Inorder + Two Pointers

```
BST:
        5
       / \
      3   6
     / \   \
    2   4   7

Inorder: [2, 3, 4, 5, 6, 7]
Target: 9

Two pointers on sorted array:
left = 0 (value 2)
right = 5 (value 7)

2 + 7 = 9 = target ‚Üí Found!
```

### Approach 2: Hash Set During Traversal

```
For each node with value v:
  Check if (target - v) is in the set
  Add v to the set

Traverse: 5, 3, 2, 4, 6, 7
Set after each: {5}, {5,3}, {5,3,2}, {5,3,2,4}, {5,3,2,4,6}, ...

At node 7: target - 7 = 9 - 7 = 2
Is 2 in set {5,3,2,4,6}? YES! Found!
```

### Approach 3: Two BST Iterators (Optimal)

```
Use two iterators:
- Forward iterator (smallest to largest)
- Backward iterator (largest to smallest)

Forward: 2, 3, 4, ...
Backward: 7, 6, 5, ...

Like two pointers, but O(h) space instead of O(n).
```

---

## üíª Code Implementation

### Approach 1: Inorder + Two Pointers (Simple)

**Python:**
```python
def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
    """
    Two Sum on BST using inorder array + two pointers.
    
    Time: O(n)
    Space: O(n) for inorder array
    """
    # Get sorted array via inorder
    def inorder(node, arr):
        if node:
            inorder(node.left, arr)
            arr.append(node.val)
            inorder(node.right, arr)
    
    sorted_vals = []
    inorder(root, sorted_vals)
    
    # Two pointers on sorted array
    left, right = 0, len(sorted_vals) - 1
    while left < right:
        total = sorted_vals[left] + sorted_vals[right]
        if total == k:
            return True
        elif total < k:
            left += 1
        else:
            right -= 1
    
    return False
```

**JavaScript:**
```javascript
var findTarget = function(root, k) {
    // Inorder to sorted array
    const sortedVals = [];
    
    function inorder(node) {
        if (node) {
            inorder(node.left);
            sortedVals.push(node.val);
            inorder(node.right);
        }
    }
    inorder(root);
    
    // Two pointers
    let left = 0, right = sortedVals.length - 1;
    while (left < right) {
        const total = sortedVals[left] + sortedVals[right];
        if (total === k) return true;
        total < k ? left++ : right--;
    }
    
    return false;
};
```

### Approach 2: Hash Set (DFS)

**Python:**
```python
def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
    """
    Hash set approach - check complement during traversal.
    
    Time: O(n)
    Space: O(n) for hash set
    """
    seen = set()
    
    def dfs(node):
        if not node:
            return False
        
        complement = k - node.val
        if complement in seen:
            return True
        
        seen.add(node.val)
        
        return dfs(node.left) or dfs(node.right)
    
    return dfs(root)
```

**JavaScript:**
```javascript
var findTarget = function(root, k) {
    // Hash set approach
    const seen = new Set();
    
    function dfs(node) {
        if (!node) return false;
        
        if (seen.has(k - node.val)) return true;
        seen.add(node.val);
        
        return dfs(node.left) || dfs(node.right);
    }
    
    return dfs(root);
};
```

### Approach 3: Two Iterators (Optimal Space)

**Python:**
```python
def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
    """
    Two BST iterators - forward and backward.
    
    Time: O(n)
    Space: O(h) - two stacks of height h
    """
    if not root:
        return False
    
    # Forward iterator (smallest first)
    forward_stack = []
    def push_left(node):
        while node:
            forward_stack.append(node)
            node = node.left
    push_left(root)
    
    # Backward iterator (largest first)
    backward_stack = []
    def push_right(node):
        while node:
            backward_stack.append(node)
            node = node.right
    push_right(root)
    
    # Two pointers using iterators
    left_node = forward_stack[-1]
    right_node = backward_stack[-1]
    
    while left_node != right_node:
        total = left_node.val + right_node.val
        
        if total == k:
            return True
        elif total < k:
            # Move left forward (next smallest)
            node = forward_stack.pop()
            push_left(node.right)
            if not forward_stack:
                break
            left_node = forward_stack[-1]
        else:
            # Move right backward (next largest)
            node = backward_stack.pop()
            push_right(node.left)
            if not backward_stack:
                break
            right_node = backward_stack[-1]
    
    return False
```

**JavaScript:**
```javascript
var findTarget = function(root, k) {
    // Two iterators approach
    if (!root) return false;
    
    // Forward iterator
    const forwardStack = [];
    function pushLeft(node) {
        while (node) {
            forwardStack.push(node);
            node = node.left;
        }
    }
    pushLeft(root);
    
    // Backward iterator  
    const backwardStack = [];
    function pushRight(node) {
        while (node) {
            backwardStack.push(node);
            node = node.right;
        }
    }
    pushRight(root);
    
    // Two pointers
    let leftNode = forwardStack[forwardStack.length - 1];
    let rightNode = backwardStack[backwardStack.length - 1];
    
    while (leftNode !== rightNode) {
        const total = leftNode.val + rightNode.val;
        
        if (total === k) return true;
        
        if (total < k) {
            const node = forwardStack.pop();
            pushLeft(node.right);
            if (forwardStack.length === 0) break;
            leftNode = forwardStack[forwardStack.length - 1];
        } else {
            const node = backwardStack.pop();
            pushRight(node.left);
            if (backwardStack.length === 0) break;
            rightNode = backwardStack[backwardStack.length - 1];
        }
    }
    
    return false;
};
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Inorder + Two Pointers |" O(n) "| O(n) | Simple, stores all values |
| Hash Set |" O(n) "| O(n) | Simple, stores visited |
| Two Iterators |" O(n) "| O(h) | Optimal space |

**Why Two Iterators is Best:**
- Same O(n) time as other approaches
- Only O(h) space ‚Äî could be O(log n) for balanced tree
- Leverages BST structure efficiently

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **Three Sum BST** | Add third iterator | Extension |
| **Pair with difference** | a - b = k | Different condition |
| **Closest pair sum** | Minimize |sum - k| | Track closest |
| **Count pairs** | Count all, don't stop early | Full enumeration |

### Find Closest Pair Sum

```python
def closestPairSum(root: TreeNode, k: int) -> list[int]:
    """Find pair with sum closest to k."""
    inorder_vals = []
    # ... build inorder_vals
    
    left, right = 0, len(inorder_vals) - 1
    closest_pair = None
    min_diff = float('inf')
    
    while left < right:
        total = inorder_vals[left] + inorder_vals[right]
        diff = abs(total - k)
        
        if diff < min_diff:
            min_diff = diff
            closest_pair = [inorder_vals[left], inorder_vals[right]]
        
        if total < k:
            left += 1
        elif total > k:
            right -= 1
        else:
            return closest_pair  # Exact match
    
    return closest_pair
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Same Node Twice

```python
# ‚ùå Wrong: Might use node.val + node.val = k
if node.val * 2 == k:
    return True  # This uses the same node twice!

# ‚úÖ Correct: Ensure two DIFFERENT nodes
# The two-pointer approach naturally ensures left < right (different indices)
```

### 2. Not Handling Empty Tree

```python
# ‚ùå Wrong: Crashes on empty tree
def findTarget(root, k):
    inorder(root, arr)  # Works, but...
    left, right = 0, len(arr) - 1  # Could have 0 or 1 elements

# ‚úÖ Correct: Check edge cases
def findTarget(root, k):
    if not root:
        return False
    # ... rest of solution
```

### 3. Iterator Termination in Two-Iterator Approach

```python
# ‚ùå Wrong: Not checking if iterators overlap
while True:  # Infinite loop possible!
    ...

# ‚úÖ Correct: Stop when left and right meet
while left_node != right_node:  # Stop when they're the same node
    ...
```

---

## üìù Practice Problems (Progressive)

### Easy (Build up)
- [ ] [Two Sum (LC 1)](https://leetcode.com/problems/two-sum/) - Array version

### Medium (Apply pattern)
- [ ] [Two Sum IV (LC 653)](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) - This problem
- [ ] [BST Iterator (LC 173)](https://leetcode.com/problems/binary-search-tree-iterator/) - Used in optimal solution
- [ ] [Two Sum II (LC 167)](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) - Two pointers on sorted

### Hard (Master)
- [ ] [3Sum (LC 15)](https://leetcode.com/problems/3sum/) - Extension to three elements

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement inorder + two pointers
- **Day 3:** Implement hash set approach
- **Day 7:** Implement two iterators (optimal)
- **Day 14:** Compare all three approaches
- **Day 30:** Solve without looking

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"Since inorder traversal of a BST gives sorted order, I can convert this to a two-sum on a sorted array problem. I'll use two pointers, one from each end, adjusting based on whether the sum is too small or too large."

**Discuss trade-offs:**
1. "Inorder + two pointers is O(n) time and space ‚Äî simple to implement"
2. "Hash set is also O(n) time and space ‚Äî doesn't use BST property"
3. "Two iterators is O(n) time but O(h) space ‚Äî best when tree is balanced"

**Follow-up questions:**
- "Which approach is best?" ‚Üí Depends on tree balance and interview requirements
- "What about three sum?" ‚Üí Add another iterator/pointer

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common two-sum variant |
| Meta | ‚≠ê‚≠ê‚≠ê | Tests BST understanding |
| Google | ‚≠ê‚≠ê‚≠ê | May ask for optimal |
| Microsoft | ‚≠ê‚≠ê | Less common |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Two-sum on BST |
| Code simple approach | 8-10 min | Inorder + two pointers |
| Code optimal | 15-18 min | Two iterators |
| Discuss trade-offs | 3-4 min | Compare approaches |
| Total interview time | 25-30 min | Medium difficulty |

---

## üí° Key Insight

> **BST + Two Sum = Sorted Array + Two Pointers.** The BST's inorder property gives us sorted access, reducing this to the classic two-sum II problem. The optimal solution uses two BST iterators as "virtual" pointers into this sorted sequence.

---

## üîó Related

- **Previous:** [Greater Sum Tree (LC 538)](./4.3-Greater-Sum-Tree-LC538.md)
- **Pattern:** [Two Pointers](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md)
- **Uses:** [BST Iterator (LC 173)](./4.2-BST-Iterator-LC173.md)
- **Similar:** [Two Sum II (LC 167)](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)
