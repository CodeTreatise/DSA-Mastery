# 1.4 BST vs Binary Tree Comparison

## Overview

Understanding when to use BST-specific algorithms versus general tree algorithms is critical for interview success. This file clarifies the key differences and when each approach applies.

```
Binary Tree (no order):          BST (ordered):
        5                              5
       / \                            / \
      8   3                          3   8
     / \                            / \   \
    2   9                          1   4   9

No guaranteed order           Left < Node < Right
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Which Algorithms Apply</strong></summary>

**This is a general Binary Tree problem if:**
- Problem works on "any binary tree"
- Order doesn't matter (structure-based)
- Examples: height, diameter, level order
- Keywords: "binary tree" without "search" or "BST"

**This is a BST problem if:**
- Problem mentions "BST" or "binary search tree"
- Solution exploits left < node < right property
- Examples: validate BST, k-th smallest
- Keywords: "BST", "sorted", "ordered tree"

</details>

---

## ‚úÖ When to Use BST Algorithms

| Situation | Why BST Algorithm |
|-----------|-------------------|
| "Valid BST" check | Must use ordering property |
| K-th smallest/largest | Inorder = sorted |
| Range queries | Can prune with BST property |
| Search, insert, delete |" O(log n) possible "|
| Successor/predecessor | Ordering enables navigation |

## ‚ùå When NOT to Use BST Algorithms

| Situation | Why Not | Use Instead |
|----------|---------|-------------|
| General tree traversal | Order doesn't help | DFS/BFS |
| Finding diameter | Structure, not values | General tree DFS |
| Level order traversal | BFS regardless of values | Standard BFS |
| LCA in general tree | Values don't guide path | General LCA algorithm |
| Tree serialization | Structure preservation | General approach |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Definition](./1.1-BST-Definition.md)
- [Binary Tree Basics](../../06-Trees/01-Tree-Fundamentals/)
- [Tree Traversals](../../06-Trees/03-Tree-Traversals/)

**After mastering this:**
- Know when to switch between approaches
- Identify BST-specific optimizations
- [BST Operations](../02-BST-Operations/) - BST-specific
- [Tree Properties](../../06-Trees/04-Tree-Properties/) - General tree

</details>

---

## üìê Key Differences Explained

### 1. Search Operation

**Binary Tree Search: O(n)**
```python
def search_binary_tree(root: TreeNode, target: int) -> TreeNode:
    """Must check every node - no ordering to guide us."""
    if not root:
        return None
    if root.val == target:
        return root
    
    # Check both subtrees - can't know which has target
    left = search_binary_tree(root.left, target)
    if left:
        return left
    return search_binary_tree(root.right, target)
```

**BST Search: O(log n)**
```python
def search_bst(root: TreeNode, target: int) -> TreeNode:
    """Use ordering to choose ONE direction each step."""
    while root:
        if target == root.val:
            return root
        elif target < root.val:
            root = root.left   # Only go left
        else:
            root = root.right  # Only go right
    return None
```

### 2. Finding Minimum/Maximum

**Binary Tree: O(n)**
```python
def min_binary_tree(root: TreeNode) -> int:
    """Must check every node."""
    if not root:
        return float('inf')
    
    return min(
        root.val,
        min_binary_tree(root.left),
        min_binary_tree(root.right)
    )
```

**BST: O(h)**
```python
def min_bst(root: TreeNode) -> int:
    """Just follow left pointers."""
    while root.left:
        root = root.left
    return root.val
```

### 3. LCA (Lowest Common Ancestor)

**Binary Tree LCA: Must check both subtrees**
```python
def lca_binary_tree(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """Post-order traversal, check if p/q in each subtree."""
    if not root or root == p or root == q:
        return root
    
    left = lca_binary_tree(root.left, p, q)
    right = lca_binary_tree(root.right, p, q)
    
    if left and right:
        return root
    return left or right
```

**BST LCA: Use values to navigate**
```python
def lca_bst(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """Use values to determine direction - O(h) time."""
    while root:
        if p.val < root.val and q.val < root.val:
            root = root.left    # Both in left subtree
        elif p.val > root.val and q.val > root.val:
            root = root.right   # Both in right subtree
        else:
            return root         # Split point = LCA
    return None
```

### 4. Sorted Order Traversal

**Binary Tree: Must sort explicitly**
```python
def sorted_values_tree(root: TreeNode) -> list[int]:
    """Collect all, then sort - O(n log n)."""
    values = []
    def collect(node):
        if node:
            values.append(node.val)
            collect(node.left)
            collect(node.right)
    collect(root)
    return sorted(values)
```

**BST: Inorder is already sorted**
```python
def sorted_values_bst(root: TreeNode) -> list[int]:
    """Inorder traversal - O(n), already sorted!"""
    result = []
    def inorder(node):
        if node:
            inorder(node.left)
            result.append(node.val)  # Visit in sorted order
            inorder(node.right)
    inorder(root)
    return result  # No sorting needed
```

---

## üíª Comparison Table

| Operation | Binary Tree | BST | When BST is Better |
|-----------|-------------|-----|-------------------|
| Search |" O(n) "| O(h) | When data is ordered |
| Insert |" O(1)* "| O(h) | BST maintains order |
| Delete |" O(n) "| O(h) | Finding node is faster |
| Min/Max |" O(n) "| O(h) | Follow single path |
| K-th element |" O(n) "| O(h+k) or O(n) | Inorder property |
| Range query |" O(n) "| O(h+k) | Can prune subtrees |
| LCA |" O(n) "| O(h) | Values guide navigation |
| Sorted order |" O(n log n) "| O(n) | Inorder = sorted |

*Insert at specific position requires finding that position first.

---

## ‚ö° Complexity Analysis

### When BST Beats Binary Tree

| Scenario | Binary Tree | BST | Speedup |
|----------|-------------|-----|---------|
| 1M nodes, find value | 1,000,000 ops | ~20 ops | 50,000x |
| 1M nodes, find min | 1,000,000 ops | ~20 ops | 50,000x |
| 1M nodes, range [100,200] | 1,000,000 ops | ~20 + k ops | Huge |

### When They're Equal

| Operation | Both | Why Equal |
|-----------|------|-----------|
| Full traversal |" O(n) "| Must visit all nodes |
| Finding height |" O(n) "| Must check all paths |
| Level order |" O(n) "| BFS visits all |
| Diameter |" O(n) "| Structure-based |

---

## üîÑ Problem Classification

### Same Algorithm Works for Both

| Problem | Why Same | Example |
|---------|----------|---------|
| Tree height | Structure only | LC 104 |
| Count nodes | Structure only | LC 222 |
| Invert tree | Structure only | LC 226 |
| Symmetric tree | Structure only | LC 101 |
| Serialize/deserialize | Structure preservation | LC 297 |

### BST Has Better Algorithm

| Problem | Binary Tree | BST Approach |
|---------|-------------|--------------|
| Validate BST | N/A |" Range DFS O(n) "|
| Search |" O(n) "| O(h) |
| K-th smallest | Sort then find | Inorder early stop |
| LCA |" DFS O(n) "| Value navigation O(h) |
| Two Sum in tree |" O(n¬≤) or hash "| Inorder + two pointers |
| Range sum |" O(n) "| Pruning O(h+k) |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using BST Algorithm on General Tree

```python
# ‚ùå Wrong: Treating any tree as BST
def find_in_tree(root, target):
    # This only works for BSTs!
    if target < root.val:
        return find_in_tree(root.left, target)
    else:
        return find_in_tree(root.right, target)

# ‚úÖ Correct: Check if BST first, or use general search
def find_in_tree(root, target):
    if not root:
        return None
    if root.val == target:
        return root
    return find_in_tree(root.left, target) or find_in_tree(root.right, target)
```

### 2. Missing BST Optimization

```python
# ‚ùå Slow: Using general approach when BST property helps
def kth_smallest_slow(root, k):
    """O(n) - collects all values."""
    values = []
    def inorder(node):
        if node:
            inorder(node.left)
            values.append(node.val)
            inorder(node.right)
    inorder(root)
    return values[k-1]

# ‚úÖ Fast: Stop early using BST property
def kth_smallest_fast(root, k):
    """O(h + k) - stops after k nodes."""
    count = [0]
    result = [None]
    
    def inorder(node):
        if node and result[0] is None:
            inorder(node.left)
            count[0] += 1
            if count[0] == k:
                result[0] = node.val
                return
            inorder(node.right)
    
    inorder(root)
    return result[0]
```

### 3. Confusing BST Validity Check

```python
# ‚ùå Wrong: Only checking immediate children
def is_valid_bst_wrong(root):
    if not root:
        return True
    if root.left and root.left.val >= root.val:
        return False
    if root.right and root.right.val <= root.val:
        return False
    return is_valid_bst_wrong(root.left) and is_valid_bst_wrong(root.right)

# This incorrectly returns True for:
#       5
#      / \
#     3   8
#      \
#       7  ‚Üê 7 > 5, but it's in left subtree!

# ‚úÖ Correct: Track valid range
def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):
    if not root:
        return True
    if root.val <= min_val or root.val >= max_val:
        return False
    return (is_valid_bst(root.left, min_val, root.val) and
            is_valid_bst(root.right, root.val, max_val))
```

---

## üìù Practice Problems (Progressive)

### Binary Tree Problems (No BST property)
- [ ] [Maximum Depth (LC 104)](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
- [ ] [Invert Tree (LC 226)](https://leetcode.com/problems/invert-binary-tree/)
- [ ] [LCA of Binary Tree (LC 236)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

### BST Problems (Use BST property)
- [ ] [Validate BST (LC 98)](https://leetcode.com/problems/validate-binary-search-tree/)
- [ ] [LCA of BST (LC 235)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
- [ ] [Kth Smallest (LC 230)](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)

### Compare Both Approaches
- [ ] Solve LC 236 (Binary Tree LCA) then LC 235 (BST LCA)
- [ ] Implement search in both tree types

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** List 3 differences between BST and Binary Tree algorithms
- **Day 3:** Solve one problem of each type
- **Day 7:** Explain when to use each approach
- **Day 14:** Compare LC 235 vs LC 236 solutions
- **Day 30:** Identify BST optimizations in new problems

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**When clarifying:**
- **Always ask:** "Is this a BST or just a binary tree?"
- This question shows you understand the critical difference
- Different algorithms apply based on the answer

**When explaining:**
- "Since this is a BST, I can use the ordering property to..."
- "For a general binary tree, I'd need to check both subtrees, but..."
- "The BST property lets me prune the search space..."

**When the problem is ambiguous:**
- State your assumption: "I'll assume this is a BST based on..."
- Or solve both: "For general tree it's O(n), but for BST it's O(h)"

</details>

**Company Focus:**

| Company | Emphasis | Example |
|---------|----------|---------|
| All companies | Clarifying BST vs tree | First question |
| Amazon | Both types frequently | LC 236, LC 235 |
| Microsoft | BST operations | LC 450, LC 701 |
| Google | Optimizations | Know both approaches |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand differences | 20-25 min | Compare algorithms |
| Solve one of each | 30-40 min | LC 236 + LC 235 |
| Master identification | 1-2 hours | Multiple problems |

---

## üí° Key Insight

> **The BST property is a constraint that ENABLES optimizations.** A general binary tree gives you nothing to work with except structure. A BST gives you ordering information that can cut search space in half at each step.

---

## üîó Related

- **Previous:** [1.3 Min/Max/Successor](./1.3-BST-MinMax-Successor.md)
- **BST Operations:** [02-BST-Operations/](../02-BST-Operations/)
- **General Trees:** [06-Trees/](../../06-Trees/)
- **LCA Comparison:** [LC 235 (BST)](../07-LCA-in-BST/) vs [LC 236 (Tree)](../../06-Trees/)
