# 8.1 Heap Sort Algorithm

## Definition

**Heap Sort** is a comparison-based sorting algorithm that uses a binary heap data structure. It divides input into a sorted and unsorted region, iteratively shrinking the unsorted region by extracting the largest (or smallest) element and inserting it into the sorted region.

```
Key Properties:
- Time: O(n log n) - guaranteed
- Space: O(1) - in-place
- NOT stable (equal elements may be reordered)
- Uses max-heap for ascending sort
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>When Heap Sort is the Right Choice</strong></summary>

**Key signals:**
- Need guaranteed O(n log n) worst case
- Memory is constrained (O(1) space required)
- Stability not required
- Partial sorting needed (Top K)

**Comparison with other sorts:**

| Sort | Time (Worst) | Space | Stable | Notes |
|------|--------------|-------|--------|-------|
| Heap Sort |" O(n log n) "| O(1) | No | Guaranteed |
| Quick Sort |" O(n¬≤) "| O(log n) | No | Faster average |
| Merge Sort |" O(n log n) "| O(n) | Yes | Stable |
| Tim Sort |" O(n log n) "| O(n) | Yes | Python default |

</details>

---

## ‚úÖ When to Use Heap Sort

- Memory-constrained environments (O(1) space)
- Need worst-case O(n log n) guarantee
- Partial sorting (find k largest/smallest)
- Building streaming/online algorithms

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|---------------------|
| Stability required | Merge Sort, Tim Sort |
| Small arrays | Insertion Sort |
| Nearly sorted data | Insertion Sort, Tim Sort |
| General purpose | Quick Sort (faster average) |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Heap Fundamentals](../01-Heap-Fundamentals/1.1-What-Is-Heap.md)
- [Heapify](../02-Heap-Operations/2.4-Heapify.md)
- [Replace Operations](../02-Heap-Operations/2.5-Replace.md)

**After mastering this:**
- Understand sorting algorithm trade-offs
- Priority queue implementations
- [Complexity Analysis](./8.2-Heap-Sort-Analysis.md)

</details>

---

## üìê How It Works

### Algorithm Steps

```
Step 1: BUILD MAX-HEAP from input array
        [4, 10, 3, 5, 1] ‚Üí [10, 5, 3, 4, 1]

Step 2: EXTRACT MAX and place at end
        Swap root with last, reduce heap size, heapify
        
Iteration 1:
  [10, 5, 3, 4, 1] ‚Üí swap(0, 4) ‚Üí [1, 5, 3, 4, |10]
  heapify ‚Üí [5, 4, 3, 1, |10]
  
Iteration 2:
  [5, 4, 3, 1, |10] ‚Üí swap(0, 3) ‚Üí [1, 4, 3, |5, 10]
  heapify ‚Üí [4, 1, 3, |5, 10]
  
Iteration 3:
  [4, 1, 3, |5, 10] ‚Üí swap(0, 2) ‚Üí [3, 1, |4, 5, 10]
  heapify ‚Üí [3, 1, |4, 5, 10]
  
Iteration 4:
  [3, 1, |4, 5, 10] ‚Üí swap(0, 1) ‚Üí [1, |3, 4, 5, 10]
  
Final: [1, 3, 4, 5, 10] ‚úì
```

### Visualization

```
Build Max-Heap:            Extract Phase:

     10                        5
    /  \                      / \
   5    3         ‚Üí          4   3         ‚Üí ...
  / \                       /
 4   1                     1

Array: [10,5,3,4,1]       [5,4,3,1,|10]
        ‚Üë max                    ‚Üë sorted
```

---

## üíª Code Implementation

### Python Implementation

```python
def heap_sort(arr: list) -> None:
    """
    In-place heap sort (ascending order).
    Time: O(n log n), Space: O(1)
    """
    n = len(arr)
    
    # Step 1: Build max-heap (bottom-up)
    # Start from last non-leaf node
    for i in range(n // 2 - 1, -1, -1):
        _heapify_down(arr, n, i)
    
    # Step 2: Extract elements one by one
    for i in range(n - 1, 0, -1):
        # Swap max (root) with last element
        arr[0], arr[i] = arr[i], arr[0]
        # Heapify reduced heap
        _heapify_down(arr, i, 0)


def _heapify_down(arr: list, heap_size: int, root: int) -> None:
    """
    Maintain max-heap property starting from root.
    Only considers elements up to heap_size.
    """
    largest = root
    left = 2 * root + 1
    right = 2 * root + 2
    
    # Check left child
    if left < heap_size and arr[left] > arr[largest]:
        largest = left
    
    # Check right child
    if right < heap_size and arr[right] > arr[largest]:
        largest = right
    
    # If largest is not root, swap and continue
    if largest != root:
        arr[root], arr[largest] = arr[largest], arr[root]
        _heapify_down(arr, heap_size, largest)


# Example usage
arr = [4, 10, 3, 5, 1]
heap_sort(arr)
print(arr)  # [1, 3, 4, 5, 10]
```

### JavaScript Implementation

```javascript
function heapSort(arr) {
    const n = arr.length;
    
    // Build max-heap
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapifyDown(arr, n, i);
    }
    
    // Extract elements
    for (let i = n - 1; i > 0; i--) {
        // Swap root with last
        [arr[0], arr[i]] = [arr[i], arr[0]];
        // Heapify reduced heap
        heapifyDown(arr, i, 0);
    }
    
    return arr;
}

function heapifyDown(arr, heapSize, root) {
    let largest = root;
    const left = 2 * root + 1;
    const right = 2 * root + 2;
    
    if (left < heapSize && arr[left] > arr[largest]) {
        largest = left;
    }
    
    if (right < heapSize && arr[right] > arr[largest]) {
        largest = right;
    }
    
    if (largest !== root) {
        [arr[root], arr[largest]] = [arr[largest], arr[root]];
        heapifyDown(arr, heapSize, largest);
    }
}

// Example
const arr = [4, 10, 3, 5, 1];
heapSort(arr);
console.log(arr);  // [1, 3, 4, 5, 10]
```

### Iterative Heapify (Stack-Safe)

```python
def _heapify_down_iterative(arr: list, heap_size: int, root: int) -> None:
    """Iterative version - no recursion stack issues."""
    while True:
        largest = root
        left = 2 * root + 1
        right = 2 * root + 2
        
        if left < heap_size and arr[left] > arr[largest]:
            largest = left
        if right < heap_size and arr[right] > arr[largest]:
            largest = right
        
        if largest == root:
            break
            
        arr[root], arr[largest] = arr[largest], arr[root]
        root = largest
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Best |" O(n log n) "| O(1) | All cases same |
| Average |" O(n log n) "| O(1) | - |
| Worst |" O(n log n) "| O(1) | Guaranteed! |

**Build Heap:** O(n) - Not O(n log n)!
**Extract All:** O(n log n)
**Total:** O(n) + O(n log n) = O(n log n)

**Space:** O(1) for iterative, O(log n) for recursive (call stack)

---

## üîÑ Variations

| Variation | Difference | Use Case |
|-----------|------------|----------|
| Min-heap sort | Descending order | Reverse sort |
| Partial sort | Stop after k extractions | Top K elements |
| k-way merge | Multiple heaps | External sorting |

### Partial Sort (Top K)

```python
def partial_heap_sort(arr: list, k: int) -> list:
    """Get top k largest elements (sorted descending)."""
    n = len(arr)
    
    # Build max-heap
    for i in range(n // 2 - 1, -1, -1):
        _heapify_down(arr, n, i)
    
    result = []
    for _ in range(min(k, n)):
        # Extract max
        result.append(arr[0])
        arr[0] = arr[n - 1]
        n -= 1
        _heapify_down(arr, n, 0)
    
    return result
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Starting Index for Build Heap

```python
# ‚ùå Wrong: Starting from root
for i in range(0, n):  # Inefficient, still works but not O(n)
    heapify_up(arr, i)

# ‚úÖ Correct: Start from last non-leaf, go backwards
for i in range(n // 2 - 1, -1, -1):  # O(n) total
    heapify_down(arr, n, i)
```

### 2. Not Reducing Heap Size

```python
# ‚ùå Wrong: Using full array length
for i in range(n - 1, 0, -1):
    arr[0], arr[i] = arr[i], arr[0]
    heapify_down(arr, n, 0)  # Wrong! Uses full n

# ‚úÖ Correct: Reduce heap size each iteration
for i in range(n - 1, 0, -1):
    arr[0], arr[i] = arr[i], arr[0]
    heapify_down(arr, i, 0)  # Use i as heap size
```

### 3. Using Min-Heap for Ascending Sort

```python
# ‚ùå Wrong: Min-heap gives descending order
# Extract min ‚Üí place at end ‚Üí smallest at end!

# ‚úÖ Correct: Use max-heap for ascending
# Extract max ‚Üí place at end ‚Üí largest at end ‚Üí ascending ‚úì
```

### 4. Forgetting the Sort is In-Place

```python
# ‚ùå Wrong: Creating new array
def heap_sort(arr):
    # ... sorting ...
    return sorted_arr  # Don't need to return!

# ‚úÖ Correct: Modifies in place
def heap_sort(arr):
    # ... sorting ...
    # arr is now sorted, no return needed
```

---

## üìù Practice Problems

### Direct Heap Sort
- [ ] [Sort an Array (LC 912)](https://leetcode.com/problems/sort-an-array/) - Implement any O(n log n)

### Applications
- [ ] [Kth Largest Element (LC 215)](https://leetcode.com/problems/kth-largest-element-in-an-array/) - Partial heap sort
- [ ] [Top K Frequent Elements (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement from scratch, trace through example
- **Day 3:** Explain why build heap is O(n)
- **Day 7:** Compare with Quick Sort trade-offs
- **Day 14:** Implement without looking at notes

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Discuss Heap Sort</strong></summary>

**When asked about sorting:**
"For guaranteed O(n log n) with O(1) space, I'd use Heap Sort. It's not stable, but if that's not required, it's a solid choice."

**Comparison question:**
"Quick Sort is typically faster due to better cache locality, but Heap Sort has a guaranteed worst case. Merge Sort is stable but needs O(n) space."

**Implementation walkthrough:**
"First I build a max-heap in O(n) time by heapifying from the last non-leaf node upward. Then I repeatedly extract the max, place it at the end, and heapify the reduced heap."

**Why not stable:**
"Heap operations don't preserve relative order of equal elements. The swap-and-heapify process can move equal elements past each other."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| All | ‚≠ê‚≠ê‚≠ê | Understanding expected, rarely implement |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask implementation |
| System Design | ‚≠ê‚≠ê‚≠ê‚≠ê | External/distributed sorting |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand algorithm | 15-20 min |
| Implement from scratch | 20-25 min |
| Debug edge cases | 10 min |
| Explain complexity | 5-10 min |

---

## üí° Key Insight

> **Heap Sort leverages the heap property for in-place sorting.** By building a max-heap and repeatedly extracting the maximum to the end of the array, we get ascending order. The key insight is that after each extraction, the sorted portion grows from the right, while the heap portion shrinks from the right‚Äîboth sharing the same array space.

---

## üîó Related

- **Next:** [Heap Sort Analysis](./8.2-Heap-Sort-Analysis.md)
- **Foundation:** [Heapify](../02-Heap-Operations/2.4-Heapify.md) | [Replace](../02-Heap-Operations/2.5-Replace.md)
