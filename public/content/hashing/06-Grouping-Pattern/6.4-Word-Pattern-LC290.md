# Word Pattern (LeetCode 290)

> **Easy** | Given a pattern and a string s, find if s follows the same pattern. "Follow" means a full match: there's a bijection between a letter in pattern and a word in s.

This problem extends Isomorphic Strings to work with words instead of characters - the same bidirectional mapping concept applies.

---

## ðŸŽ¯ Pattern Recognition

<details>
<summary><strong>Problem Signals</strong></summary>

**Keywords indicating this pattern:**
- "Follows the same pattern"
- "Mapping between X and Y"
- "One-to-one correspondence"
- "Bijection/bijective"

**Problem classification:**
```
Category: Grouping Pattern - Mapping Variant
Subcategory: Bidirectional word-to-char mapping
Connection: Same as Isomorphic Strings, but char â†” word
```

</details>

---

## ðŸ“‹ Problem Statement

**LeetCode 290:** [Word Pattern](https://leetcode.com/problems/word-pattern/)

```
Given a pattern and a string s, find if s follows the same pattern.

Here "follow" means a full match, such that there is a bijection 
between a letter in pattern and a non-empty word in s.

Example 1:
Input: pattern = "abba", s = "dog cat cat dog"
Output: true
Explanation: aâ†’dog, bâ†’cat works in both directions

Example 2:
Input: pattern = "abba", s = "dog cat cat fish"
Output: false
Explanation: aâ†’dog at position 0, but aâ†’fish at position 3

Example 3:
Input: pattern = "aaaa", s = "dog cat cat dog"
Output: false
Explanation: aâ†’dog, but also aâ†’cat at position 1

Constraints:
- 1 <= pattern.length <= 300
- pattern contains only lowercase English letters
- 1 <= s.length <= 3000
- s contains only lowercase English letters and spaces
- s does not contain any leading or trailing spaces
- All words in s are separated by a single space
```

---

## âœ… When to Use This Approach

- Pattern matching between different types (chars vs words)
- Validating one-to-one mappings
- Template matching problems

## âŒ When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Pattern within string | Different problem | KMP/Z-algorithm |
| Regex matching | More complex rules | Regex engine |
| Partial matching | Need full bijection | Different logic |

---

## ðŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Related</strong></summary>

**Before this:**
- [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
- [Isomorphic Strings (LC 205)](./6.3-Isomorphic-Strings-LC205.md)

**Related problems:**
- [Word Pattern II (LC 291)](https://leetcode.com/problems/word-pattern-ii/) - Backtracking variant
- [Group Anagrams (LC 49)](./6.2-Group-Anagrams-LC49.md)

</details>

---

## ðŸ“ Solution Approach

### Key Insight

Same as Isomorphic Strings, but now we map:
- Pattern character â†’ Word
- Word â†’ Pattern character

We need **bidirectional consistency**.

### Visualization

```
pattern = "abba"
s = "dog cat cat dog"
words = ["dog", "cat", "cat", "dog"]

Step-by-step:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Index â”‚ Char â”‚ Word â”‚ char_to_word      â”‚ word_to_char      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0     â”‚ 'a'  â”‚ dog  â”‚ {'a': 'dog'}      â”‚ {'dog': 'a'}      â”‚
â”‚ 1     â”‚ 'b'  â”‚ cat  â”‚ {'a':'dog','b':'cat'} â”‚ {'dog':'a','cat':'b'} â”‚
â”‚ 2     â”‚ 'b'  â”‚ cat  â”‚ Check: bâ†’cat âœ“    â”‚ Check: catâ†’b âœ“    â”‚
â”‚ 3     â”‚ 'a'  â”‚ dog  â”‚ Check: aâ†’dog âœ“    â”‚ Check: dogâ†’a âœ“    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

All consistent â†’ Return True
```

```
pattern = "abba"
s = "dog cat cat fish"
words = ["dog", "cat", "cat", "fish"]

Step-by-step:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Index â”‚ Char â”‚ Word â”‚ char_to_word      â”‚ word_to_char      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0     â”‚ 'a'  â”‚ dog  â”‚ {'a': 'dog'}      â”‚ {'dog': 'a'}      â”‚
â”‚ 1     â”‚ 'b'  â”‚ cat  â”‚ {'a':'dog','b':'cat'} â”‚ {'dog':'a','cat':'b'} â”‚
â”‚ 2     â”‚ 'b'  â”‚ cat  â”‚ Check: bâ†’cat âœ“    â”‚ Check: catâ†’b âœ“    â”‚
â”‚ 3     â”‚ 'a'  â”‚ fish â”‚ Check: aâ†’dog â‰  fish âœ— â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Inconsistency at index 3 â†’ Return False
```

---

## ðŸ’» Code Implementation

### Python - Two Hash Maps

```python
def wordPattern(pattern: str, s: str) -> bool:
    """
    Check if string s follows the given pattern.
    
    Algorithm:
    1. Split s into words
    2. Check lengths match
    3. Use two maps: charâ†’word and wordâ†’char
    4. Verify bidirectional consistency
    
    Time: O(n + m) where n = len(pattern), m = len(s)
    Space: O(n) for the mappings
    """
    words = s.split()
    
    # Quick check: must have same number of elements
    if len(pattern) != len(words):
        return False
    
    char_to_word = {}
    word_to_char = {}
    
    for char, word in zip(pattern, words):
        # Check char â†’ word mapping
        if char in char_to_word:
            if char_to_word[char] != word:
                return False
        else:
            char_to_word[char] = word
        
        # Check word â†’ char mapping
        if word in word_to_char:
            if word_to_char[word] != char:
                return False
        else:
            word_to_char[word] = char
    
    return True


# Example trace:
# pattern = "abba", s = "dog cat cat dog"
# words = ["dog", "cat", "cat", "dog"]
# len check: 4 == 4 âœ“
#
# i=0: char='a', word='dog'
#      char_to_word = {'a': 'dog'}
#      word_to_char = {'dog': 'a'}
#
# i=1: char='b', word='cat'
#      char_to_word = {'a': 'dog', 'b': 'cat'}
#      word_to_char = {'dog': 'a', 'cat': 'b'}
#
# i=2: char='b', word='cat'
#      Check: char_to_word['b'] = 'cat' âœ“
#      Check: word_to_char['cat'] = 'b' âœ“
#
# i=3: char='a', word='dog'
#      Check: char_to_word['a'] = 'dog' âœ“
#      Check: word_to_char['dog'] = 'a' âœ“
#
# Return True
```

### Python - Using Set Comparison (Concise)

```python
def wordPattern(pattern: str, s: str) -> bool:
    """
    Concise solution using set comparison.
    
    Key insight:
    - Number of unique pairs = number of unique chars = number of unique words
    """
    words = s.split()
    
    if len(pattern) != len(words):
        return False
    
    # Create pairs and check uniqueness counts match
    pairs = list(zip(pattern, words))
    
    return len(set(pairs)) == len(set(pattern)) == len(set(words))


# Explanation:
# pattern = "abba", words = ["dog", "cat", "cat", "dog"]
# pairs = [('a','dog'), ('b','cat'), ('b','cat'), ('a','dog')]
# set(pairs) = {('a','dog'), ('b','cat')} â†’ 2
# set(pattern) = {'a', 'b'} â†’ 2
# set(words) = {'dog', 'cat'} â†’ 2
# 2 == 2 == 2 â†’ True
```

### Python - Using Index Comparison

```python
def wordPattern(pattern: str, s: str) -> bool:
    """
    Compare first occurrence indices.
    
    If strings follow same pattern, first occurrence index
    of each element at each position should match.
    """
    words = s.split()
    
    if len(pattern) != len(words):
        return False
    
    # Map to first occurrence index
    def to_pattern(seq):
        first_occur = {}
        result = []
        for i, item in enumerate(seq):
            if item not in first_occur:
                first_occur[item] = i
            result.append(first_occur[item])
        return result
    
    return to_pattern(pattern) == to_pattern(words)


# Example:
# pattern = "abba" â†’ [0, 1, 1, 0]
# words = ["dog", "cat", "cat", "dog"] â†’ [0, 1, 1, 0]
# [0, 1, 1, 0] == [0, 1, 1, 0] â†’ True
```

### JavaScript - Two Hash Maps

```javascript
/**
 * Check if string s follows the pattern.
 * 
 * @param {string} pattern - Pattern string
 * @param {string} s - Space-separated words
 * @return {boolean} - True if s follows pattern
 * 
 * Time: O(n + m)
 * Space: O(n)
 */
function wordPattern(pattern, s) {
    const words = s.split(' ');
    
    // Length check
    if (pattern.length !== words.length) {
        return false;
    }
    
    const charToWord = new Map();
    const wordToChar = new Map();
    
    for (let i = 0; i < pattern.length; i++) {
        const char = pattern[i];
        const word = words[i];
        
        // Check char â†’ word
        if (charToWord.has(char)) {
            if (charToWord.get(char) !== word) return false;
        } else {
            charToWord.set(char, word);
        }
        
        // Check word â†’ char
        if (wordToChar.has(word)) {
            if (wordToChar.get(word) !== char) return false;
        } else {
            wordToChar.set(word, char);
        }
    }
    
    return true;
}
```

### JavaScript - Set Comparison

```javascript
/**
 * Concise solution using Set comparison.
 */
function wordPattern(pattern, s) {
    const words = s.split(' ');
    
    if (pattern.length !== words.length) return false;
    
    // Create pairs
    const pairs = new Set();
    const chars = new Set();
    const uniqueWords = new Set();
    
    for (let i = 0; i < pattern.length; i++) {
        pairs.add(pattern[i] + ',' + words[i]);
        chars.add(pattern[i]);
        uniqueWords.add(words[i]);
    }
    
    return pairs.size === chars.size && chars.size === uniqueWords.size;
}
```

---

## âš¡ Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Two Maps | O(n + m) | O(n) | n = pattern length, m = string length |
| Set Comparison | O(n + m) | O(n) | Same complexity, more concise |
| Index Pattern | O(n + m) | O(n) | Creates intermediate lists |

**Where:**
- n = length of pattern
- m = length of string s
- Split operation is O(m)
- Map operations are O(1)

---

## ðŸ”„ Comparison with Isomorphic Strings

| Aspect | Isomorphic Strings | Word Pattern |
|--------|-------------------|--------------|
| Mapping | char â†” char | char â†” word |
| Split needed | No | Yes (by space) |
| Length check | Same string length | Same number of elements |
| Hash key | Single char | Word (string) |

---

## âš ï¸ Common Mistakes

### 1. Forgetting to Split the String

```python
# âŒ WRONG: Treating s as characters
def wordPattern(pattern, s):
    for i in range(len(pattern)):
        char = pattern[i]
        word = s[i]  # This gets single character, not word!
        # ...

# âœ… CORRECT: Split into words first
def wordPattern(pattern, s):
    words = s.split()
    for i in range(len(pattern)):
        char = pattern[i]
        word = words[i]
        # ...
```

### 2. Wrong Length Comparison

```python
# âŒ WRONG: Comparing string lengths
def wordPattern(pattern, s):
    if len(pattern) != len(s):  # Wrong! s is the whole string
        return False
    # ...

# âœ… CORRECT: Compare pattern length with number of words
def wordPattern(pattern, s):
    words = s.split()
    if len(pattern) != len(words):
        return False
    # ...
```

### 3. Only Checking One Direction

```python
# âŒ WRONG: Missing wordâ†’char check
def wordPattern(pattern, s):
    words = s.split()
    char_to_word = {}
    for char, word in zip(pattern, words):
        if char in char_to_word:
            if char_to_word[char] != word:
                return False
        else:
            char_to_word[char] = word
    return True

# "abba" and "dog dog dog dog" would incorrectly return True!
# aâ†’dog, bâ†’dog (both map to 'dog', no conflict in char_to_word)
# But dogâ†’a AND dogâ†’b is a conflict!

# âœ… CORRECT: Check both directions
def wordPattern(pattern, s):
    words = s.split()
    char_to_word = {}
    word_to_char = {}
    for char, word in zip(pattern, words):
        # Check both mappings...
```

### 4. Edge Case: Multiple Spaces

```python
# Modern Python's split() handles this correctly
s = "dog   cat   cat   dog"  # Multiple spaces
words = s.split()  # ['dog', 'cat', 'cat', 'dog'] âœ“

# But be careful with split(' ') vs split()
s = "dog  cat"
s.split(' ')   # ['dog', '', 'cat'] - includes empty strings!
s.split()      # ['dog', 'cat'] - correct!

# âœ… Always use split() without arguments for this problem
```

---

## ðŸ“ Practice Problems (Progressive)

| Problem | Difficulty | Key Insight |
|---------|------------|-------------|
| Isomorphic Strings | ðŸŸ¢ Easy | Same pattern, charâ†”char |
| Word Pattern | ðŸŸ¢ Easy | This problem |
| Word Pattern II | ðŸ”´ Hard | Backtracking, no spaces |

**Related LeetCode:**
- [205. Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/)
- [291. Word Pattern II](https://leetcode.com/problems/word-pattern-ii/)

<details>
<summary><strong>ðŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve after understanding Isomorphic Strings
- **Day 3:** Implement from scratch
- **Day 7:** Try set-based approach
- **Day 14:** Solve both LC 205 and LC 290 in sequence
- **Day 30:** < 5 min implementation

</details>

---

## ðŸŽ¤ Interview Context

<details>
<summary><strong>Communication Template</strong></summary>

**1. Clarify:**
> "So I need to check if there's a one-to-one mapping between pattern characters and words. Each character maps to exactly one word, and each word is mapped by exactly one character?"

**2. Edge cases to mention:**
> "What if pattern is empty? What if there are extra spaces? Are pattern and word count guaranteed to match?"

**3. Approach:**
> "I'll split the string into words, then use two hash maps to track bidirectional mapping - similar to Isomorphic Strings."

**4. Follow-up (Word Pattern II):**
> "If there are no spaces and I need to find valid splits, I'd use backtracking to try all possible word boundaries."

</details>

**Company Frequency:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Dropbox | â­â­â­â­ | Classic |
| Google | â­â­â­ | May ask follow-up |
| Uber | â­â­â­ | String focus |
| Microsoft | â­â­â­ | Standard |

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Understand problem | 2 min |
| Plan approach | 1 min |
| Implement | 5-7 min |
| Test edge cases | 2 min |
| **Total** | **10-12 min** |

---

> **ðŸ’¡ Key Insight:** This is Isomorphic Strings with words instead of characters. The key is remembering to (1) split the string into words first, and (2) check both directions of the mapping for bijective correspondence.

> **ðŸ”— Related:** [Isomorphic Strings](./6.3-Isomorphic-Strings-LC205.md) | [Grouping Pattern](./6.1-Grouping-Overview.md) | [Group Anagrams](./6.2-Group-Anagrams-LC49.md)
