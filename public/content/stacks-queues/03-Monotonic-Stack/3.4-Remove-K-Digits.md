# 3.4 Remove K Digits (LC 402)

> **Grokking Pattern:** Monotonic Stack + Greedy
>
> **Difficulty:** Medium | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê Common Greedy Stack Problem

---

## Problem Statement

Given string `num` representing a non-negative integer, and an integer `k`, return the smallest possible integer after removing `k` digits from `num`.

```
Input: num = "1432219", k = 3
Output: "1219"

Explanation:
Remove 4, 3, and 2 to get "1219", which is the smallest.

Input: num = "10200", k = 1
Output: "200"

Explanation:
Remove the leading 1, remaining = "0200" ‚Üí "200"

Input: num = "10", k = 2
Output: "0"

Explanation:
Remove all digits, return "0"
```

[LeetCode 402 - Remove K Digits](https://leetcode.com/problems/remove-k-digits/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Remove k elements to minimize/maximize"
- Result should be in the same relative order
- Greedy choice: remove larger digits that appear before smaller ones

**Key insight:**
To minimize a number, we want smaller digits in higher positions.
When we see a digit smaller than the previous one, we should remove the previous (larger) one.

This is exactly what a **monotonically increasing stack** does!

**Greedy principle:**
- Process left to right
- If current digit < stack top, pop (remove the larger digit)
- Stop when we've removed k digits

</details>

---

## ‚úÖ When to Use This Approach

- Minimizing/maximizing by removing elements
- Maintaining relative order
- When greedy + stack gives optimal solution

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Can reorder digits | Different problem | Sorting |
| Specific positions to remove | Given constraints | Direct removal |
| Need to add digits | Different problem | Different approach |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Monotonic Stack Concept](./3.1-Monotonic-Stack-Concept.md)
- Greedy algorithms basics

**After mastering this:**
- [Remove Duplicate Letters](https://leetcode.com/problems/remove-duplicate-letters/) - LC 316
- [Create Maximum Number](https://leetcode.com/problems/create-maximum-number/) - LC 321
- [Smallest Subsequence of Distinct Characters](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/) - LC 1081

**This combines:**
- Monotonic Stack (for optimal ordering)
- Greedy (remove larger digits when possible)

</details>

---

## üìê How It Works

### Core Insight

For a number to be smallest:
1. Left digits have more impact than right digits (1000 > 999)
2. We want smaller digits on the left
3. If we see a digit smaller than previous, remove the previous

### Visual Walkthrough

```
num = "1432219", k = 3

Process with increasing stack:

i=0: digit='1'
     Stack: []
     Push '1'
     Stack: ['1']
     k=3

i=1: digit='4'
     '4' > '1' (stack top), no pop
     Push '4'
     Stack: ['1', '4']
     k=3

i=2: digit='3'
     '3' < '4' (stack top), pop '4', k=2
     '3' > '1' (stack top), no pop
     Push '3'
     Stack: ['1', '3']
     k=2

i=3: digit='2'
     '2' < '3' (stack top), pop '3', k=1
     '2' > '1' (stack top), no pop
     Push '2'
     Stack: ['1', '2']
     k=1

i=4: digit='2'
     '2' = '2' (stack top), no pop (not strictly less)
     Push '2'
     Stack: ['1', '2', '2']
     k=1

i=5: digit='1'
     '1' < '2' (stack top), pop '2', k=0
     k=0, stop popping
     Push '1'
     Stack: ['1', '2', '1']
     k=0

i=6: digit='9'
     k=0, just push
     Push '9'
     Stack: ['1', '2', '1', '9']

Result: "1219"
```

### Edge Cases

```
Case 1: num = "10200", k = 1
Stack: ['1']
'0' < '1' ‚Üí pop '1', k=0
Stack: ['0', '2', '0', '0']
Result: "0200" ‚Üí Strip leading zeros ‚Üí "200"

Case 2: num = "9999", k = 2
No digit is smaller than previous ‚Üí never pop during iteration
After loop: k=2 still remaining
Remove last 2 digits: "99"

Case 3: num = "10", k = 2
Stack becomes empty
Return "0"
```

---

## üíª Code Implementation

### Solution: Monotonic Increasing Stack

**Python:**
```python
def remove_k_digits(num: str, k: int) -> str:
    """
    Remove k digits to make smallest possible number.
    
    Pattern: Monotonic Increasing Stack + Greedy
    Time: O(n), Space: O(n)
    
    Strategy:
    1. Use increasing stack (pop when current < top)
    2. Pop at most k times
    3. Handle remaining k by trimming from end
    4. Handle leading zeros
    """
    stack = []
    
    for digit in num:
        # Remove larger digits when we find smaller one
        while k > 0 and stack and digit < stack[-1]:
            stack.pop()
            k -= 1
        stack.append(digit)
    
    # If k still remaining, remove from end
    # (digits are in increasing order now)
    while k > 0:
        stack.pop()
        k -= 1
    
    # Build result and strip leading zeros
    result = ''.join(stack).lstrip('0')
    
    # Handle empty result
    return result if result else '0'


def remove_k_digits_verbose(num: str, k: int) -> str:
    """
    More explicit version with detailed comments.
    """
    if k >= len(num):
        return '0'
    
    stack = []
    removals_left = k
    
    for digit in num:
        # Greedy: while we can still remove and current digit
        # is smaller than top, pop the larger digit
        while (removals_left > 0 and 
               stack and 
               stack[-1] > digit):
            stack.pop()
            removals_left -= 1
        
        stack.append(digit)
    
    # If we haven't removed k digits yet (monotonic portion)
    # Remove from the end (they're the largest due to ordering)
    stack = stack[:len(stack) - removals_left]
    
    # Convert to string and handle leading zeros
    result = ''.join(stack).lstrip('0')
    
    return result or '0'
```

**JavaScript:**
```javascript
/**
 * Remove k digits to make smallest number.
 * Pattern: Monotonic Increasing Stack + Greedy
 * Time: O(n), Space: O(n)
 */
function removeKdigits(num, k) {
    const stack = [];
    
    for (const digit of num) {
        // Pop larger digits when current is smaller
        while (k > 0 && stack.length > 0 && digit < stack[stack.length - 1]) {
            stack.pop();
            k--;
        }
        stack.push(digit);
    }
    
    // Remove remaining k from end
    while (k > 0) {
        stack.pop();
        k--;
    }
    
    // Build result, strip leading zeros
    let result = stack.join('').replace(/^0+/, '');
    
    return result || '0';
}

// Alternative with explicit array slicing
function removeKdigitsAlt(num, k) {
    if (k >= num.length) return '0';
    
    const stack = [];
    let remaining = k;
    
    for (const digit of num) {
        while (remaining > 0 && stack.length && stack[stack.length - 1] > digit) {
            stack.pop();
            remaining--;
        }
        stack.push(digit);
    }
    
    // Trim from end if needed
    const finalLength = stack.length - remaining;
    const result = stack.slice(0, finalLength).join('');
    
    // Remove leading zeros
    let i = 0;
    while (i < result.length - 1 && result[i] === '0') {
        i++;
    }
    
    return result.slice(i) || '0';
}
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Monotonic Stack |" O(n) "| O(n) | Each digit pushed/popped once |

**Why O(n)?**
- Each digit is pushed onto stack exactly once
- Each digit is popped at most once
- String building is O(n)
- Leading zero removal is O(n)

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Maximize instead of minimize | Use decreasing stack | Create Maximum Number |
| Must include each character once | Track character counts | Remove Duplicate Letters |
| Two arrays, take from each | Complex greedy | Create Maximum Number |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Handling Remaining k

```python
# ‚ùå WRONG: Only removes during iteration
for digit in num:
    while k > 0 and stack and digit < stack[-1]:
        stack.pop()
        k -= 1
    stack.append(digit)
# What if k > 0 still? (e.g., "1234", k=2)

# ‚úÖ CORRECT: Handle remaining k
while k > 0:
    stack.pop()
    k -= 1
```

### 2. Not Handling Leading Zeros

```python
# ‚ùå WRONG: Return stack directly
return ''.join(stack)  # Could return "0200"

# ‚úÖ CORRECT: Strip leading zeros
return ''.join(stack).lstrip('0') or '0'
```

### 3. Not Handling All Digits Removed

```python
# ‚ùå WRONG: No check for empty result
return ''.join(stack).lstrip('0')  # Returns "" if all zeros removed

# ‚úÖ CORRECT: Return "0" if empty
return ''.join(stack).lstrip('0') or '0'
```

### 4. Using Wrong Comparison

```python
# ‚ùå WRONG: Using <= removes equal digits unnecessarily
while k > 0 and stack and digit <= stack[-1]:

# ‚úÖ CORRECT: Only remove strictly larger
while k > 0 and stack and digit < stack[-1]:
```

---

## üìù Practice Problems (Progressive)

### This Problem
- [ ] [Remove K Digits](https://leetcode.com/problems/remove-k-digits/) - LC 402 ‚≠ê

### Related Problems
- [ ] [Remove Duplicate Letters](https://leetcode.com/problems/remove-duplicate-letters/) - LC 316
- [ ] [Smallest Subsequence of Distinct Characters](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/) - LC 1081
- [ ] [Create Maximum Number](https://leetcode.com/problems/create-maximum-number/) - LC 321 (Hard)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement and trace through examples
**Day 3:** Handle all edge cases from memory
**Day 7:** Solve without notes
**Day 14:** Solve Remove Duplicate Letters
**Day 21:** Compare with Create Maximum Number

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
> "To minimize the result, I want smaller digits in higher positions. I'll use a greedy approach with a monotonic increasing stack."

**Explain the greedy choice:**
> "When I see a digit smaller than the previous one, I should remove the previous larger digit. The stack naturally maintains this - I pop when current is smaller than top."

**Handle edge cases:**
> "After processing all digits, if I haven't removed k digits yet (like in '1234'), I remove from the end. I also need to strip leading zeros and handle empty result."

**Complexity:**
> "Time is O(n) since each digit is pushed and popped at most once. Space is O(n) for the stack."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common greedy problem |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Tests greedy thinking |
| Microsoft | ‚≠ê‚≠ê‚≠ê | May ask variations |
| Bloomberg | ‚≠ê‚≠ê‚≠ê | String manipulation |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Read examples |
| Identify greedy insight | 3-5 min | "Remove larger digits before smaller" |
| Implement | 10-12 min | Handle edge cases |
| Test | 3-5 min | Check leading zeros, remaining k |
| Interview target | 20-25 min | Including explanation |

---

> **üí° Key Insight:** The greedy principle here is that to minimize a number, we want the smallest possible digits in the highest (leftmost) positions. When we encounter a digit smaller than the previous one, we should "go back" and remove the larger digits. The monotonic increasing stack perfectly captures this - we pop larger elements when a smaller one arrives.

---

## üîó Related

- [Monotonic Stack Concept](./3.1-Monotonic-Stack-Concept.md) - Pattern overview
- [Remove Duplicate Letters](https://leetcode.com/problems/remove-duplicate-letters/) - Similar technique (LC 316)
- [Daily Temperatures](./3.2-Next-Greater-Problems/03-Daily-Temperatures.md) - Monotonic stack basics
