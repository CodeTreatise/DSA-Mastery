# 4.2 Kth Largest Element in Array (LC 215)

## Problem Statement

[LeetCode 215 - Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)

Given an integer array `nums` and an integer `k`, return the **kth largest** element in the array.

Note that it is the kth largest element in sorted order, not the kth distinct element.

```
Example 1:
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5

Example 2:
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4

Constraints:
- 1 <= k <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a classic Top K / Kth Element problem:**
- Find a specific rank element (kth largest)
- Don't need full sort, just one element
- Multiple approaches possible

**Keywords:**
- "kth largest", "kth smallest"
- Single element, not K elements
- Array of numbers

**Approach options:**
| Approach | Time | Space | Best When |
|----------|------|-------|-----------|
| Min-heap size K |" O(n log k) "| O(k) | k << n |
| Full sort |" O(n log n) "| O(1) | Simple, any k |
| QuickSelect |" O(n) avg "| O(1) | Need fastest avg |

</details>

---

## ‚úÖ When to Use

- Need single Kth element
- k is significantly smaller than n
- Can't modify original array (heap approach)
- Streaming data scenarios

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Need all K elements | Returns only one | Use K elements variant |
| k ‚âà n | Heap loses advantage | Just sort |
|" Guaranteed O(n) needed "| Heap is O(n log k) | QuickSelect with random pivot |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Top K Pattern Overview](./4.1-Top-K-Overview.md)
- [Heap Operations](../02-Heap-Operations/2.1-Insert.md)

**After mastering this:**
- [Kth Largest in Stream (LC 703)](./4.3-Kth-Largest-Stream-LC703.md)
- [Top K Frequent (LC 347)](./4.4-Top-K-Frequent-LC347.md)

**Combines with:**
- QuickSelect for O(n) average
- Sorting for simplicity

</details>

---

## üìê How It Works

### Approach 1: Min-Heap of Size K

```
nums = [3,2,1,5,6,4], k = 2

Goal: Find 2nd largest (which is 5)

Min-heap maintains K largest elements:
Step 1: Push 3 ‚Üí [3]
Step 2: Push 2 ‚Üí [2, 3]    (size = k = 2)
Step 3: Push 1 ‚Üí 1 < root(2), skip (would be popped anyway)
        Actually: Push then pop ‚Üí [2, 3]
Step 4: Push 5 ‚Üí [2, 3, 5] ‚Üí pop ‚Üí [3, 5]
Step 5: Push 6 ‚Üí [3, 5, 6] ‚Üí pop ‚Üí [5, 6]
Step 6: Push 4 ‚Üí 4 < root(5), skip
        Actually: Push then pop ‚Üí [5, 6]

Final heap: [5, 6]
Root = 5 = 2nd largest ‚úì
```

### Approach 2: QuickSelect (Optimal)

```
QuickSelect is like QuickSort but only recurses on one side.

nums = [3,2,1,5,6,4], k = 2 (want index n-k = 4 after partition)

Pivot = 4 (random choice)
Partition: [3,2,1] 4 [5,6]
           indices 0-2, 3, 4-5

We want index 4. Pivot at index 3.
4 < 4? No. 4 > 4? No. Wait, want index 4, pivot at 3.
Recurse right: [5,6]
Pivot = 5
Partition: [] 5 [6]
Index 4 is where 5 lands. Done!

Answer: 5
```

---

## üíª Code Implementation

### Approach 1: Min-Heap (Recommended for Interviews)

**Python:**
```python
import heapq

def findKthLargest(nums: list[int], k: int) -> int:
    """
    Find Kth largest using min-heap of size K.
    
    Time: O(n log k) - n elements, O(log k) per heap op
    Space: O(k) - heap size
    
    Key insight: Min-heap of size K keeps K largest.
                 Root = smallest of K largest = Kth largest.
    """
    min_heap = []
    
    for num in nums:
        heapq.heappush(min_heap, num)
        if len(min_heap) > k:
            heapq.heappop(min_heap)  # Remove smallest
    
    return min_heap[0]  # Root = Kth largest
```

**JavaScript:**
```javascript
var findKthLargest = function(nums, k) {
    // Min-heap approach
    // JavaScript has no built-in heap, so use sorted insertion
    // or implement MinHeap class
    
    class MinHeap {
        constructor() { this.heap = []; }
        
        size() { return this.heap.length; }
        peek() { return this.heap[0]; }
        
        push(val) {
            this.heap.push(val);
            this._bubbleUp(this.heap.length - 1);
        }
        
        pop() {
            if (this.size() === 0) return undefined;
            const min = this.heap[0];
            const last = this.heap.pop();
            if (this.size() > 0) {
                this.heap[0] = last;
                this._bubbleDown(0);
            }
            return min;
        }
        
        _bubbleUp(i) {
            while (i > 0) {
                const parent = Math.floor((i - 1) / 2);
                if (this.heap[parent] <= this.heap[i]) break;
                [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
                i = parent;
            }
        }
        
        _bubbleDown(i) {
            const n = this.size();
            while (true) {
                let smallest = i;
                const left = 2 * i + 1, right = 2 * i + 2;
                if (left < n && this.heap[left] < this.heap[smallest]) smallest = left;
                if (right < n && this.heap[right] < this.heap[smallest]) smallest = right;
                if (smallest === i) break;
                [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
                i = smallest;
            }
        }
    }
    
    const minHeap = new MinHeap();
    
    for (const num of nums) {
        minHeap.push(num);
        if (minHeap.size() > k) {
            minHeap.pop();
        }
    }
    
    return minHeap.peek();
};
```

### Approach 2: QuickSelect (Optimal Average)

**Python:**
```python
import random

def findKthLargest(nums: list[int], k: int) -> int:
    """
    QuickSelect approach - O(n) average time.
    
    Find (n-k)th smallest = Kth largest.
    
    Time: O(n) average, O(n¬≤) worst
    Space: O(1) - in-place partitioning
    """
    # Kth largest = (n-k)th index in sorted array
    target_idx = len(nums) - k
    
    def quickselect(left: int, right: int) -> int:
        # Random pivot to avoid worst case
        pivot_idx = random.randint(left, right)
        pivot = nums[pivot_idx]
        
        # Move pivot to end
        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
        
        # Partition: elements < pivot go to left
        store_idx = left
        for i in range(left, right):
            if nums[i] < pivot:
                nums[store_idx], nums[i] = nums[i], nums[store_idx]
                store_idx += 1
        
        # Move pivot to final position
        nums[store_idx], nums[right] = nums[right], nums[store_idx]
        
        # Check which side to recurse
        if store_idx == target_idx:
            return nums[store_idx]
        elif store_idx < target_idx:
            return quickselect(store_idx + 1, right)
        else:
            return quickselect(left, store_idx - 1)
    
    return quickselect(0, len(nums) - 1)
```

**JavaScript:**
```javascript
var findKthLargest = function(nums, k) {
    // QuickSelect - O(n) average
    const targetIdx = nums.length - k;
    
    function quickselect(left, right) {
        // Random pivot
        const pivotIdx = left + Math.floor(Math.random() * (right - left + 1));
        const pivot = nums[pivotIdx];
        
        // Move pivot to end
        [nums[pivotIdx], nums[right]] = [nums[right], nums[pivotIdx]];
        
        // Partition
        let storeIdx = left;
        for (let i = left; i < right; i++) {
            if (nums[i] < pivot) {
                [nums[storeIdx], nums[i]] = [nums[i], nums[storeIdx]];
                storeIdx++;
            }
        }
        
        // Move pivot to final position
        [nums[storeIdx], nums[right]] = [nums[right], nums[storeIdx]];
        
        if (storeIdx === targetIdx) return nums[storeIdx];
        if (storeIdx < targetIdx) return quickselect(storeIdx + 1, right);
        return quickselect(left, storeIdx - 1);
    }
    
    return quickselect(0, nums.length - 1);
};
```

### Approach 3: Sorting (Simplest)

**Python:**
```python
def findKthLargest(nums: list[int], k: int) -> int:
    """
    Simple sort approach.
    
    Time: O(n log n)
    Space: O(1) to O(n) depending on sort
    """
    nums.sort(reverse=True)
    return nums[k - 1]
```

---

## ‚ö° Complexity Analysis

| Approach | Time (Avg) | Time (Worst) | Space | Notes |
|----------|------------|--------------|-------|-------|
| Min-heap |" O(n log k) "| O(n log k) |" O(k) "| Consistent |
| QuickSelect |" O(n) "| O(n¬≤) |" O(1) "| Random pivot helps |
| Sort |" O(n log n) "| O(n log n) |" O(1) "| Simple |
| Max-heap |" O(n + k log n) "| O(n + k log n) |" O(n) "| Less efficient |

**Which to choose:**
```
k << n (k is small):   Min-heap O(n log k) ‚âà O(n)
k ‚âà n (k is large):    Sort O(n log n) - simpler
Need O(n) guarantee:   QuickSelect with random pivot
Interview default:     Min-heap (clean, predictable)
```

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **Kth smallest** | Use max-heap of size K | Mirror logic |
| **Streaming** | Maintain heap, add new elements | LC 703 |
| **K largest** | Return all heap elements | Slight change |
| **With duplicates** | Handle in comparison | Same approach |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Heap Type

```python
# ‚ùå Wrong: Using max-heap then popping K times
def wrong_approach(nums, k):
    max_heap = [-x for x in nums]
    heapq.heapify(max_heap)
    for _ in range(k - 1):
        heapq.heappop(max_heap)
    return -max_heap[0]
    # Works but O(n + k log n), not O(n log k)!

# ‚úÖ Correct: Min-heap of size K
def correct_approach(nums, k):
    min_heap = []
    for num in nums:
        heapq.heappush(min_heap, num)
        if len(min_heap) > k:
            heapq.heappop(min_heap)
    return min_heap[0]  # O(n log k)
```

### 2. Off-by-One Error

```python
# ‚ùå Wrong: Confusing index vs rank
return sorted(nums)[k]  # This is (k+1)th smallest!

# ‚úÖ Correct: k-1 for 0-indexed
return sorted(nums, reverse=True)[k - 1]  # Kth largest
```

### 3. QuickSelect Without Random Pivot

```python
# ‚ùå Risky: Fixed pivot can cause O(n¬≤)
pivot = nums[right]  # Bad for sorted input!

# ‚úÖ Safe: Random pivot
pivot_idx = random.randint(left, right)
```

---

## üìù Practice Problems (Progressive)

### Easy (Build up)
- [ ] [Kth Largest in Stream (LC 703)](https://leetcode.com/problems/kth-largest-element-in-a-stream/) - Streaming version

### Medium (Core problem)
- [ ] [Kth Largest Element (LC 215)](https://leetcode.com/problems/kth-largest-element-in-an-array/) - **This problem**
- [ ] [Top K Frequent (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/) - Next step
- [ ] [K Closest Points (LC 973)](https://leetcode.com/problems/k-closest-points-to-origin/) - Distance variant

### Hard (Extensions)
- [ ] [Median of Two Sorted Arrays (LC 4)](https://leetcode.com/problems/median-of-two-sorted-arrays/) - Related concept

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement heap approach
- **Day 3:** Implement QuickSelect
- **Day 7:** Solve without looking at code
- **Day 14:** Explain trade-offs between approaches
- **Day 30:** Teach someone the heap type choice

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening:**
"I see we need the Kth largest element. I'll use a min-heap of size K. The insight is that a min-heap of size K naturally maintains the K largest elements, and the root is the smallest of those K, which is exactly the Kth largest."

**If asked about alternatives:**
"I could also use QuickSelect for O(n) average time, though it has O(n¬≤) worst case. The heap approach is O(n log k) but more predictable. For this problem, if k is small, heap is excellent."

**Trade-off discussion:**
| Approach | Pros | Cons |
|----------|------|------|
| Min-heap |" Predictable O(n log k), doesn't modify array "| O(k) space |
| QuickSelect |" O(n) average, O(1) space "| Modifies array, O(n¬≤) worst |
| Sort | Simple, stable |" O(n log n) even for k=1 "|

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common, often first heap problem |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Asked frequently |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask for QuickSelect follow-up |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard heap question |
| Apple | ‚≠ê‚≠ê‚≠ê | Occasionally asked |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Simple statement |
| Code heap solution | 5-8 min | Standard pattern |
| Code QuickSelect | 10-15 min | More complex |
| Discuss trade-offs | 3-5 min | Key for senior roles |
| Total interview time | 15-25 min | Depends on follow-ups |

---

## üí° Key Insight

> **The counterintuitive choice makes it work:** For the Kth **largest**, use a **min**-heap. The min-heap acts as a filter that keeps only the K largest elements, and its root (minimum of those K) is exactly what we want.

---

## üîó Related

- **Previous:** [Top K Overview](./4.1-Top-K-Overview.md)
- **Next:** [Kth Largest in Stream (LC 703)](./4.3-Kth-Largest-Stream-LC703.md)
- **Variant:** [Top K Frequent (LC 347)](./4.4-Top-K-Frequent-LC347.md)
