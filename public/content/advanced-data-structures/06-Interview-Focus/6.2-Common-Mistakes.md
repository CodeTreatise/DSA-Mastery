# Common Mistakes in Advanced Data Structures

> **Learn from these pitfalls to write bug-free code in interviews.**

---

## 1Ô∏è‚É£ Union-Find Mistakes

### Mistake 1: Forgetting Path Compression

```python
# ‚ùå WRONG - O(n) per find
def find(self, x):
    while self.parent[x] != x:
        x = self.parent[x]
    return x

# ‚úÖ CORRECT - O(Œ±(n)) amortized with path compression
def find(self, x):
    if self.parent[x] != x:
        self.parent[x] = self.find(self.parent[x])  # Flatten!
    return self.parent[x]
```

**Impact:** Without path compression, chains can be O(n) long.

---

### Mistake 2: Comparing Elements Instead of Roots

```python
# ‚ùå WRONG - compares elements, not roots
def union(self, x, y):
    if x == y: return False  # Wrong check!
    self.parent[y] = x
    return True

# ‚úÖ CORRECT - compare roots
def union(self, x, y):
    root_x, root_y = self.find(x), self.find(y)
    if root_x == root_y: return False  # Already connected
    self.parent[root_y] = root_x
    return True
```

---

### Mistake 3: Wrong Rank Update

```python
# ‚ùå WRONG - always increment rank
def union(self, x, y):
    px, py = self.find(x), self.find(y)
    self.parent[py] = px
    self.rank[px] += 1  # Wrong!

# ‚úÖ CORRECT - only increment when equal ranks
def union(self, x, y):
    px, py = self.find(x), self.find(y)
    if self.rank[px] < self.rank[py]:
        px, py = py, px
    self.parent[py] = px
    if self.rank[px] == self.rank[py]:
        self.rank[px] += 1
```

---

## 2Ô∏è‚É£ LRU Cache Mistakes

### Mistake 1: Not Updating on Get

```python
# ‚ùå WRONG - doesn't update recency on get
def get(self, key):
    if key in self.cache:
        return self.cache[key]
    return -1

# ‚úÖ CORRECT - move to most recent
def get(self, key):
    if key in self.cache:
        self.cache.move_to_end(key)  # Update recency!
        return self.cache[key]
    return -1
```

---

### Mistake 2: Double Counting on Put

```python
# ‚ùå WRONG - may evict the key we just inserted
def put(self, key, value):
    if len(self.cache) >= self.capacity:
        self.cache.popitem(last=False)  # Evict before checking!
    self.cache[key] = value

# ‚úÖ CORRECT - check if key exists first
def put(self, key, value):
    if key in self.cache:
        self.cache.move_to_end(key)
    self.cache[key] = value
    if len(self.cache) > self.capacity:  # Check after
        self.cache.popitem(last=False)
```

---

### Mistake 3: Linked List Without Dummy Nodes

```python
# ‚ùå WRONG - edge case hell without dummies
class LRUCache:
    def __init__(self, capacity):
        self.head = None
        self.tail = None
        # ... lots of null checks everywhere

# ‚úÖ CORRECT - dummy nodes simplify code
class LRUCache:
    def __init__(self, capacity):
        self.head = ListNode()  # Dummy
        self.tail = ListNode()  # Dummy
        self.head.next = self.tail
        self.tail.prev = self.head
```

---

## 3Ô∏è‚É£ Segment Tree Mistakes

### Mistake 1: Wrong Range (Inclusive vs Exclusive)

```python
# ‚ùå WRONG - mixing inclusive/exclusive
def query(self, l, r):  # Is r included or not?
    # Unclear!

# ‚úÖ CORRECT - be consistent, document clearly
def query(self, l, r):  # [l, r) - r is exclusive
    """Query sum of arr[l:r] (r exclusive)."""
```

**Pro tip:** Iterative segment tree typically uses [l, r), recursive uses [l, r].

---

### Mistake 2: Not Handling Leaf Updates

```python
# ‚ùå WRONG - forgot to update the actual array position
def update(self, i, val):
    i += self.n
    # Missing: self.tree[i] = val
    while i > 1:
        i //= 2
        self.tree[i] = self.tree[2*i] + self.tree[2*i+1]

# ‚úÖ CORRECT
def update(self, i, val):
    i += self.n
    self.tree[i] = val  # Set leaf first!
    while i > 1:
        i //= 2
        self.tree[i] = self.tree[2*i] + self.tree[2*i+1]
```

---

### Mistake 3: Wrong Query Loop Condition

```python
# ‚ùå WRONG
while l <= r:  # Will include r twice when l==r

# ‚úÖ CORRECT
while l < r:
```

---

## 4Ô∏è‚É£ Fenwick Tree (BIT) Mistakes

### Mistake 1: 0-indexed vs 1-indexed Confusion

```python
# ‚ùå WRONG - BIT is 1-indexed, using 0
def update(self, i, delta):
    while i <= self.n:  # If i=0, infinite loop!
        self.tree[i] += delta
        i += i & (-i)

# ‚úÖ CORRECT - convert to 1-indexed
def update(self, i, delta):
    i += 1  # Convert 0-indexed to 1-indexed
    while i <= self.n:
        self.tree[i] += delta
        i += i & (-i)
```

---

### Mistake 2: Using BIT for Range Min/Max

```python
# ‚ùå WRONG - BIT doesn't support non-invertible operations
def range_min(self, l, r):
    # This doesn't work! min(prefix[r]) - min(prefix[l-1]) ‚â† min(range)

# ‚úÖ CORRECT - use Segment Tree for min/max
```

**BIT works for:** sum, XOR (invertible operations)
**BIT doesn't work for:** min, max, GCD (non-invertible)

---

### Mistake 3: Wrong Lowbit Direction

```python
# ‚ùå WRONG - adding lowbit in query
def query(self, i):
    result = 0
    while i > 0:
        result += self.tree[i]
        i += i & (-i)  # Wrong! Goes up, not down

# ‚úÖ CORRECT - subtract lowbit in query
def query(self, i):
    result = 0
    while i > 0:
        result += self.tree[i]
        i -= i & (-i)  # Correct - goes down
```

**Remember:**
- Update: add lowbit (i += i & -i)
- Query: subtract lowbit (i -= i & -i)

---

## 5Ô∏è‚É£ Monotonic Stack/Deque Mistakes

### Mistake 1: Wrong Comparison Direction

```python
# For NEXT GREATER element:

# ‚ùå WRONG - keeps larger elements
while stack and nums[stack[-1]] > nums[i]:
    stack.pop()

# ‚úÖ CORRECT - keeps larger elements, pops smaller
while stack and nums[stack[-1]] < nums[i]:
    idx = stack.pop()
    result[idx] = nums[i]  # Current is the next greater
```

---

### Mistake 2: Forgetting Window Bounds in Deque

```python
# ‚ùå WRONG - no window size check
def maxSlidingWindow(nums, k):
    dq = deque()
    for i, num in enumerate(nums):
        while dq and nums[dq[-1]] < num:
            dq.pop()
        dq.append(i)
        # Missing: remove elements outside window!

# ‚úÖ CORRECT
def maxSlidingWindow(nums, k):
    dq = deque()
    for i, num in enumerate(nums):
        # Remove elements outside window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        while dq and nums[dq[-1]] < num:
            dq.pop()
        dq.append(i)
```

---

## üìã Pre-Submission Checklist

Before submitting any advanced data structure solution:

### Union-Find
- [ ] Path compression in `find()`
- [ ] Compare roots, not elements
- [ ] Union by rank/size implemented correctly
- [ ] Handle self-loops (union(x, x))

### LRU Cache
- [ ] Update recency on both get AND put
- [ ] Check capacity AFTER inserting
- [ ] Use dummy nodes for linked list

### Segment Tree
- [ ] Clear on [l, r] vs [l, r) convention
- [ ] Update leaf before propagating up
- [ ] Correct loop condition (< vs <=)

### Fenwick Tree
- [ ] Convert 0-indexed to 1-indexed
- [ ] Only use for invertible operations
- [ ] Add lowbit for update, subtract for query

### Monotonic Stack
- [ ] Correct comparison for greater vs smaller
- [ ] Store indices, not values
- [ ] Handle window bounds for deque

---

> **üí° Key Insight:** Most bugs come from off-by-one errors and mixing conventions. Pick one convention and stick with it throughout your implementation.

> **üîó Related:** [Quick Reference](./6.1-Quick-Reference.md) | [Practice Roadmap ‚Üí](./6.3-Practice-Roadmap.md)
