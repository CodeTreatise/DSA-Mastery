# Tree DP Patterns

> **DP on trees: when recursion meets optimization.** Tree DP combines the natural recursive structure of trees with dynamic programming to solve optimization problems. The key is understanding that each node's answer depends on its children's answers.

---

## ðŸ“‹ Overview

Tree DP problems follow a pattern: **post-order traversal with state passing**.

| Category | Example Problems | Key Insight |
|----------|-----------------|-------------|
| **Path Problems** | Diameter, Max Path Sum | Track extending paths |
| **Subtree Problems** | House Robber III | Take or skip current |
| **Matching/Covering** | Min Vertex Cover | Set cover on trees |
| **Rerooting** | Sum of Distances | Change root efficiently |

---

## ðŸŽ¯ Pattern Recognition

**Tree DP signals:**
- "Maximum/minimum path in tree"
- "Each node can be included or excluded"
- "Compute something for each node as root"
- "Optimal selection on tree nodes"

**Keywords:**
- "binary tree", "tree structure"
- "diameter", "path sum"
- "rob houses" (tree version)
- "vertex cover", "independent set"

---

## ðŸ“ Core Tree DP Patterns

### Pattern 1: Path Problems (Max Path Sum)

**Problem:** Find the maximum path sum in a binary tree. A path can start and end at any node.

**Key Insight:** At each node, we track:
1. **Best "arm"**: max sum of path that EXTENDS through this node (to parent)
2. **Best "complete"**: max sum of path that ENDS at this subtree (update global)

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def max_path_sum(root: TreeNode) -> int:
    """
    LC 124: Binary Tree Maximum Path Sum
    Time: O(n), Space: O(h)
    """
    max_sum = [float('-inf')]  # Global max (using list for mutability)
    
    def dfs(node):
        """Return max sum of path extending UP from this node."""
        if not node:
            return 0
        
        # Max gain from left/right (ignore negative paths)
        left_gain = max(0, dfs(node.left))
        right_gain = max(0, dfs(node.right))
        
        # Path through this node (left â†’ node â†’ right)
        path_sum = node.val + left_gain + right_gain
        max_sum[0] = max(max_sum[0], path_sum)
        
        # Return max gain EXTENDING to parent (choose one side)
        return node.val + max(left_gain, right_gain)
    
    dfs(root)
    return max_sum[0]
```

```javascript
function maxPathSum(root) {
    let maxSum = -Infinity;
    
    function dfs(node) {
        if (!node) return 0;
        
        const leftGain = Math.max(0, dfs(node.left));
        const rightGain = Math.max(0, dfs(node.right));
        
        // Path through this node
        const pathSum = node.val + leftGain + rightGain;
        maxSum = Math.max(maxSum, pathSum);
        
        // Extend to parent
        return node.val + Math.max(leftGain, rightGain);
    }
    
    dfs(root);
    return maxSum;
}
```

---

### Pattern 2: Take or Skip (House Robber III)

**Problem:** Rob houses arranged in a binary tree. Can't rob directly connected houses.

**Key Insight:** For each node, track TWO states:
- `rob`: max money if we rob this node
- `skip`: max money if we skip this node

```python
def rob(root: TreeNode) -> int:
    """
    LC 337: House Robber III
    Each node returns (rob_this, skip_this)
    """
    def dfs(node):
        if not node:
            return (0, 0)  # (rob, skip)
        
        left_rob, left_skip = dfs(node.left)
        right_rob, right_skip = dfs(node.right)
        
        # If we rob this node, can't rob children
        rob_this = node.val + left_skip + right_skip
        
        # If we skip this node, take best from each child
        skip_this = max(left_rob, left_skip) + max(right_rob, right_skip)
        
        return (rob_this, skip_this)
    
    return max(dfs(root))
```

```javascript
function rob(root) {
    function dfs(node) {
        if (!node) return [0, 0]; // [rob, skip]
        
        const [leftRob, leftSkip] = dfs(node.left);
        const [rightRob, rightSkip] = dfs(node.right);
        
        const robThis = node.val + leftSkip + rightSkip;
        const skipThis = Math.max(leftRob, leftSkip) + Math.max(rightRob, rightSkip);
        
        return [robThis, skipThis];
    }
    
    return Math.max(...dfs(root));
}
```

---

### Pattern 3: Tree Diameter

**Problem:** Find the length of the longest path between any two nodes.

**Key Insight:** At each node, the longest path either:
1. Passes through this node (left_depth + right_depth)
2. Is entirely in left or right subtree

```python
def diameter_of_binary_tree(root: TreeNode) -> int:
    """
    LC 543: Binary Tree Diameter
    Returns number of EDGES in longest path.
    """
    diameter = [0]
    
    def depth(node):
        if not node:
            return 0
        
        left_depth = depth(node.left)
        right_depth = depth(node.right)
        
        # Update diameter (path through this node)
        diameter[0] = max(diameter[0], left_depth + right_depth)
        
        # Return depth for parent
        return 1 + max(left_depth, right_depth)
    
    depth(root)
    return diameter[0]
```

---

### Pattern 4: Minimum Vertex Cover

**Problem:** Select minimum nodes such that every edge has at least one endpoint selected.

**State:** For each node, track:
- `include[v]`: min cover if v is included
- `exclude[v]`: min cover if v is excluded

```python
def min_vertex_cover(root: TreeNode) -> int:
    """
    Minimum nodes to cover all edges.
    """
    def dfs(node):
        if not node:
            return (0, 0)  # (include, exclude)
        
        left_inc, left_exc = dfs(node.left)
        right_inc, right_exc = dfs(node.right)
        
        # If we include this node, children can be anything
        include = 1 + min(left_inc, left_exc) + min(right_inc, right_exc)
        
        # If we exclude this node, children MUST be included
        exclude = left_inc + right_inc
        
        return (include, exclude)
    
    inc, exc = dfs(root)
    return min(inc, exc)
```

---

### Pattern 5: Rerooting (Sum of Distances)

**Problem:** For each node, compute sum of distances to all other nodes.

**Key Insight:** Use two DFS passes:
1. First DFS: compute answer for root
2. Second DFS: propagate answer to children

```python
def sum_of_distances_in_tree(n: int, edges: list[list[int]]) -> list[int]:
    """
    LC 834: Sum of Distances in Tree
    Time: O(n), Space: O(n)
    """
    from collections import defaultdict
    
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    count = [1] * n  # Subtree sizes
    result = [0] * n
    
    # First DFS: compute result[0] and subtree sizes
    def dfs1(node, parent):
        for child in graph[node]:
            if child != parent:
                dfs1(child, node)
                count[node] += count[child]
                result[node] += result[child] + count[child]
    
    # Second DFS: propagate to all nodes
    def dfs2(node, parent):
        for child in graph[node]:
            if child != parent:
                # When moving from node to child:
                # - Nodes in child's subtree get 1 closer
                # - All other nodes get 1 farther
                result[child] = result[node] - count[child] + (n - count[child])
                dfs2(child, node)
    
    dfs1(0, -1)
    dfs2(0, -1)
    return result
```

---

## ðŸ”„ Pattern Comparison

| Pattern | States per Node | Return Type | Example |
|---------|-----------------|-------------|---------|
| **Path Sum** | 1 (extending gain) | int | Max Path Sum |
| **Take/Skip** | 2 (take, skip) | tuple | House Robber III |
| **Diameter** | 1 (depth) | int | Tree Diameter |
| **Cover/Match** | 2+ (include, exclude) | tuple | Vertex Cover |
| **Rerooting** | 2 DFS passes | array | Sum of Distances |

---

## âš¡ Complexity Analysis

| Problem | Time | Space |
|---------|------|-------|
| Max Path Sum | O(n) | O(h) |
| House Robber III | O(n) | O(h) |
| Tree Diameter | O(n) | O(h) |
| Min Vertex Cover | O(n) | O(h) |
| Sum of Distances | O(n) | O(n) |

Where h = height of tree (O(log n) for balanced, O(n) for skewed)

---

## âš ï¸ Common Mistakes

### 1. Forgetting to Handle Null Nodes

**âŒ Wrong:**
```python
def dfs(node):
    left = dfs(node.left)  # Crashes if node is None
```

**âœ… Correct:**
```python
def dfs(node):
    if not node:
        return 0  # Or appropriate base case
    left = dfs(node.left)
```

### 2. Confusing "Extend" vs "Complete" Paths

```python
# For path problems:
# EXTEND: path that continues to parent (pick ONE child)
# COMPLETE: path that ends here (can use BOTH children)

# Return: extending path (for parent)
# Update global: complete path (for answer)
```

### 3. Wrong State in Take/Skip

**âŒ Wrong:**
```python
# If we skip node, children must be robbed
skip_this = left_rob + right_rob
```

**âœ… Correct:**
```python
# If we skip node, children CAN be robbed (but don't have to)
skip_this = max(left_rob, left_skip) + max(right_rob, right_skip)
```

### 4. Rerooting Without Two Passes

**âŒ Wrong:**
```python
# Trying to compute all results in one pass - exponential!
for node in all_nodes:
    result[node] = dfs_from(node)  # O(n) each = O(nÂ²) total
```

**âœ… Correct:**
```python
# Two-pass rerooting: O(n) total
dfs1(root)  # Compute for root
dfs2(root)  # Propagate to all
```

---

## ðŸ“ Practice Problems

### Core Problems
- [ ] [124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/) - Hard
- [ ] [337. House Robber III](https://leetcode.com/problems/house-robber-iii/) - Medium
- [ ] [543. Binary Tree Diameter](https://leetcode.com/problems/diameter-of-binary-tree/) - Easy
- [ ] [834. Sum of Distances in Tree](https://leetcode.com/problems/sum-of-distances-in-tree/) - Hard

### Extended Problems
- [ ] [968. Binary Tree Cameras](https://leetcode.com/problems/binary-tree-cameras/) - Hard (3 states)
- [ ] [1339. Maximum Product of Splitted Binary Tree](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/) - Medium
- [ ] [687. Longest Univalue Path](https://leetcode.com/problems/longest-univalue-path/) - Medium
- [ ] [1372. Longest ZigZag Path](https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/) - Medium

---

## ðŸŽ¤ Interview Context

**Company Frequency:**
| Problem | Google | Meta | Amazon |
|---------|--------|------|--------|
| Max Path Sum | â­â­â­â­â­ | â­â­â­â­ | â­â­â­ |
| House Robber III | â­â­â­ | â­â­â­ | â­â­â­ |
| Sum of Distances | â­â­â­â­ | â­â­ | â­â­ |

**Time allocation:**
| Problem | Target Time |
|---------|-------------|
| Tree Diameter | 10-15 min |
| House Robber III | 20-25 min |
| Max Path Sum | 25-30 min |
| Sum of Distances | 35-40 min |

**Interview tips:**
1. Draw the tree and trace through by hand
2. Identify what information flows UP (child â†’ parent)
3. Identify what gets updated globally vs returned
4. Be clear about base cases (null nodes, leaves)

---

## ðŸ’¡ Key Insights

1. **Post-order traversal** is natural for Tree DP (children before parent)
2. **Return vs update global**: extending path returns, complete path updates
3. **Multiple states** (take/skip, include/exclude) handle constraints
4. **Rerooting** transforms O(nÂ²) brute force into O(n) with two passes
5. **Tree structure** makes DP clean: each node only needs children's info

---

> **ðŸ’¡ Key Pattern:** Most Tree DP follows this template:
> ```python
> def dfs(node):
>     if not node: return base_case
>     left_result = dfs(node.left)
>     right_result = dfs(node.right)
>     # Combine and update global if needed
>     return result_for_parent
> ```

> **ðŸ”— Related:** [Tree Problems](../../06-Trees.md) | [Recursion Patterns](../../02-Recursion-Backtracking.md) | [DP Fundamentals](../01-DP-Fundamentals/1.1-What-Is-DP.md)
