# 3.1 BFS Fundamentals

> **Level-by-level exploration - the foundation of shortest path in unweighted graphs**
>
> â±ï¸ **Time:** 45-60 min | ğŸ“Š **Difficulty:** Core | ğŸ¯ **Interview Frequency:** â­â­â­â­â­ (25%+ of graph problems)

---

## Overview

**Breadth-First Search (BFS)** explores a graph level by level, visiting all neighbors before moving to the next depth. This property makes BFS ideal for finding **shortest paths in unweighted graphs**.

```
BFS Visualization:

Start at node 0:

       [0]              Level 0: [0]
      / | \
    [1][2][3]           Level 1: [1, 2, 3]
    /       \
  [4]       [5]         Level 2: [4, 5]

Visit Order: 0 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
             Level by level!
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>How to Identify BFS Problems</strong></summary>

**Look for these signals:**
- "Shortest path" in an unweighted graph
- "Minimum number of steps/moves/operations"
- "Level-order traversal"
- "Nearest" or "closest" something
- "All nodes at distance K"
- "Spread" or "propagate" (like rotting oranges)

**Keywords in problem statement:**
- "minimum steps to reach"
- "shortest path"
- "level by level"
- "nearest distance"
- "how many moves"
- "simultaneously" (multi-source BFS)

**Input patterns:**
- Grid with start/end positions
- Graph with source vertex
- Tree level-order problems
- State transformation problems

</details>

---

## âœ… When to Use BFS

| Scenario | Why BFS Works |
|----------|---------------|
| Shortest path (unweighted) | First path found = shortest |
| Level-order traversal | Natural level-by-level exploration |
| Minimum operations/steps | Counts levels = steps |
| Finding all nodes at distance K | Stop at level K |
| Multi-source shortest path | Start with all sources in queue |
| Detecting cycles (alternative) | Works, but DFS often simpler |

---

## âŒ When NOT to Use BFS

| Scenario | Why Not | Better Alternative |
|----------|---------|-------------------|
| Weighted graphs | BFS ignores weights | Dijkstra's |
| Deep exploration needed | Memory for wide trees | DFS |
| Backtracking problems | BFS doesn't backtrack | DFS/Backtracking |
| Path enumeration | Need all paths, not shortest | DFS |
| Very large state space | Queue can explode | A* or bidirectional |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Graph Basics](../01-Graph-Fundamentals/1.1-What-Is-Graph.md)
- [Adjacency List](../02-Graph-Representation/2.2-Adjacency-List.md)
- [Queue data structure](../../05-Stacks-Queues/05-Stacks-Queues.md)

**After mastering this:**
- [BFS Template](./3.2-BFS-Template.md) - Generic template
- [Multi-Source BFS](./3.3-Multi-Source-BFS.md) - Multiple start points
- [Grid Traversal](../05-Grid-Traversal/5.1-Grid-Introduction.md) - BFS on 2D grids

**Combines with:**
- **Dijkstra's** = BFS + Priority Queue (weighted)
- **Bidirectional BFS** = BFS from both ends
- **0-1 BFS** = BFS with deque (0 and 1 weights)

**Grokking Pattern:** #15 - Graph BFS

</details>

---

## ğŸ“ How It Works

### Core Concept

BFS uses a **queue** (FIFO) to process nodes level by level:

1. Start with source node in queue
2. Dequeue a node, process it
3. Enqueue all unvisited neighbors
4. Repeat until queue is empty

### Step-by-Step Visualization

```
Graph:  0 â€” 1 â€” 2
        |   |
        3   4

Step 1: Queue = [0], Visited = {0}
        Process 0, add neighbors 1, 3
        
Step 2: Queue = [1, 3], Visited = {0, 1, 3}
        Process 1, add neighbors 2, 4
        
Step 3: Queue = [3, 2, 4], Visited = {0, 1, 3, 2, 4}
        Process 3 (no new neighbors)
        
Step 4: Queue = [2, 4]
        Process 2 (no new neighbors)
        
Step 5: Queue = [4]
        Process 4 (no new neighbors)
        
Step 6: Queue = []
        Done!

Traversal Order: 0 â†’ 1 â†’ 3 â†’ 2 â†’ 4
```

### Why BFS Finds Shortest Path

```
Distance from 0:

        [0]  â† Distance 0
       / | \
     [1][2][3]  â† Distance 1 (all neighbors of level 0)
     /       \
   [4]       [5]  â† Distance 2 (all neighbors of level 1)

BFS guarantees: First time we reach a node = shortest distance
Why? We explore ALL nodes at distance d before ANY node at distance d+1
```

---

## ğŸ’» Code Implementation

### Basic BFS Traversal

**Python:**
```python
from collections import deque, defaultdict

def bfs_traversal(graph, start):
    """
    Basic BFS traversal of a graph.
    
    Pattern: Level-by-level exploration using queue
    Time: O(V + E) - visit each vertex and edge once
    Space: O(V) - queue can hold all vertices
    
    Args:
        graph: Adjacency list (dict of lists)
        start: Starting vertex
    
    Returns:
        List of vertices in BFS order
    """
    visited = set([start])
    queue = deque([start])
    result = []
    
    while queue:
        node = queue.popleft()  # FIFO - crucial for BFS!
        result.append(node)
        
        # Process all neighbors
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)  # Mark visited BEFORE adding to queue
                queue.append(neighbor)
    
    return result


# Example usage
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 5],
    3: [1],
    4: [1],
    5: [2]
}

print(bfs_traversal(graph, 0))  # [0, 1, 2, 3, 4, 5]
```

### BFS with Distance Tracking

**Python:**
```python
from collections import deque

def bfs_shortest_distance(graph, start, end):
    """
    Find shortest distance from start to end in unweighted graph.
    
    Key insight: First time we reach a node = shortest path
    
    Returns:
        Distance (number of edges), or -1 if not reachable
    """
    if start == end:
        return 0
    
    visited = set([start])
    queue = deque([(start, 0)])  # (node, distance)
    
    while queue:
        node, dist = queue.popleft()
        
        for neighbor in graph[node]:
            if neighbor == end:
                return dist + 1  # Found! Return distance
            
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, dist + 1))
    
    return -1  # Not reachable


# Example: Find shortest path from 0 to 5
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 5],
    3: [1],
    4: [1],
    5: [2]
}

print(bfs_shortest_distance(graph, 0, 5))  # 2 (0 â†’ 2 â†’ 5)
```

### BFS with Path Reconstruction

**Python:**
```python
from collections import deque

def bfs_shortest_path(graph, start, end):
    """
    Find shortest path from start to end.
    
    Technique: Store parent of each visited node
    
    Returns:
        List representing the path, or empty list if not found
    """
    if start == end:
        return [start]
    
    visited = set([start])
    queue = deque([start])
    parent = {start: None}  # Track how we reached each node
    
    while queue:
        node = queue.popleft()
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = node  # Record parent
                queue.append(neighbor)
                
                if neighbor == end:
                    # Reconstruct path
                    path = []
                    current = end
                    while current is not None:
                        path.append(current)
                        current = parent[current]
                    return path[::-1]  # Reverse to get start â†’ end
    
    return []  # Not found


# Example
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 5],
    3: [1],
    4: [1],
    5: [2]
}

print(bfs_shortest_path(graph, 0, 5))  # [0, 2, 5]
```

### BFS Level by Level (Count Levels)

**Python:**
```python
from collections import deque

def bfs_by_levels(graph, start):
    """
    BFS that processes level by level.
    
    Use when you need to track:
    - Current level/depth
    - All nodes at a specific distance
    - Process level before moving to next
    """
    visited = set([start])
    queue = deque([start])
    level = 0
    result = []
    
    while queue:
        level_size = len(queue)  # Nodes at current level
        level_nodes = []
        
        # Process entire level
        for _ in range(level_size):
            node = queue.popleft()
            level_nodes.append(node)
            
            for neighbor in graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        result.append((level, level_nodes))
        level += 1
    
    return result


# Example
graph = {0: [1, 2], 1: [3, 4], 2: [5], 3: [], 4: [], 5: []}
levels = bfs_by_levels(graph, 0)
for lvl, nodes in levels:
    print(f"Level {lvl}: {nodes}")
# Level 0: [0]
# Level 1: [1, 2]
# Level 2: [3, 4, 5]
```

**JavaScript:**
```javascript
// Basic BFS Traversal
function bfsTraversal(graph, start) {
    const visited = new Set([start]);
    const queue = [start];
    const result = [];
    
    while (queue.length > 0) {
        const node = queue.shift();  // FIFO
        result.push(node);
        
        for (const neighbor of graph.get(node) || []) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }
    
    return result;
}

// BFS with Distance
function bfsShortestDistance(graph, start, end) {
    if (start === end) return 0;
    
    const visited = new Set([start]);
    const queue = [[start, 0]];  // [node, distance]
    
    while (queue.length > 0) {
        const [node, dist] = queue.shift();
        
        for (const neighbor of graph.get(node) || []) {
            if (neighbor === end) return dist + 1;
            
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push([neighbor, dist + 1]);
            }
        }
    }
    
    return -1;
}

// BFS Level by Level
function bfsByLevels(graph, start) {
    const visited = new Set([start]);
    let queue = [start];
    const result = [];
    let level = 0;
    
    while (queue.length > 0) {
        const levelSize = queue.length;
        const levelNodes = [];
        const nextQueue = [];
        
        for (let i = 0; i < levelSize; i++) {
            const node = queue[i];
            levelNodes.push(node);
            
            for (const neighbor of graph.get(node) || []) {
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    nextQueue.push(neighbor);
                }
            }
        }
        
        result.push({ level, nodes: levelNodes });
        queue = nextQueue;
        level++;
    }
    
    return result;
}
```

---

## âš¡ Complexity Analysis

| Aspect | Complexity | Notes |
|--------|------------|-------|
| **Time** | O(V + E) | Visit each vertex once, traverse each edge once |
| **Space** | O(V) | Queue can hold up to V vertices, visited set |
| Best Case | O(1) | Target is start node |
| Worst Case | O(V + E) | Target is last node or not present |

### Why O(V + E)?

```
For each vertex v:
  - Add to queue: O(1)
  - Remove from queue: O(1)
  - Process neighbors: O(degree(v))

Total neighbor processing = sum of all degrees = 2E (undirected) or E (directed)

Total = O(V) for vertex ops + O(E) for edge traversal = O(V + E)
```

### Space Breakdown

```
visited set:  O(V) - stores each vertex once
queue:        O(V) - worst case all vertices in queue
parent dict:  O(V) - for path reconstruction
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total:        O(V)
```

---

## ğŸ”„ Variations

| Variation | Difference | Example Problem |
|-----------|------------|-----------------|
| **Single-source BFS** | One start point | Basic shortest path |
| **Multi-source BFS** | Multiple start points | Rotting Oranges |
| **Bidirectional BFS** | BFS from both ends | Word Ladder II |
| **0-1 BFS** | Edges with weight 0 or 1 | Minimum cost path |
| **Level-order BFS** | Track level number | Tree level order |

---

## âš ï¸ Common Mistakes

### 1. Using List Instead of Deque

```python
# âŒ Wrong: list.pop(0) is O(n)
queue = [start]
while queue:
    node = queue.pop(0)  # O(n) operation!

# âœ… Correct: deque.popleft() is O(1)
from collections import deque
queue = deque([start])
while queue:
    node = queue.popleft()  # O(1) operation
```

### 2. Marking Visited After Dequeuing

```python
# âŒ Wrong: May add same node multiple times
queue = deque([start])
while queue:
    node = queue.popleft()
    if node in visited:  # Too late!
        continue
    visited.add(node)
    for neighbor in graph[node]:
        queue.append(neighbor)  # Duplicates possible!

# âœ… Correct: Mark visited when adding to queue
visited = set([start])
queue = deque([start])
while queue:
    node = queue.popleft()
    for neighbor in graph[node]:
        if neighbor not in visited:
            visited.add(neighbor)  # Mark BEFORE adding
            queue.append(neighbor)
```

### 3. Using BFS for Weighted Graphs

```python
# âŒ Wrong: BFS ignores edge weights
def wrong_shortest_path(graph, start, end):
    # BFS finds path with fewest edges, not lowest total weight!
    pass

# âœ… Correct: Use Dijkstra for weighted graphs
import heapq
def dijkstra(graph, start, end):
    # Priority queue by distance
    pq = [(0, start)]
    dist = {start: 0}
    # ...
```

### 4. Forgetting to Handle Disconnected Graphs

```python
# âŒ Wrong: Only visits connected component
def bfs_all_nodes(graph, start):
    # Misses nodes not reachable from start
    pass

# âœ… Correct: Start BFS from each unvisited node
def bfs_disconnected(graph):
    visited = set()
    for node in graph:
        if node not in visited:
            bfs_from(graph, node, visited)
```

---

## ğŸ“ Practice Problems (Progressive)

### Easy (Learn the pattern)
| Problem | Focus | Link |
|---------|-------|------|
| Binary Tree Level Order Traversal | Basic BFS, level tracking | [LC 102](https://leetcode.com/problems/binary-tree-level-order-traversal/) |
| Flood Fill | BFS on grid | [LC 733](https://leetcode.com/problems/flood-fill/) |
| Find if Path Exists | Basic graph BFS | [LC 1971](https://leetcode.com/problems/find-if-path-exists-in-graph/) |

### Medium (Apply variations)
| Problem | Focus | Link |
|---------|-------|------|
| Rotting Oranges | Multi-source BFS | [LC 994](https://leetcode.com/problems/rotting-oranges/) |
| 01 Matrix | Multi-source, distance | [LC 542](https://leetcode.com/problems/01-matrix/) |
| Word Ladder | State transformation | [LC 127](https://leetcode.com/problems/word-ladder/) |
| Shortest Path in Binary Matrix | Grid BFS | [LC 1091](https://leetcode.com/problems/shortest-path-in-binary-matrix/) |
| Open the Lock | State graph BFS | [LC 752](https://leetcode.com/problems/open-the-lock/) |

### Hard (Master edge cases)
| Problem | Focus | Link |
|---------|-------|------|
| Word Ladder II | BFS + path reconstruction | [LC 126](https://leetcode.com/problems/word-ladder-ii/) |
| Shortest Path to Get All Keys | BFS with state | [LC 864](https://leetcode.com/problems/shortest-path-to-get-all-keys/) |
| Cut Off Trees for Golf Event | Multiple BFS | [LC 675](https://leetcode.com/problems/cut-off-trees-for-golf-event/) |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement basic BFS from scratch, solve Flood Fill
**Day 3:** Implement BFS with distance tracking, solve 01 Matrix
**Day 7:** Implement level-by-level BFS, solve Rotting Oranges
**Day 14:** Implement BFS with path reconstruction, solve Word Ladder
**Day 30:** Review all BFS variations, identify pattern in new problems

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate BFS in Interviews</strong></summary>

**Opening statement when identifying BFS:**
> "I notice this problem asks for the minimum number of steps to reach a target. Since all moves are equivalent (unweighted), I'll use BFS which guarantees finding the shortest path."

**Explaining the approach:**
> "I'll use a queue to explore level by level. Each level represents one step. The first time I reach the target, that's the minimum distance."

**Complexity discussion:**
> "Time complexity is O(V + E) since we visit each state once and process each transition once. Space is O(V) for the queue and visited set."

**Common follow-up questions:**

Q: "Why not DFS?"
> "DFS doesn't guarantee shortest path. It might find a path with 10 steps when a 2-step path exists."

Q: "What if edges have weights?"
> "Then I'd use Dijkstra's algorithm, which is essentially BFS with a priority queue."

Q: "How would you optimize for memory?"
> "For very large state spaces, I could use bidirectional BFS, which reduces space from O(b^d) to O(b^(d/2))."

</details>

**Company Focus:**
| Company | BFS Frequency | Focus Areas |
|---------|---------------|-------------|
| Meta | â­â­â­â­â­ | Rotting Oranges, Word Ladder |
| Amazon | â­â­â­â­â­ | Grid problems, state machines |
| Google | â­â­â­â­ | Complex state BFS |
| Microsoft | â­â­â­â­ | Tree level order |

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn concept | 30-45 min | Understand queue mechanics |
| Basic implementation | 15-20 min | Template memorization |
| Solve Easy problem | 10-15 min | Direct application |
| Solve Medium problem | 20-30 min | Add distance/path tracking |
| **Master BFS pattern** | **3-5 hours** | 5-7 problems across variations |

---

> **ğŸ’¡ Key Insight:** BFS explores in "waves" from the source. Each wave represents one step. The first time you reach any node, you've taken the minimum number of steps to get there.

> **ğŸ”— Related:** [BFS Template](./3.2-BFS-Template.md) | [Multi-Source BFS](./3.3-Multi-Source-BFS.md) | [DFS Fundamentals](../04-DFS-Pattern/4.1-DFS-Fundamentals.md) | [Dijkstra's Algorithm](../08-Shortest-Path/8.1-Dijkstra-Algorithm.md)

---

**Previous:** [â† 2.4 Representation Comparison](../02-Graph-Representation/2.4-Representation-Comparison.md)  
**Next:** [3.2 BFS Template â†’](./3.2-BFS-Template.md)
