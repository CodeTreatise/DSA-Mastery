# Longest Substring Without Repeating Characters (LeetCode 3)

> **Medium** | Given a string s, find the length of the longest substring without repeating characters.

This is one of the most frequently asked interview questions - a classic application of sliding window with hash set for O(n) substring problems.

---

## üéØ Pattern Recognition

<details>
<summary><strong>Problem Signals</strong></summary>

**Keywords indicating this pattern:**
- "Longest substring"
- "Without repeating" / "all unique"
- "Contiguous characters"
- Maximum length with constraint

**Problem classification:**
```
Category: Sliding Window + Hash
Subcategory: Variable window with uniqueness constraint
Hash type: Set (for membership) or Map (for position/count)
```

</details>

---

## üìã Problem Statement

**LeetCode 3:** [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

```
Given a string s, find the length of the longest substring 
without repeating characters.

Example 1:
Input: s = "abcabcbb"
Output: 3
Explanation: "abc" is the longest, length 3.

Example 2:
Input: s = "bbbbb"
Output: 1
Explanation: "b" is the longest, length 1.

Example 3:
Input: s = "pwwkew"
Output: 3
Explanation: "wke" is the longest, length 3.
Note: "pwke" is a subsequence, not substring.

Constraints:
- 0 <= s.length <= 5 * 10^4
- s consists of English letters, digits, symbols, spaces
```

---

## ‚úÖ When to Use This Approach

- Finding longest/shortest substring with uniqueness constraint
- Sliding window with element membership tracking
- Subarray without duplicates

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need subsequence, not substring | Non-contiguous | DP |
| Count all valid substrings | Different problem | Mathematical formula |
| K distinct chars allowed | Different constraint | Modified approach |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Related</strong></summary>

**Before this:**
- [Hash Set Operations](../02-Hash-Map-Set/2.2-Hash-Set-Operations.md)
- [Sliding Window + Hash](./7.1-Sliding-Hash-Overview.md)

**Related problems:**
- [Longest Substring K Distinct (LC 340)](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/)
- [Longest Repeating Character Replacement (LC 424)](https://leetcode.com/problems/longest-repeating-character-replacement/)

</details>

---

## üìê Solution Approaches

### Approach 1: Sliding Window with Hash Set

**Key Insight:** Maintain a set of characters in current window. When we find a duplicate, shrink from left until unique again.

```
s = "abcabcbb"

Window expansion:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Right ‚îÇ Char ‚îÇ Set Before     ‚îÇ Action              ‚îÇ Max ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   0   ‚îÇ 'a'  ‚îÇ {}             ‚îÇ Add 'a'             ‚îÇ  1  ‚îÇ
‚îÇ   1   ‚îÇ 'b'  ‚îÇ {a}            ‚îÇ Add 'b'             ‚îÇ  2  ‚îÇ
‚îÇ   2   ‚îÇ 'c'  ‚îÇ {a,b}          ‚îÇ Add 'c'             ‚îÇ  3  ‚îÇ
‚îÇ   3   ‚îÇ 'a'  ‚îÇ {a,b,c}        ‚îÇ 'a' exists! Remove until 'a' gone ‚îÇ
‚îÇ       ‚îÇ      ‚îÇ Remove 'a': {b,c} ‚îÇ Add 'a': {a,b,c} ‚îÇ  3  ‚îÇ
‚îÇ   4   ‚îÇ 'b'  ‚îÇ {a,b,c}        ‚îÇ 'b' exists! Remove until 'b' gone ‚îÇ
‚îÇ       ‚îÇ      ‚îÇ Remove 'b': {a,c} ‚îÇ Add 'b': {a,b,c} ‚îÇ  3  ‚îÇ
‚îÇ   ...continues...                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Approach 2: Sliding Window with Hash Map (Optimized)

**Key Insight:** Instead of removing one by one, store the last index of each character. Jump `left` directly to `last_index + 1`.

```
s = "abcabcbb"

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Right ‚îÇ Char ‚îÇ Map (char:index)     ‚îÇ Left ‚îÇ Window   ‚îÇ Max ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   0   ‚îÇ 'a'  ‚îÇ {a:0}                ‚îÇ  0   ‚îÇ [a]      ‚îÇ  1  ‚îÇ
‚îÇ   1   ‚îÇ 'b'  ‚îÇ {a:0, b:1}           ‚îÇ  0   ‚îÇ [ab]     ‚îÇ  2  ‚îÇ
‚îÇ   2   ‚îÇ 'c'  ‚îÇ {a:0, b:1, c:2}      ‚îÇ  0   ‚îÇ [abc]    ‚îÇ  3  ‚îÇ
‚îÇ   3   ‚îÇ 'a'  ‚îÇ {a:3, b:1, c:2}      ‚îÇ  1   ‚îÇ [bca]    ‚îÇ  3  ‚îÇ
‚îÇ   ‚îÇ 'a' seen at 0, left = max(0, 0+1) = 1                       ‚îÇ
‚îÇ   4   ‚îÇ 'b'  ‚îÇ {a:3, b:4, c:2}      ‚îÇ  2   ‚îÇ [cab]    ‚îÇ  3  ‚îÇ
‚îÇ   ‚îÇ 'b' seen at 1, left = max(1, 1+1) = 2                       ‚îÇ
‚îÇ   5   ‚îÇ 'c'  ‚îÇ {a:3, b:4, c:5}      ‚îÇ  3   ‚îÇ [abc]    ‚îÇ  3  ‚îÇ
‚îÇ   6   ‚îÇ 'b'  ‚îÇ {a:3, b:6, c:5}      ‚îÇ  5   ‚îÇ [cb]     ‚îÇ  3  ‚îÇ
‚îÇ   7   ‚îÇ 'b'  ‚îÇ {a:3, b:7, c:5}      ‚îÇ  7   ‚îÇ [b]      ‚îÇ  3  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Answer: 3
```

**Why `max(left, last_index + 1)`?**

The previous occurrence might be BEFORE the current window. Example:
```
s = "abba"
At index 3 ('a'):
- Map shows 'a' was at index 0
- But left is now at 2 (after handling 'bb')
- We don't want to move left backwards!
- left = max(2, 0+1) = 2 ‚úì
```

---

## üíª Code Implementation

### Python - Approach 1: Hash Set

```python
def lengthOfLongestSubstring(s: str) -> int:
    """
    Find longest substring without repeating characters.
    
    Algorithm:
    1. Use set to track chars in current window
    2. Expand right, adding chars to set
    3. If duplicate found, shrink left until unique
    4. Track maximum window size
    
    Time: O(n) - each char added and removed at most once
    Space: O(min(n, m)) where m = size of character set
    """
    char_set = set()
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # If duplicate, shrink window from left
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        
        # Add current character
        char_set.add(s[right])
        
        # Update max length
        max_length = max(max_length, right - left + 1)
    
    return max_length


# Example trace: s = "abcabcbb"
# right=0: 'a' not in {}, add 'a' ‚Üí {a}, max=1
# right=1: 'b' not in {a}, add 'b' ‚Üí {a,b}, max=2
# right=2: 'c' not in {a,b}, add 'c' ‚Üí {a,b,c}, max=3
# right=3: 'a' in {a,b,c}!
#          remove s[0]='a' ‚Üí {b,c}, left=1
#          'a' not in {b,c}, add 'a' ‚Üí {a,b,c}, max=3
# right=4: 'b' in {a,b,c}!
#          remove s[1]='b' ‚Üí {a,c}, left=2
#          'b' not in {a,c}, add 'b' ‚Üí {a,b,c}, max=3
# ... continues, max stays 3
```

### Python - Approach 2: Hash Map (Index Tracking)

```python
def lengthOfLongestSubstring(s: str) -> int:
    """
    Optimized version: track last index of each char.
    
    Instead of removing chars one by one, jump left pointer
    directly to position after the duplicate.
    
    Time: O(n) - single pass
    Space: O(min(n, m)) where m = character set size
    """
    char_index = {}  # char ‚Üí last seen index
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        char = s[right]
        
        # If char seen before AND within current window
        if char in char_index and char_index[char] >= left:
            # Jump left to position after previous occurrence
            left = char_index[char] + 1
        
        # Update last seen index
        char_index[char] = right
        
        # Update max length
        max_length = max(max_length, right - left + 1)
    
    return max_length


# Alternative: always use max() instead of checking >= left
def lengthOfLongestSubstring_v2(s: str) -> int:
    char_index = {}
    left = 0
    max_length = 0
    
    for right, char in enumerate(s):
        if char in char_index:
            left = max(left, char_index[char] + 1)
        
        char_index[char] = right
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

### Python - Using defaultdict and Counter

```python
from collections import defaultdict

def lengthOfLongestSubstring(s: str) -> int:
    """
    Using count-based approach: track frequency in window.
    """
    count = defaultdict(int)
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        count[s[right]] += 1
        
        # Shrink while we have duplicates
        while count[s[right]] > 1:
            count[s[left]] -= 1
            left += 1
        
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

### JavaScript - Approach 1: Set

```javascript
/**
 * Find longest substring without repeating characters.
 * 
 * @param {string} s - Input string
 * @return {number} - Length of longest valid substring
 * 
 * Time: O(n)
 * Space: O(min(n, m))
 */
function lengthOfLongestSubstring(s) {
    const charSet = new Set();
    let left = 0;
    let maxLength = 0;
    
    for (let right = 0; right < s.length; right++) {
        // Shrink window while duplicate exists
        while (charSet.has(s[right])) {
            charSet.delete(s[left]);
            left++;
        }
        
        // Add current character
        charSet.add(s[right]);
        
        // Update max
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}
```

### JavaScript - Approach 2: Map (Index Tracking)

```javascript
/**
 * Optimized version using index tracking.
 * 
 * @param {string} s
 * @return {number}
 */
function lengthOfLongestSubstring(s) {
    const charIndex = new Map();
    let left = 0;
    let maxLength = 0;
    
    for (let right = 0; right < s.length; right++) {
        const char = s[right];
        
        // If seen before and within window, jump left
        if (charIndex.has(char)) {
            left = Math.max(left, charIndex.get(char) + 1);
        }
        
        // Update index
        charIndex.set(char, right);
        
        // Update max
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}
```

### JavaScript - Using Array (ASCII optimization)

```javascript
/**
 * Using array for O(1) lookups (ASCII chars only).
 * 
 * @param {string} s
 * @return {number}
 */
function lengthOfLongestSubstring(s) {
    // Array of size 128 for ASCII characters
    // -1 means character not seen yet
    const charIndex = new Array(128).fill(-1);
    let left = 0;
    let maxLength = 0;
    
    for (let right = 0; right < s.length; right++) {
        const code = s.charCodeAt(right);
        
        // If seen before and within window
        if (charIndex[code] >= left) {
            left = charIndex[code] + 1;
        }
        
        charIndex[code] = right;
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Hash Set | O(n) | O(min(n, m)) | 2n operations worst case |
| Hash Map | O(n) | O(min(n, m)) | Single pass |
| Array (ASCII) | O(n) | O(1) = O(128) | Fastest for ASCII |

**Where:**
- n = length of string
- m = size of character set (26 for lowercase, 128 for ASCII, etc.)

**Detailed Analysis:**
```
Hash Set approach:
- Each character is added exactly once: O(n)
- Each character is removed at most once: O(n)
- Total: O(2n) = O(n)

Hash Map approach:
- Single pass through string: O(n)
- Each lookup/update is O(1)
- Total: O(n)
```

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| At most K repeats | Allow K duplicates | Custom |
| At most K distinct | Different constraint | LC 340 |
| With one replacement | Can replace one char | LC 424 |
| Longest unique after deletions | Different approach | Custom |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Checking Index Without Boundary

```python
# ‚ùå WRONG: Old index might be before current window
if char in char_index:
    left = char_index[char] + 1  # Might move left backwards!

# Example: s = "abba"
# At 'a' (index 3): char_index['a'] = 0, but left = 2
# Setting left = 0 + 1 = 1 is WRONG (moves backwards)

# ‚úÖ CORRECT: Use max to prevent moving backwards
if char in char_index:
    left = max(left, char_index[char] + 1)
```

### 2. Wrong Window Length Calculation

```python
# ‚ùå WRONG: Off by one
max_length = max(max_length, right - left)  # Missing +1!

# Window [2, 5] has length 5 - 2 + 1 = 4, not 3

# ‚úÖ CORRECT: Include both endpoints
max_length = max(max_length, right - left + 1)
```

### 3. Not Handling Empty String

```python
# ‚ùå RISKY: May have issues with empty input
def lengthOfLongestSubstring(s):
    # If no explicit check, loops don't execute, returns 0
    # This actually works, but worth being explicit
    pass

# ‚úÖ SAFER: Explicit check (optional but clear)
def lengthOfLongestSubstring(s):
    if not s:
        return 0
    # ... rest of code
```

### 4. Forgetting to Update Hash After Check

```python
# ‚ùå WRONG: Update before check causes issues
for right in range(len(s)):
    char_index[s[right]] = right  # Updated first!
    if s[right] in char_index:    # Always True now!
        left = char_index[s[right]] + 1  # Wrong!

# ‚úÖ CORRECT: Check first, then update
for right in range(len(s)):
    if s[right] in char_index:
        left = max(left, char_index[s[right]] + 1)
    char_index[s[right]] = right  # Update after check
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Key Insight |
|---------|------------|-------------|
| Longest Substring Without Repeating | üü° Medium | This problem |
| Longest Substring K Distinct | üü° Medium | Count distinct |
| Longest Repeating Replacement | üü° Medium | Allow K changes |
| Minimum Window Substring | üî¥ Hard | Find, not max |

**Related LeetCode:**
- [340. Longest Substring with At Most K Distinct](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/)
- [424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)
- [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand both approaches, implement set version
- **Day 3:** Implement map version without looking
- **Day 7:** Solve LC 340 or LC 424
- **Day 14:** Explain the `max(left, ...)` trick
- **Day 30:** < 10 min implementation

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Communication Template</strong></summary>

**1. Clarify (30 sec):**
> "So I need to find the longest contiguous substring where all characters are unique. What characters are possible - just lowercase letters?"

**2. Brute Force (optional):**
> "Brute force would check all substrings - O(n¬≤) substrings, O(n) to check each. We can do better."

**3. Optimal Approach:**
> "I'll use a sliding window with a hash set. Expand right, and if we hit a duplicate, shrink from left until unique again. Each character is added and removed at most once, so O(n) time."

**4. Code and explain:**
> "I'll track the window with left and right pointers, and use a set for O(1) membership checks."

**5. Follow-up optimization:**
> "I could optimize further by storing the last index of each character and jumping left directly to that position instead of shrinking one at a time."

</details>

**Company Frequency:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Top 3 most asked |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Classic |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask variations |
| Bloomberg | ‚≠ê‚≠ê‚≠ê‚≠ê | Frequent |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand problem | 2 min |
| Plan approach | 2 min |
| Implement (set) | 5-7 min |
| Implement (map) | 7-10 min |
| Test edge cases | 2 min |
| **Total** | **12-18 min** |

---

> **üí° Key Insight:** The sliding window maintains a valid substring (all unique). When we find a duplicate at position `right`, we shrink from `left` until the duplicate is removed. Using a hash map with indices lets us jump directly instead of removing one by one.

> **üîó Related:** [Sliding Window + Hash](./7.1-Sliding-Hash-Overview.md) | [Find All Anagrams](./7.3-Find-Anagrams-LC438.md) | [Hash Set Operations](../02-Hash-Map-Set/2.2-Hash-Set-Operations.md)
