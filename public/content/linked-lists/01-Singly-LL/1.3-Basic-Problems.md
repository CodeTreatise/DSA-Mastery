# 1.3 Basic Linked List Problems

> **Foundation:** Common interview problems using basic operations
>
> ‚è±Ô∏è Estimated Learning Time: 30-45 minutes

---

## Overview

This section covers essential linked list problems that test your understanding of traversal, pointer manipulation, and basic operations. These problems frequently appear in interviews and serve as building blocks for more complex algorithms.

**Problems covered:**
- Find length / count nodes
- Find Nth node from beginning/end
- Find middle element
- Count occurrences
- Print in reverse

---

## üéØ Pattern Recognition

<details>
<summary><strong>Common Problem Categories</strong></summary>

| Category | Examples | Key Technique |
|----------|----------|---------------|
| Counting | Length, occurrences | Simple traversal |
| Position-based | Nth node, middle | One or two pointers |
| Searching | Find value, check existence | Traversal with condition |
| Transformation | Print reverse | Recursion or stack |

</details>

---

## ‚úÖ When to Apply These Techniques

- **Single traversal** - Length, search, count
- **Two pointers** - Middle, Nth from end
- **Recursion** - Reverse operations, from-end problems
- **Stack** - Reverse printing without modifying list

---

## ‚ùå Common Pitfalls

| Problem | Pitfall | Solution |
|---------|---------|----------|
| Find length | Infinite loop on cycle | Use fast/slow or visited set |
| Nth from end | Off-by-one | Verify with examples |
| Find middle | Odd vs even handling | Know which middle you return |
| Count occurrences | Missing null check | Check empty list first |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Linked List Basics](./1.1-Basics.md) - Node structure
- [Basic Operations](./1.2-Operations.md) - Traversal, insert, delete

**After mastering this:**
- [Fast & Slow Pointer](../04-Fast-Slow-Pointer/4.1-Concept.md) - Cycle detection, middle finding
- [In-Place Reversal](../05-In-Place-Reversal/5.1-Reversal-Technique.md) - Actual reversal
- [Two Pointer Problems](../07-Two-Pointer-Problems/) - Advanced techniques

</details>

---

## üìê Problems with Solutions

### Problem 1: Find Length of Linked List

Count the number of nodes in the list.

```
Input:  1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí null
Output: 4
```

**Python:**
```python
def get_length(head: ListNode) -> int:
    """
    Count nodes in linked list.
    Time: O(n), Space: O(1)
    """
    count = 0
    current = head
    while current:
        count += 1
        current = current.next
    return count


def get_length_recursive(head: ListNode) -> int:
    """Recursive version - O(n) space for call stack."""
    if not head:
        return 0
    return 1 + get_length_recursive(head.next)
```

**JavaScript:**
```javascript
function getLength(head) {
    let count = 0;
    let current = head;
    while (current) {
        count++;
        current = current.next;
    }
    return count;
}
```

---

### Problem 2: Find Nth Node from Beginning

Get the node at position n (0-indexed or 1-indexed based on requirement).

```
Input:  1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí null, n = 2 (0-indexed)
Output: Node(3)
```

**Python:**
```python
def get_nth_node(head: ListNode, n: int) -> ListNode:
    """
    Get node at index n (0-indexed).
    Time: O(n), Space: O(1)
    Returns None if n is out of bounds.
    """
    if n < 0:
        return None
    
    current = head
    for _ in range(n):
        if not current:
            return None  # n exceeds list length
        current = current.next
    
    return current  # May be None if n == length
```

**JavaScript:**
```javascript
function getNthNode(head, n) {
    if (n < 0) return null;
    
    let current = head;
    for (let i = 0; i < n; i++) {
        if (!current) return null;
        current = current.next;
    }
    return current;
}
```

---

### Problem 3: Find Nth Node from End (LC 19 variant)

Get the node that is n positions from the end.

```
Input:  1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí null, n = 2
Output: Node(4) (second from end)
```

**Approach 1: Two-Pass (Simple)**

**Python:**
```python
def get_nth_from_end_two_pass(head: ListNode, n: int) -> ListNode:
    """
    Two-pass approach: count length, then traverse.
    Time: O(n), Space: O(1)
    """
    # First pass: get length
    length = 0
    current = head
    while current:
        length += 1
        current = current.next
    
    # Check if n is valid
    if n > length or n <= 0:
        return None
    
    # Second pass: traverse to (length - n)th node
    current = head
    for _ in range(length - n):
        current = current.next
    
    return current
```

**Approach 2: Two-Pointer (One-Pass)**

```
The key insight: If we have two pointers n apart,
when the front pointer reaches the end, 
the back pointer is n positions from the end.

Start:  [1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí [5] ‚Üí null
         ‚Üë                        ‚Üë
        back                    front (n=2 ahead)

Move both:
        [1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí [5] ‚Üí null
               ‚Üë                       ‚Üë
              back                   front‚Üínull

When front is null, back is at [4] (2nd from end)
```

**Python:**
```python
def get_nth_from_end_one_pass(head: ListNode, n: int) -> ListNode:
    """
    One-pass approach: two pointers with gap of n.
    Time: O(n), Space: O(1)
    """
    if n <= 0:
        return None
    
    fast = head
    slow = head
    
    # Move fast n steps ahead
    for _ in range(n):
        if not fast:
            return None  # n is larger than length
        fast = fast.next
    
    # Move both until fast reaches null
    while fast:
        slow = slow.next
        fast = fast.next
    
    return slow
```

**JavaScript:**
```javascript
function getNthFromEnd(head, n) {
    if (n <= 0) return null;
    
    let fast = head;
    let slow = head;
    
    // Move fast n steps ahead
    for (let i = 0; i < n; i++) {
        if (!fast) return null;
        fast = fast.next;
    }
    
    // Move both until fast is null
    while (fast) {
        slow = slow.next;
        fast = fast.next;
    }
    
    return slow;
}
```

---

### Problem 4: Find Middle Element (LC 876)

Find the middle node of the list. For even length, return the second middle.

```
Input:  1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí null
Output: Node(3)

Input:  1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí null
Output: Node(3) (second middle)
```

**Python:**
```python
def find_middle(head: ListNode) -> ListNode:
    """
    Find middle using slow and fast pointers.
    Time: O(n), Space: O(1)
    
    For even length, returns second middle.
    """
    if not head:
        return None
    
    slow = head
    fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow


def find_first_middle(head: ListNode) -> ListNode:
    """
    For even length, returns first middle.
    Useful for splitting list into two equal halves.
    """
    if not head:
        return None
    
    slow = head
    fast = head
    
    # Stop one step earlier
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow
```

**JavaScript:**
```javascript
function findMiddle(head) {
    if (!head) return null;
    
    let slow = head;
    let fast = head;
    
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    return slow;
}
```

---

### Problem 5: Count Occurrences of Value

Count how many times a value appears in the list.

```
Input:  1 ‚Üí 2 ‚Üí 1 ‚Üí 3 ‚Üí 1 ‚Üí null, val = 1
Output: 3
```

**Python:**
```python
def count_occurrences(head: ListNode, val) -> int:
    """
    Count occurrences of val in list.
    Time: O(n), Space: O(1)
    """
    count = 0
    current = head
    while current:
        if current.val == val:
            count += 1
        current = current.next
    return count
```

**JavaScript:**
```javascript
function countOccurrences(head, val) {
    let count = 0;
    let current = head;
    while (current) {
        if (current.val === val) count++;
        current = current.next;
    }
    return count;
}
```

---

### Problem 6: Print Linked List in Reverse

Print values from tail to head without modifying the list.

```
Input:  1 ‚Üí 2 ‚Üí 3 ‚Üí null
Output: 3 2 1 (printed)
```

**Approach 1: Recursive**

**Python:**
```python
def print_reverse_recursive(head: ListNode) -> None:
    """
    Print in reverse using recursion.
    Time: O(n), Space: O(n) call stack
    """
    if not head:
        return
    
    # First, recurse to the end
    print_reverse_recursive(head.next)
    # Then print on the way back
    print(head.val, end=' ')


# Usage: print_reverse_recursive(head)
```

**Approach 2: Using Stack**

**Python:**
```python
def print_reverse_stack(head: ListNode) -> None:
    """
    Print in reverse using explicit stack.
    Time: O(n), Space: O(n)
    """
    stack = []
    current = head
    
    while current:
        stack.append(current.val)
        current = current.next
    
    while stack:
        print(stack.pop(), end=' ')
```

**JavaScript:**
```javascript
function printReverseRecursive(head) {
    if (!head) return;
    printReverseRecursive(head.next);
    console.log(head.val);
}

function printReverseStack(head) {
    const stack = [];
    let current = head;
    
    while (current) {
        stack.push(current.val);
        current = current.next;
    }
    
    while (stack.length) {
        console.log(stack.pop());
    }
}
```

---

## üíª Complete Problem Set

### Summary Table

| Problem | Time | Space | Key Technique |
|---------|------|-------|---------------|
| Get length |" O(n) "| O(1) | Simple traversal |
| Get Nth node |" O(n) "| O(1) | Traverse n steps |
| Nth from end (2 pass) |" O(n) "| O(1) | Count then traverse |
| Nth from end (1 pass) |" O(n) "| O(1) | Two pointers with gap |
| Find middle |" O(n) "| O(1) | Fast and slow pointers |
| Count occurrences |" O(n) "| O(1) | Traversal with counter |
| Print reverse |" O(n) "| O(n) | Recursion or stack |

---

## ‚ö° Complexity Analysis

All problems are **O(n) time** since we need to traverse the list.

**Space varies:**
- O(1): Most iterative solutions
- O(n): Recursive solutions (call stack) or stack-based

---

## üîÑ Variations

| Base Problem | Variation | Change |
|--------------|-----------|--------|
| Find middle | First vs second middle | Different stop condition |
| Nth from end | Remove Nth from end | Deletion instead of retrieval |
| Count occurrences | Remove all occurrences | Delete instead of count |
| Print reverse | Actually reverse | Modify pointers |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Off-by-One Errors

```python
# Nth from end: Is n 0-indexed or 1-indexed?
# Always clarify! LeetCode uses 1-indexed.

# ‚ùå Wrong assumption
# n=1 means last node, not second-to-last
```

### 2. Not Handling Edge Cases

```python
# Always check:
# - Empty list (head = None)
# - Single node
# - n larger than list length
# - n = 0 (invalid in some contexts)
```

### 3. Modifying Original List

```python
# ‚ùå Wrong - modifies head
def get_length(head):
    count = 0
    while head:  # Using head directly!
        count += 1
        head = head.next
    return count
# After this, head is None!

# ‚úÖ Correct - use separate pointer
def get_length(head):
    count = 0
    current = head
    while current:
        count += 1
        current = current.next
    return count
```

---

## üìù Practice Problems (Progressive)

### Easy (Apply basics)
- [ ] [Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) - LC 876
- [ ] [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) - LC 141

### Medium (Extend techniques)
- [ ] [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) - LC 19
- [ ] [Delete Node in a Linked List](https://leetcode.com/problems/delete-node-in-a-linked-list/) - LC 237

### Related
- [ ] [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) - LC 206

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**For basic problems:**
- **Day 1:** Implement all 6 problems from memory
- **Day 3:** Focus on two-pointer techniques (middle, nth from end)
- **Day 7:** Solve LC 876 and LC 19
- **Day 14:** Review edge cases for each problem
- **Day 30:** Re-implement entire set without reference

</details>

---

## üé§ Interview Context

<details>
<summary><strong>What Interviewers Look For</strong></summary>

**For these problems, interviewers evaluate:**
1. Can you think of multiple approaches?
2. Do you know the two-pointer technique?
3. Can you handle edge cases?
4. Is your code clean and bug-free?

**Common follow-up questions:**
- "Can you do it in one pass?" ‚Üí Two pointers
- "What if the list has a cycle?" ‚Üí Fast/slow handles it
- "What about memory usage?" ‚Üí Iterative vs recursive

</details>

**Company Focus:**

| Company | Common Problems | Notes |
|---------|-----------------|-------|
| Amazon | Middle, Nth from end | Often as warm-up |
| Meta | All basics | Clean code focus |
| Google | May ask optimization | One-pass solutions |
| Microsoft | Standard problems | Edge cases important |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn all problems | 30-45 min | Core concepts |
| Practice each | 10-15 min | Per problem |
| Master techniques | 1-2 hours | All variations |
| Interview prep | 2-3 problems | Quick practice |

---

> **üí° Key Insight:** The two-pointer technique (fast/slow or gap technique) converts many two-pass problems into one-pass solutions. For middle: fast goes 2x speed. For Nth from end: create N gap between pointers.

---

## üîó Related

- [Linked List Basics](./1.1-Basics.md) - Node structure
- [Basic Operations](./1.2-Operations.md) - CRUD operations
- [Fast & Slow Pointer](../04-Fast-Slow-Pointer/4.1-Concept.md) - Pattern deep dive
- [Two Pointer Problems](../07-Two-Pointer-Problems/) - More applications
