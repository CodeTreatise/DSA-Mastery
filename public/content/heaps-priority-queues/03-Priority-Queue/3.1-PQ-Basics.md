# 3.1 Priority Queue Basics

## Definition

A **Priority Queue** is an abstract data type (ADT) where each element has an associated priority, and elements are served based on their priority rather than their insertion order.

```
Regular Queue (FIFO):      vs      Priority Queue:

Enqueue: A ‚Üí B ‚Üí C                 Enqueue: A(3) ‚Üí B(1) ‚Üí C(2)
Dequeue: A, B, C                   Dequeue: B(1), C(2), A(3)
                                   (lowest priority value first)
```

**Key distinction:** Priority Queue is a **concept** (ADT), while Heap is an **implementation**.

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Priority Queue</strong></summary>

**Key signals:**
- "Process by priority/importance"
- "Get minimum/maximum repeatedly"
- "Schedule tasks by deadline"
- "Always need best/worst element"
- "Merge sorted streams"

**Problem keywords:**
- "Kth largest/smallest"
- "Top K elements"
- "Median in stream"
- "Shortest path" (Dijkstra)
- "Minimum spanning tree" (Prim)
- "Task scheduling"

</details>

---

## ‚úÖ When to Use

| Scenario | Why Priority Queue? |
|----------|---------------------|
| Repeated min/max extraction |" O(log n) per operation "|
| Task scheduling | Process by priority |
| Dijkstra's algorithm | Get minimum distance node |
| Merge K sorted lists | Get smallest across lists |
| Top K elements | Maintain K best |
| Median in stream | Track middle element |

## ‚ùå When NOT to Use

| Scenario | Better Alternative | Why |
|----------|---------------------|-----|
| Single min/max |" One-pass scan O(n) "| No need for structure |
| Random access by priority | Balanced BST | BST allows search |
| Need all sorted | Sort array | heapsort is in-place |
| Small static data | Simple array | Overhead not worth it |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What is a Heap](../01-Heap-Fundamentals/1.1-What-Is-Heap.md)
- [Heap Operations](../02-Heap-Operations/2.1-Insert.md)
- Basic queue concept (FIFO)

**After mastering this:**
- [Priority Queue Implementation](./3.2-PQ-Implementation.md)
- [Top K Pattern](../04-Top-K-Pattern/4.1-Top-K-Overview.md)
- Dijkstra's Algorithm (Graphs unit)

**Related concepts:**
- Abstract Data Type (ADT)
- Interface vs Implementation

</details>

---

## üìê How It Works

### ADT vs Implementation

```
Priority Queue (ADT) - The "What"
‚îú‚îÄ‚îÄ enqueue(element, priority)  - Add with priority
‚îú‚îÄ‚îÄ dequeue()                   - Remove highest priority
‚îú‚îÄ‚îÄ peek()                      - View highest priority
‚îî‚îÄ‚îÄ isEmpty()                   - Check if empty

Implementation Options (The "How"):
‚îú‚îÄ‚îÄ Binary Heap ‚≠ê (Most common)
‚îÇ   ‚îú‚îÄ‚îÄ enqueue: O(log n)
‚îÇ   ‚îú‚îÄ‚îÄ dequeue: O(log n)
‚îÇ   ‚îî‚îÄ‚îÄ peek: O(1)
‚îú‚îÄ‚îÄ Unsorted Array
‚îÇ   ‚îú‚îÄ‚îÄ enqueue: O(1)
‚îÇ   ‚îú‚îÄ‚îÄ dequeue: O(n) ‚ùå
‚îÇ   ‚îî‚îÄ‚îÄ peek: O(n) ‚ùå
‚îú‚îÄ‚îÄ Sorted Array
‚îÇ   ‚îú‚îÄ‚îÄ enqueue: O(n) ‚ùå
‚îÇ   ‚îú‚îÄ‚îÄ dequeue: O(1)
‚îÇ   ‚îî‚îÄ‚îÄ peek: O(1)
‚îú‚îÄ‚îÄ Balanced BST
‚îÇ   ‚îú‚îÄ‚îÄ enqueue: O(log n)
‚îÇ   ‚îú‚îÄ‚îÄ dequeue: O(log n)
‚îÇ   ‚îî‚îÄ‚îÄ peek: O(log n)
‚îî‚îÄ‚îÄ Fibonacci Heap
    ‚îú‚îÄ‚îÄ enqueue: O(1) amortized
    ‚îú‚îÄ‚îÄ dequeue: O(log n) amortized
    ‚îî‚îÄ‚îÄ decrease-key: O(1) amortized
```

### Why Heap is the Go-To Implementation

```
For n operations:

Implementation      Total Time       Practical Speed
Binary Heap         O(n log n)       ‚≠ê Fast, simple
Unsorted Array      O(n¬≤)            ‚ùå Too slow
Sorted Array        O(n¬≤)            ‚ùå Too slow
Balanced BST        O(n log n)       Good, more complex
Fibonacci Heap      O(n)             Best theory, complex practice
```

### Priority Queue Operations

```
Min-Priority Queue Example:

Initial: empty

enqueue("Task A", 3):
   [Task A(3)]

enqueue("Task B", 1):
   [Task B(1), Task A(3)]
   (B has higher priority = lower number)

enqueue("Task C", 2):
   [Task B(1), Task A(3), Task C(2)]
   ‚Üí After heapify: [Task B(1), Task C(2), Task A(3)] (conceptually)

peek():
   Returns Task B (priority 1, highest)

dequeue():
   Returns Task B, removes it
   [Task C(2), Task A(3)]

dequeue():
   Returns Task C
   [Task A(3)]
```

---

## üíª Code Implementation

### Python Priority Queue Options

**Python:**
```python
import heapq
from queue import PriorityQueue
from dataclasses import dataclass, field
from typing import Any

# Option 1: heapq (Most common for competitive programming)
# =========================================================
def heapq_demo():
    """
    heapq provides min-heap operations on a list.
    Priority = element value (smaller = higher priority)
    """
    pq = []
    
    # Enqueue (push)
    heapq.heappush(pq, 3)
    heapq.heappush(pq, 1)
    heapq.heappush(pq, 2)
    
    # Peek
    print(f"Peek: {pq[0]}")  # 1
    
    # Dequeue (pop)
    print(f"Dequeue: {heapq.heappop(pq)}")  # 1
    print(f"Dequeue: {heapq.heappop(pq)}")  # 2
    print(f"Dequeue: {heapq.heappop(pq)}")  # 3


# Option 2: PriorityQueue (Thread-safe, for production)
# ======================================================
def priority_queue_demo():
    """
    queue.PriorityQueue is thread-safe.
    Use for multi-threaded applications.
    """
    pq = PriorityQueue()
    
    pq.put(3)
    pq.put(1)
    pq.put(2)
    
    print(f"Dequeue: {pq.get()}")  # 1
    print(f"Dequeue: {pq.get()}")  # 2
    print(f"Empty: {pq.empty()}")  # False


# Option 3: With custom objects (using tuples)
# =============================================
def custom_priority_demo():
    """
    Use tuples: (priority, data)
    heapq compares by first element, then second if tie.
    """
    pq = []
    
    heapq.heappush(pq, (3, "Task A"))
    heapq.heappush(pq, (1, "Task B"))
    heapq.heappush(pq, (2, "Task C"))
    
    while pq:
        priority, task = heapq.heappop(pq)
        print(f"Priority {priority}: {task}")
    # Output: Priority 1: Task B, Priority 2: Task C, Priority 3: Task A


# Option 4: With dataclass (cleanest for complex objects)
# ========================================================
@dataclass(order=True)
class PrioritizedItem:
    priority: int
    item: Any = field(compare=False)  # Don't compare item

def dataclass_demo():
    """
    Use dataclass with order=True for comparable objects.
    field(compare=False) excludes item from comparison.
    """
    pq = []
    
    heapq.heappush(pq, PrioritizedItem(3, "Task A"))
    heapq.heappush(pq, PrioritizedItem(1, "Task B"))
    heapq.heappush(pq, PrioritizedItem(2, "Task C"))
    
    while pq:
        entry = heapq.heappop(pq)
        print(f"Priority {entry.priority}: {entry.item}")
```

**JavaScript:**
```javascript
// JavaScript doesn't have built-in Priority Queue
// Use a simple MinHeap implementation

class PriorityQueue {
    constructor(compareFn = (a, b) => a - b) {
        this.heap = [];
        this.compare = compareFn;
    }
    
    get size() { return this.heap.length; }
    isEmpty() { return this.size === 0; }
    
    enqueue(element) {
        this.heap.push(element);
        this._bubbleUp(this.size - 1);
    }
    
    dequeue() {
        if (this.isEmpty()) return undefined;
        
        const min = this.heap[0];
        const last = this.heap.pop();
        
        if (!this.isEmpty()) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        
        return min;
    }
    
    peek() {
        return this.heap[0];
    }
    
    _bubbleUp(index) {
        while (index > 0) {
            const parent = Math.floor((index - 1) / 2);
            if (this.compare(this.heap[parent], this.heap[index]) <= 0) break;
            [this.heap[parent], this.heap[index]] = [this.heap[index], this.heap[parent]];
            index = parent;
        }
    }
    
    _bubbleDown(index) {
        const n = this.size;
        while (true) {
            let smallest = index;
            const left = 2 * index + 1;
            const right = 2 * index + 2;
            
            if (left < n && this.compare(this.heap[left], this.heap[smallest]) < 0) {
                smallest = left;
            }
            if (right < n && this.compare(this.heap[right], this.heap[smallest]) < 0) {
                smallest = right;
            }
            
            if (smallest === index) break;
            
            [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];
            index = smallest;
        }
    }
}

// Usage
const pq = new PriorityQueue();
pq.enqueue(3);
pq.enqueue(1);
pq.enqueue(2);

console.log(pq.dequeue()); // 1
console.log(pq.dequeue()); // 2
console.log(pq.dequeue()); // 3

// With custom comparator (max priority queue)
const maxPQ = new PriorityQueue((a, b) => b - a);
maxPQ.enqueue(3);
maxPQ.enqueue(1);
maxPQ.enqueue(2);
console.log(maxPQ.dequeue()); // 3

// With objects
const taskPQ = new PriorityQueue((a, b) => a.priority - b.priority);
taskPQ.enqueue({ task: "Task A", priority: 3 });
taskPQ.enqueue({ task: "Task B", priority: 1 });
taskPQ.enqueue({ task: "Task C", priority: 2 });
console.log(taskPQ.dequeue()); // { task: "Task B", priority: 1 }
```

---

## ‚ö° Complexity Analysis

| Operation | Heap | Unsorted Array | Sorted Array | BST |
|-----------|------|----------------|--------------|-----|
| enqueue |" O(log n) "| O(1) |" O(n) "| O(log n) |
| dequeue |" O(log n) "| O(n) |" O(1)* "| O(log n) |
| peek |" O(1) "| O(n) |" O(1) "| O(log n) |
| build |" O(n) "| O(n) |" O(n log n) "| O(n log n) |

*O(1) if removing from end, O(n) if from beginning

**Why heap wins:**
```
For n enqueue + n dequeue operations:

Heap:           O(n log n) total
Unsorted Array: O(n¬≤) total  (n dequeues * O(n) each)
Sorted Array:   O(n¬≤) total  (n enqueues * O(n) each)

Heap is optimal for balanced read/write workloads.
```

---

## üîÑ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| **Min-PQ** | Smallest priority first | Default, Dijkstra |
| **Max-PQ** | Largest priority first | Top K largest |
| **Indexed PQ** | Update priority by key | Dijkstra with decrease-key |
| **Double-ended PQ** | Min and max access | Min-max heap |
| **Stable PQ** | FIFO for same priority | Task scheduling |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Confusing Priority Queue with Heap

```python
# Priority Queue = Abstract concept (what it does)
# Heap = Implementation (how it's done)

# You can implement PQ with:
# - Binary heap (most common)
# - Sorted array
# - Balanced BST
# - Fibonacci heap
```

### 2. Forgetting heapq is Min-Heap

```python
import heapq

# ‚ùå Expecting max-heap behavior
pq = [5, 3, 8, 1]
heapq.heapify(pq)
print(heapq.heappop(pq))  # 1, not 8!

# ‚úÖ For max-heap, negate values
max_pq = [-x for x in [5, 3, 8, 1]]
heapq.heapify(max_pq)
print(-heapq.heappop(max_pq))  # 8
```

### 3. Comparing Non-Comparable Objects

```python
import heapq

# ‚ùå Wrong: Objects without comparison
class Task:
    def __init__(self, name):
        self.name = name

heapq.heappush([], Task("A"))
heapq.heappush([], Task("B"))  # TypeError!

# ‚úÖ Correct: Use tuple with priority
heapq.heappush([], (1, "task_id", Task("A")))

# Or use dataclass with order=True
```

### 4. Modifying Priority After Insertion

```python
import heapq

# ‚ö†Ô∏è Priority queues don't support decrease-key efficiently
pq = [(5, "node1"), (3, "node2")]
heapq.heapify(pq)

# Can't directly update node1's priority to 2
# Workaround: Insert new, mark old as invalid (lazy deletion)
```

---

## üìù Practice Problems (Progressive)

### Easy (Understand concept)
- [ ] [Last Stone Weight (LC 1046)](https://leetcode.com/problems/last-stone-weight/)
- [ ] [Kth Largest Element in a Stream (LC 703)](https://leetcode.com/problems/kth-largest-element-in-a-stream/)

### Medium (Apply patterns)
- [ ] [Kth Largest Element in an Array (LC 215)](https://leetcode.com/problems/kth-largest-element-in-an-array/)
- [ ] [Top K Frequent Elements (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/)
- [ ] [Task Scheduler (LC 621)](https://leetcode.com/problems/task-scheduler/)

### Hard (Master)
- [ ] [Find Median from Data Stream (LC 295)](https://leetcode.com/problems/find-median-from-data-stream/)
- [ ] [Merge K Sorted Lists (LC 23)](https://leetcode.com/problems/merge-k-sorted-lists/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement PQ with heapq
- **Day 3:** Implement from scratch
- **Day 7:** Solve Top K problem
- **Day 14:** Apply to graph algorithm
- **Day 30:** Optimize with indexed PQ

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Explain This in Interviews</strong></summary>

**Describing Priority Queue:**
"A Priority Queue is an abstract data type where elements are processed by priority rather than insertion order. It supports enqueue, dequeue, and peek operations. The most common implementation is a binary heap, which gives O(log n) for insert and extract, and O(1) for peek."

**When to suggest it:**
"I'm seeing we need to repeatedly get the minimum element. This suggests a Priority Queue, which I'll implement using a min-heap. This gives us O(log n) per extraction instead of O(n) with a simple array scan."

**Implementation choice:**
"In Python, I'll use heapq which provides min-heap operations. For a max-heap, I'll negate values. For custom objects, I'll use tuples with priority as the first element."

</details>

**Company Focus:**

| Company | Frequency | Common Problems |
|---------|-----------|-----------------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Scheduling, Top K |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Stream processing |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Graph algorithms |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Task scheduling |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 15-20 min | ADT vs implementation |
| Use heapq | 10-15 min | Python built-in |
| Implement from scratch | 30-45 min | With bubble up/down |
| Apply to problems | 20-30 min | Per problem |

---

## üí° Key Insight

> **Priority Queue is the "what" (abstraction), Heap is the "how" (implementation).** A Priority Queue guarantees you can always efficiently get the highest-priority element. A binary heap achieves this with O(log n) insert/extract and O(1) peek, making it the go-to implementation for most problems.

---

## üîó Related

- **Previous:** [Replace Operations](../02-Heap-Operations/2.5-Replace.md)
- **Next:** [Priority Queue Implementation](./3.2-PQ-Implementation.md)
- **Patterns:** [Top K](../04-Top-K-Pattern/4.1-Top-K-Overview.md) | [Two Heaps](../05-Two-Heaps-Pattern/5.1-Two-Heaps-Overview.md)
