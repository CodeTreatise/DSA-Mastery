# 4.2 Queue Using Stacks (LC 232)

> **Grokking Pattern:** #7 Stacks - Design
>
> **Difficulty:** Easy | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Classic Interview Problem

---

## Problem Statement

Implement a first-in-first-out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).

Implement the `MyQueue` class:
- `void push(int x)` - Pushes element x to the back of the queue
- `int pop()` - Removes the element from the front and returns it
- `int peek()` - Returns the element at the front
- `boolean empty()` - Returns true if the queue is empty

**You must use only standard stack operations.**

```
Example:
MyQueue myQueue = new MyQueue();
myQueue.push(1);    // queue: [1]
myQueue.push(2);    // queue: [1, 2]
myQueue.peek();     // returns 1
myQueue.pop();      // returns 1, queue: [2]
myQueue.empty();    // returns false
```

[LeetCode 232 - Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Implement X using Y" (data structure conversion)
- Need to reverse the order of operations
- Stack is LIFO, Queue is FIFO ‚Üí need to reverse

**Key insight:**
Two stacks can simulate a queue:
- One stack for input (push)
- One stack for output (pop/peek)
- Transfer between them reverses order twice ‚Üí original order!

</details>

---

## ‚úÖ When to Use This Approach

- When only stack operations are allowed
- BFS simulation with stack-only language
- Understanding data structure internals

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Language has native queue | Unnecessary complexity | collections.deque, Queue |
|" Need O(1) worst-case "| Amortized O(1) only | Circular array queue |
| High-frequency real-time |" Occasional O(n) pop "| Native queue |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md)
- [Queue Basics](../05-Queue-Fundamentals/5.1-Queue-Basics.md)
- LIFO vs FIFO ordering

**After mastering this:**
- [Stack Using Queues](./4.3-Stack-Using-Queues.md) - Reverse problem
- [Min Stack](./4.1-Min-Stack.md) - Similar design thinking
- [BFS with Stack](link) - Application

**This demonstrates:**
- Data structure simulation
- Amortized analysis
- Lazy evaluation pattern

</details>

---

## üìê How It Works

### Core Insight

```
Stack: LIFO (Last In First Out)   [1,2,3] ‚Üí pop ‚Üí 3
Queue: FIFO (First In First Out)  [1,2,3] ‚Üí pop ‚Üí 1

Two reversals = original order!
Stack1 ‚Üí Stack2 reverses: [1,2,3] ‚Üí [3,2,1]
Pop from Stack2: returns 1, 2, 3 (FIFO!)
```

### Two-Stack Approach

```
INPUT STACK        OUTPUT STACK
(for push)         (for pop/peek)

Push(1): [1]         []
Push(2): [1,2]       []
Push(3): [1,2,3]     []

Pop(): Transfer all to output
         []         [3,2,1]
       Pop from output ‚Üí returns 1

Pop():   []         [3,2]
       Pop from output ‚Üí returns 2

Push(4): [4]        [3]
(can push while output not empty!)

Pop():   [4]        []
       Output empty, transfer: [] [4]
       Wait, that's wrong! Let me redo...

Actually: when output empty, transfer ALL from input
         []         [4]
       Pop ‚Üí returns 3
       
Hmm, let me trace more carefully:

Push(4): [4]        [3]    ‚Üê output still has 3
Pop():   [4]        [3]    ‚Üí pop from output ‚Üí returns 3
Pop():   [4]        []     ‚Üê output now empty
         Transfer: []      [4]
         Pop ‚Üí returns 4
```

### Visual Walkthrough

```
Initial: input=[], output=[]

push(1): input=[1], output=[]
push(2): input=[1,2], output=[]

peek(): output empty ‚Üí transfer
        input=[], output=[2,1]
        return output[-1] ‚Üí 1

pop():  output=[2,1]
        pop output[-1] ‚Üí return 1
        output=[2]

push(3): input=[3], output=[2]
         (push always goes to input)

pop():  output=[2] not empty
        pop output[-1] ‚Üí return 2
        output=[]

pop():  output=[] empty ‚Üí transfer from input
        input=[], output=[3]
        pop ‚Üí return 3
```

---

## üíª Code Implementation

### Solution: Two Stacks (Amortized O(1))

**Python:**
```python
class MyQueue:
    """
    Queue implemented with two stacks.
    
    Approach:
    - input_stack: receives all push operations
    - output_stack: serves all pop/peek operations
    - Transfer from input to output only when output is empty
    
    Time: Amortized O(1) for all operations
    Space: O(n)
    """
    
    def __init__(self):
        self.input_stack = []   # For push
        self.output_stack = []  # For pop/peek
    
    def push(self, x: int) -> None:
        """Push to back of queue. Always O(1)."""
        self.input_stack.append(x)
    
    def _transfer(self) -> None:
        """Transfer all elements from input to output.
        
        This reverses the order, making LIFO ‚Üí FIFO.
        Only called when output is empty.
        """
        while self.input_stack:
            self.output_stack.append(self.input_stack.pop())
    
    def pop(self) -> int:
        """Remove and return front element. Amortized O(1)."""
        if not self.output_stack:
            self._transfer()
        return self.output_stack.pop()
    
    def peek(self) -> int:
        """Return front element without removing. Amortized O(1)."""
        if not self.output_stack:
            self._transfer()
        return self.output_stack[-1]
    
    def empty(self) -> bool:
        """Check if queue is empty. O(1)."""
        return not self.input_stack and not self.output_stack


# Alternative with explicit size tracking
class MyQueueWithSize:
    def __init__(self):
        self.input_stack = []
        self.output_stack = []
        self._size = 0
    
    def push(self, x: int) -> None:
        self.input_stack.append(x)
        self._size += 1
    
    def pop(self) -> int:
        if not self.output_stack:
            while self.input_stack:
                self.output_stack.append(self.input_stack.pop())
        self._size -= 1
        return self.output_stack.pop()
    
    def peek(self) -> int:
        if not self.output_stack:
            while self.input_stack:
                self.output_stack.append(self.input_stack.pop())
        return self.output_stack[-1]
    
    def empty(self) -> bool:
        return self._size == 0
    
    def size(self) -> int:
        return self._size
```

**JavaScript:**
```javascript
/**
 * Queue implemented with two stacks.
 * Time: Amortized O(1) for all operations
 * Space: O(n)
 */
class MyQueue {
    constructor() {
        this.inputStack = [];  // For push
        this.outputStack = []; // For pop/peek
    }
    
    /**
     * Push element to back of queue.
     * @param {number} x
     * @return {void}
     */
    push(x) {
        this.inputStack.push(x);
    }
    
    /**
     * Transfer from input to output when output empty.
     * @private
     */
    _transfer() {
        while (this.inputStack.length > 0) {
            this.outputStack.push(this.inputStack.pop());
        }
    }
    
    /**
     * Remove and return front element.
     * @return {number}
     */
    pop() {
        if (this.outputStack.length === 0) {
            this._transfer();
        }
        return this.outputStack.pop();
    }
    
    /**
     * Return front element without removing.
     * @return {number}
     */
    peek() {
        if (this.outputStack.length === 0) {
            this._transfer();
        }
        return this.outputStack[this.outputStack.length - 1];
    }
    
    /**
     * Check if queue is empty.
     * @return {boolean}
     */
    empty() {
        return this.inputStack.length === 0 && this.outputStack.length === 0;
    }
}
```

---

## ‚ö° Complexity Analysis

| Operation | Amortized Time | Worst Case | Space |
|-----------|----------------|------------|-------|
| push |" O(1) "| O(1) | - |
| pop |" O(1) "| O(n) | - |
| peek |" O(1) "| O(n) | - |
| empty |" O(1) "| O(1) | - |
| Overall | - | - |" O(n) "|

### Why Amortized O(1)?

Each element is:
1. Pushed to input_stack once: O(1)
2. Popped from input_stack once: O(1)
3. Pushed to output_stack once: O(1)
4. Popped from output_stack once: O(1)

Total: 4 operations per element ‚Üí O(4n) for n elements ‚Üí O(1) per operation amortized.

**Worst case O(n):** When output is empty and we need to transfer all n elements.

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Stack using Queues | Reverse conversion | LC 225 |
|" O(1) push, O(n) pop "| Transfer on every pop | Simpler but slower |
| With max/min | Add auxiliary tracking | Custom |
| Thread-safe | Add locks | Production systems |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Transferring on Every Operation

```python
# ‚ùå WRONG: O(n) every time
def pop(self):
    while self.input_stack:
        self.output_stack.append(self.input_stack.pop())
    val = self.output_stack.pop()
    while self.output_stack:
        self.input_stack.append(self.output_stack.pop())
    return val

# ‚úÖ CORRECT: Only transfer when output empty
def pop(self):
    if not self.output_stack:  # Only when needed
        while self.input_stack:
            self.output_stack.append(self.input_stack.pop())
    return self.output_stack.pop()
```

### 2. Forgetting to Transfer Before Peek

```python
# ‚ùå WRONG: May access empty output_stack
def peek(self):
    return self.output_stack[-1]

# ‚úÖ CORRECT: Transfer if needed
def peek(self):
    if not self.output_stack:
        self._transfer()
    return self.output_stack[-1]
```

### 3. Wrong Empty Check

```python
# ‚ùå WRONG: Only checks one stack
def empty(self):
    return not self.input_stack

# ‚úÖ CORRECT: Check both stacks
def empty(self):
    return not self.input_stack and not self.output_stack
```

---

## üìù Practice Problems (Progressive)

### This Problem
- [ ] [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) - LC 232 ‚≠ê

### Related Problems
- [ ] [Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/) - LC 225
- [ ] [Min Stack](https://leetcode.com/problems/min-stack/) - LC 155
- [ ] [Design Circular Queue](https://leetcode.com/problems/design-circular-queue/) - LC 622

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement and trace through examples
**Day 3:** Implement without notes
**Day 7:** Explain amortized analysis
**Day 14:** Solve Stack Using Queues (reverse problem)
**Day 21:** Compare both implementations

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening:**
> "A stack is LIFO and a queue is FIFO. To simulate FIFO with LIFO, I need to reverse the order. I can do this by using two stacks - the reversal happens when transferring between them."

**Explain the lazy transfer:**
> "The key optimization is to only transfer when the output stack is empty. This gives amortized O(1) because each element is moved at most twice in its lifetime."

**Trace through example:**
> "Let me show with push(1), push(2), pop()..."

**Handle follow-up on worst case:**
> "Worst case is O(n) when we need to transfer, but amortized is O(1) because each element is transferred exactly once."

**Alternative approaches:**
> "There's a simpler version that transfers on every pop (O(n) per pop), but the lazy version is more efficient."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Frequently asked |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask amortized analysis |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Design focus |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | LIFO vs FIFO |
| Explain approach | 3-5 min | Two-stack idea |
| Implement | 8-10 min | With lazy transfer |
| Test | 3-5 min | Walk through operations |
| Interview target | 18-22 min | Including explanation |

---

> **üí° Key Insight:** Two reversals cancel out! When you pop from stack1 to stack2, the order reverses. When you then pop from stack2, you get the original insertion order (FIFO). The lazy transfer optimization ensures each element moves only once between stacks, giving amortized O(1).

---

## üîó Related

- [Stack Using Queues](./4.3-Stack-Using-Queues.md) - Reverse problem
- [Min Stack](./4.1-Min-Stack.md) - Related design
- [Circular Queue](../05-Queue-Fundamentals/5.2-Circular-Queue.md) - Queue implementation
