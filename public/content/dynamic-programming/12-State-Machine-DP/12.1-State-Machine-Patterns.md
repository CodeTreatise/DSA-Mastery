# State Machine DP Patterns

> **When your problem has explicit states and transitions.** State Machine DP models problems where you move between defined states, and the optimal solution depends on tracking which state you're in at each step.

---

## ðŸ“‹ Overview

State Machine DP is perfect when:
- You have **distinct states** (holding, not holding, cooldown, etc.)
- **Transitions** between states follow specific rules
- You want to **maximize/minimize** something at the end

| Category | Example | States |
|----------|---------|--------|
| **Stock Trading** | Buy/Sell with cooldown | Hold, Sold, Rest |
| **String Editing** | Delete or keep | Deleting, Not deleting |
| **Games** | Turn-based choices | Player states |

---

## ðŸŽ¯ Pattern Recognition

**State Machine DP signals:**
- "Can do action A, then must do B"
- "Cooldown period after action"
- "Limited number of transactions"
- "Must alternate between states"

**Keywords:**
- "cooldown", "freeze"
- "at most k transactions"
- "buy and sell"
- "alternating", "consecutive"

---

## ðŸ“ The Stock Trading Family

The best examples of State Machine DP are the stock trading problems.

### The Framework

```
States at each day:
  - HOLD: We own a stock
  - SOLD: We just sold (in cooldown)
  - REST: We don't own and not in cooldown

Transitions:
  REST â†’ HOLD (buy)
  HOLD â†’ HOLD (do nothing)
  HOLD â†’ SOLD (sell)
  SOLD â†’ REST (cooldown ends)
  REST â†’ REST (do nothing)
```

```
Diagram:
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                       â”‚
         â–¼         buy           â”‚
       REST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º HOLD â”€â”˜ (keep holding)
         â–²                    â”‚
         â”‚                    â”‚ sell
         â”‚                    â–¼
         â””â”€â”€â”€â”€â”€ cooldown â”€â”€â”€ SOLD
```

---

## ðŸ’» Stock Trading Problems

### 1. Best Time to Buy and Sell Stock (LC 121) - One Transaction

```python
def max_profit_one(prices: list[int]) -> int:
    """
    At most ONE transaction.
    Track minimum price seen so far.
    """
    min_price = float('inf')
    max_profit = 0
    
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    
    return max_profit
```

### 2. Best Time to Buy and Sell Stock II (LC 122) - Unlimited Transactions

```python
def max_profit_unlimited(prices: list[int]) -> int:
    """
    Unlimited transactions.
    State Machine: hold vs not_hold
    """
    hold = float('-inf')  # Max profit while holding
    not_hold = 0          # Max profit while not holding
    
    for price in prices:
        prev_hold = hold
        hold = max(hold, not_hold - price)      # Keep or buy
        not_hold = max(not_hold, prev_hold + price)  # Keep or sell
    
    return not_hold
```

```javascript
function maxProfitUnlimited(prices) {
    let hold = -Infinity;
    let notHold = 0;
    
    for (const price of prices) {
        const prevHold = hold;
        hold = Math.max(hold, notHold - price);
        notHold = Math.max(notHold, prevHold + price);
    }
    
    return notHold;
}
```

### 3. Best Time to Buy and Sell Stock with Cooldown (LC 309)

```python
def max_profit_cooldown(prices: list[int]) -> int:
    """
    After selling, must wait one day before buying.
    States: hold, sold, rest
    """
    if not prices:
        return 0
    
    hold = float('-inf')  # Holding a stock
    sold = 0              # Just sold (in cooldown)
    rest = 0              # Not holding, not in cooldown
    
    for price in prices:
        prev_hold = hold
        prev_sold = sold
        
        hold = max(hold, rest - price)       # Keep holding OR buy
        sold = prev_hold + price             # Sell today
        rest = max(rest, prev_sold)          # Stay resting OR cooldown ends
    
    return max(sold, rest)
```

```javascript
function maxProfitCooldown(prices) {
    let hold = -Infinity;
    let sold = 0;
    let rest = 0;
    
    for (const price of prices) {
        const prevHold = hold;
        const prevSold = sold;
        
        hold = Math.max(hold, rest - price);
        sold = prevHold + price;
        rest = Math.max(rest, prevSold);
    }
    
    return Math.max(sold, rest);
}
```

### 4. Best Time to Buy and Sell Stock with Transaction Fee (LC 714)

```python
def max_profit_with_fee(prices: list[int], fee: int) -> int:
    """
    Each transaction has a fee.
    States: hold vs not_hold (fee paid on sell)
    """
    hold = float('-inf')
    not_hold = 0
    
    for price in prices:
        prev_hold = hold
        hold = max(hold, not_hold - price)
        not_hold = max(not_hold, prev_hold + price - fee)  # Pay fee on sell
    
    return not_hold
```

### 5. Best Time to Buy and Sell Stock III (LC 123) - At Most 2 Transactions

```python
def max_profit_two(prices: list[int]) -> int:
    """
    At most 2 transactions.
    States: buy1, sell1, buy2, sell2
    """
    buy1 = buy2 = float('-inf')
    sell1 = sell2 = 0
    
    for price in prices:
        buy1 = max(buy1, -price)           # First buy
        sell1 = max(sell1, buy1 + price)   # First sell
        buy2 = max(buy2, sell1 - price)    # Second buy (after first sell)
        sell2 = max(sell2, buy2 + price)   # Second sell
    
    return sell2
```

### 6. Best Time to Buy and Sell Stock IV (LC 188) - At Most K Transactions

```python
def max_profit_k(k: int, prices: list[int]) -> int:
    """
    At most k transactions.
    States: buy[i], sell[i] for i in 0..k
    """
    n = len(prices)
    if n == 0 or k == 0:
        return 0
    
    # If k >= n/2, it's equivalent to unlimited
    if k >= n // 2:
        profit = 0
        for i in range(1, n):
            if prices[i] > prices[i-1]:
                profit += prices[i] - prices[i-1]
        return profit
    
    # DP with k transactions
    buy = [float('-inf')] * (k + 1)
    sell = [0] * (k + 1)
    
    for price in prices:
        for i in range(1, k + 1):
            buy[i] = max(buy[i], sell[i-1] - price)
            sell[i] = max(sell[i], buy[i] + price)
    
    return sell[k]
```

---

## ðŸ”„ State Machine Visualization

### Cooldown Problem States

```
Day 0   Day 1   Day 2   Day 3
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
REST â”€â–º HOLD â”€â–º SOLD â”€â–º REST
  â”‚       â”‚              â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     (can stay in same state)
```

### K Transactions States

```
Start â”€â–º Buy1 â”€â–º Sell1 â”€â–º Buy2 â”€â–º Sell2 â”€â–º ... â”€â–º BuyK â”€â–º SellK
            â”‚       â”‚        â”‚       â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€ (can stay)
```

---

## âš¡ Complexity Summary

| Problem | Time | Space |
|---------|------|-------|
| One transaction | O(n) | O(1) |
| Unlimited | O(n) | O(1) |
| With cooldown | O(n) | O(1) |
| With fee | O(n) | O(1) |
| At most 2 | O(n) | O(1) |
| At most k | O(nk) | O(k) |

---

## âš ï¸ Common Mistakes

### 1. Forgetting to Use Previous State

**âŒ Wrong:**
```python
hold = max(hold, not_hold - price)
not_hold = max(not_hold, hold + price)  # Uses NEW hold!
```

**âœ… Correct:**
```python
prev_hold = hold
hold = max(hold, not_hold - price)
not_hold = max(not_hold, prev_hold + price)  # Uses OLD hold
```

### 2. Wrong Initial States

**âŒ Wrong:**
```python
hold = 0  # Can't have 0 profit while holding without buying
```

**âœ… Correct:**
```python
hold = float('-inf')  # Impossible state initially
```

### 3. Cooldown Transition Error

```python
# After SOLD, must go to REST, not directly to HOLD
# SOLD â†’ REST (forced)
# REST â†’ HOLD (optional)
```

---

## ðŸ“ General State Machine Template

```python
def state_machine_dp(input_data):
    """
    General template for state machine DP.
    """
    # Define initial states
    state_a = initial_a
    state_b = initial_b
    # ... more states as needed
    
    for item in input_data:
        # Save previous states
        prev_a = state_a
        prev_b = state_b
        
        # Transition rules
        state_a = best(stay_in_a, transition_from_other)
        state_b = best(stay_in_b, transition_from_a)
    
    # Answer is best of final states
    return best(state_a, state_b, ...)
```

---

## ðŸ“ Practice Problems

### Stock Problems
- [ ] [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) - Easy
- [ ] [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/) - Medium
- [ ] [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/) - Hard
- [ ] [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/) - Hard
- [ ] [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/) - Medium
- [ ] [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/) - Medium

### Other State Machine Problems
- [ ] [1262. Greatest Sum Divisible by Three](https://leetcode.com/problems/greatest-sum-divisible-by-three/) - Medium
- [ ] [1363. Largest Multiple of Three](https://leetcode.com/problems/largest-multiple-of-three/) - Hard
- [ ] [801. Minimum Swaps To Make Sequences Increasing](https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/) - Hard

---

## ðŸŽ¤ Interview Context

**Company Frequency:**
| Problem | Google | Meta | Amazon |
|---------|--------|------|--------|
| Stock I | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| Stock II | â­â­â­â­ | â­â­â­â­ | â­â­â­â­ |
| Stock III/IV | â­â­â­ | â­â­â­ | â­â­ |
| With Cooldown | â­â­â­â­ | â­â­â­ | â­â­â­ |

**Time allocation:**
| Problem | Target Time |
|---------|-------------|
| Stock I | 5-10 min |
| Stock II | 10-15 min |
| With Cooldown | 20-25 min |
| At most K | 25-30 min |

---

## ðŸ’¡ Key Insights

1. **Identify states explicitly**: What distinct situations can you be in?
2. **Map transitions**: From each state, what states can you reach?
3. **Initialize carefully**: Impossible states get -âˆž (for max) or +âˆž (for min)
4. **Save previous states**: Transitions often need the OLD values
5. **Answer is a final state**: Usually the "done" or "not_holding" state

---

> **ðŸ’¡ Key Pattern:** Draw the state machine diagram first! Once you see the states and arrows, the code writes itself:
> ```
> for item:
>     new_state_A = best(transitions INTO state A)
>     new_state_B = best(transitions INTO state B)
> ```

> **ðŸ”— Related:** [Fibonacci Pattern](../02-Fibonacci-Pattern/4.1-Fibonacci-Pattern-Overview.md) | [Linear DP](../02-Fibonacci-Pattern/4.2-Linear-DP-Patterns.md) | [DP Fundamentals](../01-DP-Fundamentals/1.1-What-Is-DP.md)
