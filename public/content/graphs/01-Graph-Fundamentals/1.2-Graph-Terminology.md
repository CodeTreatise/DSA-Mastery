# 1.2 Graph Terminology

> **Essential vocabulary for all graph algorithms**
>
> â±ï¸ **Time:** 25-35 min | ğŸ“Š **Difficulty:** Beginner | ğŸ¯ **Interview Frequency:** Foundation

---

## Overview

Understanding graph terminology is essential before diving into graph algorithms. These terms form the vocabulary used to describe problems, analyze algorithms, and communicate solutions in interviews.

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>Terminology in Problem Statements</strong></summary>

**When you see these words, recall these concepts:**

| Problem Phrase | Maps To |
|---------------|---------|
| "connected to", "linked with" | Edge, Adjacent |
| "reachable from" | Path exists |
| "returns to starting point" | Cycle |
| "all nodes connected" | Connected graph |
| "one-way" | Directed edge |
| "cost/weight/distance" | Weighted edge |
| "number of connections" | Degree |
| "isolated groups" | Components |

</details>

---

## âœ… When to Use

- Discussing graph algorithms with clarity
- Analyzing problem requirements
- Communicating solutions in interviews
- Understanding algorithm documentation
- Reading academic papers or textbooks

---

## âŒ When NOT to Use

| Term | Common Misuse |
|------|---------------|
| "Node" | Using interchangeably with "element" (be specific) |
| "Connected" | Confusing with "edge exists" vs "path exists" |
| "Path" | Confusing with "edge" (path = sequence of edges) |
| "Cycle" | Confusing with "loop" (loop = self-edge) |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Graph?](./1.1-What-Is-Graph.md)

**After mastering this:**
- [Types of Graphs](./1.3-Types-Of-Graphs.md)
- [Graph Representation](../02-Graph-Representation/2.1-Adjacency-Matrix.md)
- [BFS Fundamentals](../03-BFS-Pattern/3.1-BFS-Fundamentals.md)
- [DFS Fundamentals](../04-DFS-Pattern/4.1-DFS-Fundamentals.md)

</details>

---

## ğŸ“ How It Works

### Core Terminology with Visualizations

#### 1. Vertex (Node) and Edge

```
    Vertex/Node              Edge (Connection)
        â—                     â— â”€â”€â”€â”€â”€â”€ â—
      (A)                    (A)      (B)
                            
    A single point          A connection between
    in the graph            two vertices
```

**Vertex (Node):** A fundamental unit representing an entity.
**Edge:** A connection between two vertices.

---

#### 2. Adjacent Vertices and Neighbors

```
        [B]
       / | \
     [A] | [D]
       \ | /
        [C]

    A and B are adjacent (connected by edge)
    B's neighbors: {A, C, D}
    A's neighbors: {B, C}
```

**Adjacent:** Two vertices connected by an edge.
**Neighbors:** All vertices adjacent to a given vertex.

---

#### 3. Degree (In-Degree, Out-Degree)

```
    UNDIRECTED                  DIRECTED
    
        [B]                        [B]
       / | \                      â†‘ | â†“
     [A] | [D]                  [A] | [D]
       \ | /                      â†‘ | â†“
        [C]                        [C]
    
    deg(B) = 3                 in-deg(B) = 1 (Aâ†’B)
    deg(A) = 2                 out-deg(B) = 2 (Bâ†’C, Bâ†’D)
    deg(C) = 3                 in-deg(D) = 1
```

| Term | Definition | Formula |
|------|------------|---------|
| **Degree** | Number of edges incident to vertex | deg(v) |
| **In-degree** | Number of incoming edges (directed) | in-deg(v) |
| **Out-degree** | Number of outgoing edges (directed) | out-deg(v) |

**Handshaking Lemma:** Sum of all degrees = 2 Ã— |E| (each edge counted twice)

---

#### 4. Path

```
    Path from A to D:
    
    [A] â†’ [B] â†’ [C] â†’ [D]
    
    Path: A â†’ B â†’ C â†’ D
    Path length: 3 (number of edges)
    
    Another path: A â†’ E â†’ D (length 2)
    
    [A] â†’ [B] â†’ [C]
      â†“           â†“
    [E] â”€â”€â”€â”€â”€â”€â”€â†’ [D]
```

**Path:** A sequence of vertices where each adjacent pair is connected by an edge.
**Path Length:** Number of edges in the path.
**Simple Path:** A path with no repeated vertices.

---

#### 5. Cycle

```
    CYCLE                      NO CYCLE (TREE)
    
    [A] â”€â”€â”€ [B]                    [A]
     |       |                    /   \
     |       |                  [B]   [C]
    [D] â”€â”€â”€ [C]                  |
                                [D]
    
    Cycle: A â†’ B â†’ C â†’ D â†’ A
    (Returns to starting vertex)
```

**Cycle:** A path that starts and ends at the same vertex with at least one edge.
**Self-loop:** An edge from a vertex to itself (A â†’ A).
**Acyclic:** A graph with no cycles.

---

#### 6. Connected Graph and Components

```
    CONNECTED GRAPH           DISCONNECTED GRAPH
    
    [A] â”€â”€â”€ [B]               [A] â”€â”€â”€ [B]    [E] â”€â”€â”€ [F]
     |       |                 |       |
    [D] â”€â”€â”€ [C]               [D] â”€â”€â”€ [C]    (2 components)
    
    (1 component - all         Component 1    Component 2
     vertices reachable)
```

**Connected (Undirected):** A path exists between every pair of vertices.
**Component:** A maximal connected subgraph.
**Strongly Connected (Directed):** A directed path exists between every pair in both directions.
**Weakly Connected (Directed):** Connected if we ignore edge directions.

---

#### 7. Weighted Graph

```
    UNWEIGHTED                 WEIGHTED
    
    [A] â”€â”€â”€ [B]               [A] â”€â”€5â”€â”€ [B]
     |       |                 |          |
    [D] â”€â”€â”€ [C]               3          2
                               |          |
                              [D] â”€â”€4â”€â”€ [C]
    
    All edges "cost" 1         Edge A-B has weight 5
                               Edge D-C has weight 4
```

**Weight:** A value associated with an edge (cost, distance, time, etc.).
**Weighted Graph:** A graph where edges have weights.

---

## ğŸ’» Code Implementation

**Python - Computing Graph Properties:**
```python
from collections import defaultdict

class GraphAnalyzer:
    """Compute various graph properties and metrics."""
    
    def __init__(self, directed=False):
        self.graph = defaultdict(list)
        self.directed = directed
        self.vertices = set()
    
    def add_edge(self, u, v):
        """Add an edge to the graph."""
        self.graph[u].append(v)
        self.vertices.add(u)
        self.vertices.add(v)
        if not self.directed:
            self.graph[v].append(u)
    
    def degree(self, v):
        """Return degree of vertex v (undirected graph)."""
        return len(self.graph[v])
    
    def in_degree(self, v):
        """Return in-degree of vertex v (directed graph)."""
        count = 0
        for u in self.graph:
            if v in self.graph[u]:
                count += 1
        return count
    
    def out_degree(self, v):
        """Return out-degree of vertex v (directed graph)."""
        return len(self.graph[v])
    
    def neighbors(self, v):
        """Return list of neighbors of vertex v."""
        return self.graph[v]
    
    def has_path(self, start, end, visited=None):
        """Check if path exists between start and end using DFS."""
        if visited is None:
            visited = set()
        
        if start == end:
            return True
        
        visited.add(start)
        for neighbor in self.graph[start]:
            if neighbor not in visited:
                if self.has_path(neighbor, end, visited):
                    return True
        return False
    
    def is_connected(self):
        """Check if graph is connected (undirected)."""
        if not self.vertices:
            return True
        
        start = next(iter(self.vertices))
        visited = set()
        self._dfs(start, visited)
        
        return len(visited) == len(self.vertices)
    
    def _dfs(self, v, visited):
        """Helper DFS for connectivity check."""
        visited.add(v)
        for neighbor in self.graph[v]:
            if neighbor not in visited:
                self._dfs(neighbor, visited)
    
    def count_components(self):
        """Count number of connected components."""
        visited = set()
        components = 0
        
        for vertex in self.vertices:
            if vertex not in visited:
                self._dfs(vertex, visited)
                components += 1
        
        return components

# Example usage
g = GraphAnalyzer(directed=False)
g.add_edge('A', 'B')
g.add_edge('B', 'C')
g.add_edge('C', 'D')
g.add_edge('D', 'A')

print(f"Degree of B: {g.degree('B')}")  # 2
print(f"Neighbors of A: {g.neighbors('A')}")  # ['B', 'D']
print(f"Path A to C: {g.has_path('A', 'C')}")  # True
print(f"Connected: {g.is_connected()}")  # True
```

**JavaScript:**
```javascript
class GraphAnalyzer {
    constructor(directed = false) {
        this.graph = new Map();
        this.directed = directed;
        this.vertices = new Set();
    }
    
    addEdge(u, v) {
        if (!this.graph.has(u)) this.graph.set(u, []);
        if (!this.graph.has(v)) this.graph.set(v, []);
        
        this.graph.get(u).push(v);
        this.vertices.add(u);
        this.vertices.add(v);
        
        if (!this.directed) {
            this.graph.get(v).push(u);
        }
    }
    
    degree(v) {
        return this.graph.get(v)?.length || 0;
    }
    
    inDegree(v) {
        let count = 0;
        for (const [vertex, neighbors] of this.graph) {
            if (neighbors.includes(v)) count++;
        }
        return count;
    }
    
    outDegree(v) {
        return this.graph.get(v)?.length || 0;
    }
    
    neighbors(v) {
        return this.graph.get(v) || [];
    }
    
    hasPath(start, end, visited = new Set()) {
        if (start === end) return true;
        
        visited.add(start);
        for (const neighbor of this.neighbors(start)) {
            if (!visited.has(neighbor)) {
                if (this.hasPath(neighbor, end, visited)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    isConnected() {
        if (this.vertices.size === 0) return true;
        
        const start = this.vertices.values().next().value;
        const visited = new Set();
        this._dfs(start, visited);
        
        return visited.size === this.vertices.size;
    }
    
    _dfs(v, visited) {
        visited.add(v);
        for (const neighbor of this.neighbors(v)) {
            if (!visited.has(neighbor)) {
                this._dfs(neighbor, visited);
            }
        }
    }
    
    countComponents() {
        const visited = new Set();
        let components = 0;
        
        for (const vertex of this.vertices) {
            if (!visited.has(vertex)) {
                this._dfs(vertex, visited);
                components++;
            }
        }
        return components;
    }
}

// Example
const g = new GraphAnalyzer(false);
g.addEdge('A', 'B');
g.addEdge('B', 'C');
g.addEdge('C', 'D');
g.addEdge('D', 'A');

console.log(`Degree of B: ${g.degree('B')}`);  // 2
console.log(`Neighbors of A: ${g.neighbors('A')}`);  // ['B', 'D']
console.log(`Path A to C: ${g.hasPath('A', 'C')}`);  // true
console.log(`Connected: ${g.isConnected()}`);  // true
```

---

## âš¡ Complexity Analysis

| Property Computation | Time Complexity | Notes |
|---------------------|-----------------|-------|
| Degree (undirected) | O(1) | Size of adjacency list |
| In-degree | O(V + E) | Must scan all edges |
| Out-degree | O(1) | Size of adjacency list |
| Find neighbors | O(1) | Direct list access |
| Check path exists | O(V + E) | BFS/DFS traversal |
| Count components | O(V + E) | Full graph traversal |
| Check connected | O(V + E) | Single DFS/BFS |

---

## ğŸ”„ Variations

### Complete Terminology Reference

| Term | Definition | Visual |
|------|------------|--------|
| **Walk** | Sequence of vertices (can repeat) | Aâ†’Bâ†’Câ†’Bâ†’D |
| **Trail** | Walk with no repeated edges | Aâ†’Bâ†’Câ†’D (edges distinct) |
| **Path** | Walk with no repeated vertices | Aâ†’Bâ†’Câ†’D (vertices distinct) |
| **Circuit** | Trail starting/ending at same vertex | Aâ†’Bâ†’Câ†’Dâ†’A (trail + cycle) |
| **Cycle** | Path starting/ending at same vertex | Aâ†’Bâ†’Câ†’A (path + closes) |

### Directed Graph Specific Terms

| Term | Definition |
|------|------------|
| **Strongly Connected** | Path exists in both directions between all pairs |
| **Weakly Connected** | Connected when ignoring edge directions |
| **DAG** | Directed Acyclic Graph |
| **Source** | Vertex with in-degree 0 |
| **Sink** | Vertex with out-degree 0 |

---

## âš ï¸ Common Mistakes

### 1. Confusing "Connected" vs "Adjacent"

```python
# Adjacent: directly connected by an edge
# Connected: path exists (may go through other vertices)

# âŒ Wrong thinking
"A and C are connected" â†’ checking if edge (A,C) exists

# âœ… Correct
# A and C are adjacent if edge (A,C) exists
# A and C are connected if ANY path Aâ†’...â†’C exists
```

### 2. Path vs Walk

```python
# âŒ Wrong: Counting Aâ†’Bâ†’Aâ†’C as a valid path
# Paths don't repeat vertices!

# âœ… Correct
# Aâ†’Bâ†’Aâ†’C is a WALK (vertices can repeat)
# Aâ†’Bâ†’C is a PATH (no vertex repeats)
```

### 3. Degree Sum Property

```python
# âŒ Wrong: Expecting sum of degrees = |E|

# âœ… Correct: Handshaking lemma
# Sum of all degrees = 2 Ã— |E|
# (Each edge contributes 2 to total degree)

def verify_handshaking(graph):
    total_degree = sum(len(neighbors) for neighbors in graph.values())
    edge_count = total_degree // 2  # For undirected graph
    return total_degree == 2 * edge_count  # Always True
```

---

## ğŸ“ Practice Problems

### Easy (Apply Terminology)
| Problem | Difficulty | Focus |
|---------|------------|-------|
| [Find the Town Judge](https://leetcode.com/problems/find-the-town-judge/) | ğŸŸ¢ Easy | In-degree, out-degree |
| [Find Center of Star Graph](https://leetcode.com/problems/find-center-of-star-graph/) | ğŸŸ¢ Easy | Degree analysis |

### Medium (Path/Connected Analysis)
| Problem | Difficulty | Focus |
|---------|------------|-------|
| [Number of Connected Components](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/) | ğŸŸ¡ Medium | Components |
| [Graph Valid Tree](https://leetcode.com/problems/graph-valid-tree/) | ğŸŸ¡ Medium | Connected + Acyclic |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Create flashcards for all terms
- **Day 3:** Draw graphs and label all properties
- **Day 7:** Implement property calculation functions
- **Day 14:** Explain each term using real-world examples
- **Day 30:** Quickly identify terms in problem statements

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>Using Terminology in Interviews</strong></summary>

**When clarifying problems, ask:**
- "Are the edges directed or undirected?"
- "Can we assume the graph is connected?"
- "Are there any constraints on the degree of vertices?"
- "Can there be cycles?"

**When explaining solutions, say:**
- "First, I'll find all the neighbors of the starting vertex..."
- "We need to detect if there's a cycle in this directed graph..."
- "Since the graph might be disconnected, I'll iterate through all components..."

**Red flags to avoid:**
- âŒ Using "node" and "vertex" inconsistently
- âŒ Confusing "edge" with "path"
- âŒ Saying "connected" when you mean "adjacent"

</details>

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Learn all terminology | 20-25 min |
| Create flashcards | 10-15 min |
| Practice with examples | 15-20 min |
| **Total to master** | **45-60 min** |

---

> **ğŸ’¡ Key Insight:** Graph terminology is the language of graph algorithms. Mastering these terms makes learning BFS, DFS, Dijkstra, and other algorithms significantly easier.

> **ğŸ”— Related:** [What Is a Graph?](./1.1-What-Is-Graph.md) | [Types of Graphs](./1.3-Types-Of-Graphs.md) | [Graph Representation](../02-Graph-Representation/2.2-Adjacency-List.md)

---

**Previous:** [â† 1.1 What Is a Graph?](./1.1-What-Is-Graph.md)  
**Next:** [1.3 Types of Graphs â†’](./1.3-Types-Of-Graphs.md)
