# 4.3 Sort by Start Time Pattern

> **Definition:** A greedy strategy for interval problems where sorting by start time allows us to process intervals left-to-right, enabling merging and coverage operations.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Merge overlapping intervals"
- "Insert interval and merge"
- "Find gaps between intervals"
- "Process intervals in order"

**Key Insight:**
```
Why sort by START time?

Processing left-to-right lets us EXTEND or CREATE:
- If current overlaps with previous ‚Üí extend previous
- If current doesn't overlap ‚Üí start new interval

It's like reading a timeline from left to right!
```

**Visual:**
```
Input (unsorted):
[5,8]       [====]
[1,3]  [==]
[2,4]   [==]
[10,12]          [==]

Sort by start: [1,3], [2,4], [5,8], [10,12]

Process left-to-right:
[1,3]  [==]              ‚Üí Start: [1,3]
[2,4]   [==]             ‚Üí Overlaps! Extend: [1,4]
[5,8]       [====]       ‚Üí Gap! New interval: [5,8]
[10,12]          [==]    ‚Üí Gap! New interval: [10,12]

Result: [[1,4], [5,8], [10,12]]
```

</details>

---

## ‚úÖ When to Use

| Problem Type | Why Sort by Start |
|--------------|-------------------|
| Merge intervals | Process left-to-right, extend as needed |
| Insert interval | Find position, then merge |
| Find gaps | Gaps appear between non-overlapping |
| Interval coverage | Need to know where each starts |
| Meeting rooms count | Need chronological order |

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Maximize non-overlapping | End time matters more | Sort by END |
| Minimum arrows | Need to track common end | Sort by END |
| Activity selection | Want earliest ending | Sort by END |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Interval Overview](./4.1-Interval-Greedy-Overview.md)
- [Sort by End Pattern](./4.2-Sort-By-End-Pattern.md)
- Array manipulation

**After mastering this:**
- Employee Free Time (multiple lists)
- Sweep line algorithms
- Calendar booking problems

**Combines with:**
- Heaps for meeting rooms
- Two pointers for interval intersection
- Binary search for range queries

</details>

---

## üìê How It Works

### The Merge Algorithm

```
1. Sort intervals by start time (ascending)
2. Initialize result with first interval
3. For each remaining interval:
   - If current overlaps with last in result:
     ‚Üí Extend last's end if needed
   - If current doesn't overlap:
     ‚Üí Add current as new interval
4. Return merged result
```

### Step-by-Step Visualization

```
Input: [[1,3], [2,6], [8,10], [15,18]]

Already sorted by start time!

Step 1: Initialize result = [[1,3]]
        Current: [1,3]
        
Step 2: Check [2,6]
        Last in result: [1,3]
        Does [2,6] overlap [1,3]? 
        2 <= 3? YES ‚Üí Overlap!
        Extend: [1, max(3,6)] = [1,6]
        Result: [[1,6]]
        
Step 3: Check [8,10]
        Last in result: [1,6]
        Does [8,10] overlap [1,6]?
        8 <= 6? NO ‚Üí Gap!
        Add new interval
        Result: [[1,6], [8,10]]
        
Step 4: Check [15,18]
        Last in result: [8,10]
        Does [15,18] overlap [8,10]?
        15 <= 10? NO ‚Üí Gap!
        Add new interval
        Result: [[1,6], [8,10], [15,18]]

Output: [[1,6], [8,10], [15,18]]
```

---

## üíª Code Implementation

### Merge Intervals (LeetCode 56)

```python
def merge(intervals: list[list[int]]) -> list[list[int]]:
    """
    LeetCode 56: Merge Intervals
    
    Merge all overlapping intervals into continuous ranges.
    
    Time: O(n log n), Space: O(n) for output
    
    Args:
        intervals: List of [start, end] pairs
        
    Returns:
        List of merged non-overlapping intervals
    """
    if not intervals:
        return []
    
    # KEY: Sort by START time
    intervals.sort(key=lambda x: x[0])
    
    # Start with first interval
    merged = [intervals[0]]
    
    for i in range(1, len(intervals)):
        current_start, current_end = intervals[i]
        last_start, last_end = merged[-1]
        
        # Check for overlap: current starts before/at last's end
        if current_start <= last_end:
            # Extend the end (they overlap)
            merged[-1][1] = max(last_end, current_end)
        else:
            # No overlap, add as new interval
            merged.append([current_start, current_end])
    
    return merged


# Example
print(merge([[1,3], [2,6], [8,10], [15,18]]))
# Output: [[1,6], [8,10], [15,18]]
```

```javascript
/**
 * LeetCode 56: Merge Intervals
 * 
 * @param {number[][]} intervals - Array of [start, end] pairs
 * @return {number[][]} Merged non-overlapping intervals
 */
function merge(intervals) {
    if (intervals.length === 0) return [];
    
    // Sort by start time
    intervals.sort((a, b) => a[0] - b[0]);
    
    const merged = [intervals[0]];
    
    for (let i = 1; i < intervals.length; i++) {
        const [currStart, currEnd] = intervals[i];
        const last = merged[merged.length - 1];
        
        if (currStart <= last[1]) {
            // Overlap - extend
            last[1] = Math.max(last[1], currEnd);
        } else {
            // No overlap - new interval
            merged.push([currStart, currEnd]);
        }
    }
    
    return merged;
}
```

---

### Insert Interval (LeetCode 57)

```python
def insert(intervals: list[list[int]], new_interval: list[int]) -> list[list[int]]:
    """
    LeetCode 57: Insert Interval
    
    Insert new interval and merge if necessary.
    Input is already sorted!
    
    Time: O(n), Space: O(n)
    """
    result = []
    i = 0
    n = len(intervals)
    
    # Part 1: Add all intervals that end BEFORE new starts
    while i < n and intervals[i][1] < new_interval[0]:
        result.append(intervals[i])
        i += 1
    
    # Part 2: Merge overlapping intervals with new_interval
    while i < n and intervals[i][0] <= new_interval[1]:
        new_interval[0] = min(new_interval[0], intervals[i][0])
        new_interval[1] = max(new_interval[1], intervals[i][1])
        i += 1
    result.append(new_interval)
    
    # Part 3: Add remaining intervals
    while i < n:
        result.append(intervals[i])
        i += 1
    
    return result


# Example
print(insert([[1,3], [6,9]], [2,5]))
# Output: [[1,5], [6,9]]
```

```javascript
function insert(intervals, newInterval) {
    const result = [];
    let i = 0;
    const n = intervals.length;
    
    // Part 1: Add intervals ending before new starts
    while (i < n && intervals[i][1] < newInterval[0]) {
        result.push(intervals[i]);
        i++;
    }
    
    // Part 2: Merge overlapping
    while (i < n && intervals[i][0] <= newInterval[1]) {
        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
        i++;
    }
    result.push(newInterval);
    
    // Part 3: Add remaining
    while (i < n) {
        result.push(intervals[i]);
        i++;
    }
    
    return result;
}
```

---

### Find All Gaps (Complement)

```python
def find_gaps(intervals: list[list[int]], 
              range_start: int, 
              range_end: int) -> list[list[int]]:
    """
    Find all gaps (uncovered regions) in a range.
    
    Example: intervals = [[1,3], [5,8]], range = [0,10]
    Gaps: [[0,1], [3,5], [8,10]]
    """
    if not intervals:
        return [[range_start, range_end]]
    
    # Sort and merge first
    intervals.sort(key=lambda x: x[0])
    merged = []
    for start, end in intervals:
        if merged and start <= merged[-1][1]:
            merged[-1][1] = max(merged[-1][1], end)
        else:
            merged.append([start, end])
    
    # Find gaps
    gaps = []
    prev_end = range_start
    
    for start, end in merged:
        if start > prev_end:
            gaps.append([prev_end, start])
        prev_end = max(prev_end, end)
    
    if prev_end < range_end:
        gaps.append([prev_end, range_end])
    
    return gaps
```

---

### Interval Intersection (LeetCode 986)

```python
def interval_intersection(first_list: list[list[int]], 
                          second_list: list[list[int]]) -> list[list[int]]:
    """
    LeetCode 986: Interval List Intersections
    
    Find intersection of two sorted interval lists.
    
    Time: O(n + m), Space: O(1) excluding output
    """
    result = []
    i, j = 0, 0
    
    while i < len(first_list) and j < len(second_list):
        a_start, a_end = first_list[i]
        b_start, b_end = second_list[j]
        
        # Check if they overlap
        start = max(a_start, b_start)
        end = min(a_end, b_end)
        
        if start <= end:  # Valid intersection
            result.append([start, end])
        
        # Move pointer of interval that ends first
        if a_end < b_end:
            i += 1
        else:
            j += 1
    
    return result
```

```javascript
function intervalIntersection(firstList, secondList) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < firstList.length && j < secondList.length) {
        const [aStart, aEnd] = firstList[i];
        const [bStart, bEnd] = secondList[j];
        
        // Intersection bounds
        const start = Math.max(aStart, bStart);
        const end = Math.min(aEnd, bEnd);
        
        if (start <= end) {
            result.push([start, end]);
        }
        
        // Advance the one that ends first
        aEnd < bEnd ? i++ : j++;
    }
    
    return result;
}
```

---

## ‚ö° Complexity Analysis

| Problem | Time | Space | Notes |
|---------|------|-------|-------|
| Merge Intervals | O(n log n) | O(n) | Sort + merge |
| Insert Interval | O(n) | O(n) | Already sorted |
| Interval Intersection | O(n + m) | O(min(n,m)) | Two pointers |
| Find Gaps | O(n log n) | O(n) | Sort + merge + scan |

**Why Sort by Start:**
- Enables left-to-right processing
- Easy to detect overlaps: `current_start <= last_end`
- Easy to extend: `max(last_end, current_end)`

---

## üîÑ Variations

| Variation | Key Difference | Example |
|-----------|---------------|---------|
| Merge intervals | Combine overlapping | LC 56 |
| Insert and merge | Pre-sorted input | LC 57 |
| Interval intersection | Two lists | LC 986 |
| Employee free time | Multiple people | LC 759 |
| Meeting rooms II | Count overlap | Use heap |
| Calendar booking | Dynamic insert/check | TreeMap |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Overlap Condition

```python
# ‚ùå WRONG: Checking if starts overlap
if current_start == last_end:  # Too restrictive

# ‚ùå WRONG: Off by one
if current_start < last_end:  # Misses touching

# ‚úÖ CORRECT: Current starts before/at last ends
if current_start <= last_end:
    # They overlap (or touch)
```

### 2. Not Extending Correctly

```python
# ‚ùå WRONG: Just using current's end
merged[-1][1] = current_end
# Fails for: [1,6] and [2,4] ‚Üí should stay [1,6]

# ‚úÖ CORRECT: Take maximum
merged[-1][1] = max(merged[-1][1], current_end)
```

### 3. Modifying Input

```python
# ‚ùå RISKY: Modifying merged[-1] as list
merged[-1][1] = ...  # Works but mutates

# ‚úÖ SAFER: Create new list if needed
# Or be aware you're mutating
```

### 4. Forgetting Edge Cases

```python
# Edge case: empty input
if not intervals:
    return []

# Edge case: single interval
if len(intervals) == 1:
    return intervals

# Edge case: all overlapping
# [[1,10], [2,3], [4,5]] ‚Üí [[1,10]]
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)
- [ ] [Merge Intervals](https://leetcode.com/problems/merge-intervals/) - Classic
  - Key: Sort by start, extend or add

### Medium (Apply variations)
- [ ] [Insert Interval](https://leetcode.com/problems/insert-interval/) - Already sorted
  - Key: Three-phase approach
- [ ] [Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/)
  - Key: Two pointers on sorted lists
- [ ] [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)
  - Key: Sort by start, use heap for end times

### Hard (Complex variations)
- [ ] [Employee Free Time](https://leetcode.com/problems/employee-free-time/)
  - Key: Merge all, find gaps
- [ ] [Data Stream as Disjoint Intervals](https://leetcode.com/problems/data-stream-as-disjoint-intervals/)
  - Key: Dynamic merge with TreeMap

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve Merge Intervals (template memorization)
- **Day 3:** Solve Insert Interval without template
- **Day 7:** Solve Interval List Intersections
- **Day 14:** Explain all three to someone
- **Day 30:** Employee Free Time (combines patterns)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Communication Strategy</strong></summary>

**Opening statement:**
```
"This is a merge intervals problem. I'll:
1. Sort by start time to process left-to-right
2. For each interval, check if it overlaps with the last merged
3. If overlap ‚Üí extend, otherwise ‚Üí add new

Let me trace through an example..."
```

**Key questions to ask:**
- "Are the intervals already sorted?"
- "Can intervals touch? Is [1,2] and [2,3] overlap or gap?"
- "What should I return for empty input?"

**Company Focus:**
| Company | Frequency | Twist |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Often asked |
| Google | ‚≠ê‚≠ê‚≠ê | May add constraints |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Calendar apps |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Standard versions |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Recognize pattern | 30 sec |
| Explain approach | 1 min |
| Code merge | 5-7 min |
| Handle edge cases | 1-2 min |
| Test | 1-2 min |
| **Total** | **8-12 min** |

---

> **üí° Key Insight:** Sort by start = process chronologically = know when to merge vs. when to start new. It's the natural way to "read" a timeline from left to right.

> **üîó Related:** [Sort by End Pattern](./4.2-Sort-By-End-Pattern.md) | [Interval Overview](./4.1-Interval-Greedy-Overview.md) | [Meeting Rooms II](./4.4-Interval-Practice/Meeting-Rooms-II.md)
