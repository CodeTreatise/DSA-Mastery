# Two Sum Pattern

> **The foundational hash map pattern that transforms O(n¬≤) brute force into O(n) elegance.**

The Two Sum pattern is the most important hash map technique in coding interviews. It demonstrates the core principle: **trade space for time** by storing seen values for O(1) lookup.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- Find a **pair** of elements with a specific relationship
- Target sum, difference, or product
- Need to check if **complement exists**
- "Find two numbers that..." phrasing

**Keywords in problem statement:**
- "two numbers", "pair", "sum to", "target"
- "indices of", "find elements"
- "complement", "difference equals"

**Problem variations:**
1. Return indices vs return values
2. Sorted vs unsorted array
3. Single pair vs all pairs
4. Sum vs difference vs product

</details>

---

## ‚úÖ When to Use

- Finding pairs with a target sum/difference
- Need O(n) time instead of O(n¬≤) brute force
- Array is **unsorted** (sorted ‚Üí use Two Pointers instead)
- Only need to find **one valid pair**
- Checking if complement exists in seen elements

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Array is sorted | Two Pointers is O(1) space | Two Pointers |
| Find ALL pairs | Hash map finds first match | Nested loops with dedup |
| Need indices + values are duplicate | May return wrong indices | Track all indices per value |
| Very limited memory | Hash map uses O(n) space | Sort + Two Pointers |
| Finding triplets/quadruplets | Need additional loop | k-Sum with recursion |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Hash Map Basics](../02-Hash-Map-Set/2.1-Hash-Map-Basics.md) - O(1) lookup
- [Array Traversal](../../01-Arrays-Strings/01-Arrays/1.3-Array-Traversal.md)
- Time/Space complexity analysis

**After mastering this:**
- [3Sum](https://leetcode.com/problems/3sum/) - Two Sum inside a loop
- [4Sum](https://leetcode.com/problems/4sum/) - Recursive k-Sum
- [Two Sum II - Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) - Two Pointers variant

**Combines with:**
- Sliding Window for subarray problems
- Prefix Sum for range queries
- Sorting for optimization

</details>

---

## üìê How It Works

### Core Insight

Instead of checking every pair (O(n¬≤)), we realize:
- If we need `a + b = target`
- Then for each `a`, we need `b = target - a`
- Store seen values ‚Üí check if complement exists in O(1)

### Step-by-Step Algorithm

```
1. Create empty hash map: {value ‚Üí index}
2. For each element at index i:
   a. Calculate complement = target - nums[i]
   b. If complement exists in hash map:
      - Return [hash_map[complement], i]
   c. Otherwise, store nums[i] ‚Üí i in hash map
3. If no pair found, return empty/error
```

### Visualization

```
Array: [2, 7, 11, 15]  Target: 9

Step 1: num=2, complement=7
        Hash: {}
        7 not in hash ‚Üí store {2: 0}

Step 2: num=7, complement=2
        Hash: {2: 0}
        2 IS in hash! ‚Üí return [0, 1] ‚úì

Answer: indices [0, 1] ‚Üí values 2 + 7 = 9
```

### Why Store After Checking?

```
Array: [3, 3]  Target: 6

If we store BEFORE checking:
  Step 1: store {3: 0}, then check complement=3
          3 IS in hash ‚Üí return [0, 0] ‚ùå WRONG! Same element!

If we check BEFORE storing:
  Step 1: check complement=3, not in {} ‚Üí store {3: 0}
  Step 2: check complement=3, IS in {3: 0} ‚Üí return [0, 1] ‚úì
```

---

## üíª Code Implementation

### Python

```python
def two_sum(nums: list[int], target: int) -> list[int]:
    """
    Find indices of two numbers that sum to target.
    
    Pattern: Two Sum (Hash Map complement lookup)
    Time: O(n) - single pass through array
    Space: O(n) - hash map stores up to n elements
    """
    seen = {}  # value ‚Üí index
    
    for i, num in enumerate(nums):
        complement = target - num
        
        # Check if complement was seen before
        if complement in seen:
            return [seen[complement], i]
        
        # Store current number for future lookups
        seen[num] = i
    
    return []  # No solution found


def two_sum_all_pairs(nums: list[int], target: int) -> list[list[int]]:
    """Find ALL pairs that sum to target (values, not indices)."""
    seen = set()
    result = set()  # Use set to avoid duplicates
    
    for num in nums:
        complement = target - num
        if complement in seen:
            # Store as sorted tuple to avoid duplicates like (2,7) and (7,2)
            pair = tuple(sorted([num, complement]))
            result.add(pair)
        seen.add(num)
    
    return [list(p) for p in result]
```

### JavaScript

```javascript
/**
 * Find indices of two numbers that sum to target.
 * 
 * Pattern: Two Sum (Hash Map complement lookup)
 * Time: O(n) - single pass through array
 * Space: O(n) - hash map stores up to n elements
 */
function twoSum(nums, target) {
    const seen = new Map(); // value ‚Üí index
    
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        
        // Check if complement was seen before
        if (seen.has(complement)) {
            return [seen.get(complement), i];
        }
        
        // Store current number for future lookups
        seen.set(nums[i], i);
    }
    
    return []; // No solution found
}

// Find all pairs (returns values)
function twoSumAllPairs(nums, target) {
    const seen = new Set();
    const result = new Set();
    
    for (const num of nums) {
        const complement = target - num;
        if (seen.has(complement)) {
            const pair = [num, complement].sort((a, b) => a - b).join(',');
            result.add(pair);
        }
        seen.add(num);
    }
    
    return [...result].map(p => p.split(',').map(Number));
}
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Best | O(1) | O(1) | Pair found at indices 0,1 |
| Average | O(n) | O(n) | Single pass, store half elements |
| Worst | O(n) | O(n) | Pair at end or no solution |

**Why O(n) Time:**
- Single pass through array: n iterations
- Hash map lookup/insert: O(1) average per operation
- Total: n √ó O(1) = O(n)

**Why O(n) Space:**
- Hash map stores at most n-1 elements
- In worst case, we store all but last element before finding pair

**Trade-off Analysis:**
| Approach | Time | Space |
|----------|------|-------|
| Brute Force (nested loops) | O(n¬≤) | O(1) |
| Sort + Two Pointers | O(n log n) | O(1) or O(n) |
| **Hash Map** | **O(n)** | **O(n)** |

---

## üîÑ Variations

| Variation | Difference | Example Problem |
|-----------|------------|-----------------|
| **Two Sum II (Sorted)** | Use Two Pointers, O(1) space | [LC 167](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) |
| **Two Sum III (Design)** | Support add + find operations | [LC 170](https://leetcode.com/problems/two-sum-iii-data-structure-design/) |
| **Two Sum - BST** | Find pair in BST | [LC 653](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) |
| **3Sum** | Find triplets, sort + two pointers | [LC 15](https://leetcode.com/problems/3sum/) |
| **4Sum** | Find quadruplets, recursive | [LC 18](https://leetcode.com/problems/4sum/) |
| **Two Sum - Difference** | Find pair with target difference | Similar pattern |
| **Pair with Given Product** | a √ó b = target | Use target/a as complement |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Same Element Twice

```python
# ‚ùå WRONG: Storing before checking
def two_sum_wrong(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        seen[num] = i  # Store first!
        if target - num in seen:  # Check after
            return [seen[target - num], i]  # May return same index!

# ‚úÖ CORRECT: Check before storing
def two_sum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        if target - num in seen:  # Check first!
            return [seen[target - num], i]
        seen[num] = i  # Store after
```

### 2. Handling Duplicates Wrong

```python
# ‚ùå Problem: [3, 3], target = 6
# If we need ALL pairs of indices, hash map overwrites

# ‚úÖ For all indices, store list of indices per value
from collections import defaultdict
def two_sum_all_indices(nums, target):
    value_to_indices = defaultdict(list)
    for i, num in enumerate(value_to_indices):
        value_to_indices[num].append(i)
    # Then find pairs...
```

### 3. Returning Wrong Order

```python
# ‚ùå Some problems require [smaller_index, larger_index]
# Make sure to check problem requirements

# ‚úÖ Return in correct order
return [seen[complement], i]  # seen[complement] < i always
```

### 4. Not Handling No Solution

```python
# ‚ùå Assuming solution always exists
def two_sum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        if target - num in seen:
            return [seen[target - num], i]
        seen[num] = i
    # Falls off without return!

# ‚úÖ Handle no solution case
    return []  # or raise ValueError("No solution")
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)

| Problem | Link | Focus |
|---------|------|-------|
| Two Sum | [LC 1](https://leetcode.com/problems/two-sum/) | Core pattern |
| Two Sum II - Sorted | [LC 167](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) | Compare with Two Pointers |
| Contains Duplicate II | [LC 219](https://leetcode.com/problems/contains-duplicate-ii/) | Hash + distance constraint |

### Medium (Apply variations)

| Problem | Link | Focus |
|---------|------|-------|
| 3Sum | [LC 15](https://leetcode.com/problems/3sum/) | Two Sum in loop |
| 4Sum | [LC 18](https://leetcode.com/problems/4sum/) | Recursive k-Sum |
| Two Sum IV - BST | [LC 653](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) | Tree + Hash Set |
| Longest Consecutive | [LC 128](https://leetcode.com/problems/longest-consecutive-sequence/) | Hash Set variant |

### Hard (Master edge cases)

| Problem | Link | Focus |
|---------|------|-------|
| 4Sum II | [LC 454](https://leetcode.com/problems/4sum-ii/) | Split + Hash Map |
| Max Points on Line | [LC 149](https://leetcode.com/problems/max-points-on-a-line/) | Slope as key |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

After solving Two Sum (LC 1):
- **Day 1:** Solve without looking at solution
- **Day 3:** Explain the pattern out loud, solve LC 167
- **Day 7:** Solve 3Sum (LC 15) using Two Sum as building block
- **Day 14:** Teach the pattern to someone, solve LC 128
- **Day 30:** Revisit 4Sum or a variation

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening (30 seconds):**
> "I see we need to find two numbers that sum to a target. The brute force would check every pair in O(n¬≤). But we can use a hash map to achieve O(n) - for each number, we store it and check if its complement exists."

**Before coding:**
> "Let me clarify: should I return indices or values? Is the array sorted? Can there be duplicates? Is there always exactly one solution?"

**While coding:**
> "I'll iterate once, checking if the complement exists before storing the current number. This prevents using the same element twice."

**After coding:**
> "Time is O(n) for one pass with O(1) hash operations. Space is O(n) for the hash map. If memory were a constraint, I could sort and use two pointers for O(n log n) time and O(1) space."

</details>

**Company Frequency:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common, often as warm-up |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Expected to solve quickly |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask follow-ups (3Sum, k-Sum) |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Classic interview question |
| Apple | ‚≠ê‚≠ê‚≠ê‚≠ê | Frequent in phone screens |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn Two Sum pattern | 20-30 min | First exposure |
| Solve LC 1 (Two Sum) | 5-10 min | Should be fast |
| Solve LC 167 (Sorted) | 10-15 min | Compare approaches |
| Master 3Sum | 25-35 min | Builds on Two Sum |
| Full pattern mastery | 2-3 hours | All variations |

---

> **üí° Key Insight:** The Two Sum pattern works because hash maps give O(1) lookup. Instead of asking "does any previous element sum to target?", we ask "does the specific complement exist?" - a question hash maps answer instantly.

> **üîó Related:** [Contains Duplicate II](./4.3-Contains-Duplicate-II-LC219.md) | [Longest Consecutive](./4.4-Longest-Consecutive-LC128.md) | [Frequency Pattern](../03-Frequency-Pattern/3.1-Frequency-Overview.md)
