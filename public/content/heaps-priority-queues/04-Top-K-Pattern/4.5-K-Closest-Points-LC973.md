# 4.5 K Closest Points to Origin (LC 973)

## Problem Statement

[LeetCode 973 - K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/)

Given an array of `points` where `points[i] = [xi, yi]` represents a point on the X-Y plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`.

The distance between two points is the Euclidean distance: `‚àö((x1-x2)¬≤ + (y1-y2)¬≤)`.

You may return the answer in **any order**. The answer is guaranteed to be unique (except for the order).

```
Example 1:
Input: points = [[1,3],[-2,2]], k = 1
Output: [[-2,2]]
Explanation: 
- Distance of (1,3) from origin = ‚àö(1¬≤ + 3¬≤) = ‚àö10
- Distance of (-2,2) from origin = ‚àö(4 + 4) = ‚àö8
‚àö8 < ‚àö10, so [-2,2] is closer.

Example 2:
Input: points = [[3,3],[5,-1],[-2,4]], k = 2
Output: [[3,3],[-2,4]] (or [[-2,4],[3,3]])
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a Top K with Custom Distance problem:**
- K closest = K smallest distances
- Use MAX-heap of size K (for K smallest)
- Compare by distance, store points

**Keywords:**
- "k closest", "k nearest"
- "closest to origin/point"
- Distance-based ranking

**Key insight:**
- K smallest distances ‚Üí MAX-heap of size K
- Root = largest of K smallest = threshold for entry

</details>

---

## ‚úÖ When to Use

- K nearest neighbor problems
- Closest points to a reference
- Any K smallest by computed value

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Need all points sorted | Just sort by distance | Full sort |
| K ‚âà n | Heap advantage lost | Sort |
| Streaming points | Need different structure | Online algorithms |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Top K Pattern Overview](./4.1-Top-K-Overview.md)
- Euclidean distance formula
- Max-heap in Python (negate values)

**After mastering this:**
- [Find K Closest Elements (LC 658)](https://leetcode.com/problems/find-k-closest-elements/)
- K-NN algorithm foundations

**Combines with:**
- Distance calculation
- Max-heap for K smallest

</details>

---

## üìê How It Works

### The Key Insight: MAX-Heap for K Smallest

```
For K LARGEST ‚Üí MIN-heap of size K
For K SMALLEST ‚Üí MAX-heap of size K

Why? Max-heap keeps K smallest.
     Root = largest of K smallest = Kth smallest.
     New point must have distance < root to enter.
```

### Skip Square Root Optimization

```
Compare ‚àö8 vs ‚àö10:
  ‚àö8 < ‚àö10  ‚ü∫  8 < 10

We can compare squared distances instead!
No need to compute actual square roots.

dist_squared = x¬≤ + y¬≤
```

### Visualization

```
points = [[3,3],[5,-1],[-2,4]], k = 2

Distances squared:
- [3,3]: 9 + 9 = 18
- [5,-1]: 25 + 1 = 26
- [-2,4]: 4 + 16 = 20

Max-heap of size 2 (stores K smallest):

Process [3,3] dist=18: heap = [(-18, [3,3])]
Process [5,-1] dist=26: heap = [(-18, [3,3]), (-26, [5,-1])]
                        heap size = K, now filtering
Process [-2,4] dist=20: 20 < 26 (root), replace!
                        heap = [(-18, [3,3]), (-20, [-2,4])]
                        (after heapify: [(-20, [-2,4]), (-18, [3,3])])

Result: [[3,3], [-2,4]] - the 2 closest points ‚úì
```

---

## üíª Code Implementation

### Approach 1: Max-Heap of Size K

**Python:**
```python
import heapq

def kClosest(points: list[list[int]], k: int) -> list[list[int]]:
    """
    Find K closest points using max-heap of size K.
    
    Time: O(n log k) - n points, O(log k) per heap op
    Space: O(k) - heap size
    
    Pattern: K smallest ‚Üí MAX-heap
             Store negative distance for max-heap behavior.
    """
    # Max-heap: store (-distance_squared, point)
    # Negative because Python has min-heap
    max_heap = []
    
    for x, y in points:
        dist_sq = x * x + y * y
        
        if len(max_heap) < k:
            heapq.heappush(max_heap, (-dist_sq, [x, y]))
        elif dist_sq < -max_heap[0][0]:
            # Closer than farthest in heap, replace
            heapq.heapreplace(max_heap, (-dist_sq, [x, y]))
    
    return [point for _, point in max_heap]
```

**JavaScript:**
```javascript
var kClosest = function(points, k) {
    // Max-heap of size K for K smallest distances
    
    class MaxHeap {
        constructor() { this.heap = []; }
        
        size() { return this.heap.length; }
        peek() { return this.heap[0]; }
        
        push(val) {
            this.heap.push(val);
            this._bubbleUp(this.heap.length - 1);
        }
        
        pop() {
            if (this.size() === 0) return undefined;
            const max = this.heap[0];
            const last = this.heap.pop();
            if (this.size() > 0) {
                this.heap[0] = last;
                this._bubbleDown(0);
            }
            return max;
        }
        
        _bubbleUp(i) {
            while (i > 0) {
                const parent = Math.floor((i - 1) / 2);
                if (this.heap[parent][0] >= this.heap[i][0]) break;
                [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
                i = parent;
            }
        }
        
        _bubbleDown(i) {
            const n = this.size();
            while (true) {
                let largest = i;
                const left = 2 * i + 1, right = 2 * i + 2;
                if (left < n && this.heap[left][0] > this.heap[largest][0]) largest = left;
                if (right < n && this.heap[right][0] > this.heap[largest][0]) largest = right;
                if (largest === i) break;
                [this.heap[i], this.heap[largest]] = [this.heap[largest], this.heap[i]];
                i = largest;
            }
        }
    }
    
    const maxHeap = new MaxHeap();
    
    for (const [x, y] of points) {
        const distSq = x * x + y * y;
        
        if (maxHeap.size() < k) {
            maxHeap.push([distSq, [x, y]]);
        } else if (distSq < maxHeap.peek()[0]) {
            maxHeap.pop();
            maxHeap.push([distSq, [x, y]]);
        }
    }
    
    return maxHeap.heap.map(([_, point]) => point);
};
```

### Approach 2: Sort (Simpler, O(n log n))

**Python:**
```python
def kClosest(points: list[list[int]], k: int) -> list[list[int]]:
    """
    Simple sort by distance.
    
    Time: O(n log n), Space: O(1) to O(n)
    """
    points.sort(key=lambda p: p[0]**2 + p[1]**2)
    return points[:k]
```

**JavaScript:**
```javascript
var kClosest = function(points, k) {
    // Sort by squared distance
    points.sort((a, b) => (a[0]**2 + a[1]**2) - (b[0]**2 + b[1]**2));
    return points.slice(0, k);
};
```

### Approach 3: QuickSelect (O(n) Average)

**Python:**
```python
import random

def kClosest(points: list[list[int]], k: int) -> list[list[int]]:
    """
    QuickSelect for K closest.
    
    Time: O(n) average, O(n¬≤) worst
    Space: O(1)
    """
    def dist(point):
        return point[0]**2 + point[1]**2
    
    def partition(left, right):
        pivot_idx = random.randint(left, right)
        pivot_dist = dist(points[pivot_idx])
        
        # Move pivot to end
        points[pivot_idx], points[right] = points[right], points[pivot_idx]
        
        store = left
        for i in range(left, right):
            if dist(points[i]) < pivot_dist:
                points[store], points[i] = points[i], points[store]
                store += 1
        
        points[store], points[right] = points[right], points[store]
        return store
    
    left, right = 0, len(points) - 1
    while left < right:
        pivot = partition(left, right)
        if pivot == k:
            break
        elif pivot < k:
            left = pivot + 1
        else:
            right = pivot - 1
    
    return points[:k]
```

---

## ‚ö° Complexity Analysis

| Approach | Time (Avg) | Time (Worst) | Space | Notes |
|----------|------------|--------------|-------|-------|
| Max-heap |" O(n log k) "| O(n log k) |" O(k) "| Consistent |
| Sort |" O(n log n) "| O(n log n) |" O(1) "| Simple |
| QuickSelect |" O(n) "| O(n¬≤) |" O(1) "| Fastest avg |

**Space optimization note:**
Heap uses O(k) space, which is better when k << n.

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **Closest to a point** | Change distance formula | Slight modification |
| **K farthest** | Use min-heap | Reverse logic |
| **Weighted distance** | Custom distance function | Same pattern |
| **Manhattan distance** | |x1-x2| + |y1-y2| | Different formula |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Computing Square Root

```python
# ‚ùå Unnecessary: Computing actual distance
import math
dist = math.sqrt(x**2 + y**2)

# ‚úÖ Optimized: Compare squared distances
dist_sq = x**2 + y**2
# ‚àöa < ‚àöb ‚ü∫ a < b (for non-negative a, b)
```

### 2. Wrong Heap Type

```python
# ‚ùå Wrong: Min-heap for K smallest
min_heap = []
for point in points:
    heapq.heappush(min_heap, (dist(point), point))
    if len(min_heap) > k:
        heapq.heappop(min_heap)  # Removes CLOSEST!

# ‚úÖ Correct: Max-heap for K smallest (negate distance)
max_heap = []
for point in points:
    heapq.heappush(max_heap, (-dist(point), point))
    if len(max_heap) > k:
        heapq.heappop(max_heap)  # Removes FARTHEST (most negative)
```

### 3. Tuple Comparison Issues

```python
# ‚ùå Risky: When distances are equal, lists compared
heapq.heappush(heap, (-dist, [x, y]))  # [x,y] comparison may fail

# ‚úÖ Safe: Use tuple instead of list
heapq.heappush(heap, (-dist, (x, y)))  # Tuples compare fine

# Or add a tiebreaker index
heapq.heappush(heap, (-dist, i, [x, y]))
```

---

## üìù Practice Problems (Progressive)

### Easy (Build up)
- [ ] [Kth Largest Element (LC 215)](https://leetcode.com/problems/kth-largest-element-in-an-array/) - Basic Top K

### Medium (Core problem)
- [ ] [K Closest Points (LC 973)](https://leetcode.com/problems/k-closest-points-to-origin/) - **This problem**
- [ ] [Find K Closest Elements (LC 658)](https://leetcode.com/problems/find-k-closest-elements/) - 1D version

### Hard (Extensions)
- [ ] [Closest Binary Search Tree Value II (LC 272)](https://leetcode.com/problems/closest-binary-search-tree-value-ii/) - BST + K closest

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement max-heap approach
- **Day 3:** Solve with sort and QuickSelect
- **Day 7:** Explain why max-heap for K smallest
- **Day 14:** Solve LC 658 (1D variant)
- **Day 30:** Code all three approaches

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening:**
"This is a K closest problem. For K smallest values, I'll use a max-heap of size K. The key insight is that the max-heap keeps K smallest distances, with the root being the threshold - any new point must be closer than the root to enter."

**Optimization discussion:**
"I'll compare squared distances instead of actual distances to avoid unnecessary square root computations. Since we only care about relative ordering, ‚àöa < ‚àöb ‚ü∫ a < b."

**Complexity:**
"Time is O(n log k) - we process n points with O(log k) heap operations each. Space is O(k) for the heap."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common, often asked |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard heap problem |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask for QuickSelect |
| LinkedIn | ‚≠ê‚≠ê‚≠ê‚≠ê | Frequently asked |
| Uber | ‚≠ê‚≠ê‚≠ê‚≠ê | Geo/location relevance |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Simple geometry |
| Code heap solution | 8-10 min | Watch for negation |
| Code sort solution | 3-5 min | One-liner |
| Discuss optimizations | 3-5 min | QuickSelect, skip sqrt |
| Total interview time | 20-25 min | Standard medium |

---

## üí° Key Insight

> **For K smallest, use a MAX-heap.** The max-heap of size K maintains K smallest elements. Its root is the largest of those K (the Kth smallest), acting as a threshold. New elements only enter if they beat this threshold. Also, **skip the square root** - comparing squared distances gives the same ordering.

---

## üîó Related

- **Previous:** [Top K Frequent (LC 347)](./4.4-Top-K-Frequent-LC347.md)
- **Next:** [Top K Frequent Words (LC 692)](./4.6-Top-K-Frequent-Words-LC692.md)
- **Pattern:** [Top K Overview](./4.1-Top-K-Overview.md)
