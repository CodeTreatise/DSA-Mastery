# 2.1 Backtracking Basics

> **Introduction to Backtracking: Exploring All Possibilities**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - Foundation for Subsets, Permutations, Combinations  
> **Prerequisites:** [1.1-1.3 Recursion Fundamentals](../01-Recursion/1.1-Recursion-Basics.md)

---

## Overview

**Backtracking** is a systematic method for exploring all possible solutions by building candidates incrementally and abandoning ("backtracking" from) candidates that fail to satisfy constraints.

Think of it as **organized trial and error**:
1. Try a choice
2. Explore further (recurse)
3. Undo the choice (backtrack)
4. Try the next choice

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Backtracking</strong></summary>

**Look for these signals:**
- "Find **all** solutions" or "generate **all** possibilities"
- "**Combinations**, **permutations**, **subsets**"
- Constraint satisfaction (Sudoku, N-Queens)
- Decision tree exploration

**Keywords in problem statement:**
- "all possible", "all valid", "generate all"
- "combination", "permutation", "subset"
- "ways to", "configurations"

**Problem characteristics:**
- Solution built incrementally (step by step)
- Need to explore multiple paths
- Can prune invalid paths early

</details>

---

## ‚úÖ When to Use Backtracking

- **Generate all combinations/permutations/subsets**
- **Constraint satisfaction** (Sudoku, N-Queens, crosswords)
- **Path finding with all paths** (maze, word search)
- **Optimization over discrete choices** (when DP doesn't apply)

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Need only ONE solution | DFS/BFS | Stops at first solution |
| Shortest path | BFS | Backtracking doesn't guarantee shortest |
| Optimal substructure | Dynamic Programming | More efficient |
| Large state space | Greedy or approximation | Exponential time |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Recursion Basics](../01-Recursion/1.1-Recursion-Basics.md)
- [Recursion Patterns](../01-Recursion/1.2-Recursion-Patterns.md)
- [Thinking Recursively](../01-Recursion/1.3-Thinking-Process.md)

**After mastering this:**
- [Backtracking Template](./2.2-Backtracking-Template.md) - Detailed template
- [Core Patterns](./2.3-Core-Patterns/) - Subsets, Permutations, etc.

**Related concepts:**
- DFS (backtracking is DFS on decision tree)
- Recursion (backtracking uses recursion)
- Tree traversal (solution space is a tree)

</details>

---

## üìê How Backtracking Works

### The Decision Tree

Every backtracking problem can be visualized as a **decision tree**:
- **Nodes:** Partial solutions
- **Edges:** Choices we can make
- **Leaves:** Complete solutions (valid or invalid)

```
Generate subsets of [1, 2]:

                    []
                 /      \
        include 1        exclude 1
              /             \
           [1]              []
          /    \          /    \
    include 2  exclude 2  include 2  exclude 2
         |        |          |          |
       [1,2]     [1]        [2]        []
       
Subsets: [[], [1], [2], [1,2]]
```

### The Three Steps

```
1. CHOOSE  ‚Üí Make a decision (add element, take path, etc.)
2. EXPLORE ‚Üí Recurse with the new state
3. UNCHOOSE ‚Üí Undo the decision (backtrack)
```

---

## üíª Code: Basic Template

```python
def backtrack(candidates, current_state, result):
    """
    Generic backtracking template.
    
    candidates: choices available
    current_state: current partial solution
    result: collection of all valid solutions
    """
    # Base case: is current_state a valid solution?
    if is_solution(current_state):
        result.append(copy(current_state))  # Save a copy!
        return
    
    for choice in get_choices(candidates, current_state):
        # Pruning: skip invalid choices early
        if not is_valid(choice, current_state):
            continue
        
        # 1. CHOOSE
        make_choice(current_state, choice)
        
        # 2. EXPLORE
        backtrack(candidates, current_state, result)
        
        # 3. UNCHOOSE (backtrack)
        undo_choice(current_state, choice)
```

### Concrete Example: Generate Subsets

```python
def subsets(nums: list[int]) -> list[list[int]]:
    """
    Generate all subsets of nums.
    
    Time: O(2^n * n), Space: O(n)
    """
    result = []
    
    def backtrack(index: int, current: list):
        # Every state is a valid subset
        result.append(current[:])  # Copy current
        
        # Try including each remaining element
        for i in range(index, len(nums)):
            # CHOOSE
            current.append(nums[i])
            
            # EXPLORE (start from i+1 to avoid duplicates)
            backtrack(i + 1, current)
            
            # UNCHOOSE
            current.pop()
    
    backtrack(0, [])
    return result
```

```javascript
function subsets(nums) {
    const result = [];
    
    function backtrack(index, current) {
        result.push([...current]);  // Copy current
        
        for (let i = index; i < nums.length; i++) {
            // CHOOSE
            current.push(nums[i]);
            
            // EXPLORE
            backtrack(i + 1, current);
            
            // UNCHOOSE
            current.pop();
        }
    }
    
    backtrack(0, []);
    return result;
}
```

---

## üìê Backtracking vs. Recursion vs. DFS

| Aspect | Recursion | DFS | Backtracking |
|--------|-----------|-----|--------------|
| **Goal** | Solve subproblems | Explore graph/tree | Find all solutions |
| **State** | Pass down or return | Visited set | Modify & restore |
| **Undo** | Implicit (returns) | Mark unvisited | Explicit undo |
| **Example** | Factorial | Tree traversal | N-Queens |

**Backtracking IS recursion + explicit state restoration:**

```python
# Pure recursion (no undo needed)
def factorial(n):
    if n <= 1: return 1
    return n * factorial(n - 1)

# DFS (mark visited)
def dfs(node, visited):
    visited.add(node)
    for neighbor in node.neighbors:
        if neighbor not in visited:
            dfs(neighbor, visited)

# Backtracking (explicit undo)
def backtrack(current):
    for choice in choices:
        current.append(choice)     # CHOOSE
        backtrack(current)         # EXPLORE
        current.pop()              # UNCHOOSE (explicit undo!)
```

---

## ‚ö° Complexity Analysis

Backtracking typically has **exponential** complexity:

| Problem Type | Time | Space |
|--------------|------|-------|
| Subsets |" O(2‚Åø * n) "| O(n) |
| Permutations |" O(n! * n) "| O(n) |
| Combinations (n choose k) |" O(C(n,k) * k) "| O(k) |
| Constraint satisfaction |" O(possibilities^n) "| O(n) |

**Why exponential?**
- We're exploring a decision tree
- Each level doubles (subsets) or multiplies by remaining choices
- Pruning can reduce but not eliminate exponential growth

---

## üîÑ Variations

| Variation | Description | Example |
|-----------|-------------|---------|
| **No pruning** | Explore all paths | All subsets |
| **Constraint pruning** | Skip invalid branches | Sudoku |
| **Optimization** | Track best solution | N-Queens count |
| **Early termination** | Stop at first solution | Find one valid |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Copy the Solution

‚ùå **Wrong:**
```python
def backtrack(current, result):
    if is_complete(current):
        result.append(current)  # Same reference, will be modified!
    ...
```

‚úÖ **Correct:**
```python
def backtrack(current, result):
    if is_complete(current):
        result.append(current[:])  # Copy the list
        # or: result.append(list(current))
    ...
```

### 2. Not Undoing the Choice

‚ùå **Wrong:**
```python
for choice in choices:
    current.append(choice)
    backtrack(current)
    # Forgot to pop! current keeps growing
```

‚úÖ **Correct:**
```python
for choice in choices:
    current.append(choice)
    backtrack(current)
    current.pop()  # MUST undo the choice
```

### 3. Modifying Iteration Variable

‚ùå **Wrong:**
```python
for i in range(len(nums)):
    nums.remove(nums[i])  # Modifying while iterating!
    backtrack(nums)
    nums.insert(i, nums[i])  # Can't recover correctly
```

‚úÖ **Correct:**
```python
for i in range(len(nums)):
    current.append(nums[i])  # Build separate state
    backtrack(i + 1, current)
    current.pop()
```

### 4. Wrong Base Case

‚ùå **Wrong:**
```python
def permutations(nums, current):
    if len(current) > len(nums):  # Off-by-one
        result.append(current[:])
    ...
```

‚úÖ **Correct:**
```python
def permutations(nums, current):
    if len(current) == len(nums):  # Exact length
        result.append(current[:])
        return
    ...
```

---

## üìù Practice Problems

### Easy (Learn the concept)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Subsets | Basic backtracking | [LC 78](https://leetcode.com/problems/subsets/) |
| Letter Combinations | Multiple choices | [LC 17](https://leetcode.com/problems/letter-combinations-of-a-phone-number/) |

### Medium (Apply pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Permutations | Ordering matters | [LC 46](https://leetcode.com/problems/permutations/) |
| Combination Sum | With repetition | [LC 39](https://leetcode.com/problems/combination-sum/) |
| Subsets II | Handling duplicates | [LC 90](https://leetcode.com/problems/subsets-ii/) |
| Palindrome Partitioning | Constraint validation | [LC 131](https://leetcode.com/problems/palindrome-partitioning/) |

### Hard (Master pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| N-Queens | Complex constraints | [LC 51](https://leetcode.com/problems/n-queens/) |
| Sudoku Solver | Constraint propagation | [LC 37](https://leetcode.com/problems/sudoku-solver/) |
| Word Search II | Trie + backtracking | [LC 212](https://leetcode.com/problems/word-search-ii/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1: Foundations**
- Day 1: Understand decision tree, implement subsets
- Day 2: Implement permutations, compare with subsets
- Day 3: Solve LC 78, LC 46
- Day 5: Combination Sum (LC 39)

**Week 2: Apply**
- Day 8: Subsets II (handle duplicates)
- Day 10: Palindrome Partitioning
- Day 12: N-Queens (complex constraints)
- Day 14: Review all, identify common patterns

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Opening statement:**
> "This is a backtracking problem where we need to explore all possibilities. I'll use the choose-explore-unchoose pattern."

**Explaining your approach:**
> "I'll build the solution incrementally. At each step, I'll make a choice, recurse, and then undo that choice to try alternatives."

**When discussing complexity:**
> "Since we're generating all solutions, the time is exponential‚ÄîO(2^n) for subsets, O(n!) for permutations."

**If asked about optimization:**
> "I can prune invalid branches early by checking constraints before recursing."

**Company focus:**

| Company | Backtracking Focus |
|---------|-------------------|
| Google | N-Queens, Sudoku, Word Search |
| Meta | Permutations, Subsets, Combinations |
| Amazon | Combination Sum, Letter Combinations |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 20-30 min | With decision tree |
| First backtracking (subsets) | 20-30 min | Template learning |
| Permutations variation | 15-20 min | Apply template |
| 3 Medium problems | 60-90 min | Practice |

---

## üí° Key Insight

> **Backtracking = DFS on a decision tree with explicit undo**
>
> The key mental shift:
> 1. See the problem as exploring a tree of choices
> 2. Each path from root to leaf is a potential solution
> 3. **Always undo** your choice before trying the next one
>
> The template is always: **CHOOSE ‚Üí EXPLORE ‚Üí UNCHOOSE**

---

## üîó Related

- [Backtracking Template](./2.2-Backtracking-Template.md) - Detailed template
- [Subsets Pattern](./2.3-Core-Patterns/01-Subsets-Pattern.md) - First core pattern
- [Permutations Pattern](./2.3-Core-Patterns/02-Permutations-Pattern.md) - Second core pattern
- [Recursion Basics](../01-Recursion/1.1-Recursion-Basics.md) - Foundation
