# 6.2 Merge K Sorted Lists (LC 23)

> **Grokking Pattern:** K-way Merge using Heap
>
> **Difficulty:** Hard | **Frequency:** â­â­â­â­â­ Very High

---

## Problem Statement

You are given an array of `k` linked lists, each sorted in ascending order. Merge all the linked lists into one sorted linked list and return it.

```
Input: lists = [[1,4,5], [1,3,4], [2,6]]
       list1: 1 â†’ 4 â†’ 5
       list2: 1 â†’ 3 â†’ 4
       list3: 2 â†’ 6

Output: 1 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 4 â†’ 5 â†’ 6
```

[LeetCode 23 - Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- Multiple (k) sorted sequences to merge
- Need to find minimum across k elements repeatedly
- Output must maintain sorted order

**Keywords in problem statement:**
- "k sorted lists/arrays", "merge all", "priority queue"

**This pattern appears in:**
- External sorting (merge phase)
- Database query results merging
- Streaming data from multiple sources

</details>

---

## âœ… When to Use This Approach

- Merging k sorted lists/arrays
- External sort merge phase
- Finding smallest/largest across k sorted streams
- Top K from multiple sources

---

## âŒ When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Only 2 lists | Overkill | Two pointers |
| Unsorted lists | Doesn't apply | Sort first |
| Very small k | Heap overhead | Divide and conquer |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Merge Two Sorted Lists](./6.1-Merge-Two-Sorted.md)
- [Heaps/Priority Queues](../../08-Heaps-Priority-Queues.md)

**After mastering this:**
- Merge K Sorted Arrays
- External sorting implementation
- Merge Streams (system design)

**Combines with:**
- Divide and Conquer (alternative approach)
- Priority Queue for efficient minimum finding

</details>

---

## ğŸ“ Approaches Overview

| Approach | Time | Space | Best When |
|----------|------|-------|-----------|
| Brute Force |" O(nk log nk) "| O(nk) | Never |
| Merge one by one |" O(nk) "| O(1) | k is very small |
| Divide and Conquer |" O(n log k) "| O(log k) | k is large |
| **Min Heap** |" O(n log k) "| O(k) | **Best general** |

Where n = total nodes, k = number of lists.

---

## ğŸ“ Approach 1: Min Heap (Recommended)

### Core Idea

Use a min-heap to always have access to the smallest element across all k lists:

1. Push head of each list into the heap
2. Pop the minimum node
3. Add its next node to the heap
4. Repeat until heap is empty

### Visualization

```
Initial lists:
  list1: 1 â†’ 4 â†’ 5
  list2: 1 â†’ 3 â†’ 4
  list3: 2 â†’ 6

Heap: [1â‚, 1â‚‚, 2â‚ƒ]  (subscript = list index)

Pop min (1â‚), add to result, push 4â‚
Heap: [1â‚‚, 2â‚ƒ, 4â‚]
Result: 1

Pop min (1â‚‚), add to result, push 3â‚‚
Heap: [2â‚ƒ, 4â‚, 3â‚‚]
Result: 1 â†’ 1

Pop min (2â‚ƒ), add to result, push 6â‚ƒ
Heap: [3â‚‚, 4â‚, 6â‚ƒ]
Result: 1 â†’ 1 â†’ 2

... continue until heap is empty
```

### Implementation

**Python:**

```python
import heapq

def merge_k_lists(lists: list[ListNode]) -> ListNode:
    """
    Merge k sorted linked lists using min-heap.
    
    Time: O(n log k) where n = total nodes
    Space: O(k) for heap
    """
    # Handle edge cases
    if not lists:
        return None
    
    # Create min heap with (value, index, node)
    # Index is for tie-breaking (required in Python 3)
    heap = []
    for i, head in enumerate(lists):
        if head:
            heapq.heappush(heap, (head.val, i, head))
    
    dummy = ListNode(-1)
    current = dummy
    
    while heap:
        val, idx, node = heapq.heappop(heap)
        
        # Add node to result
        current.next = node
        current = current.next
        
        # Push next node from same list
        if node.next:
            heapq.heappush(heap, (node.next.val, idx, node.next))
    
    return dummy.next
```

**JavaScript:**

```javascript
// JavaScript doesn't have built-in heap, use a MinHeap class
class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    push(node) {
        this.heap.push(node);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();
        
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this._bubbleDown(0);
        return min;
    }
    
    isEmpty() {
        return this.heap.length === 0;
    }
    
    _bubbleUp(idx) {
        while (idx > 0) {
            const parent = Math.floor((idx - 1) / 2);
            if (this.heap[parent].val <= this.heap[idx].val) break;
            [this.heap[parent], this.heap[idx]] = [this.heap[idx], this.heap[parent]];
            idx = parent;
        }
    }
    
    _bubbleDown(idx) {
        const n = this.heap.length;
        while (true) {
            let smallest = idx;
            const left = 2 * idx + 1;
            const right = 2 * idx + 2;
            
            if (left < n && this.heap[left].val < this.heap[smallest].val) {
                smallest = left;
            }
            if (right < n && this.heap[right].val < this.heap[smallest].val) {
                smallest = right;
            }
            if (smallest === idx) break;
            
            [this.heap[smallest], this.heap[idx]] = [this.heap[idx], this.heap[smallest]];
            idx = smallest;
        }
    }
}

function mergeKLists(lists) {
    if (!lists || lists.length === 0) return null;
    
    const heap = new MinHeap();
    
    // Add all heads to heap
    for (const head of lists) {
        if (head) heap.push(head);
    }
    
    const dummy = new ListNode(-1);
    let current = dummy;
    
    while (!heap.isEmpty()) {
        const node = heap.pop();
        current.next = node;
        current = current.next;
        
        if (node.next) {
            heap.push(node.next);
        }
    }
    
    return dummy.next;
}
```

---

## ğŸ“ Approach 2: Divide and Conquer

### Core Idea

Recursively merge pairs of lists, reducing the problem size by half each time:

```
k lists â†’ k/2 lists â†’ k/4 lists â†’ ... â†’ 1 list
```

### Visualization

```
[L1, L2, L3, L4, L5, L6, L7, L8]
          â†“ (merge pairs)
    [L12, L34, L56, L78]
          â†“ (merge pairs)
       [L1234, L5678]
          â†“ (merge pairs)
         [L12345678]
```

### Implementation

**Python:**

```python
def merge_k_lists_divide_conquer(lists: list[ListNode]) -> ListNode:
    """
    Merge k sorted lists using divide and conquer.
    
    Time: O(n log k)
    Space: O(log k) for recursion stack
    """
    if not lists:
        return None
    
    return merge_lists_range(lists, 0, len(lists) - 1)


def merge_lists_range(lists, left, right):
    """Merge lists from index left to right."""
    if left == right:
        return lists[left]
    
    mid = (left + right) // 2
    
    left_merged = merge_lists_range(lists, left, mid)
    right_merged = merge_lists_range(lists, mid + 1, right)
    
    return merge_two_lists(left_merged, right_merged)


def merge_two_lists(l1, l2):
    """Merge two sorted lists (from LC 21)."""
    dummy = ListNode(-1)
    current = dummy
    
    while l1 and l2:
        if l1.val <= l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    
    current.next = l1 if l1 else l2
    return dummy.next
```

**JavaScript:**

```javascript
function mergeKListsDC(lists) {
    if (!lists || lists.length === 0) return null;
    
    return mergeRange(lists, 0, lists.length - 1);
}

function mergeRange(lists, left, right) {
    if (left === right) return lists[left];
    
    const mid = Math.floor((left + right) / 2);
    const leftMerged = mergeRange(lists, left, mid);
    const rightMerged = mergeRange(lists, mid + 1, right);
    
    return mergeTwoLists(leftMerged, rightMerged);
}
```

---

## âš¡ Complexity Analysis

### Min Heap Approach

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Best |" O(n log k) "| O(k) | All lists equal length |
| Average |" O(n log k) "| O(k) | Typical case |
| Worst |" O(n log k) "| O(k) | Same as average |

**Why O(n log k):**
- Each of the n nodes is pushed and popped from heap once
- Each heap operation is O(log k)
- Total: n * O(log k) = O(n log k)

### Divide and Conquer Approach

| Case | Time | Space | Notes |
|------|------|-------|-------|
| All |" O(n log k) "| O(log k) | Recursion depth |

---

## ğŸ”„ Variations

| Variation | Difference | Approach |
|-----------|------------|----------|
| Merge K Arrays | Arrays instead of lists | Same approaches work |
| Find median of K lists | Need middle element | Modified two-heap |
| Top K from K lists | Only need K elements | Early termination |
| Merge with duplicates | Remove duplicates | Skip in merge step |

---

## âš ï¸ Common Mistakes

### 1. Not Handling Empty Lists in Array

```python
# âŒ Wrong - crashes on empty list
for head in lists:
    heapq.heappush(heap, (head.val, head))  # head might be None!

# âœ… Correct - check for None
for i, head in enumerate(lists):
    if head:  # Check before pushing
        heapq.heappush(heap, (head.val, i, head))
```

### 2. Python Heap Comparison Issue

```python
# âŒ Wrong - can't compare ListNode objects when values are equal
heap = []
heapq.heappush(heap, (node1.val, node1))
heapq.heappush(heap, (node2.val, node2))  # Crashes if val equal!

# âœ… Correct - use index as tiebreaker
heapq.heappush(heap, (head.val, i, head))  # i is unique
```

### 3. Using Wrong Time Complexity Analysis

```python
# âŒ Wrong analysis
# "Each merge is O(n), we do k-1 merges, so O(nk)"

# This is only true for merge-one-by-one approach!

# âœ… Correct for heap approach
# Each of n nodes: 1 push + 1 pop = O(log k) each
# Total: O(n log k)
```

---

## ğŸ“ Practice Problems (Progressive)

### Easy (Building block)
- [ ] [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) - LC 21

### Medium
- [ ] [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) - LC 23 â­
- [ ] [Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/) - LC 378

### Hard
- [ ] [Smallest Range Covering Elements from K Lists](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/) - LC 632

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement heap solution
- **Day 3:** Implement divide and conquer solution
- **Day 7:** Solve without reference, compare both approaches
- **Day 14:** Analyze time complexity of both approaches
- **Day 30:** Extend to Smallest Range (LC 632)

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
> "This is a k-way merge problem. I'll use a min-heap to always access the smallest element across k lists in O(log k) time."

**Alternative mention:**
> "I could also use divide and conquer, merging pairs of lists recursively. Both have O(n log k) time."

**Explain heap choice:**
> "The heap always contains at most k nodes (one from each list). Each operation is O(log k), and we process n total nodes."

**Follow-up preparation:**
- "What if k is very large?" â†’ Heap handles gracefully
- "What if lists are very unequal?" â†’ Still O(n log k)
- "Can you do it with O(1) space?" â†’ Yes with divide and conquer, O(log k) stack

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | â­â­â­â­â­ | Top interview question |
| Meta | â­â­â­â­ | Heap knowledge tested |
| Google | â­â­â­â­ | May ask variations |
| Microsoft | â­â­â­ | Standard interview question |

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 3-5 min | Extension of merge two |
| Heap solution | 15-20 min | Main approach |
| D&C solution | 15-20 min | Alternative |
| Handle edge cases | 3-5 min | Empty lists, single list |
| Interview target | 25-30 min | Including explanation |

---

> **ğŸ’¡ Key Insight:** When you need to repeatedly find the minimum among k candidates, think **min-heap**. The heap guarantees O(log k) for both insertion and extraction, giving O(n log k) overall.

---

## ğŸ”— Related

- [Merge Two Sorted Lists](./6.1-Merge-Two-Sorted.md) - Foundation problem
- [Heaps Overview](../../08-Heaps-Priority-Queues.md) - Data structure used
- [Divide and Conquer](../../02-Recursion-Backtracking.md) - Alternative approach
