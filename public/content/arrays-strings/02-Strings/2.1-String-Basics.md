# 2.1 String Basics

> **Strings are character arrays with special properties**  
> **Prerequisite for:** Pattern Matching, Two Pointers on Strings, Sliding Window

---

## What is a String?

A **string** is a sequence of characters. In most languages, strings are implemented as arrays of characters with additional methods for text manipulation.

> üí° *String problems are essentially array problems with characters. Most array techniques (Two Pointers, Sliding Window) apply directly to strings.*

---

## üìê Memory Representation

```
String: "HELLO"

Memory:  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ  'H'  ‚îÇ  'E'  ‚îÇ  'L'  ‚îÇ  'L'  ‚îÇ  'O'  ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Index:      0       1       2       3       4

ASCII:     72      69      76      76      79
```

**Key Properties:**
- **Ordered:** Characters maintain their position
- **Indexed:** Each character accessible by position
- **Length:** Number of characters in the string

---

## üîí Mutability

### Immutable Strings (Python, Java, JavaScript)

```python
# Python - strings are IMMUTABLE
s = "hello"
s[0] = 'H'  # ‚ùå TypeError: strings don't support item assignment

# Must create a new string
s = 'H' + s[1:]  # "Hello" (new string created)

# Each operation creates new string
s = s + " world"  # Creates new string in memory
```

**Implications:**
- Concatenation in a loop is O(n¬≤) - creates new string each time
- Use `''.join(list)` for efficient string building
- String methods return NEW strings, don't modify original

### Mutable Strings (C++, C)

```cpp
// C++ - strings are MUTABLE
string s = "hello";
s[0] = 'H';  // ‚úÖ "Hello" - modifies in place

// C - character arrays
char s[] = "hello";
s[0] = 'H';  // ‚úÖ Modifies in place
```

---

## üíª Declaration & Common Operations

### Python

```python
# Declaration
s = "Hello"
s = 'Hello'
s = """Multi
line"""
s = str(123)  # "123"

# Length
len(s)  # 5

# Indexing (0-based)
s[0]    # 'H' (first)
s[-1]   # 'o' (last)
s[1:4]  # 'ell' (slice)
s[::-1] # 'olleH' (reverse)

# Immutable operations (return new strings)
s.upper()       # 'HELLO'
s.lower()       # 'hello'
s.strip()       # Remove whitespace
s.replace('l', 'L')  # 'HeLLo'
s.split(' ')    # Split by delimiter

# Search
'ell' in s      # True
s.find('ell')   # 1 (index, -1 if not found)
s.index('ell')  # 1 (raises error if not found)
s.count('l')    # 2

# Character operations
s.isalpha()     # All letters?
s.isdigit()     # All digits?
s.isalnum()     # All alphanumeric?
ord('A')        # 65 (ASCII value)
chr(65)         # 'A' (character from ASCII)

# Efficient building (for loops)
chars = ['H', 'e', 'l', 'l', 'o']
result = ''.join(chars)  # 'Hello' - O(n)
```

### JavaScript

```javascript
// Declaration
let s = "Hello";
let s = 'Hello';
let s = `Template ${variable}`;
let s = String(123);

// Length
s.length;  // 5

// Indexing (0-based)
s[0];                  // 'H'
s[s.length - 1];       // 'o'
s.slice(1, 4);         // 'ell'
s.substring(1, 4);     // 'ell' (similar to slice)

// Methods (return new strings)
s.toUpperCase();       // 'HELLO'
s.toLowerCase();       // 'hello'
s.trim();              // Remove whitespace
s.replace('l', 'L');   // 'HeLlo' (first only)
s.replaceAll('l', 'L'); // 'HeLLo' (all)
s.split('');           // ['H','e','l','l','o']

// Search
s.includes('ell');     // true
s.indexOf('ell');      // 1 (-1 if not found)
s.lastIndexOf('l');    // 3

// Character operations
s.charCodeAt(0);       // 72 (character code)
String.fromCharCode(72); // 'H'

// Efficient building
let chars = ['H', 'e', 'l', 'l', 'o'];
let result = chars.join('');  // 'Hello'
```

### Java

```java
// Declaration
String s = "Hello";
String s = new String("Hello");

// Length
s.length();  // 5

// Indexing
s.charAt(0);              // 'H'
s.substring(1, 4);        // "ell"

// Methods
s.toUpperCase();          // "HELLO"
s.toLowerCase();          // "hello"
s.trim();                 // Remove whitespace
s.replace('l', 'L');      // "HeLLo"

// Search
s.contains("ell");        // true
s.indexOf("ell");         // 1

// Character operations
(int) 'A';                // 65
(char) 65;                // 'A'

// Efficient building (StringBuilder)
StringBuilder sb = new StringBuilder();
sb.append("Hello");
sb.append(" World");
String result = sb.toString();  // O(n) total
```

---

## ‚ö° Time Complexity

| Operation | Python | JavaScript | Notes |
|-----------|--------|------------|-------|
| Length |" O(1) "| O(1) | Stored as property |
| Access by index |" O(1) "| O(1) | Direct access |
| Concatenation |" O(n+m) "| O(n+m) | Creates new string |
| Slice |" O(k) "| O(k) | k = slice length |
| Find/Search |" O(n*m) "| O(n*m) | n = string, m = pattern |
| Replace |" O(n) "| O(n) | Scans entire string |
| Join |" O(n) "| O(n) | n = total characters |
| Upper/Lower |" O(n) "| O(n) | Copies all chars |

### Concatenation in Loop - AVOID!

‚ùå **Wrong - O(n¬≤):**
```python
result = ""
for char in chars:
    result += char  # Creates new string each time!
```

‚úÖ **Correct - O(n):**
```python
result = ''.join(chars)  # Single allocation

# Or use list for building
parts = []
for char in chars:
    parts.append(char)  # O(1) amortized
result = ''.join(parts)  # O(n)
```

---

## üîÑ String Traversal

### Forward Traversal

```python
s = "Hello"

# By index
for i in range(len(s)):
    print(f"Index {i}: {s[i]}")

# By character
for char in s:
    print(char)

# With enumerate
for i, char in enumerate(s):
    print(f"{i}: {char}")
```

### Backward Traversal

```python
s = "Hello"

# By index
for i in range(len(s) - 1, -1, -1):
    print(s[i])

# Using reversed
for char in reversed(s):
    print(char)

# Slice (creates new string)
for char in s[::-1]:
    print(char)
```

---

## üéØ Common String Techniques

### 1. Two Pointers on Strings

```python
def is_palindrome(s: str) -> bool:
    """Check if string is palindrome.
    
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(s) - 1
    
    while left < right:
        # Skip non-alphanumeric
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True
```

### 2. Frequency Counting

```python
from collections import Counter

def are_anagrams(s1: str, s2: str) -> bool:
    """Check if two strings are anagrams.
    
    Time: O(n), Space: O(1) - only 26 letters
    """
    if len(s1) != len(s2):
        return False
    return Counter(s1) == Counter(s2)


# Manual approach (no imports)
def are_anagrams_manual(s1: str, s2: str) -> bool:
    if len(s1) != len(s2):
        return False
    
    count = [0] * 26
    for c in s1:
        count[ord(c) - ord('a')] += 1
    for c in s2:
        count[ord(c) - ord('a')] -= 1
    
    return all(c == 0 for c in count)
```

### 3. String to Character Array

```python
# Python - strings are already iterable
s = "hello"
chars = list(s)  # ['h', 'e', 'l', 'l', 'o']

# Modify
chars[0] = 'H'

# Back to string
s = ''.join(chars)  # 'Hello'
```

```javascript
// JavaScript
let s = "hello";
let chars = s.split('');  // ['h', 'e', 'l', 'l', 'o']

// Modify
chars[0] = 'H';

// Back to string
s = chars.join('');  // 'Hello'
```

### 4. String Reversal

```python
# Method 1: Slicing (creates new string)
s = "hello"
reversed_s = s[::-1]  # "olleh"

# Method 2: Using reversed() and join
reversed_s = ''.join(reversed(s))

# Method 3: Two pointers (for mutable structures)
def reverse_string(chars: list[str]) -> None:
    """Reverse in-place."""
    left, right = 0, len(chars) - 1
    while left < right:
        chars[left], chars[right] = chars[right], chars[left]
        left += 1
        right -= 1
```

---

## üìä ASCII and Character Arithmetic

```python
# ASCII values
ord('A')  # 65
ord('Z')  # 90
ord('a')  # 97
ord('z')  # 122
ord('0')  # 48
ord('9')  # 57

# Convert digit character to int
char = '5'
num = ord(char) - ord('0')  # 5

# Convert letter to index (0-25)
char = 'c'
index = ord(char) - ord('a')  # 2

# Check if lowercase letter
def is_lower(c):
    return ord('a') <= ord(c) <= ord('z')

# Check if digit
def is_digit(c):
    return ord('0') <= ord(c) <= ord('9')
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. String Immutability Confusion

‚ùå **Wrong:**
```python
s = "hello"
s[0] = 'H'  # TypeError!
```

‚úÖ **Correct:**
```python
s = "hello"
s = 'H' + s[1:]  # Create new string
# Or use list
chars = list(s)
chars[0] = 'H'
s = ''.join(chars)
```

### 2. Inefficient Concatenation

‚ùå **Wrong:**
```python
result = ""
for i in range(10000):
    result += str(i)  # O(n¬≤)!
```

‚úÖ **Correct:**
```python
result = ''.join(str(i) for i in range(10000))  # O(n)
```

### 3. Comparing Strings in JavaScript

‚ùå **Wrong:**
```javascript
"10" > "9"  // false! (lexicographic comparison)
```

‚úÖ **Correct:**
```javascript
parseInt("10") > parseInt("9")  // true
```

### 4. Empty String Edge Case

‚ùå **Wrong:**
```python
s = ""
first = s[0]  # IndexError!
```

‚úÖ **Correct:**
```python
s = ""
first = s[0] if s else None
# Or
if len(s) > 0:
    first = s[0]
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>When String Techniques Apply</strong></summary>

**Use string-specific approaches when:**
- Problem involves character manipulation
- Substring or subsequence finding
- Pattern matching or validation
- Anagram or permutation checking
- Palindrome detection

**Keywords in problem statement:**
- "palindrome", "anagram", "permutation"
- "substring", "subsequence"
- "reverse", "rotate"
- "pattern", "match", "find"
- "unique characters", "repeating"

</details>

---

## ‚úÖ When to Use Strings

- **Text processing** - Natural language, parsing
- **Pattern matching** - Search, validation
- **Encoding/decoding** - Serialization, compression
- **Character-level operations** - Anagrams, palindromes

## ‚ùå When NOT to Use Strings

| Situation | Why | Use Instead |
|-----------|-----|-------------|
| Frequent modifications | Immutability creates copies | List/StringBuilder |
| Numeric operations | String arithmetic is slow | int/float |
| Binary data | Character encoding issues | bytes/bytearray |
| Large concatenations |" O(n¬≤) in loops "| join() or StringBuilder |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Array Basics](../01-Arrays/1.1-Array-Basics.md) - Strings are char arrays
- Basic character encoding (ASCII)

**After mastering this:**
- [String Techniques](./2.4-String-Techniques.md) - Two Pointers, Sliding Window
- [Pattern Matching](./2.5-Pattern-Matching.md) - KMP, Rabin-Karp
- [Two Pointers](../01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md) - Applied to strings

**Related concepts:**
- **Hash Maps** - For anagram/frequency problems
- **Tries** - For prefix-based problems
- **Regular Expressions** - For complex patterns

</details>

---

## üîÑ Variations

| String Type | Description | Use Case |
|-------------|-------------|----------|
| Immutable | Cannot modify in-place | Python str, Java String |
| Mutable | Can modify in-place | C++ string, char arrays |
| Unicode | Full character set | Internationalization |
| ASCII | 128 characters | English text, simple parsing |
| Byte string | Raw bytes | Binary data, network protocols |
| Template/Format | Interpolation | Output formatting |

---

## üìù Practice Problems

| Problem | Difficulty | Focus | LeetCode |
|---------|------------|-------|----------|
| Reverse String | Easy | Two pointers | [LC 344](https://leetcode.com/problems/reverse-string/) |
| Valid Palindrome | Easy | Character filtering | [LC 125](https://leetcode.com/problems/valid-palindrome/) |
| Valid Anagram | Easy | Frequency counting | [LC 242](https://leetcode.com/problems/valid-anagram/) |
| First Unique Character | Easy | Hash map | [LC 387](https://leetcode.com/problems/first-unique-character-in-a-string/) |
| Longest Common Prefix | Easy | Vertical scanning | [LC 14](https://leetcode.com/problems/longest-common-prefix/) |
| String to Integer (atoi) | Medium | Parsing, edge cases | [LC 8](https://leetcode.com/problems/string-to-integer-atoi/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

After learning string basics:
- **Day 1:** Implement string reversal, palindrome check
- **Day 3:** Solve anagram problems with frequency array
- **Day 7:** Explain immutability and efficient concatenation
- **Day 14:** Implement atoi with all edge cases
- **Day 30:** Review ASCII vs Unicode handling

</details>

---

## üé§ Interview Context

<details>
<summary><strong>What Interviewers Expect</strong></summary>

**Foundation knowledge (expected):**
- String immutability in Python/Java/JS
- O(n) cost of concatenation in loops
- Character to ASCII conversion
- Common string methods

**Common interview scenarios:**
| Problem Type | Expected Approach |
|--------------|-------------------|
| Palindrome |" Two pointers, O(1) space "|
| Anagram | Sort or frequency array |
| Substring | Sliding window |
| Pattern match | KMP for bonus points |

**Company focus:**
| Company | String Focus |
|---------|--------------|
| Amazon | Parsing, validation |
| Google | Pattern matching, complex strings |
| Meta | Clean code, edge cases |
| Microsoft | Fundamentals, clear logic |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn string basics | 30 min | Indexing, methods |
| Understand immutability | 20 min | Critical for efficiency |
| Practice Easy problems | 10-15 min each | Build confidence |
| Master frequency counting | 30 min | Key technique |

---

## üìù Common String Methods Quick Reference

### Python

| Method | Description | Example |
|--------|-------------|---------|
| `s.upper()` | All uppercase | `"hello" ‚Üí "HELLO"` |
| `s.lower()` | All lowercase | `"HELLO" ‚Üí "hello"` |
| `s.strip()` | Remove whitespace | `" hi " ‚Üí "hi"` |
| `s.split(delim)` | Split to list | `"a,b" ‚Üí ["a", "b"]` |
| `s.join(list)` | Join list to string | `["a","b"] ‚Üí "a,b"` |
| `s.replace(old, new)` | Replace substring | `"hello" ‚Üí "jello"` |
| `s.find(sub)` | Find index | `"hello".find("l") ‚Üí 2` |
| `s.count(sub)` | Count occurrences | `"hello".count("l") ‚Üí 2` |
| `s.startswith(pre)` | Check prefix | `"hello".startswith("he") ‚Üí True` |
| `s.endswith(suf)` | Check suffix | `"hello".endswith("lo") ‚Üí True` |
| `s.isalpha()` | All letters? | `"abc".isalpha() ‚Üí True` |
| `s.isdigit()` | All digits? | `"123".isdigit() ‚Üí True` |
| `s.isalnum()` | Alphanumeric? | `"a1".isalnum() ‚Üí True` |

### JavaScript

| Method | Description | Example |
|--------|-------------|---------|
| `s.toUpperCase()` | All uppercase | `"hello" ‚Üí "HELLO"` |
| `s.toLowerCase()` | All lowercase | `"HELLO" ‚Üí "hello"` |
| `s.trim()` | Remove whitespace | `" hi " ‚Üí "hi"` |
| `s.split(delim)` | Split to array | `"a,b" ‚Üí ["a", "b"]` |
| `arr.join(delim)` | Join array | `["a","b"] ‚Üí "a,b"` |
| `s.replace(old, new)` | Replace first | `"hello" ‚Üí "jello"` |
| `s.replaceAll(old, new)` | Replace all | All occurrences |
| `s.indexOf(sub)` | Find index | `"hello".indexOf("l") ‚Üí 2` |
| `s.includes(sub)` | Contains? | `"hello".includes("ell") ‚Üí true` |
| `s.startsWith(pre)` | Check prefix | `"hello".startsWith("he") ‚Üí true` |
| `s.endsWith(suf)` | Check suffix | `"hello".endsWith("lo") ‚Üí true` |
| `s.charCodeAt(i)` | Char code at index | `"A".charCodeAt(0) ‚Üí 65` |

---

## üîó Related

- [String Techniques](./2.4-String-Techniques.md) - Two Pointers, Sliding Window on strings
- [Pattern Matching](./2.5-Pattern-Matching.md) - KMP, Rabin-Karp
- [Hash Maps](../03-Hashing/3.1-Hash-Maps.md) - For frequency counting

---

> **üí° Key Insight:** Strings in most languages are immutable arrays of characters. Use the same techniques (Two Pointers, Sliding Window) but be mindful of creating new strings in loops - use `''.join()` or `StringBuilder` for efficient concatenation.
