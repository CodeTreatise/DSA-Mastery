# 5.3 Deque (Double-Ended Queue)

> **Foundation Concept** | Essential for Sliding Window & Monotonic Problems

---

## Definition

A **Deque** (Double-Ended Queue) is a linear data structure that allows insertion and deletion at both ends in O(1) time.

Pronounced "deck" (rhymes with "check").

**Combines best of stack and queue:**
- Can use as stack (add/remove from same end)
- Can use as queue (add to one end, remove from other)
- Or use both ends freely

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use a Deque</strong></summary>

**Look for these signals:**
- Need O(1) operations at both ends
- Sliding window problems
- Monotonic queue (sliding window max/min)
- Need both stack and queue behavior

**Keywords:**
- "sliding window maximum/minimum"
- "add to front or back"
- "remove from either end"
- "maintain order with expiration"

</details>

---

## ‚úÖ When to Use Deque

- Sliding window max/min problems
- Implementing monotonic deque
- When you need stack AND queue behavior
- BFS with priority (0-1 BFS)
- Palindrome checking (both ends)

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Only need one end | Overkill | Stack or Queue |
| Random access | Deque is sequential | Array |
| Need sorting | Deque is unordered | Priority Queue |
| Simple FIFO/LIFO | Simpler structures exist | Queue/Stack |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md)
- [Queue Basics](./5.1-Queue-Basics.md)

**After mastering this:**
- [Monotonic Deque](../06-Monotonic-Deque/6.1-Monotonic-Deque-Concept.md)
- [Sliding Window Maximum](../06-Monotonic-Deque/6.2-Sliding-Window-Maximum.md)

**Related structures:**
- Stack (one-end deque)
- Queue (restricted deque)
- Circular Deque (fixed-size variant)

</details>

---

## üìê How It Works

### Core Operations

| Operation | Description | Time |
|-----------|-------------|------|
| `append(x)` / `push_back(x)` | Add to back |" O(1) "|
| `appendleft(x)` / `push_front(x)` | Add to front |" O(1) "|
| `pop()` / `pop_back()` | Remove from back |" O(1) "|
| `popleft()` / `pop_front()` | Remove from front |" O(1) "|
| `peek_back()` | View back |" O(1) "|
| `peek_front()` | View front |" O(1) "|

### Visual Representation

```
Deque: [1, 2, 3, 4, 5]
        ‚Üë           ‚Üë
      FRONT       BACK

Operations:
appendleft(0):  [0, 1, 2, 3, 4, 5]  ‚Üê Added to front
append(6):      [0, 1, 2, 3, 4, 5, 6]  ‚Üê Added to back
popleft():      [1, 2, 3, 4, 5, 6]  ‚Üê Removed 0 from front
pop():          [1, 2, 3, 4, 5]  ‚Üê Removed 6 from back
```

### Deque as Stack and Queue

```
# As Stack (use right end only):
deque.append(x)   # push
deque.pop()       # pop
deque[-1]         # peek

# As Queue (use both ends):
deque.append(x)   # enqueue (back)
deque.popleft()   # dequeue (front)
deque[0]          # front
```

---

## üíª Code Implementation

### Using collections.deque (Python - Recommended)

**Python:**
```python
from collections import deque

# Create deque
d = deque()

# Add elements
d.append(1)        # Add to back: deque([1])
d.append(2)        # Add to back: deque([1, 2])
d.appendleft(0)    # Add to front: deque([0, 1, 2])

# View elements
print(d[0])        # Front: 0
print(d[-1])       # Back: 2

# Remove elements
back = d.pop()     # Remove from back: 2, deque([0, 1])
front = d.popleft() # Remove from front: 0, deque([1])

# Other operations
d.extend([2, 3, 4])     # Add multiple to back
d.extendleft([-1, -2])  # Add multiple to front (reversed!)
d.rotate(1)             # Rotate right by 1
d.rotate(-1)            # Rotate left by 1

# Create with max length
d = deque(maxlen=3)     # Auto-discards from opposite end
d.append(1)  # [1]
d.append(2)  # [1, 2]
d.append(3)  # [1, 2, 3]
d.append(4)  # [2, 3, 4] (1 discarded from front)
```

**JavaScript:**
```javascript
// JavaScript doesn't have built-in deque
// Array works but shift()/unshift() are O(n)

// Simple usage (not optimal for front operations)
const deque = [];
deque.push(1);           // Add to back
deque.unshift(0);        // Add to front (O(n)!)
deque.pop();             // Remove from back
deque.shift();           // Remove from front (O(n)!)

// For O(1) operations, implement with doubly linked list
// or use a library
```

### Deque Class Implementation

**Python:**
```python
from collections import deque

class Deque:
    """
    Deque wrapper with clear method names.
    Uses collections.deque for O(1) operations.
    """
    
    def __init__(self):
        self._items = deque()
    
    # Add operations
    def push_front(self, item):
        """Add to front. O(1)."""
        self._items.appendleft(item)
    
    def push_back(self, item):
        """Add to back. O(1)."""
        self._items.append(item)
    
    # Remove operations
    def pop_front(self):
        """Remove and return front. O(1)."""
        if self.is_empty():
            raise IndexError("pop from empty deque")
        return self._items.popleft()
    
    def pop_back(self):
        """Remove and return back. O(1)."""
        if self.is_empty():
            raise IndexError("pop from empty deque")
        return self._items.pop()
    
    # View operations
    def peek_front(self):
        """View front without removing. O(1)."""
        if self.is_empty():
            raise IndexError("peek from empty deque")
        return self._items[0]
    
    def peek_back(self):
        """View back without removing. O(1)."""
        if self.is_empty():
            raise IndexError("peek from empty deque")
        return self._items[-1]
    
    # Utility
    def is_empty(self):
        return len(self._items) == 0
    
    def size(self):
        return len(self._items)
    
    def __len__(self):
        return self.size()
    
    def __bool__(self):
        return not self.is_empty()
```

**JavaScript (Optimized):**
```javascript
class Deque {
    /**
     * Deque implementation using doubly linked list
     * for true O(1) operations at both ends.
     */
    constructor() {
        this.head = null;
        this.tail = null;
        this._size = 0;
    }
    
    pushFront(val) {
        const node = { val, prev: null, next: this.head };
        if (this.head) {
            this.head.prev = node;
        }
        this.head = node;
        if (!this.tail) {
            this.tail = node;
        }
        this._size++;
    }
    
    pushBack(val) {
        const node = { val, prev: this.tail, next: null };
        if (this.tail) {
            this.tail.next = node;
        }
        this.tail = node;
        if (!this.head) {
            this.head = node;
        }
        this._size++;
    }
    
    popFront() {
        if (!this.head) {
            throw new Error("pop from empty deque");
        }
        const val = this.head.val;
        this.head = this.head.next;
        if (this.head) {
            this.head.prev = null;
        } else {
            this.tail = null;
        }
        this._size--;
        return val;
    }
    
    popBack() {
        if (!this.tail) {
            throw new Error("pop from empty deque");
        }
        const val = this.tail.val;
        this.tail = this.tail.prev;
        if (this.tail) {
            this.tail.next = null;
        } else {
            this.head = null;
        }
        this._size--;
        return val;
    }
    
    peekFront() {
        return this.head ? this.head.val : undefined;
    }
    
    peekBack() {
        return this.tail ? this.tail.val : undefined;
    }
    
    isEmpty() {
        return this._size === 0;
    }
    
    size() {
        return this._size;
    }
}
```

---

## ‚ö° Complexity Analysis

| Operation | collections.deque | Array (JS) | Linked List |
|-----------|-------------------|------------|-------------|
| push_front |" O(1) "| O(n) |" O(1) "|
| push_back |" O(1) "| O(1) |" O(1) "|
| pop_front |" O(1) "| O(n) |" O(1) "|
| pop_back |" O(1) "| O(1) |" O(1) "|
| peek_front |" O(1) "| O(1) |" O(1) "|
| peek_back |" O(1) "| O(1) |" O(1) "|
| Access by index |" O(n) "| O(1) |" O(n) "|

---

## üîÑ Common Deque Patterns

### Pattern 1: Sliding Window Maximum (Monotonic Deque)

```python
from collections import deque

def sliding_window_max(nums, k):
    """
    Use decreasing deque to track maximum in window.
    Deque stores indices with values in decreasing order.
    """
    result = []
    dq = deque()  # stores indices
    
    for i, num in enumerate(nums):
        # Remove expired elements from front
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Remove smaller elements from back
        while dq and nums[dq[-1]] < num:
            dq.pop()
        
        dq.append(i)
        
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result
```

### Pattern 2: Palindrome Checking

```python
from collections import deque

def is_palindrome(s):
    """Check palindrome by comparing both ends."""
    d = deque(s.lower().replace(' ', ''))
    
    while len(d) > 1:
        if d.popleft() != d.pop():
            return False
    return True
```

### Pattern 3: 0-1 BFS

```python
from collections import deque

def shortest_path_01(graph, start, end):
    """
    BFS where edges have weight 0 or 1.
    Add weight-0 edges to front, weight-1 to back.
    """
    dist = {start: 0}
    dq = deque([start])
    
    while dq:
        node = dq.popleft()
        
        for neighbor, weight in graph[node]:
            new_dist = dist[node] + weight
            
            if neighbor not in dist or new_dist < dist[neighbor]:
                dist[neighbor] = new_dist
                if weight == 0:
                    dq.appendleft(neighbor)  # Priority!
                else:
                    dq.append(neighbor)
    
    return dist.get(end, -1)
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Array Operations in JavaScript

```javascript
// ‚ùå WRONG: O(n) operations
deque.unshift(x);  // Add to front - O(n)
deque.shift();     // Remove from front - O(n)

// ‚úÖ CORRECT: Use proper deque implementation
// or track indices to avoid shifting
```

### 2. Forgetting Bounds Check

```python
# ‚ùå WRONG: Crashes on empty
val = dq.popleft()  # IndexError if empty

# ‚úÖ CORRECT: Check first
if dq:
    val = dq.popleft()
```

### 3. Indexing Confusion

```python
# Front is [0], back is [-1]
front = dq[0]   # First element (front)
back = dq[-1]   # Last element (back)

# ‚ùå WRONG: Mixed up
dq.popleft()    # Removes front
dq.pop()        # Removes back (not front!)
```

---

## üìù Practice Problems

### Deque Applications
- [ ] [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) - LC 239 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
- [ ] [Design Circular Deque](https://leetcode.com/problems/design-circular-deque/) - LC 641

### Related
- [ ] [Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/) - LC 1091 (BFS)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Use deque for basic operations
**Day 3:** Implement Sliding Window Maximum
**Day 7:** Implement palindrome checker
**Day 14:** Use 0-1 BFS pattern
**Day 21:** Solve without looking at notes

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Deque Interview Tips</strong></summary>

**When to mention deque:**
> "For sliding window max, I need O(1) operations at both ends, so I'll use a deque."

**Python-specific:**
> "I'll use collections.deque which gives O(1) for append/pop at both ends."

**JavaScript note:**
> "JavaScript's Array doesn't have O(1) front operations, so I'll either use an index-based approach or implement a proper deque."

**Monotonic deque explanation:**
> "The deque maintains indices in decreasing order of values. This lets me query the maximum in O(1) while handling element expiration from the front."

</details>

**Company Focus:**

| Company | Frequency | Common Use |
|---------|-----------|------------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Sliding Window Max |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Monotonic problems |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Design problems |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn operations | 10-15 min | Basic usage |
| Sliding window max | 25-30 min | With explanation |
| Master pattern | 2-3 hours | Multiple problems |

---

> **üí° Key Insight:** The deque's power is flexibility - it's a stack, a queue, or both, all with O(1) operations. For sliding window problems, this flexibility allows us to maintain candidates at one end while expiring them from the other, achieving what would otherwise require O(n) per window.

---

## üîó Related

- [Queue Basics](./5.1-Queue-Basics.md) - FIFO-only version
- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md) - LIFO-only version
- [Monotonic Deque](../06-Monotonic-Deque/6.1-Monotonic-Deque-Concept.md) - Key application
- [Sliding Window Maximum](../06-Monotonic-Deque/6.2-Sliding-Window-Maximum.md) - Classic problem
