# What Is a Trie?

> **A Trie (pronounced "try") is a tree-like data structure that stores strings character by character, enabling blazing-fast prefix operations.**

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Trie Problems</strong></summary>

**Look for these signals:**
- "Find all words starting with prefix..."
- "Implement autocomplete/search suggestions"
- "Check if word exists in dictionary"
- "Find longest common prefix"
- "Word search in a grid" (Trie + Backtracking)
- "Maximum XOR of two numbers" (Bit Trie)

**Keywords in problem statement:**
- "prefix", "dictionary", "autocomplete"
- "spell check", "word search"
- "starts with", "common prefix"
- "XOR", "maximum XOR" (for Bit Trie)

**Data characteristics:**
- Many strings with common prefixes
- Need to search by prefix, not just exact match
- Dictionary/vocabulary operations

</details>

---

## ‚úÖ When to Use Trie

| Scenario | Why Trie Works |
|----------|----------------|
| **Prefix-based search** | O(m) lookup where m = prefix length |
| **Autocomplete systems** | Efficiently enumerate all words with prefix |
| **Spell checking** | Quick dictionary lookup + suggestions |
| **Word games (Boggle, Scrabble)** | Prune invalid paths early |
| **IP routing tables** | Longest prefix matching |
| **Contact list search** | Real-time filtering as user types |

---

## ‚ùå When NOT to Use Trie

| Scenario | Better Alternative | Why |
|----------|-------------------|-----|
| **Exact match only** | Hash Map | O(1) average, less memory |
| **Few strings** | Array/List | Simpler, less overhead |
| **Memory constrained** | Hash Set | Tries use more memory |
| **Numeric range queries** | Segment Tree | Purpose-built for ranges |
| **Single string patterns** | KMP/Rabin-Karp | More efficient for single pattern |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Tree Basics](../../06-Trees.md) - Trie is a tree structure
- [Hash Maps](../../09-Hashing.md) - Children often stored as hash maps
- [Recursion/DFS](../../02-Recursion-Backtracking.md) - Trie traversal uses DFS

**After mastering this:**
- [Trie Operations](../02-Trie-Operations/3.1-Insert-Operation.md) - Insert, Search, Delete
- [Trie + Backtracking](../03-Trie-Patterns/4.2-Trie-Plus-Backtracking.md) - Word Search II
- [Bit Trie](../04-Bit-Trie/5.1-Bit-Trie-Fundamentals.md) - XOR problems

**Combines with:**
- **Backtracking** for grid word search
- **DFS** for enumerating all words
- **DP** for word break problems
- **Heap** for top-K suggestions

</details>

---

## üìê How It Works

### The Core Idea

A Trie stores strings **character by character** along paths from root to leaf. Each node represents a character, and each path represents a prefix or complete word.

### Visual Example

```
Words to store: ["app", "apple", "ant", "bee", "be"]

        (root)
       /   |   \
      a    b    ...
     / \    \
    p   n    e
   /     \    \
  p(‚úì)    t(‚úì)  e(‚úì)
 /              |
l               (be ends here)
|
e(‚úì)

Legend:
- (‚úì) = End of word marker (is_end = true)
- Each edge represents a character
- Path from root = prefix of word(s)
```

### Key Properties

| Property | Description |
|----------|-------------|
| **Root** | Empty node, starting point |
| **Edges** | Characters connecting nodes |
| **Nodes** | Store children map + end marker |
| **Path** | Root ‚Üí Node = prefix |
| **End Marker** | `is_end = true` marks complete words |

### Why "Trie"?

The name comes from "re**TRIE**val" - it's designed for fast string retrieval. Also called:
- **Prefix Tree** (most descriptive)
- **Digital Tree**
- **Radix Tree** (compressed variant)

---

## üíª Trie Structure Overview

### Node Structure

**Python:**
```python
class TrieNode:
    def __init__(self):
        # Option 1: HashMap (flexible, any characters)
        self.children = {}  # char -> TrieNode
        
        # Option 2: Array (fixed, lowercase only)
        # self.children = [None] * 26
        
        self.is_end = False  # Marks end of a word
        
        # Optional extensions:
        # self.count = 0      # Number of words with this prefix
        # self.word = None    # Store complete word at end node
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        // HashMap approach (flexible)
        this.children = new Map();  // or {} for object
        this.isEnd = false;
        
        // Optional extensions:
        // this.count = 0;
        // this.word = null;
    }
}
```

### Trie Class Shell

```python
class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        """Add word to trie."""
        pass
    
    def search(self, word: str) -> bool:
        """Check if exact word exists."""
        pass
    
    def startsWith(self, prefix: str) -> bool:
        """Check if any word starts with prefix."""
        pass
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| **Insert** | O(m) | O(m) | m = word length, worst case creates m nodes |
| **Search** | O(m) | O(1) | Just traversal, no extra space |
| **StartsWith** | O(m) | O(1) | Same as search |
| **Delete** | O(m) | O(m) | Recursive stack |
| **Build Trie** | O(n √ó m) | O(n √ó m) | n words, avg length m |

**Why O(m) is powerful:**
- Independent of number of words stored
- Hash map lookup is O(m) too (for hashing string)
- But Trie enables **prefix operations** Hash Map can't do efficiently

### Space Analysis

```
Space = O(ALPHABET_SIZE √ó m √ó n) worst case
      = O(26 √ó avg_length √ó num_words) for lowercase

Actual space is usually much less due to shared prefixes!
```

**Example:**
- Words: ["app", "apple", "application"]
- Without Trie: 3 + 5 + 11 = 19 characters
- With Trie: Only 11 nodes (shared "appl" prefix)

---

## üîÑ Trie vs Other Structures

| Feature | Trie | Hash Map | BST |
|---------|------|----------|-----|
| **Insert** | O(m) | O(m) avg | O(m log n) |
| **Search** | O(m) | O(m) avg | O(m log n) |
| **Prefix Search** | O(m) ‚úÖ | O(n √ó m) ‚ùå | O(m log n) |
| **Autocomplete** | O(m + k) ‚úÖ | O(n √ó m) ‚ùå | O(m log n + k) |
| **Space** | High | Low | Medium |
| **Ordered** | Yes (by prefix) | No | Yes |

**Key insight:** Trie shines when you need **prefix operations**. For exact match only, Hash Map is simpler and more space-efficient.

---

## ‚ö†Ô∏è Common Mistakes

### 1. Confusing Search vs StartsWith

**‚ùå Wrong:**
```python
def search(self, word):
    node = self._traverse(word)
    return node is not None  # Wrong! Doesn't check is_end
```

**‚úÖ Correct:**
```python
def search(self, word):
    node = self._traverse(word)
    return node is not None and node.is_end  # Must be complete word!
```

### 2. Forgetting to Mark End

**‚ùå Wrong:**
```python
def insert(self, word):
    node = self.root
    for char in word:
        if char not in node.children:
            node.children[char] = TrieNode()
        node = node.children[char]
    # Forgot to mark is_end!
```

**‚úÖ Correct:**
```python
def insert(self, word):
    node = self.root
    for char in word:
        if char not in node.children:
            node.children[char] = TrieNode()
        node = node.children[char]
    node.is_end = True  # Mark word completion!
```

### 3. Wrong Character Indexing

**‚ùå Wrong (for Array[26]):**
```python
index = ord(char)  # Wrong! 'a' = 97, not 0
```

**‚úÖ Correct:**
```python
index = ord(char) - ord('a')  # 'a' = 0, 'z' = 25
```

---

## üìù Practice Problems

### Easy (Learn the structure)
- [ ] [Implement Trie](https://leetcode.com/problems/implement-trie-prefix-tree/) - LC 208 ‚≠ê Start here

### Medium (Apply patterns)
- [ ] [Design Add and Search Words](https://leetcode.com/problems/design-add-and-search-words-data-structure/) - LC 211
- [ ] [Replace Words](https://leetcode.com/problems/replace-words/) - LC 648
- [ ] [Search Suggestions System](https://leetcode.com/problems/search-suggestions-system/) - LC 1268

### Hard (Master the pattern)
- [ ] [Word Search II](https://leetcode.com/problems/word-search-ii/) - LC 212 ‚≠ê Classic
- [ ] [Concatenated Words](https://leetcode.com/problems/concatenated-words/) - LC 472

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

After learning Trie basics:
- **Day 1:** Implement Trie from scratch (no looking)
- **Day 3:** Solve "Add and Search Words" with wildcards
- **Day 7:** Tackle "Word Search II" (Trie + Backtracking)
- **Day 14:** Design an autocomplete system
- **Day 30:** Review all patterns, explain to someone

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Recognizing the pattern:**
> "This problem involves prefix-based operations on a dictionary of words. A Trie would give us O(m) lookup where m is the word length, and importantly, it allows us to efficiently find all words with a given prefix."

**Explaining the structure:**
> "A Trie is like a tree where each edge represents a character. We traverse from the root, following character edges. Each node has a boolean marking if a complete word ends there."

**Discussing trade-offs:**
> "Trie uses more memory than a hash set due to pointer overhead, but it enables prefix operations that hash sets can't do efficiently. For this problem where we need [prefix search/autocomplete], that trade-off is worth it."

</details>

**Company Frequency:**

| Company | Frequency | Common Problems |
|---------|-----------|-----------------|
| **Uber** | ‚≠ê‚≠ê‚≠ê‚≠ê | Autocomplete, word search |
| **Airbnb** | ‚≠ê‚≠ê‚≠ê‚≠ê | Search suggestions |
| **Dropbox** | ‚≠ê‚≠ê‚≠ê | File path matching |
| **Google** | ‚≠ê‚≠ê | Less common, but appears |
| **Amazon** | ‚≠ê‚≠ê | Occasionally in design |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn Trie concept | 30-45 min | This file |
| Implement basic Trie | 20-30 min | Insert, Search, StartsWith |
| Solve LC 208 | 15-20 min | First Trie problem |
| Master Trie patterns | 2-3 hours | Multiple problems |
| Word Search II | 30-45 min | Hard, needs practice |

---

> **üí° Key Insight:** A Trie trades space for time on prefix operations. Every path from root represents a prefix shared by all words below it. This sharing is what makes Tries efficient for dictionaries with common prefixes.

> **üîó Related:** [TrieNode Structure](./2.1-TrieNode-Structure.md) | [Insert Operation](../02-Trie-Operations/3.1-Insert-Operation.md) | [Trie + Backtracking](../03-Trie-Patterns/4.2-Trie-Plus-Backtracking.md)
