# 2.4 Heapify (Build Heap)

## Definition

**Heapify** transforms an unordered array into a valid heap in **O(n)** time. This is more efficient than inserting elements one by one (O(n log n)).

```
Heapify transforms:

Unordered array:      ‚Üí      Valid Min-Heap:
[5, 3, 8, 1, 2]              [1, 2, 8, 5, 3]

    5                            1
   / \                          / \
  3   8           ‚Üí            2   8
 / \                          / \
1   2                        5   3
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Heapify</strong></summary>

**Primary scenarios:**
- Have existing array, need heap
- Building heap from scratch
- Heap sort (heapify first)
- Top K from static array

**Key insight:**
```
n insertions: O(n log n)
Heapify:      O(n)

For large n, heapify is significantly faster!
```

**When heapify vs repeated insert:**
- Have all elements upfront ‚Üí heapify
- Elements arrive one by one ‚Üí insert

</details>

---

## ‚úÖ When to Use

| Scenario | Why Heapify? |
|----------|--------------|
| Array to heap |" O(n) vs O(n log n) "|
| Heap sort | First step |
| nsmallest/nlargest | Build then extract |
| Bulk initialization | All elements known |

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|---------------------|
| Streaming data |" Use insert O(log n) "|
| Single element | Just insert |
| Already a heap | No need |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Insert (bubble up)](./2.1-Insert.md)
- [Extract (bubble down)](./2.2-Extract.md)
- [Heap Property](../01-Heap-Fundamentals/1.2-Heap-Property.md)

**After mastering this:**
- [Heap Sort](../08-Heap-Sort/8.1-Heap-Sort-Algorithm.md)
- [Top K Pattern](../04-Top-K-Pattern/4.1-Top-K-Overview.md)

**Related:**
- Bottom-up construction
- Floyd's algorithm

</details>

---

## üìê How It Works

### The Key Insight: Bottom-Up

```
Why bottom-up is O(n):

Naive approach (top-down, n inserts):
  Each insert is O(log n)
  Total: O(n log n)

Bottom-up approach:
  1. Start from last internal node (has children)
  2. Bubble down each node
  3. Work backward to root

Leaves (n/2 nodes): Already satisfy heap property (no children)
Level above leaves: At most 1 swap each
Level above that: At most 2 swaps each
...

Mathematical sum: O(n)
```

### Algorithm

```
HEAPIFY(arr):
    n = len(arr)
    
    # Start from last internal node (index n//2 - 1)
    # and work backward to root (index 0)
    
    for i from (n//2 - 1) down to 0:
        BUBBLE_DOWN(arr, i, n)

Why start at n//2 - 1?
  - Nodes from n//2 to n-1 are leaves
  - Leaves trivially satisfy heap property
  - Only need to fix internal nodes
```

### Visual Example

```
Build min-heap from [5, 3, 8, 1, 2]:

Initial (not a heap):
        5
       / \
      3   8
     / \
    1   2

n = 5, last internal node = 5//2 - 1 = 1

Step 1: Bubble down node at index 1 (value 3)
  Compare 3 with children 1, 2
  1 < 2 < 3 ‚Üí swap 3 with 1
        5
       / \
      1   8
     / \
    3   2

Step 2: Bubble down node at index 0 (value 5)
  Compare 5 with children 1, 8
  1 < 5 < 8 ‚Üí swap 5 with 1
        1
       / \
      5   8
     / \
    3   2
    
  Now 5 at index 1, compare with children 3, 2
  2 < 3 < 5 ‚Üí swap 5 with 2
        1
       / \
      2   8
     / \
    3   5

Done! Valid min-heap: [1, 2, 8, 3, 5]
```

### Why O(n)? Mathematical Proof

```
Height of tree: h = log‚ÇÇ(n)

At level i (0 = root, h = leaves):
  Number of nodes: 2^i
  Max bubble-down distance: h - i

Total work:
  Œ£ (nodes at level i) * (bubble-down distance)
  = Œ£ 2^i * (h - i)  for i = 0 to h-1
  
Let k = h - i (height from bottom):
  = Œ£ 2^(h-k) * k  for k = 1 to h
  = 2^h * Œ£ (k / 2^k)  for k = 1 to h
  = n * Œ£ (k / 2^k)
  
Œ£ (k / 2^k) converges to 2 (infinite series)

Therefore: Total work = O(2n) = O(n)
```

---

## üíª Code Implementation

### Min-Heap Heapify

**Python:**
```python
import heapq

def heapify_builtin(arr: list) -> None:
    """
    Transform array into min-heap in-place.
    Uses Python's heapq.
    
    Time: O(n)
    Space: O(1)
    """
    heapq.heapify(arr)


def heapify_manual(arr: list) -> None:
    """
    Manual heapify implementation (min-heap).
    """
    n = len(arr)
    
    # Start from last internal node
    for i in range(n // 2 - 1, -1, -1):
        bubble_down(arr, i, n)


def bubble_down(arr: list, i: int, n: int) -> None:
    """Bubble down for min-heap."""
    while True:
        smallest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[left] < arr[smallest]:
            smallest = left
        if right < n and arr[right] < arr[smallest]:
            smallest = right
        
        if smallest == i:
            break
        
        arr[i], arr[smallest] = arr[smallest], arr[i]
        i = smallest


# Example:
arr = [5, 3, 8, 1, 2]
heapify_manual(arr)
print(arr)  # [1, 2, 8, 5, 3] or similar valid min-heap
```

**JavaScript:**
```javascript
function heapify(arr) {
    const n = arr.length;
    
    // Start from last internal node
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        bubbleDown(arr, i, n);
    }
}

function bubbleDown(arr, i, n) {
    while (true) {
        let smallest = i;
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        
        if (left < n && arr[left] < arr[smallest]) smallest = left;
        if (right < n && arr[right] < arr[smallest]) smallest = right;
        
        if (smallest === i) break;
        
        [arr[i], arr[smallest]] = [arr[smallest], arr[i]];
        i = smallest;
    }
}

// Example:
const arr = [5, 3, 8, 1, 2];
heapify(arr);
console.log(arr);  // [1, 2, 8, 5, 3]
```

### Max-Heap Heapify

**Python:**
```python
def heapify_max(arr: list) -> None:
    """Build max-heap from array."""
    n = len(arr)
    
    for i in range(n // 2 - 1, -1, -1):
        bubble_down_max(arr, i, n)


def bubble_down_max(arr: list, i: int, n: int) -> None:
    """Bubble down for max-heap."""
    while True:
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[left] > arr[largest]:
            largest = left
        if right < n and arr[right] > arr[largest]:
            largest = right
        
        if largest == i:
            break
        
        arr[i], arr[largest] = arr[largest], arr[i]
        i = largest


# Example:
arr = [5, 3, 8, 1, 2]
heapify_max(arr)
print(arr)  # [8, 3, 5, 1, 2] (max at root)
```

### Heapify for nlargest/nsmallest

**Python:**
```python
import heapq

def find_k_largest_heapify(arr: list, k: int) -> list:
    """
    Find K largest using heapify.
    
    Strategy: Build max-heap, extract K times
    Time: O(n + k log n)
    """
    # Negate for max-heap
    max_heap = [-x for x in arr]
    heapq.heapify(max_heap)  # O(n)
    
    result = []
    for _ in range(k):  # O(k log n)
        result.append(-heapq.heappop(max_heap))
    
    return result


def find_k_smallest_heapify(arr: list, k: int) -> list:
    """
    Find K smallest using heapify.
    
    Time: O(n + k log n)
    """
    heap = arr.copy()
    heapq.heapify(heap)  # O(n)
    
    result = []
    for _ in range(k):  # O(k log n)
        result.append(heapq.heappop(heap))
    
    return result


# Compare with heapq's built-in:
arr = [5, 3, 8, 1, 2, 9, 4, 7, 6]
print(heapq.nsmallest(3, arr))  # [1, 2, 3]
print(heapq.nlargest(3, arr))   # [9, 8, 7]
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Bottom-up heapify |" O(n) "| O(1) | In-place |
| n insertions |" O(n log n) "| O(1) | Slower |
| heapq.heapify |" O(n) "| O(1) | Python built-in |

**When is O(n) important?**
```
For n = 1,000,000:
  O(n) ‚âà 1,000,000 operations
  O(n log n) ‚âà 20,000,000 operations

Heapify is ~20x faster for large arrays!
```

---

## üîÑ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| **heapify** | Build min-heap | Standard |
| **heapify_max** | Build max-heap | Priority max |
| **Partial heapify** | K elements only | Top K |
| **Floyd's algorithm** | Classic bottom-up | Original name |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Starting from Wrong Index

```python
# ‚ùå Wrong: Starting from index 0 (includes leaves unnecessarily)
for i in range(n - 1, -1, -1):
    bubble_down(arr, i, n)

# ‚úÖ Correct: Start from last internal node
for i in range(n // 2 - 1, -1, -1):
    bubble_down(arr, i, n)
```

### 2. Using Insert Loop Instead of Heapify

```python
# ‚ùå Suboptimal: O(n log n)
def build_heap_slow(arr):
    heap = []
    for x in arr:
        heapq.heappush(heap, x)
    return heap

# ‚úÖ Optimal: O(n)
def build_heap_fast(arr):
    heap = arr.copy()
    heapq.heapify(heap)
    return heap
```

### 3. Modifying Original Array Unexpectedly

```python
# ‚ùå Risky: Modifies original
arr = [5, 3, 8, 1, 2]
heapq.heapify(arr)  # arr is now a heap!

# ‚úÖ Safe: Work on copy if original needed
arr = [5, 3, 8, 1, 2]
heap = arr.copy()
heapq.heapify(heap)
# arr unchanged, heap is min-heap
```

### 4. Forgetting n Parameter in Bubble Down

```python
# ‚ùå Wrong: Using len(arr) inside bubble_down when n differs
def bubble_down(arr, i):
    n = len(arr)  # Problem during heap sort!
    
# ‚úÖ Correct: Pass n as parameter
def bubble_down(arr, i, n):
    # Use n for bounds checking
```

---

## üìù Practice Problems (Progressive)

### Easy (Understand heapify)
- [ ] Implement heapify for min-heap
- [ ] Implement heapify for max-heap
- [ ] [Kth Largest Element (LC 215)](https://leetcode.com/problems/kth-largest-element-in-an-array/)

### Medium (Apply heapify)
- [ ] [Top K Frequent Elements (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/)
- [ ] [Sort Characters by Frequency (LC 451)](https://leetcode.com/problems/sort-characters-by-frequency/)

### Hard (Master heapify)
- [ ] Implement heap sort using heapify
- [ ] [Sort an Array (LC 912)](https://leetcode.com/problems/sort-an-array/) - Use heap sort

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement heapify manually
- **Day 3:** Trace through with example
- **Day 7:** Prove O(n) complexity
- **Day 14:** Use heapify in heap sort
- **Day 30:** Compare with n inserts timing

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Explain This in Interviews</strong></summary>

**Describing heapify:**
"Heapify builds a heap from an unordered array in O(n) time using bottom-up construction. We start from the last internal node and bubble down each node toward the root. Since leaves already satisfy the heap property, we skip them."

**Why O(n):**
"The key insight is that most nodes are near the bottom where bubble-down distance is small. Leaves (half the nodes) need 0 work. The level above needs at most 1 swap each. When you sum it up mathematically, it's O(n)."

**When to use:**
"I use heapify when I have all elements upfront - like finding K largest from a static array. For streaming data where elements arrive one by one, I'd use individual inserts instead."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| All | ‚≠ê‚≠ê‚≠ê‚≠ê | Fundamental operation |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê |" May ask for O(n) proof "|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Applied in Top K |
| Meta | ‚≠ê‚≠ê‚≠ê | Used in priority queue |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 15-20 min |" Why O(n) "|
| Implement | 15-20 min | Bottom-up loop |
|" Prove O(n) "| 10-15 min | Mathematical |
| Apply to heap sort | 20-25 min | Full algorithm |

---

## üí° Key Insight

> **Heapify is O(n) because most work happens near leaves where bubble-down is cheap.** The bottom-up approach exploits the tree structure: half the nodes are leaves (0 work), quarter have max 1 swap, eighth have max 2 swaps, etc. This geometric sum converges to O(n), not O(n log n).

---

## üîó Related

- **Previous:** [Peek Operation](./2.3-Peek.md)
- **Next:** [Heap Sort](../08-Heap-Sort/8.1-Heap-Sort-Algorithm.md)
- **Related:** [Insert](./2.1-Insert.md) | [Extract](./2.2-Extract.md)
