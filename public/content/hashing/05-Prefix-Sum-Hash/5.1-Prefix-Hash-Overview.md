# Prefix Sum + Hash Map Pattern

> **Turn O(n¬≤) subarray problems into O(n) using prefix sums and hash maps.**

The Prefix Sum + Hash Map pattern is one of the most powerful techniques for subarray problems. It transforms "find subarray with property X" into "find two prefix sums with relationship Y."

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem signals:**
- "Subarray sum equals K"
- "Count subarrays with sum..."
- "Longest subarray with sum..."
- "Subarray sum divisible by..."
- Contiguous elements with some sum property

**Key insight:**
```
sum(arr[i:j]) = prefix[j] - prefix[i-1]
```

If we want `sum(arr[i:j]) == k`:
```
prefix[j] - prefix[i-1] == k
prefix[i-1] == prefix[j] - k
```

So we look for a previous prefix sum equal to `current_prefix - k`.

</details>

---

## ‚úÖ When to Use

- Finding subarrays with target sum
- Counting subarrays with specific sum
- Longest/shortest subarray with sum property
- Subarray sum divisible by K
- Problems involving contiguous elements and sums

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Non-contiguous subsequences | Prefix only works for contiguous | DP |
| Product instead of sum | Need different approach | Logarithms or different pattern |
| Maximum subarray sum | Different optimization | Kadane's Algorithm |
| Two Sum (elements, not subarray) | Not subarray problem | Two Sum pattern |
| Sliding window with fixed size | Simpler approach | Basic sliding window |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- [Prefix Sum Basics](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/03-Prefix-Sum.md)
- [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
- [Two Sum Pattern](../04-Two-Sum-Pattern/4.1-Two-Sum-Overview.md) - Similar "complement" logic

**After mastering:**
- [Subarray Sum Equals K (LC 560)](./5.2-Subarray-Sum-K-LC560.md)
- [Continuous Subarray Sum (LC 523)](./5.3-Continuous-Subarray-LC523.md)
- Subarray Sums Divisible by K (LC 974)
- Maximum Size Subarray Sum Equals k (LC 325)

**Combines with:**
- Hash Map for O(1) prefix lookup
- Modular arithmetic for divisibility problems

</details>

---

## üìê How It Works

### The Core Transformation

**Problem:** Find subarray with sum = k

**Brute Force (O(n¬≤)):**
```python
for i in range(n):
    for j in range(i, n):
        if sum(arr[i:j+1]) == k:  # O(n) sum
            # Found!
```

**With Prefix Sum + Hash (O(n)):**
```python
prefix = 0
prefix_map = {0: 1}  # Sum 0 seen once (empty prefix)

for num in arr:
    prefix += num
    # If (prefix - k) exists, we found subarray(s)!
    if prefix - k in prefix_map:
        # Subarray from that index to here has sum k
        count += prefix_map[prefix - k]
    prefix_map[prefix] = prefix_map.get(prefix, 0) + 1
```

### Why It Works

```
Array:    [1,  2,  3,  4,  5]  Target k = 9
Indices:   0   1   2   3   4

Prefix:   [1,  3,  6,  10, 15]

At index 3, prefix = 10
We want subarray sum = 9
Need previous prefix = 10 - 9 = 1
Prefix 1 exists at index 0!
So arr[1:4] = [2,3,4] sums to 9 ‚úì
```

### Visualization

```
Array:  [  3,   4,   7,   2,  -3,   1,   4,   2  ]
Index:     0    1    2    3    4    5    6    7

Prefix: [  3,   7,  14,  16,  13,  14,  18,  20  ]

Target k = 7

At index 1: prefix = 7
            prefix - k = 7 - 7 = 0
            prefix_map has 0 ‚Üí subarray [0:2] = [3,4] sums to 7 ‚úì

At index 2: prefix = 14
            prefix - k = 14 - 7 = 7
            prefix_map has 7 ‚Üí subarray [2:3] = [7] sums to 7 ‚úì

At index 5: prefix = 14
            prefix - k = 14 - 7 = 7
            prefix_map has 7 ‚Üí subarray [2:6] = [7,2,-3,1] sums to 7 ‚úì
```

---

## üíª Code Implementation

### Python - Count Subarrays with Sum K

```python
from collections import defaultdict
from typing import List

def subarray_sum_count(nums: List[int], k: int) -> int:
    """
    Count subarrays with sum equal to k.
    
    Key insight: If prefix[j] - prefix[i] = k,
    then subarray from i+1 to j has sum k.
    
    Time: O(n), Space: O(n)
    """
    count = 0
    prefix = 0
    prefix_count = defaultdict(int)
    prefix_count[0] = 1  # Empty prefix (sum 0 exists once)
    
    for num in nums:
        prefix += num
        
        # How many times have we seen (prefix - k)?
        # Each occurrence gives us a valid subarray
        count += prefix_count[prefix - k]
        
        # Record this prefix sum
        prefix_count[prefix] += 1
    
    return count
```

### Python - Find Any Subarray with Sum K

```python
def subarray_with_sum(nums: List[int], k: int) -> tuple:
    """
    Find indices of any subarray with sum k.
    Returns (start, end) inclusive, or (-1, -1) if none.
    
    Time: O(n), Space: O(n)
    """
    prefix = 0
    prefix_index = {0: -1}  # prefix_sum -> first index where seen
    
    for i, num in enumerate(nums):
        prefix += num
        
        if prefix - k in prefix_index:
            start = prefix_index[prefix - k] + 1
            return (start, i)
        
        # Only store first occurrence for subarray finding
        if prefix not in prefix_index:
            prefix_index[prefix] = i
    
    return (-1, -1)
```

### Python - Longest Subarray with Sum K

```python
def longest_subarray_sum_k(nums: List[int], k: int) -> int:
    """
    Find length of longest subarray with sum k.
    
    Key: Store only the FIRST occurrence of each prefix sum.
    This maximizes the subarray length.
    
    Time: O(n), Space: O(n)
    """
    max_length = 0
    prefix = 0
    prefix_index = {0: -1}  # First occurrence
    
    for i, num in enumerate(nums):
        prefix += num
        
        if prefix - k in prefix_index:
            length = i - prefix_index[prefix - k]
            max_length = max(max_length, length)
        
        # Only store first occurrence (for maximum length)
        if prefix not in prefix_index:
            prefix_index[prefix] = i
    
    return max_length
```

### JavaScript - Count Subarrays with Sum K

```javascript
/**
 * Count subarrays with sum equal to k.
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
function subarraySumCount(nums, k) {
    let count = 0;
    let prefix = 0;
    const prefixCount = new Map([[0, 1]]);  // Sum 0 seen once
    
    for (const num of nums) {
        prefix += num;
        
        // Count valid subarrays ending here
        if (prefixCount.has(prefix - k)) {
            count += prefixCount.get(prefix - k);
        }
        
        // Record this prefix
        prefixCount.set(prefix, (prefixCount.get(prefix) || 0) + 1);
    }
    
    return count;
}
```

### JavaScript - Longest Subarray with Sum K

```javascript
function longestSubarraySumK(nums, k) {
    let maxLength = 0;
    let prefix = 0;
    const prefixIndex = new Map([[0, -1]]);  // First occurrence
    
    for (let i = 0; i < nums.length; i++) {
        prefix += nums[i];
        
        if (prefixIndex.has(prefix - k)) {
            const length = i - prefixIndex.get(prefix - k);
            maxLength = Math.max(maxLength, length);
        }
        
        // Only store first occurrence
        if (!prefixIndex.has(prefix)) {
            prefixIndex.set(prefix, i);
        }
    }
    
    return maxLength;
}
```

---

## ‚ö° Complexity Analysis

| Variant | Time | Space | Notes |
|---------|------|-------|-------|
| Count subarrays | O(n) | O(n) | Count all occurrences |
| Find any subarray | O(n) | O(n) | Store first index |
| Longest subarray | O(n) | O(n) | Store first index |
| Divisible by K | O(n) | O(K) | At most K remainders |

**Why O(n) time:**
- Single pass through array
- O(1) hash map operations

**Why O(n) space:**
- At most n unique prefix sums
- For divisibility: only K possible remainders

---

## üîÑ Variations

| Variation | Key Difference | Problem |
|-----------|----------------|---------|
| Count subarrays | Store count of each prefix | LC 560 |
| Longest subarray | Store first index only | LC 325 |
| Subarray divisible by K | Use prefix % k | LC 974 |
| Continuous subarray sum | Multiple of k | LC 523 |
| Product of subarray | Use log sums | Different approach |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting the Empty Prefix

```python
# ‚ùå WRONG: Missing prefix 0
prefix_count = {}

# ‚úÖ CORRECT: Initialize with 0
prefix_count = {0: 1}  # Empty subarray has sum 0
```

**Why:** If subarray starting from index 0 has sum k, we need prefix - k = 0 to exist.

### 2. Wrong Initialization for Index Problems

```python
# For counting: prefix_count = {0: 1}
# For finding indices: prefix_index = {0: -1}
#                                          ^^ -1 not 0!
```

### 3. Storing Last vs First Index

```python
# For LONGEST subarray: store FIRST occurrence
if prefix not in prefix_index:
    prefix_index[prefix] = i

# For SHORTEST subarray: store LAST occurrence
prefix_index[prefix] = i  # Always update
```

### 4. Modulo for Negative Numbers

```python
# For divisibility problems:
# ‚ùå WRONG: Python % is always non-negative, but JS isn't
remainder = prefix % k  # This is fine in Python

# JavaScript:
// ‚ùå WRONG: -5 % 3 = -2 in JS
// ‚úÖ CORRECT: ((prefix % k) + k) % k
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Key Insight | Link |
|---------|------------|-------------|------|
| Subarray Sum Equals K | üü° Medium | Count occurrences | [LC 560](https://leetcode.com/problems/subarray-sum-equals-k/) |
| Continuous Subarray Sum | üü° Medium | Multiple of k + length ‚â• 2 | [LC 523](https://leetcode.com/problems/continuous-subarray-sum/) |
| Max Size Subarray Sum K | üü° Medium | Store first index | [LC 325](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/) |
| Subarray Sums Divisible by K | üü° Medium | Modular arithmetic | [LC 974](https://leetcode.com/problems/subarray-sums-divisible-by-k/) |
| Make Sum Divisible by P | üü° Medium | Remove minimum subarray | [LC 1590](https://leetcode.com/problems/make-sum-divisible-by-p/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve LC 560 (subarray sum = k)
- **Day 3:** Solve LC 523 (multiple of k)
- **Day 7:** Solve LC 974 (divisible by k)
- **Day 14:** Solve LC 325 (longest subarray)
- **Day 30:** Mix of above, < 10 min each

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interview</strong></summary>

**Recognize the pattern:**
> "This is a subarray sum problem. I can use prefix sums with a hash map to solve it in O(n)."

**Explain the transformation:**
> "Instead of checking all O(n¬≤) subarrays, I'll track prefix sums. If current prefix minus target exists in my hash map, I've found a valid subarray."

**Handle follow-ups:**
> "For longest subarray: I store first occurrence of each prefix."
> "For divisibility: I use prefix mod k instead of prefix sum."

**Edge cases to mention:**
- Empty prefix (initialize map with 0)
- Negative numbers (still works!)
- Target k = 0 (need prefix to repeat)

</details>

**Company Focus:**

| Company | Frequency | Common Problems |
|---------|-----------|-----------------|
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | LC 560, LC 523 |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | LC 560, variations |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | LC 560 |
| Microsoft | ‚≠ê‚≠ê‚≠ê | LC 560 |

---

## ‚è±Ô∏è Time Estimates

| Activity | Target Time |
|----------|-------------|
| Understand pattern | 15-20 min |
| Solve LC 560 | 15 min |
| Solve LC 523 | 20 min |
| Master pattern | 5-6 problems |

---

> **üí° Key Insight:** The prefix sum + hash map pattern converts "find subarray with sum k" to "find prefix difference of k" - a simple hash lookup.

> **üîó Related:** [Prefix Sum Basics](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/03-Prefix-Sum.md) | [Two Sum Pattern](../04-Two-Sum-Pattern/4.1-Two-Sum-Overview.md) | [Subarray Sum K](./5.2-Subarray-Sum-K-LC560.md)
