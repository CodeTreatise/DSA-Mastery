# 7.1 Union-Find (Disjoint Set Union) Basics (Grokking Pattern #30)

> **Track connected components dynamically - essential for connectivity problems**
>
> üéØ **Interview Impact:** ~5-10% of graph problems | **Frequency:** High (Amazon, Google, Microsoft)

---

## Overview

**Union-Find** (also called **Disjoint Set Union** or DSU) is a data structure that tracks a partition of elements into disjoint (non-overlapping) sets. It supports two primary operations:

1. **Find(x)**: Which set does element x belong to?
2. **Union(x, y)**: Merge the sets containing x and y

```
Initial: {0}, {1}, {2}, {3}, {4}  (5 separate sets)

Union(0, 1): {0, 1}, {2}, {3}, {4}
Union(2, 3): {0, 1}, {2, 3}, {4}
Union(0, 2): {0, 1, 2, 3}, {4}

Find(1) == Find(3)?  ‚Üí Yes (same set)
Find(1) == Find(4)?  ‚Üí No (different sets)
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Union-Find Problems</strong></summary>

**Strong signals:**
1. "Connected components" that change dynamically
2. "Are X and Y connected?"
3. "Merge/union groups"
4. Undirected graph connectivity
5. Equivalence relations

**Keywords:**
- "Union", "merge", "group"
- "Connected", "same set/group"
- "Number of components"
- "Minimum spanning tree" (Kruskal's uses Union-Find)

**Union-Find vs DFS/BFS:**
| Use Union-Find | Use DFS/BFS |
|----------------|-------------|
| Dynamic connectivity (edges added) | Static graph |
| Need to answer many "connected?" queries | One-time traversal |
| Minimum spanning tree | Shortest path |
| Cycle detection in undirected graph | Path finding |

</details>

---

## ‚úÖ When to Use

- Dynamic connectivity queries (edges added over time)
- Kruskal's algorithm for MST
- Cycle detection in undirected graphs
- Connected components with merge operations
- Equivalence classes

## ‚ùå When NOT to Use

| Situation | Use Instead |
|-----------|-------------|
| Need shortest path | BFS or Dijkstra |
| Directed graph | DFS/BFS or Tarjan's |
| Static graph, one query | Single DFS/BFS |
| Need to traverse path | DFS with path tracking |

---

## üìê How It Works

### The Core Idea

Each set is represented as a **tree**, where all elements point to a common **root** (the representative).

```
Set {0, 1, 2, 3}:          parent array:
      0                    [0, 0, 0, 2]
     / \                   parent[0] = 0 (root)
    1   2                  parent[1] = 0
        |                  parent[2] = 0
        3                  parent[3] = 2
```

### Basic Operations

**Find(x):** Follow parent pointers until reaching root
```
Find(3): 3 ‚Üí 2 ‚Üí 0 (root)
```

**Union(x, y):** Connect root of one tree to root of other
```
Union(1, 4): Find(1)=0, Find(4)=4
             Set parent[4] = 0 (or parent[0] = 4)
```

---

## üíª Basic Implementation

**Python:**
```python
class UnionFind:
    """Basic Union-Find without optimizations."""
    
    def __init__(self, n: int):
        """Initialize n elements, each in its own set."""
        self.parent = list(range(n))  # parent[i] = i initially
        self.count = n  # Number of disjoint sets
    
    def find(self, x: int) -> int:
        """Find the root (representative) of x's set."""
        while self.parent[x] != x:
            x = self.parent[x]
        return x
    
    def union(self, x: int, y: int) -> bool:
        """
        Merge sets containing x and y.
        Returns True if merge happened, False if already same set.
        """
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False  # Already in same set
        
        # Make root_x the parent of root_y
        self.parent[root_y] = root_x
        self.count -= 1
        return True
    
    def connected(self, x: int, y: int) -> bool:
        """Check if x and y are in the same set."""
        return self.find(x) == self.find(y)
    
    def get_count(self) -> int:
        """Return number of disjoint sets."""
        return self.count


# Usage example
uf = UnionFind(5)
print(uf.count)  # 5

uf.union(0, 1)
uf.union(2, 3)
print(uf.count)  # 3

print(uf.connected(0, 1))  # True
print(uf.connected(0, 2))  # False

uf.union(1, 3)  # Connects {0,1} with {2,3}
print(uf.connected(0, 2))  # True
print(uf.count)  # 2
```

**JavaScript:**
```javascript
class UnionFind {
    constructor(n) {
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.count = n;
    }
    
    find(x) {
        while (this.parent[x] !== x) {
            x = this.parent[x];
        }
        return x;
    }
    
    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);
        
        if (rootX === rootY) return false;
        
        this.parent[rootY] = rootX;
        this.count--;
        return true;
    }
    
    connected(x, y) {
        return this.find(x) === this.find(y);
    }
}

// Usage
const uf = new UnionFind(5);
uf.union(0, 1);
uf.union(2, 3);
console.log(uf.connected(0, 2));  // false
uf.union(1, 3);
console.log(uf.connected(0, 2));  // true
console.log(uf.count);  // 2
```

---

## ‚ö° Complexity Analysis (Basic)

| Operation | Time | Space |
|-----------|------|-------|
| **Find** | O(n) worst | O(n) |
| **Union** | O(n) worst | O(n) |
| **Space** | ‚Äî | O(n) |

**Why O(n)?** Without optimizations, the tree can become a long chain:
```
Worst case tree:
0 ‚Üê 1 ‚Üê 2 ‚Üê 3 ‚Üê 4

Find(4) requires 4 hops = O(n)
```

---

## üîÑ Visual Trace

```
Initial: 0  1  2  3  4
parent: [0, 1, 2, 3, 4]
count: 5

Union(0, 1):
  Find(0)=0, Find(1)=1
  parent[1] = 0
  parent: [0, 0, 2, 3, 4]
  count: 4

Union(2, 3):
  Find(2)=2, Find(3)=3
  parent[3] = 2
  parent: [0, 0, 2, 2, 4]
  count: 3

Union(1, 3):
  Find(1)=0, Find(3)=2
  parent[2] = 0
  parent: [0, 0, 0, 2, 4]
  count: 2

Trees now:
    0           4
   /|\
  1 2
    |
    3
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Handling Self-Union

```python
# ‚ùå Not checking if already same set
def union(self, x, y):
    self.parent[self.find(y)] = self.find(x)
    self.count -= 1  # Always decrements!

# ‚úÖ Correct: Check first
def union(self, x, y):
    root_x, root_y = self.find(x), self.find(y)
    if root_x == root_y:
        return False  # Already connected
    self.parent[root_y] = root_x
    self.count -= 1
    return True
```

### 2. Using Index Instead of Root

```python
# ‚ùå Wrong: Connecting x directly to y
self.parent[y] = x

# ‚úÖ Correct: Connect root of y's tree to root of x's tree
self.parent[self.find(y)] = self.find(x)
```

### 3. Forgetting to Update Count

```python
# ‚ùå Missing count update
def union(self, x, y):
    if self.find(x) != self.find(y):
        self.parent[self.find(y)] = self.find(x)
        # Forgot to decrement count!
```

---

## üìù Basic Practice Problems

| Problem | Key Concept | Link |
|---------|-------------|------|
| Number of Provinces | Count components | [LC 547](https://leetcode.com/problems/number-of-provinces/) |
| Redundant Connection | Cycle detection | [LC 684](https://leetcode.com/problems/redundant-connection/) |
| Accounts Merge | Merge by equivalence | [LC 721](https://leetcode.com/problems/accounts-merge/) |

---

## üé§ Interview Context

<details>
<summary><strong>When Interviewers Expect Union-Find</strong></summary>

**Clear signals:**
- "Add edges and check connectivity"
- "Merge groups dynamically"
- "Find minimum spanning tree"

**vs. DFS/BFS:**
- If graph is static and you do one traversal ‚Üí DFS/BFS
- If connectivity queries come with edge additions ‚Üí Union-Find

**Mention optimizations:**
> "The basic version has O(n) operations, but with path compression and union by rank, we get nearly O(1) amortized - specifically O(Œ±(n)) where Œ± is the inverse Ackermann function, practically constant."

</details>

---

> **üí° Key Insight:** Union-Find answers "are these two elements connected?" by asking "do they have the same representative (root)?" It's the go-to structure when you need dynamic connectivity tracking.

---

**Next:** [Optimizations (Path Compression + Union by Rank) ‚Üí](./7.2-Optimizations.md)
