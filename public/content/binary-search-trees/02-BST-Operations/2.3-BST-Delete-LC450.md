# 2.3 Delete Node in BST (LC 450)

## Problem Statement

[LeetCode 450 - Delete Node in a BST](https://leetcode.com/problems/delete-node-in-a-bst/)

Given a root of a BST and a key, delete the node with the given key and return the new root. The BST property must be maintained.

```
Input: root = [5,3,6,2,4,null,7], key = 3
        5                    5
       / \                  / \
      3   6       ‚Üí        4   6
     / \   \              /     \
    2   4   7            2       7

Output: [5,4,6,2,null,null,7]
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a BST Delete problem with 3 cases:**

1. **Leaf node:** Just remove it
2. **One child:** Replace with child
3. **Two children:** Replace with successor (or predecessor)

**Keywords:**
- "delete", "remove" from BST
- "maintain BST property"
- "restructure tree"

**Pattern:** Search + Case-based restructuring

</details>

---

## ‚úÖ When to Use

- Removing elements from BST
- Implementing set/map removal
- Any dynamic BST that needs deletion

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Lazy deletion needed | Full delete is expensive | Mark as deleted |
| Frequent deletions | Can unbalance | Self-balancing tree |
| Bulk deletions | Inefficient | Rebuild tree |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Search (LC 700)](./2.1-BST-Search-LC700.md) - Find node first
- [BST Insert (LC 701)](./2.2-BST-Insert-LC701.md) - Understand structure
- [Successor/Predecessor](../01-BST-Fundamentals/1.3-BST-MinMax-Successor.md) - For two-child case

**After mastering this:**
- [Trim BST (LC 669)](../03-BST-Validation/3.3-Trim-BST-LC669.md) - Range-based deletion
- [Self-Balancing Trees](../08-Advanced-BST/8.2-Self-Balancing-Overview.md) - Maintain balance

**Combines with:**
- Search (to find the node)
- Successor finding (for replacement)

</details>

---

## üìê How It Works

### The Three Cases

#### Case 1: Leaf Node (No Children)
```
Delete 7:
    5               5
   / \             / \
  3   6    ‚Üí      3   6
       \
        7         (just remove)
```

#### Case 2: One Child
```
Delete 6 (has right child only):
    5               5
   / \             / \
  3   6    ‚Üí      3   7
       \
        7         (replace with child)
```

#### Case 3: Two Children (Most Complex)
```
Delete 3 (has both children):
    5                    5
   / \                  / \
  3   6       ‚Üí        4   6
 / \   \              /     \
2   4   7            2       7

Step 1: Find successor (smallest in right subtree) = 4
Step 2: Replace 3's value with 4
Step 3: Delete the original 4 (which is a simpler case)
```

### Why Use Successor?

```
The successor is the smallest value greater than the node.

If we replace the deleted node with its successor:
- All values in left subtree are still smaller ‚úì
- All values in right subtree are still larger ‚úì
- BST property maintained!

We could also use predecessor (largest in left subtree).
```

---

## üíª Code Implementation

### Recursive (Clean and Preferred)

**Python:**
```python
def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
    """
    Delete node with given key from BST.
    
    Time: O(h) - find node + find successor
    Space: O(h) - recursion stack
    
    Three cases:
    1. Leaf: just remove
    2. One child: replace with child
    3. Two children: replace with successor value, delete successor
    """
    if not root:
        return None
    
    # Step 1: Find the node to delete
    if key < root.val:
        root.left = self.deleteNode(root.left, key)
    elif key > root.val:
        root.right = self.deleteNode(root.right, key)
    else:
        # Found the node to delete
        
        # Case 1 & 2: Zero or one child
        if not root.left:
            return root.right  # Replace with right (or None)
        if not root.right:
            return root.left   # Replace with left
        
        # Case 3: Two children
        # Find inorder successor (smallest in right subtree)
        successor = self.findMin(root.right)
        
        # Replace current value with successor's value
        root.val = successor.val
        
        # Delete the successor from right subtree
        root.right = self.deleteNode(root.right, successor.val)
    
    return root

def findMin(self, node: TreeNode) -> TreeNode:
    """Find minimum value node in subtree."""
    while node.left:
        node = node.left
    return node
```

**JavaScript:**
```javascript
var deleteNode = function(root, key) {
    if (!root) return null;
    
    // Search for the node
    if (key < root.val) {
        root.left = deleteNode(root.left, key);
    } else if (key > root.val) {
        root.right = deleteNode(root.right, key);
    } else {
        // Found node to delete
        
        // Case 1 & 2: Zero or one child
        if (!root.left) return root.right;
        if (!root.right) return root.left;
        
        // Case 3: Two children
        let successor = findMin(root.right);
        root.val = successor.val;
        root.right = deleteNode(root.right, successor.val);
    }
    
    return root;
};

function findMin(node) {
    while (node.left) node = node.left;
    return node;
}
```

### Alternative: Using Predecessor

**Python:**
```python
def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
    """Delete using predecessor instead of successor."""
    if not root:
        return None
    
    if key < root.val:
        root.left = self.deleteNode(root.left, key)
    elif key > root.val:
        root.right = self.deleteNode(root.right, key)
    else:
        if not root.left:
            return root.right
        if not root.right:
            return root.left
        
        # Use predecessor (largest in left subtree)
        predecessor = self.findMax(root.left)
        root.val = predecessor.val
        root.left = self.deleteNode(root.left, predecessor.val)
    
    return root

def findMax(self, node: TreeNode) -> TreeNode:
    """Find maximum value node in subtree."""
    while node.right:
        node = node.right
    return node
```

### Iterative (More Complex but O(1) Space)

**Python:**
```python
def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
    """Iterative deletion - O(1) space."""
    # Find node and its parent
    parent, current = None, root
    
    while current and current.val != key:
        parent = current
        if key < current.val:
            current = current.left
        else:
            current = current.right
    
    if not current:
        return root  # Key not found
    
    # Delete the node
    replacement = self.deleteHelper(current)
    
    if not parent:
        return replacement  # Deleting root
    elif parent.left == current:
        parent.left = replacement
    else:
        parent.right = replacement
    
    return root

def deleteHelper(self, node: TreeNode) -> TreeNode:
    """Get replacement for deleted node."""
    if not node.left:
        return node.right
    if not node.right:
        return node.left
    
    # Two children: find successor and restructure
    successor_parent = node
    successor = node.right
    
    while successor.left:
        successor_parent = successor
        successor = successor.left
    
    # Replace node value with successor value
    node.val = successor.val
    
    # Remove successor
    if successor_parent == node:
        successor_parent.right = successor.right
    else:
        successor_parent.left = successor.right
    
    return node
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space (Recursive) | Space (Iterative) |
|------|------|-------------------|-------------------|
| Leaf |" O(h) "| O(h) |" O(1) "|
| One child |" O(h) "| O(h) |" O(1) "|
| Two children |" O(h) "| O(h) |" O(1) "|

**Breakdown:**
- **Finding node:** O(h)
- **Finding successor:** O(h) in worst case (height of right subtree)
- **Total:** O(h) since paths don't overlap significantly

**Why O(h):**
```
Delete node at depth d:
1. Navigate to node: d steps
2. Find successor: at most h - d steps
3. Delete successor: already at that location

Total ‚â§ h steps
```

---

## üîÑ Variations

| Variation | Modification | Use Case |
|-----------|--------------|----------|
| **Lazy delete** | Mark as deleted | Frequent deletions |
| **Using predecessor** | Use max of left subtree | Either works |
| **Delete by merging** | Merge left/right subtrees | Alternative approach |
| **With balancing** | Rebalance after delete | AVL/Red-Black |

### Delete by Merging (Alternative to Successor)

```python
def deleteByMerge(root: TreeNode, key: int) -> TreeNode:
    """Delete by merging left subtree into right subtree."""
    if not root:
        return None
    
    if key < root.val:
        root.left = deleteByMerge(root.left, key)
    elif key > root.val:
        root.right = deleteByMerge(root.right, key)
    else:
        if not root.left:
            return root.right
        if not root.right:
            return root.left
        
        # Merge: attach left subtree to leftmost of right subtree
        leftmost = root.right
        while leftmost.left:
            leftmost = leftmost.left
        leftmost.left = root.left
        
        return root.right
    
    return root
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Handling All Three Cases

```python
# ‚ùå Wrong: Forgetting leaf case or one-child case
def deleteNode(root, key):
    if root.val == key:
        successor = findMin(root.right)  # Crashes if no right!
        ...

# ‚úÖ Correct: Check cases in order
def deleteNode(root, key):
    if root.val == key:
        if not root.left:
            return root.right
        if not root.right:
            return root.left
        # Only now handle two-children case
        ...
```

### 2. Not Returning the Modified Subtree

```python
# ‚ùå Wrong: Not reassigning the child
def deleteNode(root, key):
    if key < root.val:
        self.deleteNode(root.left, key)  # Lost the returned value!
    ...

# ‚úÖ Correct: Reassign the returned subtree
def deleteNode(root, key):
    if key < root.val:
        root.left = self.deleteNode(root.left, key)  # Reconnect!
    ...
```

### 3. Deleting Wrong Node (Successor's Original)

```python
# ‚ùå Wrong: Forgetting to delete successor after copying value
def deleteNode(root, key):
    if found:
        successor = findMin(root.right)
        root.val = successor.val
        # Missing: delete the original successor!

# ‚úÖ Correct: Delete the successor from right subtree
def deleteNode(root, key):
    if found:
        successor = findMin(root.right)
        root.val = successor.val
        root.right = deleteNode(root.right, successor.val)  # Delete original!
```

---

## üìù Practice Problems (Progressive)

### Easy (Build up to delete)
- [ ] [Search in BST (LC 700)](https://leetcode.com/problems/search-in-a-binary-search-tree/) - Find node first
- [ ] [Inorder Successor (LC 285)](https://leetcode.com/problems/inorder-successor-in-bst/) - Key concept for delete

### Medium (Apply deletion)
- [ ] [Delete Node in BST (LC 450)](https://leetcode.com/problems/delete-node-in-a-bst/) - This problem
- [ ] [Trim BST (LC 669)](https://leetcode.com/problems/trim-a-binary-search-tree/) - Range deletion
- [ ] [Balance a BST (LC 1382)](https://leetcode.com/problems/balance-a-binary-search-tree/) - Restructure tree

### Hard (Master edge cases)
- [ ] Implement AVL delete with rotations
- [ ] [Remove BST keys outside range](https://www.geeksforgeeks.org/remove-bst-keys-outside-the-given-range/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Draw all three cases on paper
- **Day 3:** Implement with successor approach
- **Day 7:** Implement with predecessor approach
- **Day 14:** Code iterative version
- **Day 30:** Explain to someone without looking at code

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"BST deletion has three cases depending on the node's children. For leaf nodes, I just remove. For one child, I replace with that child. For two children, I find the inorder successor, copy its value, and delete the successor recursively."

**Walk through example:**
- Draw the three cases
- Explain WHY successor maintains BST property

**Key points:**
- "The successor is always in the right subtree"
- "Successor has at most one child (no left), so deleting it is simple"
- "Time is O(h) since we traverse at most two paths"

**Follow-up questions:**
- "Why successor and not just any node?" ‚Üí Must maintain BST ordering
- "Could you use predecessor?" ‚Üí Yes, same approach but max of left
- "What about iterative?" ‚Üí More complex but O(1) space

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common BST question |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Fundamentals of BST |
| Google | ‚≠ê‚≠ê‚≠ê | May ask about balancing |
| Apple | ‚≠ê‚≠ê‚≠ê | Implementation details |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand 3 cases | 5-7 min | Draw each case |
| Code recursive | 12-15 min | Handle all cases |
| Code iterative | 18-22 min | More edge cases |
| Discuss complexity | 3-5 min |" O(h) explanation "|
| Total interview time | 25-35 min | Medium difficulty |

---

## üí° Key Insight

> **BST deletion's complexity comes from maintaining the invariant.** The successor (or predecessor) is the only value that can replace a two-child node without violating the BST property ‚Äî it's the closest value on one side, ensuring all comparisons still work.

---

## üîó Related

- **Previous:** [BST Insert (LC 701)](./2.2-BST-Insert-LC701.md)
- **Next:** [Inorder Successor (LC 285)](./2.4-Inorder-Successor-LC285.md)
- **Related:** [Trim BST (LC 669)](../03-BST-Validation/3.3-Trim-BST-LC669.md)
- **Foundation:** [Successor/Predecessor](../01-BST-Fundamentals/1.3-BST-MinMax-Successor.md)
