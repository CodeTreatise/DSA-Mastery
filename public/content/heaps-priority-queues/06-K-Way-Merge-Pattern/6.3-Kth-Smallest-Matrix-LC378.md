# 6.3 Kth Smallest Element in a Sorted Matrix (LC 378)

## Problem Statement

Given an `n x n` matrix where each row and column is sorted in ascending order, find the **kth smallest element**.

Note: It is the kth smallest element in sorted order, not the kth distinct element.

```
Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
Output: 13

Sorted elements: [1,5,9,10,11,12,13,13,15]
8th smallest = 13
```

**LeetCode:** [378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>Pattern: K-Way Merge OR Binary Search</strong></summary>

**Key signals:**
- "Sorted matrix" (each row sorted)
- "Kth smallest"
- Multiple sorted sequences

**Two valid approaches:**
```
Approach 1: K-Way Merge
  - Treat each row as a sorted list
  - Merge n sorted lists, stop at kth element
  - Time: O(k log n)

Approach 2: Binary Search on Value
  - Binary search for value where count(‚â§ value) = k
  - Count using matrix structure
  - Time: O(n log(max - min))
```

**When to use which:**
- K-Way Merge: k is small, k << n¬≤
- Binary Search: k is large, or need exact value in O(1) space

</details>

---

## ‚úÖ When to Use Each Approach

| Condition | Best Approach |
|-----------|---------------|
| k is small (k ‚âà n) | K-Way Merge |
| k is large (k ‚âà n¬≤) | Binary Search |
| Need streaming | K-Way Merge |
| Minimize space |" Binary Search O(1) "|

---

## üìê Solution Approaches

### Approach 1: K-Way Merge (Min-Heap)

```
Treat matrix as n sorted lists:
  Row 0: [1, 5, 9]
  Row 1: [10, 11, 13]
  Row 2: [12, 13, 15]

Min-heap contains one element from each "active" row:
  Initial: [(1, 0, 0)]  // (value, row, col)

Extract minimum, push next element from same row:
  Pop (1, 0, 0) ‚Üí push (5, 0, 1)
  Pop (5, 0, 1) ‚Üí push (9, 0, 2)
  Pop (9, 0, 2) ‚Üí no more in row 0
  Pop (10, 1, 0) ‚Üí push (11, 1, 1)
  ...

After k pops, return that value.
```

### Approach 2: Binary Search on Value

```
The kth smallest value x satisfies:
  count(elements ‚â§ x) ‚â• k
  count(elements < x) < k

Binary search between min (matrix[0][0]) and max (matrix[n-1][n-1])

For each mid value, count how many elements ‚â§ mid:
  Start from bottom-left corner
  If current ‚â§ mid: add row+1, move right
  Else: move up

If count ‚â• k, x might be answer or smaller ‚Üí search left
If count < k, x too small ‚Üí search right
```

---

## üíª Code Implementation

### Approach 1: K-Way Merge (Min-Heap)

**Python:**
```python
import heapq

def kthSmallest_heap(matrix: list[list[int]], k: int) -> int:
    """
    K-Way Merge approach using min-heap.
    
    Heap contains: (value, row, col)
    Extract k times to get kth smallest.
    
    Time: O(k log n) where n = number of rows
    Space: O(n) for heap
    """
    n = len(matrix)
    
    # Initialize heap with first element of each row
    # But actually, we only need first element (top-left)
    # because columns are also sorted!
    min_heap = [(matrix[0][0], 0, 0)]
    visited = {(0, 0)}
    
    for _ in range(k - 1):  # Pop k-1 times, then top is answer
        val, row, col = heapq.heappop(min_heap)
        
        # Add right neighbor
        if col + 1 < n and (row, col + 1) not in visited:
            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))
            visited.add((row, col + 1))
        
        # Add bottom neighbor
        if row + 1 < n and (row + 1, col) not in visited:
            heapq.heappush(min_heap, (matrix[row + 1][col], row + 1, col))
            visited.add((row + 1, col))
    
    return min_heap[0][0]


# Alternative: Initialize with first column (classic K-way merge)
def kthSmallest_heap_v2(matrix: list[list[int]], k: int) -> int:
    """
    Treat each row as a sorted list, merge them.
    
    Time: O(k log n)
    Space: O(n)
    """
    n = len(matrix)
    
    # Heap: (value, row, col)
    # Start with first element of each row
    min_heap = [(matrix[i][0], i, 0) for i in range(n)]
    heapq.heapify(min_heap)
    
    result = 0
    for _ in range(k):
        result, row, col = heapq.heappop(min_heap)
        
        if col + 1 < n:
            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))
    
    return result


# Example
matrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]
print(kthSmallest_heap(matrix, 8))  # 13
```

### Approach 2: Binary Search on Value

**Python:**
```python
def kthSmallest_binary(matrix: list[list[int]], k: int) -> int:
    """
    Binary Search on value range.
    
    Find smallest value x where count(‚â§ x) ‚â• k.
    
    Time: O(n log(max - min))
    Space: O(1)
    """
    n = len(matrix)
    
    def count_less_or_equal(mid):
        """Count elements ‚â§ mid using matrix structure."""
        count = 0
        row, col = n - 1, 0  # Start bottom-left
        
        while row >= 0 and col < n:
            if matrix[row][col] <= mid:
                count += row + 1  # All elements in this column up to row
                col += 1
            else:
                row -= 1
        
        return count
    
    left, right = matrix[0][0], matrix[n - 1][n - 1]
    
    while left < right:
        mid = (left + right) // 2
        count = count_less_or_equal(mid)
        
        if count < k:
            left = mid + 1
        else:
            right = mid
    
    return left


# Example
matrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]
print(kthSmallest_binary(matrix, 8))  # 13
```

### JavaScript Solutions

**JavaScript:**
```javascript
// Approach 1: K-Way Merge
function kthSmallestHeap(matrix, k) {
    const n = matrix.length;
    
    // Simple min-heap for this purpose
    const heap = [[matrix[0][0], 0, 0]];
    const visited = new Set(['0,0']);
    
    const push = (val, row, col) => {
        heap.push([val, row, col]);
        let i = heap.length - 1;
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (heap[parent][0] <= heap[i][0]) break;
            [heap[parent], heap[i]] = [heap[i], heap[parent]];
            i = parent;
        }
    };
    
    const pop = () => {
        const min = heap[0];
        const last = heap.pop();
        if (heap.length > 0) {
            heap[0] = last;
            let i = 0;
            while (true) {
                let smallest = i;
                const left = 2 * i + 1, right = 2 * i + 2;
                if (left < heap.length && heap[left][0] < heap[smallest][0]) smallest = left;
                if (right < heap.length && heap[right][0] < heap[smallest][0]) smallest = right;
                if (smallest === i) break;
                [heap[i], heap[smallest]] = [heap[smallest], heap[i]];
                i = smallest;
            }
        }
        return min;
    };
    
    for (let i = 0; i < k - 1; i++) {
        const [val, row, col] = pop();
        
        if (col + 1 < n && !visited.has(`${row},${col + 1}`)) {
            push(matrix[row][col + 1], row, col + 1);
            visited.add(`${row},${col + 1}`);
        }
        if (row + 1 < n && !visited.has(`${row + 1},${col}`)) {
            push(matrix[row + 1][col], row + 1, col);
            visited.add(`${row + 1},${col}`);
        }
    }
    
    return heap[0][0];
}


// Approach 2: Binary Search
function kthSmallestBinary(matrix, k) {
    const n = matrix.length;
    
    const countLessOrEqual = (mid) => {
        let count = 0;
        let row = n - 1, col = 0;
        
        while (row >= 0 && col < n) {
            if (matrix[row][col] <= mid) {
                count += row + 1;
                col++;
            } else {
                row--;
            }
        }
        return count;
    };
    
    let left = matrix[0][0], right = matrix[n - 1][n - 1];
    
    while (left < right) {
        const mid = Math.floor((left + right) / 2);
        if (countLessOrEqual(mid) < k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return left;
}
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Best When |
|----------|------|-------|-----------|
| K-Way Merge |" O(k log n) "| O(n) | k is small |
| Binary Search |" O(n log(max-min)) "| O(1) | k is large |
| Flatten + Sort |" O(n¬≤ log n¬≤) "| O(n¬≤) | Never optimal |

**Comparison:**
```
For n x n matrix:
  k = n:      Heap = O(n log n),    Binary = O(n log range)
  k = n¬≤/2:   Heap = O(n¬≤ log n),   Binary = O(n log range)
  k = n¬≤:     Heap = O(n¬≤ log n),   Binary = O(n log range)

Binary search wins for large k!
```

**Why binary search can find exact value:**
- We binary search on values that exist in matrix
- Even if mid doesn't exist, we find the boundary
- The answer will always be a value from the matrix

---

## üîÑ Variations

| Variation | Difference | Approach |
|-----------|------------|----------|
| Kth largest | Reverse order | Similar with max-heap |
| Range count | Count in [lo, hi] | Binary search |
| Unsorted matrix | Only rows sorted | Still works |
| Infinite matrix | Generator | Streaming |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Heap: Revisiting Same Cell

```python
# ‚ùå Wrong: May push same cell multiple times
min_heap = [(matrix[0][0], 0, 0)]
while heap:
    val, r, c = heappop(min_heap)
    heappush(min_heap, (matrix[r][c+1], r, c+1))  # Might duplicate!
    heappush(min_heap, (matrix[r+1][c], r+1, c))

# ‚úÖ Correct: Track visited cells
visited = {(0, 0)}
if (r, c+1) not in visited:
    heappush(...)
    visited.add((r, c+1))
```

### 2. Binary Search: Wrong Boundary

```python
# ‚ùå Wrong: Using count >= k to go left
if count >= k:
    right = mid - 1  # Might miss the answer!

# ‚úÖ Correct: Use right = mid (inclusive)
if count >= k:
    right = mid  # mid might be the answer
```

### 3. Binary Search: Assuming mid is in Matrix

```python
# ‚ùå Wrong: Assuming left is always in matrix
while left < right:
    mid = (left + right) // 2
    if count_less_or_equal(mid) < k:
        left = mid + 1
    else:
        right = mid
# left might not exist in matrix!

# Actually ‚úÖ Correct: The algorithm guarantees left IS in matrix
# Because we're finding the smallest value with count >= k
# And that value must exist in the matrix
```

### 4. K-Way Merge: Only Using First Row

```python
# ‚ùå Wrong: Only initializing with first element
heap = [(matrix[0][0], 0, 0)]
# Then only adding right neighbors ‚Üí misses elements!

# ‚úÖ Correct: Add both right AND down neighbors
# OR initialize with first element of each row
```

---

## üìù Related Practice Problems

### Similar
- [ ] [Merge K Sorted Lists (LC 23)](https://leetcode.com/problems/merge-k-sorted-lists/)
- [ ] [Find K Pairs with Smallest Sums (LC 373)](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/)

### Binary Search Variants
- [ ] [Search a 2D Matrix II (LC 240)](https://leetcode.com/problems/search-a-2d-matrix-ii/)
- [ ] [Median of Two Sorted Arrays (LC 4)](https://leetcode.com/problems/median-of-two-sorted-arrays/)

### Harder
- [ ] [Smallest Range Covering Elements (LC 632)](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement heap solution
- **Day 3:** Implement binary search solution
- **Day 7:** Compare complexities
- **Day 14:** Solve LC 373 (related)
- **Day 30:** Explain both approaches

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate Solutions</strong></summary>

**Opening:**
"I see two approaches here. First, K-Way Merge: treat each row as a sorted list and merge them using a min-heap, stopping at the kth element. Second, Binary Search on value: search for the smallest value where the count of elements ‚â§ that value is at least k."

**Discussing trade-offs:**
"K-Way Merge is O(k log n), better when k is small. Binary Search is O(n log(max-min)), better for large k or when we need O(1) space."

**For heap solution:**
"I'll use a min-heap with (value, row, col) tuples. Starting from top-left, I pop the minimum and push its right and bottom neighbors. After k pops, the answer is the last value popped."

**For binary search:**
"I'll binary search between min and max values. For each mid, I count elements ‚â§ mid by starting from bottom-left and moving right when ‚â§ mid (adding row+1 to count) or up when > mid."

</details>

**Company Focus:**

| Company | Frequency | Preferred Approach |
|---------|-----------|-------------------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Both, discuss trade-offs |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Heap approach |
| Meta | ‚≠ê‚≠ê‚≠ê | Either |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Binary search |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 3-5 min | Note sorted properties |
| Design (both) | 7-10 min | Discuss trade-offs |
| Implement heap | 12-15 min | With visited set |
| Implement binary | 10-12 min | Count function |
| Test | 3-5 min | Trace through |

**Interview target:** 30-35 minutes (one approach in detail)

---

## üí° Key Insight

> **For sorted matrix queries, you have two weapons: K-Way Merge (treat rows as sorted lists, use heap) and Binary Search on Value (use matrix structure to count efficiently).** K-Way Merge is O(k log n), Binary Search is O(n log range). Choose based on k vs n.

---

## üîó Related

- **Previous:** [Merge K Sorted Lists (LC 23)](./6.2-Merge-K-Lists-LC23.md)
- **Next:** [Smallest Range (LC 632)](./6.4-Smallest-Range-LC632.md)
- **Pattern:** [K-Way Merge Overview](./6.1-K-Way-Merge-Overview.md)
