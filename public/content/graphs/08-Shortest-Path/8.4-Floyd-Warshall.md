# 8.4 Floyd-Warshall Algorithm

> **All-pairs shortest path in O(V¬≥) - elegant DP solution**
>
> ‚è±Ô∏è **Study Time:** 30 min | üìä **Priority:** Medium | üéØ **Pattern:** Dynamic Programming

---

## Overview

**Floyd-Warshall** finds shortest paths between **all pairs** of vertices. Unlike Dijkstra (single source) or Bellman-Ford (single source with negatives), Floyd-Warshall computes the entire distance matrix.

**Core Idea (DP):**
```
dist[i][j] = shortest path from i to j using only vertices 0..k as intermediates

Base case: Direct edges or infinity
Transition: dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Floyd-Warshall Problems</strong></summary>

**Look for these signals:**
- Need shortest path between **all pairs** of nodes
- Small graph (V ‚â§ 400, since O(V¬≥))
- Dense graph (many edges)
- "Within threshold distance" problems

**Keywords in problem statement:**
- "for each pair", "between all cities"
- "reachability within distance X"
- "transitive closure"

**Choose Floyd-Warshall when:**
- Need all-pairs shortest paths
- Graph is small and dense
- Edges can be negative (but no negative cycles)

</details>

---

## ‚úÖ When to Use

- All-pairs shortest path needed
- Small graph (V ‚â§ 400)
- Dense graphs (E close to V¬≤)
- Transitive closure problems
- Reachability within threshold

## ‚ùå When NOT to Use

| Scenario | Better Choice | Why |
|----------|--------------|-----|
| Single source | Dijkstra/BF | O(E log V) vs O(V¬≥) |
| Large sparse graph | V √ó Dijkstra | O(V √ó E log V) < O(V¬≥) |
| Unweighted | V √ó BFS | O(V √ó (V+E)) |
| Very large graph | Specialized algorithms | O(V¬≥) too slow |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Dynamic Programming Basics](../../11-Dynamic-Programming.md)
- [Dijkstra's Algorithm](./8.2-Dijkstra.md)
- [Matrix Representation](../02-Graph-Representation/2.2-Adjacency-Matrix.md)

**After mastering this:**
- Johnson's Algorithm (all-pairs with reweighting)
- Transitive Closure
- Diameter of graph problems

**Combines with:**
- Binary search for optimization
- Matrix operations for path counting
- Negative cycle detection

</details>

---

## üìê How It Works

### The DP Insight

```
Key question: Can we improve path i‚Üíj by going through k?

dist[i][j] = min(
    dist[i][j],           // Current best (not using k)
    dist[i][k] + dist[k][j]  // Go through k
)

Process k from 0 to V-1, and we consider all possible intermediates!
```

### Step-by-Step Visualization

```
Graph:           Initial Distance Matrix:
    3                  0    1    2
0 ‚îÄ‚îÄ‚îÄ‚Üí 1           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       ‚îÇ          ‚îÇ  0   3   ‚àû   ‚îÇ  (direct edges only)
8‚îÇ      ‚îÇ1     0   ‚îÇ               ‚îÇ
‚Üì       ‚Üì          ‚îÇ  ‚àû   0   1   ‚îÇ
2 ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      1   ‚îÇ               ‚îÇ
                   ‚îÇ  ‚àû   ‚àû   0   ‚îÇ
               2   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

k=0 (consider paths through 0):
  No improvements (0 has no incoming edges)

k=1 (consider paths through 1):
  dist[0][2] = min(‚àû, dist[0][1] + dist[1][2])
             = min(‚àû, 3 + 1) = 4 ‚úì

k=2 (consider paths through 2):
  No improvements

Final Matrix:
     0    1    2
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ  0   3   4   ‚îÇ  0‚Üí2 goes through 1
0 ‚îÇ               ‚îÇ
  ‚îÇ  ‚àû   0   1   ‚îÇ
1 ‚îÇ               ‚îÇ
  ‚îÇ  ‚àû   ‚àû   0   ‚îÇ
2 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üíª Code Implementation

**Python:**
```python
from typing import List, Tuple

def floyd_warshall(n: int, edges: List[Tuple[int, int, int]]) -> List[List[float]]:
    """
    Floyd-Warshall all-pairs shortest path.
    
    Args:
        n: Number of vertices (0 to n-1)
        edges: List of (u, v, weight) tuples
    
    Returns:
        dist matrix where dist[i][j] = shortest path from i to j
    
    Time: O(V¬≥)
    Space: O(V¬≤)
    """
    INF = float('inf')
    
    # Initialize distance matrix
    dist = [[INF] * n for _ in range(n)]
    
    # Distance to self is 0
    for i in range(n):
        dist[i][i] = 0
    
    # Fill in direct edges
    for u, v, weight in edges:
        dist[u][v] = min(dist[u][v], weight)  # Handle parallel edges
    
    # Floyd-Warshall DP
    for k in range(n):  # Intermediate vertex
        for i in range(n):  # Source
            for j in range(n):  # Destination
                if dist[i][k] != INF and dist[k][j] != INF:
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    return dist


def floyd_warshall_with_path(n: int, edges: List[Tuple[int, int, int]]):
    """
    Floyd-Warshall with path reconstruction.
    """
    INF = float('inf')
    dist = [[INF] * n for _ in range(n)]
    next_node = [[None] * n for _ in range(n)]  # For path reconstruction
    
    for i in range(n):
        dist[i][i] = 0
    
    for u, v, weight in edges:
        if weight < dist[u][v]:
            dist[u][v] = weight
            next_node[u][v] = v  # Next step from u toward v is v
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] != INF and dist[k][j] != INF:
                    if dist[i][k] + dist[k][j] < dist[i][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]
                        next_node[i][j] = next_node[i][k]  # Go toward k first
    
    def get_path(u, v):
        if next_node[u][v] is None:
            return []
        path = [u]
        while u != v:
            u = next_node[u][v]
            path.append(u)
        return path
    
    return dist, get_path


def detect_negative_cycle(n: int, edges: List[Tuple[int, int, int]]) -> bool:
    """
    Detect negative cycle using Floyd-Warshall.
    A negative cycle exists if any dist[i][i] < 0.
    """
    dist = floyd_warshall(n, edges)
    
    for i in range(n):
        if dist[i][i] < 0:
            return True
    
    return False


# Example usage
edges = [(0, 1, 3), (1, 2, 1), (0, 2, 8)]
dist = floyd_warshall(3, edges)
print("Distance matrix:")
for row in dist:
    print([x if x != float('inf') else '‚àû' for x in row])
```

**JavaScript:**
```javascript
function floydWarshall(n, edges) {
    const INF = Infinity;
    
    // Initialize distance matrix
    const dist = Array.from({ length: n }, () => 
        new Array(n).fill(INF)
    );
    
    // Distance to self is 0
    for (let i = 0; i < n; i++) {
        dist[i][i] = 0;
    }
    
    // Fill in direct edges
    for (const [u, v, weight] of edges) {
        dist[u][v] = Math.min(dist[u][v], weight);
    }
    
    // Floyd-Warshall DP
    for (let k = 0; k < n; k++) {
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (dist[i][k] !== INF && dist[k][j] !== INF) {
                    dist[i][j] = Math.min(
                        dist[i][j],
                        dist[i][k] + dist[k][j]
                    );
                }
            }
        }
    }
    
    return dist;
}

// Transitive closure (can i reach j?)
function transitiveClosure(n, edges) {
    const reach = Array.from({ length: n }, () => 
        new Array(n).fill(false)
    );
    
    for (let i = 0; i < n; i++) {
        reach[i][i] = true;
    }
    
    for (const [u, v] of edges) {
        reach[u][v] = true;
    }
    
    for (let k = 0; k < n; k++) {
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                reach[i][j] = reach[i][j] || (reach[i][k] && reach[k][j]);
            }
        }
    }
    
    return reach;
}
```

---

## ‚ö° Complexity Analysis

| Aspect | Complexity | Notes |
|--------|------------|-------|
| **Time** | O(V¬≥) | Three nested loops |
| **Space** | O(V¬≤) | Distance matrix |

**Why O(V¬≥):**
- k loop: V iterations (intermediate nodes)
- i loop: V iterations (sources)
- j loop: V iterations (destinations)
- Total: V √ó V √ó V = V¬≥

**When is this efficient?**
- Dense graphs (E ‚âà V¬≤): Floyd-Warshall is simpler
- Need all pairs: V √ó Dijkstra = O(V √ó E log V)
  - Sparse: E ‚âà V ‚Üí O(V¬≤ log V) < O(V¬≥) ‚úì
  - Dense: E ‚âà V¬≤ ‚Üí O(V¬≥ log V) > O(V¬≥), so Floyd-Warshall wins

---

## üîÑ Variations

### 1. Transitive Closure

Just check if path exists (boolean):

```python
def transitive_closure(n, edges):
    """
    Can node i reach node j?
    """
    reach = [[False] * n for _ in range(n)]
    
    for i in range(n):
        reach[i][i] = True
    
    for u, v in edges:
        reach[u][v] = True
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                reach[i][j] = reach[i][j] or (reach[i][k] and reach[k][j])
    
    return reach
```

### 2. Find the City (LC 1334)

Count nodes reachable within threshold:

```python
def findTheCity(n, edges, distanceThreshold):
    """
    Find city with smallest number of reachable cities.
    """
    INF = float('inf')
    dist = [[INF] * n for _ in range(n)]
    
    for i in range(n):
        dist[i][i] = 0
    
    for u, v, w in edges:
        dist[u][v] = min(dist[u][v], w)
        dist[v][u] = min(dist[v][u], w)  # Undirected!
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    # Count reachable cities for each city
    result = 0
    min_count = n + 1
    
    for i in range(n):
        count = sum(1 for j in range(n) if i != j and dist[i][j] <= distanceThreshold)
        if count <= min_count:
            min_count = count
            result = i  # Take largest index if tie
    
    return result
```

### 3. Minimax Path

Instead of sum, use max (find path minimizing maximum edge):

```python
def minimax_path(n, edges):
    """
    dist[i][j] = minimum of maximum edge weights on any path from i to j.
    """
    INF = float('inf')
    dist = [[INF] * n for _ in range(n)]
    
    for i in range(n):
        dist[i][i] = 0
    
    for u, v, w in edges:
        dist[u][v] = min(dist[u][v], w)
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                # Path i‚Üík‚Üíj has max edge = max(max_edge(i,k), max_edge(k,j))
                through_k = max(dist[i][k], dist[k][j])
                dist[i][j] = min(dist[i][j], through_k)
    
    return dist
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Loop Order

```python
# ‚ùå WRONG: k must be outermost loop!
for i in range(n):
    for j in range(n):
        for k in range(n):  # Wrong!
            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

# ‚úÖ CORRECT: k is the "stage" of DP
for k in range(n):  # Consider intermediate k
    for i in range(n):
        for j in range(n):
            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

### 2. Overflow with Infinity

```python
# ‚ùå WRONG: inf + inf can cause issues
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
# If both are inf, this might behave unexpectedly

# ‚úÖ CORRECT: Check for infinity first
if dist[i][k] != INF and dist[k][j] != INF:
    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

### 3. Forgetting Self-Loops

```python
# ‚ùå WRONG: Forget to initialize diagonal
dist = [[INF] * n for _ in range(n)]
# dist[i][i] is INF!

# ‚úÖ CORRECT: Self-distance is 0
for i in range(n):
    dist[i][i] = 0
```

### 4. Undirected Graph - Missing Reverse Edge

```python
# ‚ùå WRONG: Only add one direction
for u, v, w in edges:
    dist[u][v] = w

# ‚úÖ CORRECT: Add both directions for undirected
for u, v, w in edges:
    dist[u][v] = min(dist[u][v], w)
    dist[v][u] = min(dist[v][u], w)
```

---

## üìù Practice Problems (Progressive)

### Easy (Basic implementation)
- [ ] [Find the Town Judge](https://leetcode.com/problems/find-the-town-judge/) - Reachability
- [ ] [Find Center of Star Graph](https://leetcode.com/problems/find-center-of-star-graph/) - Graph properties

### Medium (Apply Floyd-Warshall)
- [ ] [Find the City](https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/) - Count within threshold
- [ ] [Network Delay Time](https://leetcode.com/problems/network-delay-time/) - Can use FW (but Dijkstra better)

### Hard (Variations)
- [ ] [Shortest Path Visiting All Nodes](https://leetcode.com/problems/shortest-path-visiting-all-nodes/) - With bitmask DP
- [ ] [Evaluate Division](https://leetcode.com/problems/evaluate-division/) - Transitive closure with multiplication

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

| Day | Activity |
|-----|----------|
| 1 | Implement basic Floyd-Warshall |
| 3 | Explain why k must be outer loop |
| 7 | Solve Find the City problem |
| 14 | Implement path reconstruction |
| 30 | Solve a minimax variant |

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**When to mention Floyd-Warshall:**
> "Since we need shortest paths between all pairs of nodes and the graph is small, I'll use Floyd-Warshall. It's O(V¬≥) time and O(V¬≤) space."

**Explain the DP:**
> "The key insight is: for each pair (i,j), can we do better by going through node k? We iterate k from 0 to V-1, and at each step, dist[i][j] represents the shortest path using only nodes 0 to k-1 as intermediates."

**Why k must be outer:**
> "k represents the 'stage' of our DP. At stage k, we assume all paths through 0..k-1 are optimal. Then we consider if k improves any path."

</details>

**Company Focus:**
| Company | Frequency | Notes |
|---------|-----------|-------|
| **Google** | Medium | Often with modifications |
| **Meta** | Low | Prefer single-source |
| **Amazon** | Medium | Reachability problems |
| **Microsoft** | Medium | Graph connectivity |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn algorithm | 25 min | After Dijkstra/BF |
| Implement from scratch | 10 min | Simple triple loop |
| Solve Find the City | 25 min | Apply directly |
| Path reconstruction | 15 min | Add next_node tracking |

---

> **üí° Key Insight:** Floyd-Warshall is **DP with a clever ordering**. By making k the outer loop, when we consider paths through k, we've already computed all optimal paths using nodes 0..k-1.

---

> **üîó Related:** [Dijkstra](./8.2-Dijkstra.md) | [Bellman-Ford](./8.3-Bellman-Ford.md) | [Dynamic Programming](../../11-Dynamic-Programming.md)

---

**Back:** [‚Üê Bellman-Ford](./8.3-Bellman-Ford.md) | **Next:** [Shortest Path Practice ‚Üí](./8.5-SP-Practice/)
