# Sliding Window + Hash Pattern Overview

> **Combine sliding window traversal with hash-based state tracking for efficient substring/subarray problems.**

The sliding window + hash pattern uses a hash map or set to track element frequencies or membership within a dynamic window, enabling O(n) solutions for problems that would otherwise require O(n¬≤) brute force.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem signals:**
- "Substring with property X"
- "Longest/shortest subarray containing..."
- "Find all anagrams/permutations in string"
- "At most K distinct elements"
- "Minimum window containing all..."

**Two key components:**
```
1. Sliding Window: Dynamic range [left, right]
   - Expands right to include new elements
   - Shrinks left when constraint violated
   
2. Hash State: Track what's in the window
   - Hash Map: frequency counts
   - Hash Set: unique element tracking
```

**Pattern formula:**
```
Hash + Sliding Window = O(n) substring/subarray with constraints
```

</details>

---

## ‚úÖ When to Use

- Finding substrings/subarrays with specific character/element constraints
- Counting distinct elements in a range
- Finding permutations or anagrams within a string
- Maximum/minimum window with constraints
- Subarray with at most/at least K distinct elements

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need all pairs, not subarrays | Different structure | Two Sum pattern |
| Fixed window size only | Simpler approach | Basic sliding window |
| Non-contiguous elements | Window assumes contiguous | DP or hash alone |
| Ordered output needed | Additional sorting | Sort after finding |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- [Sliding Window Basics](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/02-Sliding-Window.md)
- [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
- [Frequency Pattern](../03-Frequency-Pattern/3.1-Frequency-Overview.md)

**After mastering:**
- [Longest Substring Without Repeating (LC 3)](./7.2-Longest-Substring-LC3.md)
- [Find All Anagrams (LC 438)](./7.3-Find-Anagrams-LC438.md)

**Related patterns:**
- Two Pointers (different: not about containment)
- Prefix Sum + Hash (different: not about contiguous windows)

</details>

---

## üìê How It Works

### The Core Idea

**Problem type:** Find substrings/subarrays satisfying a constraint

**Brute force:** Check every possible window ‚Üí O(n¬≤) or worse

**Optimized:** Slide a window, track state in hash ‚Üí O(n)

### Template Structure

```python
def sliding_window_hash_template(s, constraint):
    """
    Generic template for sliding window + hash problems.
    
    Window state tracked in hash map/set:
    - Expand right: add new element to hash
    - Contract left: remove element from hash (when needed)
    - Check constraint using hash
    """
    window_state = {}  # or set()
    left = 0
    result = 0  # or [] for collecting all valid windows
    
    for right in range(len(s)):
        # 1. Add s[right] to window state
        char = s[right]
        window_state[char] = window_state.get(char, 0) + 1
        
        # 2. Shrink window while constraint violated
        while constraint_violated(window_state):
            left_char = s[left]
            window_state[left_char] -= 1
            if window_state[left_char] == 0:
                del window_state[left_char]
            left += 1
        
        # 3. Update result (window [left, right] is valid)
        result = max(result, right - left + 1)
    
    return result
```

### Visualization - Longest Substring Without Repeating

```
s = "abcabcbb"

Window expansion (right moves ‚Üí):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Step ‚îÇ Window    ‚îÇ Hash Map        ‚îÇ Action       ‚îÇ Longest ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  0   ‚îÇ [a]       ‚îÇ {a:1}           ‚îÇ Add 'a'      ‚îÇ 1       ‚îÇ
‚îÇ  1   ‚îÇ [ab]      ‚îÇ {a:1, b:1}      ‚îÇ Add 'b'      ‚îÇ 2       ‚îÇ
‚îÇ  2   ‚îÇ [abc]     ‚îÇ {a:1, b:1, c:1} ‚îÇ Add 'c'      ‚îÇ 3       ‚îÇ
‚îÇ  3   ‚îÇ [abc]a    ‚îÇ {a:2, b:1, c:1} ‚îÇ Add 'a'‚Üídup! ‚îÇ         ‚îÇ
‚îÇ      ‚îÇ  [bca]    ‚îÇ {a:1, b:1, c:1} ‚îÇ Shrink left  ‚îÇ 3       ‚îÇ
‚îÇ  4   ‚îÇ  [bca]b   ‚îÇ {a:1, b:2, c:1} ‚îÇ Add 'b'‚Üídup! ‚îÇ         ‚îÇ
‚îÇ      ‚îÇ   [cab]   ‚îÇ {a:1, b:1, c:1} ‚îÇ Shrink left  ‚îÇ 3       ‚îÇ
‚îÇ  5   ‚îÇ   [cab]c  ‚îÇ {a:1, b:1, c:2} ‚îÇ Add 'c'‚Üídup! ‚îÇ         ‚îÇ
‚îÇ      ‚îÇ    [abc]  ‚îÇ {a:1, b:1, c:1} ‚îÇ Shrink left  ‚îÇ 3       ‚îÇ
‚îÇ  6   ‚îÇ    [abc]b ‚îÇ {a:1, b:2, c:1} ‚îÇ Add 'b'‚Üídup! ‚îÇ         ‚îÇ
‚îÇ      ‚îÇ     [cb]  ‚îÇ {b:1, c:1}      ‚îÇ Shrink left  ‚îÇ 3       ‚îÇ
‚îÇ      ‚îÇ      [b]b ‚îÇ {b:2}           ‚îÇ Still dup!   ‚îÇ         ‚îÇ
‚îÇ      ‚îÇ       [b] ‚îÇ {b:1}           ‚îÇ Shrink left  ‚îÇ 3       ‚îÇ
‚îÇ  7   ‚îÇ       [b]b‚îÇ {b:2}           ‚îÇ Add 'b'‚Üídup! ‚îÇ         ‚îÇ
‚îÇ      ‚îÇ        [b]‚îÇ {b:1}           ‚îÇ Shrink left  ‚îÇ 3       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Answer: 3 ("abc")
```

### Visualization - Find All Anagrams (Fixed Window)

```
s = "cbaebabacd", p = "abc" (window size = 3)

Need: window with exactly {a:1, b:1, c:1}

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Window   ‚îÇ Hash                ‚îÇ Match? ‚îÇ Result               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ [cba]    ‚îÇ {c:1, b:1, a:1}     ‚îÇ ‚úì      ‚îÇ [0]                  ‚îÇ
‚îÇ [bae]    ‚îÇ {b:1, a:1, e:1}     ‚îÇ ‚úó      ‚îÇ [0]                  ‚îÇ
‚îÇ [aeb]    ‚îÇ {a:1, e:1, b:1}     ‚îÇ ‚úó      ‚îÇ [0]                  ‚îÇ
‚îÇ [eba]    ‚îÇ {e:1, b:1, a:1}     ‚îÇ ‚úó      ‚îÇ [0]                  ‚îÇ
‚îÇ [bab]    ‚îÇ {b:2, a:1}          ‚îÇ ‚úó      ‚îÇ [0]                  ‚îÇ
‚îÇ [aba]    ‚îÇ {a:2, b:1}          ‚îÇ ‚úó      ‚îÇ [0]                  ‚îÇ
‚îÇ [bac]    ‚îÇ {b:1, a:1, c:1}     ‚îÇ ‚úì      ‚îÇ [0, 6]               ‚îÇ
‚îÇ [acd]    ‚îÇ {a:1, c:1, d:1}     ‚îÇ ‚úó      ‚îÇ [0, 6]               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Answer: [0, 6]
```

---

## üíª Code Templates

### Python - Variable Window Size (Longest Valid)

```python
from collections import defaultdict

def longest_substring_with_constraint(s: str, constraint_fn) -> int:
    """
    Find longest substring satisfying constraint.
    
    Args:
        s: Input string
        constraint_fn: Function that checks if window is valid
                      Takes window_count dict, returns bool
    
    Time: O(n) - each char added and removed at most once
    Space: O(k) where k = number of unique chars
    """
    window_count = defaultdict(int)
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # Expand: add s[right] to window
        window_count[s[right]] += 1
        
        # Shrink: remove from left while constraint violated
        while not constraint_fn(window_count):
            window_count[s[left]] -= 1
            if window_count[s[left]] == 0:
                del window_count[s[left]]
            left += 1
        
        # Update result
        max_length = max(max_length, right - left + 1)
    
    return max_length


# Example: Longest without repeating (all frequencies ‚â§ 1)
def all_unique(count):
    return all(v <= 1 for v in count.values())

result = longest_substring_with_constraint("abcabcbb", all_unique)  # 3


# Example: At most K distinct characters
def at_most_k_distinct(k):
    def check(count):
        return len(count) <= k
    return check

result = longest_substring_with_constraint("eceba", at_most_k_distinct(2))  # 3
```

### Python - Fixed Window Size (Match Condition)

```python
from collections import Counter

def fixed_window_match(s: str, target_count: dict, window_size: int) -> list:
    """
    Find all positions where fixed-size window matches target count.
    
    Use case: Find all anagrams of p in s
    
    Time: O(n) - slide window across string
    Space: O(k) where k = alphabet size
    """
    result = []
    window_count = Counter()
    
    for i in range(len(s)):
        # Add new character
        window_count[s[i]] += 1
        
        # Remove character going out of window
        if i >= window_size:
            left_char = s[i - window_size]
            window_count[left_char] -= 1
            if window_count[left_char] == 0:
                del window_count[left_char]
        
        # Check if current window matches target
        if i >= window_size - 1 and window_count == target_count:
            result.append(i - window_size + 1)
    
    return result


# Example: Find all anagrams
s = "cbaebabacd"
p = "abc"
positions = fixed_window_match(s, Counter(p), len(p))  # [0, 6]
```

### Python - Minimum Window Containing All

```python
from collections import Counter, defaultdict

def min_window_containing(s: str, t: str) -> str:
    """
    Find minimum window in s containing all characters of t.
    
    LC 76: Minimum Window Substring
    
    Time: O(n + m)
    Space: O(k) where k = unique chars
    """
    if not t or not s:
        return ""
    
    # Count required characters
    required = Counter(t)
    required_unique = len(required)
    
    # Track window state
    window_count = defaultdict(int)
    formed = 0  # Number of unique chars with required frequency
    
    # Result: (window length, left, right)
    ans = (float('inf'), 0, 0)
    
    left = 0
    for right in range(len(s)):
        char = s[right]
        window_count[char] += 1
        
        # Check if this char's frequency matches requirement
        if char in required and window_count[char] == required[char]:
            formed += 1
        
        # Try to contract window while valid
        while formed == required_unique and left <= right:
            # Update result if this window is smaller
            if right - left + 1 < ans[0]:
                ans = (right - left + 1, left, right)
            
            # Remove left char from window
            left_char = s[left]
            window_count[left_char] -= 1
            if left_char in required and window_count[left_char] < required[left_char]:
                formed -= 1
            left += 1
    
    return "" if ans[0] == float('inf') else s[ans[1]:ans[2]+1]
```

### JavaScript - Variable Window

```javascript
/**
 * Longest substring with at most k distinct characters.
 * 
 * @param {string} s - Input string
 * @param {number} k - Max distinct characters
 * @return {number} - Length of longest valid substring
 */
function longestSubstringKDistinct(s, k) {
    const windowCount = new Map();
    let left = 0;
    let maxLength = 0;
    
    for (let right = 0; right < s.length; right++) {
        // Expand: add s[right]
        const rightChar = s[right];
        windowCount.set(rightChar, (windowCount.get(rightChar) || 0) + 1);
        
        // Shrink: while more than k distinct
        while (windowCount.size > k) {
            const leftChar = s[left];
            windowCount.set(leftChar, windowCount.get(leftChar) - 1);
            if (windowCount.get(leftChar) === 0) {
                windowCount.delete(leftChar);
            }
            left++;
        }
        
        // Update result
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}
```

### JavaScript - Fixed Window Match

```javascript
/**
 * Find all anagram starting indices.
 * 
 * @param {string} s - Source string
 * @param {string} p - Pattern to find anagrams of
 * @return {number[]} - Starting indices
 */
function findAnagrams(s, p) {
    if (p.length > s.length) return [];
    
    const result = [];
    const pCount = new Map();
    const windowCount = new Map();
    
    // Build pattern frequency
    for (const char of p) {
        pCount.set(char, (pCount.get(char) || 0) + 1);
    }
    
    // Helper to compare maps
    const mapsEqual = (m1, m2) => {
        if (m1.size !== m2.size) return false;
        for (const [key, val] of m1) {
            if (m2.get(key) !== val) return false;
        }
        return true;
    };
    
    for (let i = 0; i < s.length; i++) {
        // Add new character
        windowCount.set(s[i], (windowCount.get(s[i]) || 0) + 1);
        
        // Remove old character
        if (i >= p.length) {
            const oldChar = s[i - p.length];
            if (windowCount.get(oldChar) === 1) {
                windowCount.delete(oldChar);
            } else {
                windowCount.set(oldChar, windowCount.get(oldChar) - 1);
            }
        }
        
        // Check match
        if (i >= p.length - 1 && mapsEqual(windowCount, pCount)) {
            result.push(i - p.length + 1);
        }
    }
    
    return result;
}
```

---

## ‚ö° Complexity Analysis

| Problem Type | Time | Space | Notes |
|--------------|------|-------|-------|
| Longest valid | O(n) | O(k) | Each char added/removed once |
| Fixed window match | O(n) | O(k) | Slide window once |
| Minimum window | O(n) | O(k) | Two pointer shrinking |
| Count valid substrings | O(n) | O(k) | May need math formula |

Where k = size of character set (often 26 for lowercase, 256 for ASCII)

---

## üîÑ Problem Categories

| Category | Example Problem | Key Insight |
|----------|----------------|-------------|
| Max length, no repeats | LC 3 | Hash set for uniqueness |
| Max length, K distinct | LC 340 | Count distinct in hash |
| Fixed size, match pattern | LC 438 | Compare frequency maps |
| Min window, contain all | LC 76 | Shrink when valid |
| Substring count | LC 992 | atMost(K) - atMost(K-1) |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Off-by-One in Fixed Window

```python
# ‚ùå WRONG: Starting result check too early
for i in range(len(s)):
    window_count[s[i]] += 1
    if window_count == target:  # Wrong! Window not full yet
        result.append(i)

# ‚úÖ CORRECT: Wait until window is full
for i in range(len(s)):
    window_count[s[i]] += 1
    if i >= window_size:
        # Remove character leaving window
        window_count[s[i - window_size]] -= 1
    
    if i >= window_size - 1:  # Window is now full
        if window_count == target:
            result.append(i - window_size + 1)
```

### 2. Not Deleting Zero Counts

```python
# ‚ùå WRONG: Zero counts cause comparison to fail
window_count['a'] -= 1  # Now 0, but still in dict

# target = {'b': 1}
# window_count = {'a': 0, 'b': 1}
# window_count == target  # False! Because 'a' exists

# ‚úÖ CORRECT: Delete zero entries
window_count['a'] -= 1
if window_count['a'] == 0:
    del window_count['a']
```

### 3. Wrong Window Size Calculation

```python
# ‚ùå WRONG: Window size off by one
window_size = right - left  # This is length - 1!

# ‚úÖ CORRECT: Include both endpoints
window_size = right - left + 1
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Pattern Variant | Link |
|---------|------------|-----------------|------|
| Longest Substring Without Repeating | üü° Medium | Variable, uniqueness | [LC 3](https://leetcode.com/problems/longest-substring-without-repeating-characters/) |
| Find All Anagrams | üü° Medium | Fixed, match | [LC 438](https://leetcode.com/problems/find-all-anagrams-in-a-string/) |
| Permutation in String | üü° Medium | Fixed, match | [LC 567](https://leetcode.com/problems/permutation-in-string/) |
| Longest Substring K Distinct | üü° Medium | Variable, count | [LC 340](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/) |
| Minimum Window Substring | üî¥ Hard | Variable, contain all | [LC 76](https://leetcode.com/problems/minimum-window-substring/) |
| Subarrays with K Different | üî¥ Hard | Count trick | [LC 992](https://leetcode.com/problems/subarrays-with-k-different-integers/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand template, solve LC 3
- **Day 3:** Solve LC 438 (fixed window)
- **Day 7:** Solve LC 76 (minimum window)
- **Day 14:** Compare variable vs fixed window approaches
- **Day 30:** Mix of problems, < 15 min each

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Communication Template</strong></summary>

**Recognize the pattern:**
> "This is a substring problem with a constraint on characters. I'll use sliding window with a hash map to track character frequencies in O(n) time."

**Explain the approach:**
> "I'll maintain a window [left, right]. As I expand right, I add characters to my hash map. When the constraint is violated, I shrink from the left until it's valid again."

**Discuss complexity:**
> "Time is O(n) because each character is added and removed at most once. Space is O(k) for the hash map where k is the character set size."

</details>

**Company Focus:**

| Company | Frequency | Common Problems |
|---------|-----------|-----------------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | LC 3, LC 438 |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | LC 76, LC 3 |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | LC 3, LC 438 |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | LC 76, variations |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand template | 20 min |
| Solve LC 3 | 15-20 min |
| Solve LC 438 | 15-20 min |
| Master pattern | 4-5 problems |

---

> **üí° Key Insight:** The sliding window + hash pattern transforms O(n¬≤) substring enumeration into O(n) by maintaining state incrementally. When expanding, add to hash; when shrinking, remove from hash. The hash lets us check constraints in O(1).

> **üîó Related:** [Longest Substring (LC 3)](./7.2-Longest-Substring-LC3.md) | [Find Anagrams (LC 438)](./7.3-Find-Anagrams-LC438.md) | [Sliding Window Basics](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/02-Sliding-Window.md)
