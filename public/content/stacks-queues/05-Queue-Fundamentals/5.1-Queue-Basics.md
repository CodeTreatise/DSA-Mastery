# 5.1 Queue Basics

> **Grokking Pattern:** Related to BFS (#5, #6)
>
> **Foundation Concept** | Essential for BFS and Scheduling Problems

---

## Definition

A **Queue** is a linear data structure that follows the **FIFO** (First-In-First-Out) principle. The first element added is the first one removed.

**Real-world analogies:**
- Waiting line at a store: first in line, first served
- Print queue: first document sent, first printed
- Task scheduler: first task submitted, first executed
- Breadth-first search: process nodes level by level

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use a Queue</strong></summary>

**Look for these signals:**
- "First come, first served"
- "Process in order"
- "Level-by-level" traversal
- "Breadth-first" exploration
- Scheduling or buffering

**Keywords:**
- "FIFO", "first-in-first-out"
- "order of arrival"
- "BFS", "level order"
- "schedule", "buffer"
- "process in order"

</details>

---

## ‚úÖ When to Use Queue

- Breadth-first search (BFS)
- Level-order tree traversal
- Task scheduling
- Buffer between producer/consumer
- Sliding window problems (with deque)
- Order processing

---

## ‚ùå When NOT to Use Queue

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| LIFO needed | Queue is FIFO | Stack |
| Priority ordering | Queue is FIFO | Priority Queue / Heap |
| Random access | Queue is sequential | Array |
| Need both ends frequently | Queue optimized for front/back | Deque |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Array Basics](../../01-Arrays-Strings/01-Arrays/1.1-Array-Basics.md)
- Basic programming concepts

**After mastering this:**
- [Circular Queue](./5.2-Circular-Queue.md)
- [Deque](./5.3-Deque.md)
- [BFS on Trees](../../06-Trees/)
- [BFS on Graphs](../../10-Graphs/)

**Related structures:**
- Stack (LIFO counterpart)
- Deque (double-ended queue)
- Priority Queue (ordering by priority)

</details>

---

## üìê How It Works

### Core Operations

| Operation | Description | Time |
|-----------|-------------|------|
| `enqueue(x)` | Add element to back |" O(1) "|
| `dequeue()` | Remove and return front |" O(1)* "|
| `front()`/`peek()` | Return front without removing |" O(1) "|
| `isEmpty()` | Check if queue is empty |" O(1) "|
| `size()` | Return number of elements |" O(1) "|

*O(1) with proper implementation (deque), O(n) with list

### Visual Representation

```
ENQUEUE operations:
enqueue(1) ‚Üí enqueue(2) ‚Üí enqueue(3)

FRONT                      BACK
‚îå‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1 ‚îÇ      ‚îÇ 1 ‚îÇ 2 ‚îÇ      ‚îÇ 1 ‚îÇ 2 ‚îÇ 3 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò
  ‚Üë          ‚Üë               ‚Üë       ‚Üë
FRONT      FRONT           FRONT   BACK

DEQUEUE operations:
dequeue() ‚Üí dequeue() ‚Üí dequeue()
Returns: 1, 2, 3 (FIFO order)
```

### Queue vs Stack

```
Queue (FIFO): First in, first out
In: 1, 2, 3 ‚Üí Out: 1, 2, 3

Stack (LIFO): Last in, first out  
In: 1, 2, 3 ‚Üí Out: 3, 2, 1
```

---

## üíª Code Implementation

### Using collections.deque (Python - Recommended)

**Python:**
```python
from collections import deque

# Create queue
queue = deque()

# Enqueue: add to back
queue.append(1)
queue.append(2)
queue.append(3)
print(queue)  # deque([1, 2, 3])

# Peek: see front
front = queue[0]  # 1

# Dequeue: remove from front
val = queue.popleft()  # 1
print(queue)  # deque([2, 3])

# Is empty?
is_empty = len(queue) == 0

# Size
size = len(queue)  # 2
```

**JavaScript:**
```javascript
// JavaScript: Array works but shift() is O(n)
// For true O(1), implement with linked list or use index pointers

const queue = [];

// Enqueue
queue.push(1);
queue.push(2);
queue.push(3);
console.log(queue);  // [1, 2, 3]

// Peek
const front = queue[0];  // 1

// Dequeue (WARNING: O(n) with array)
const val = queue.shift();  // 1
console.log(queue);  // [2, 3]

// Is empty
const isEmpty = queue.length === 0;
```

### Queue Class Implementation

**Python:**
```python
from collections import deque

class Queue:
    """
    Queue implementation using deque.
    All operations are O(1).
    """
    
    def __init__(self):
        self._items = deque()
    
    def enqueue(self, item) -> None:
        """Add item to back of queue."""
        self._items.append(item)
    
    def dequeue(self):
        """Remove and return front item. Raises if empty."""
        if self.is_empty():
            raise IndexError("dequeue from empty queue")
        return self._items.popleft()
    
    def front(self):
        """Return front item without removing. Raises if empty."""
        if self.is_empty():
            raise IndexError("front from empty queue")
        return self._items[0]
    
    def is_empty(self) -> bool:
        """Return True if queue is empty."""
        return len(self._items) == 0
    
    def size(self) -> int:
        """Return number of items in queue."""
        return len(self._items)
    
    def __len__(self) -> int:
        return self.size()
    
    def __bool__(self) -> bool:
        return not self.is_empty()
    
    def __repr__(self) -> str:
        return f"Queue({list(self._items)})"


# Usage
queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
print(queue.front())   # 1
print(queue.dequeue()) # 1
print(len(queue))      # 1
```

**JavaScript:**
```javascript
class Queue {
    constructor() {
        this.items = [];
        this.frontIndex = 0;  // Avoid shift() which is O(n)
    }
    
    enqueue(item) {
        this.items.push(item);
    }
    
    dequeue() {
        if (this.isEmpty()) {
            throw new Error("dequeue from empty queue");
        }
        const item = this.items[this.frontIndex];
        this.frontIndex++;
        
        // Cleanup to prevent memory bloat
        if (this.frontIndex > 100 && this.frontIndex > this.items.length / 2) {
            this.items = this.items.slice(this.frontIndex);
            this.frontIndex = 0;
        }
        
        return item;
    }
    
    front() {
        if (this.isEmpty()) {
            throw new Error("front from empty queue");
        }
        return this.items[this.frontIndex];
    }
    
    isEmpty() {
        return this.frontIndex >= this.items.length;
    }
    
    size() {
        return this.items.length - this.frontIndex;
    }
}
```

---

## ‚ö° Complexity Analysis

| Operation | deque (Python) | Array (JS) | Optimized Queue |
|-----------|----------------|------------|-----------------|
| enqueue |" O(1) "| O(1) |" O(1) "|
| dequeue |" O(1) "| O(n)* |" O(1) "|
| front |" O(1) "| O(1) |" O(1) "|
| isEmpty |" O(1) "| O(1) |" O(1) "|
| size |" O(1) "| O(1) |" O(1) "|

*JavaScript's `shift()` is O(n) because it reindexes the array.

---

## üîÑ Queue Variants

| Variant | Description | Use Case |
|---------|-------------|----------|
| Circular Queue | Fixed-size, wraps around | Bounded buffer |
| Deque | Double-ended | Sliding window |
| Priority Queue | Ordered by priority | Task scheduling, Dijkstra |
| Blocking Queue | Thread-safe, waits | Producer-consumer |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using list.pop(0) in Python

```python
# ‚ùå WRONG: O(n) operation
queue = []
queue.append(1)
val = queue.pop(0)  # O(n)!

# ‚úÖ CORRECT: Use deque
from collections import deque
queue = deque()
queue.append(1)
val = queue.popleft()  # O(1)
```

### 2. Using shift() in JavaScript Loops

```javascript
// ‚ùå WRONG: O(n) per shift, O(n¬≤) total
while (queue.length > 0) {
    process(queue.shift());  // O(n) each!
}

// ‚úÖ CORRECT: Use index
let i = 0;
while (i < queue.length) {
    process(queue[i++]);
}
```

### 3. Modifying Queue While Iterating

```python
# ‚ùå WRONG: Unpredictable behavior
for item in queue:
    if condition:
        queue.popleft()  # Modifies during iteration!

# ‚úÖ CORRECT: Process snapshot or use while
while queue and condition(queue[0]):
    queue.popleft()
```

---

## üìù Practice Problems

### BFS Applications
- [ ] [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) - LC 102
- [ ] [Number of Islands](https://leetcode.com/problems/number-of-islands/) - LC 200

### Queue Design
- [ ] [Design Circular Queue](https://leetcode.com/problems/design-circular-queue/) - LC 622
- [ ] [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) - LC 232

### Sliding Window
- [ ] [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) - LC 239

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement Queue class from memory
**Day 3:** Solve LC 102 (Level Order Traversal)
**Day 7:** Solve LC 622 (Circular Queue)
**Day 14:** Solve LC 200 (Number of Islands with BFS)
**Day 21:** Review queue vs stack selection

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Queue Interview Tips</strong></summary>

**When to mention queue:**
- "I need FIFO order, so I'll use a queue"
- "For BFS, I'll use a queue to process level by level"
- "This is a scheduling problem, classic queue use case"

**Python-specific:**
> "I'll use collections.deque for O(1) operations on both ends."

**JavaScript-specific:**
> "I'll track a front index instead of using shift() to avoid O(n) per operation."

**BFS template:**
```python
from collections import deque

def bfs(start):
    queue = deque([start])
    visited = {start}
    
    while queue:
        node = queue.popleft()
        process(node)
        
        for neighbor in get_neighbors(node):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

</details>

**Company Focus:**

| Company | Frequency | Common Problems |
|---------|-----------|-----------------|
| All | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | BFS problems |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Level order, Islands |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | BFS on graphs |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Tree traversals |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn concept | 15-20 min | FIFO understanding |
| Implement class | 10-15 min | From memory |
| Solve BFS problem | 15-25 min | Level order traversal |
| Master pattern | 2-3 hours | Multiple BFS problems |

---

> **üí° Key Insight:** The queue's FIFO property makes it perfect for "fairness" - processing things in the order they arrived. In BFS, this means processing all nodes at distance 1 before any at distance 2, ensuring we find shortest paths in unweighted graphs.

---

## üîó Related

- [Circular Queue](./5.2-Circular-Queue.md) - Fixed-size implementation
- [Deque](./5.3-Deque.md) - Double-ended variant
- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md) - LIFO counterpart
- [BFS on Trees](../../06-Trees/) - Primary application
