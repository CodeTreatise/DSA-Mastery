# Monotonic Stack/Queue Review

> **Quick reference for monotonic data structures commonly used in interviews.**
>
> Essential for "next greater/smaller element" problems.

---

## üéØ Pattern Recognition

| Problem Signal | Structure |
|----------------|-----------|
| "Next greater element" | Monotonic decreasing stack |
| "Next smaller element" | Monotonic increasing stack |
| "Previous greater/smaller" | Same, but process backwards or store indices |
| "Sliding window min/max" | Monotonic deque |

---

## üìê Monotonic Stack

### Next Greater Element

```python
def nextGreaterElements(nums):
    """
    For each element, find the next greater element to its right.
    Return -1 if none exists.
    
    Stack stores indices of elements waiting for their answer.
    Maintain decreasing order (top is smallest).
    """
    n = len(nums)
    result = [-1] * n
    stack = []  # Stores indices
    
    for i in range(n):
        # Pop elements smaller than current (found their answer!)
        while stack and nums[stack[-1]] < nums[i]:
            idx = stack.pop()
            result[idx] = nums[i]
        stack.append(i)
    
    return result


# Example
nums = [2, 1, 2, 4, 3]
print(nextGreaterElements(nums))  # [4, 2, 4, -1, -1]
```

### Next Smaller Element

```python
def nextSmallerElements(nums):
    """Same idea, but pop elements LARGER than current."""
    n = len(nums)
    result = [-1] * n
    stack = []
    
    for i in range(n):
        while stack and nums[stack[-1]] > nums[i]:
            idx = stack.pop()
            result[idx] = nums[i]
        stack.append(i)
    
    return result
```

### Previous Greater/Smaller

```python
def previousGreaterElements(nums):
    """Process left to right, answer immediately."""
    n = len(nums)
    result = [-1] * n
    stack = []  # Stores values (or indices)
    
    for i in range(n):
        while stack and stack[-1] <= nums[i]:
            stack.pop()
        if stack:
            result[i] = stack[-1]  # Top is previous greater
        stack.append(nums[i])
    
    return result
```

---

## üìê Monotonic Deque

### Sliding Window Maximum (LC 239)

```python
from collections import deque

def maxSlidingWindow(nums, k):
    """
    Return max of each sliding window of size k.
    
    Deque stores indices in decreasing order of values.
    Front is always the max for current window.
    """
    result = []
    dq = deque()  # Stores indices
    
    for i, num in enumerate(nums):
        # Remove elements outside window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Remove smaller elements (will never be max)
        while dq and nums[dq[-1]] < num:
            dq.pop()
        
        dq.append(i)
        
        # Add to result once window is full
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result


# Example
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]
```

### Sliding Window Minimum

```python
def minSlidingWindow(nums, k):
    """Same as max, but maintain increasing order."""
    result = []
    dq = deque()
    
    for i, num in enumerate(nums):
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Change: remove LARGER elements
        while dq and nums[dq[-1]] > num:
            dq.pop()
        
        dq.append(i)
        
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result
```

---

## üìä Common Applications

| Problem | Technique |
|---------|-----------|
| [Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/) | Basic monotonic stack |
| [Daily Temperatures](https://leetcode.com/problems/daily-temperatures/) | Next greater with indices |
| [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/) | Both next smaller left/right |
| [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/) | Monotonic stack or two pointers |
| [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) | Monotonic deque |

---

## ‚ö° Complexity

| Structure | Operation | Time |
|-----------|-----------|------|
| Monotonic Stack | Process all elements | O(n) total |
| Monotonic Deque | Process all elements | O(n) total |

**Why O(n)?** Each element is pushed and popped at most once.

---

## ‚ö†Ô∏è Quick Tips

1. **Stack vs Deque:** Use deque when you need to remove from front (sliding window)
2. **Store indices, not values:** Usually need to compute distances or ranges
3. **Increasing vs Decreasing:** For "next greater", maintain decreasing (so top is smallest waiting)
4. **Circular arrays:** Process array twice (2n elements)

---

> **üí° Key Insight:** Monotonic structures exploit the fact that some elements can never be answers. By maintaining order, we efficiently track only the candidates that matter.

> **üîó Related:** [Ordered Set ‚Üí](./5.4-Ordered-Set.md)
