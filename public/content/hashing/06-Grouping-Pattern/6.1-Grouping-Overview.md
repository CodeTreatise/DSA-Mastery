# Grouping Pattern Overview

> **Group elements by a common property using hash maps - transform O(n¬≤) comparisons into O(n) grouping.**

The grouping pattern uses hash maps to categorize elements that share a property. Instead of comparing every pair of elements, we compute a "signature" or "key" for each element and group elements with the same signature.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem signals:**
- "Group elements by..."
- "Find all elements with same property"
- "Categorize based on..."
- "Find anagrams / similar strings / matching patterns"
- "Which elements share..."

**Core insight:**
```
Instead of comparing elements pairwise (O(n¬≤)),
compute a KEY for each element and group by KEY (O(n))

Key = some property that equal elements share
```

**Examples of grouping keys:**
- Anagrams: sorted string or character count
- Same sum: the sum itself
- Same length: the length
- Same frequency pattern: frequency signature

</details>

---

## ‚úÖ When to Use

- Grouping elements by a shared property
- Finding all anagrams/similar items
- Categorizing data
- Mapping between equivalent representations
- Checking if two elements are "equivalent"

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Just checking existence | Overkill | Simple hash set |
| Need ordered groups | Hash is unordered | TreeMap or sort |
| Single match needed | Don't need all groups | Two Sum pattern |
| Memory constrained | Stores all groups | Sort-based grouping |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
- [Frequency Pattern](../03-Frequency-Pattern/3.1-Frequency-Overview.md)

**After mastering:**
- [Group Anagrams (LC 49)](./6.2-Group-Anagrams-LC49.md)
- [Isomorphic Strings (LC 205)](./6.3-Isomorphic-Strings-LC205.md)
- [Word Pattern (LC 290)](./6.4-Word-Pattern-LC290.md)

**Related patterns:**
- Frequency counting (for creating keys)
- Two Sum (simpler: find one pair, not groups)
- String hashing (for efficient key computation)

</details>

---

## üìê How It Works

### The Core Transformation

**Without grouping (O(n¬≤)):**
```python
# Compare every pair to check if they're anagrams
for i in range(n):
    for j in range(i+1, n):
        if is_anagram(words[i], words[j]):
            # Group together somehow
```

**With grouping (O(n)):**
```python
# Group by sorted form
groups = {}
for word in words:
    key = tuple(sorted(word))  # "eat" ‚Üí ('a', 'e', 't')
    if key not in groups:
        groups[key] = []
    groups[key].append(word)
```

### Visualization

```
Input: ["eat", "tea", "tan", "ate", "nat", "bat"]

Step 1: Compute key for each word
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Word   ‚îÇ Key (sorted)        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ "eat"  ‚îÇ ('a', 'e', 't')     ‚îÇ
‚îÇ "tea"  ‚îÇ ('a', 'e', 't')     ‚îÇ  ‚Üê Same key!
‚îÇ "tan"  ‚îÇ ('a', 'n', 't')     ‚îÇ
‚îÇ "ate"  ‚îÇ ('a', 'e', 't')     ‚îÇ  ‚Üê Same key!
‚îÇ "nat"  ‚îÇ ('a', 'n', 't')     ‚îÇ  ‚Üê Same key as "tan"!
‚îÇ "bat"  ‚îÇ ('a', 'b', 't')     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Step 2: Group by key
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Key                 ‚îÇ Group                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ('a', 'e', 't')     ‚îÇ ["eat", "tea", "ate"]  ‚îÇ
‚îÇ ('a', 'n', 't')     ‚îÇ ["tan", "nat"]         ‚îÇ
‚îÇ ('a', 'b', 't')     ‚îÇ ["bat"]                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Output: [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]
```

### Different Key Strategies

```
Strategy 1: Sort the element
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"eat" ‚Üí "aet"  (sorted)
"tea" ‚Üí "aet"  ‚Üê Same!
"ate" ‚Üí "aet"  ‚Üê Same!

Time per element: O(k log k) where k = length
Good for: strings, small arrays

Strategy 2: Count signature
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"eat" ‚Üí (1,0,0,0,1,...,1,...)  # count of each letter
"tea" ‚Üí (1,0,0,0,1,...,1,...)  ‚Üê Same!
"ate" ‚Üí (1,0,0,0,1,...,1,...)  ‚Üê Same!

Time per element: O(k)
Good for: large strings, when sorting is expensive

Strategy 3: Mathematical signature
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Numbers by sum:
[1,2,3] ‚Üí sum=6
[6,0,0] ‚Üí sum=6  ‚Üê Same!
[2,2,2] ‚Üí sum=6  ‚Üê Same!

Good for: numeric grouping
```

---

## üíª Code Implementation

### Python - Generic Grouping Template

```python
from collections import defaultdict
from typing import List, Callable, Any, Hashable

def group_by(items: List[Any], key_func: Callable[[Any], Hashable]) -> dict:
    """
    Group items by a key function.
    
    Args:
        items: List of items to group
        key_func: Function that returns a hashable key for each item
    
    Returns:
        Dictionary mapping keys to lists of items
    
    Time: O(n * T) where T is time to compute key
    Space: O(n) for storing groups
    """
    groups = defaultdict(list)
    for item in items:
        key = key_func(item)
        groups[key].append(item)
    return dict(groups)


# Example usage

# Group numbers by parity
numbers = [1, 2, 3, 4, 5, 6, 7, 8]
parity_groups = group_by(numbers, lambda x: x % 2)
# {1: [1, 3, 5, 7], 0: [2, 4, 6, 8]}

# Group strings by length
words = ["apple", "bat", "car", "door", "egg"]
length_groups = group_by(words, len)
# {5: ["apple"], 3: ["bat", "car", "egg"], 4: ["door"]}

# Group strings by first letter
first_letter_groups = group_by(words, lambda s: s[0])
# {'a': ["apple"], 'b': ["bat"], 'c': ["car"], 'd': ["door"], 'e': ["egg"]}
```

### Python - Anagram Grouping (Two Approaches)

```python
from collections import defaultdict

def group_anagrams_sorted(strs: List[str]) -> List[List[str]]:
    """
    Group anagrams using sorted string as key.
    
    Time: O(n * k log k) where k = max string length
    Space: O(n * k)
    """
    groups = defaultdict(list)
    
    for s in strs:
        # Key: sorted characters as tuple
        key = tuple(sorted(s))
        groups[key].append(s)
    
    return list(groups.values())


def group_anagrams_count(strs: List[str]) -> List[List[str]]:
    """
    Group anagrams using character count as key.
    
    Time: O(n * k) - faster for long strings
    Space: O(n * k)
    """
    groups = defaultdict(list)
    
    for s in strs:
        # Key: count of each character
        count = [0] * 26
        for c in s:
            count[ord(c) - ord('a')] += 1
        key = tuple(count)  # Lists aren't hashable, tuples are
        groups[key].append(s)
    
    return list(groups.values())


# Performance comparison:
# - Sorted key: O(k log k) per string, simpler code
# - Count key: O(k) per string, better for long strings
# - For typical interview strings (short), both are fine
```

### Python - Mapping Pattern (Isomorphic/Word Pattern)

```python
def create_pattern_signature(s: str) -> tuple:
    """
    Create a canonical pattern signature.
    
    "egg" ‚Üí (0, 1, 1)  # e=0, g=1, g=1
    "add" ‚Üí (0, 1, 1)  # a=0, d=1, d=1
    
    Same signature = same pattern!
    """
    char_to_id = {}
    pattern = []
    next_id = 0
    
    for char in s:
        if char not in char_to_id:
            char_to_id[char] = next_id
            next_id += 1
        pattern.append(char_to_id[char])
    
    return tuple(pattern)


def group_by_pattern(words: List[str]) -> List[List[str]]:
    """Group words that have the same pattern."""
    groups = defaultdict(list)
    
    for word in words:
        key = create_pattern_signature(word)
        groups[key].append(word)
    
    return list(groups.values())


# Example:
# ["egg", "add", "foo", "bar", "abc"]
# "egg" ‚Üí (0,1,1)
# "add" ‚Üí (0,1,1)  ‚Üê Same as "egg"
# "foo" ‚Üí (0,1,1)  ‚Üê Same pattern!
# "bar" ‚Üí (0,1,2)  ‚Üê Different
# "abc" ‚Üí (0,1,2)  ‚Üê Same as "bar"
# Groups: [["egg", "add", "foo"], ["bar", "abc"]]
```

### JavaScript - Grouping Implementations

```javascript
/**
 * Generic grouping function
 */
function groupBy(items, keyFunc) {
    const groups = new Map();
    
    for (const item of items) {
        const key = keyFunc(item);
        if (!groups.has(key)) {
            groups.set(key, []);
        }
        groups.get(key).push(item);
    }
    
    return groups;
}

/**
 * Group anagrams using sorted key
 */
function groupAnagrams(strs) {
    const groups = new Map();
    
    for (const s of strs) {
        const key = s.split('').sort().join('');
        if (!groups.has(key)) {
            groups.set(key, []);
        }
        groups.get(key).push(s);
    }
    
    return [...groups.values()];
}

/**
 * Group anagrams using count key
 */
function groupAnagramsCount(strs) {
    const groups = new Map();
    
    for (const s of strs) {
        // Create count array as key
        const count = new Array(26).fill(0);
        for (const c of s) {
            count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;
        }
        const key = count.join(',');  // Convert to string for Map key
        
        if (!groups.has(key)) {
            groups.set(key, []);
        }
        groups.get(key).push(s);
    }
    
    return [...groups.values()];
}

/**
 * Create pattern signature for isomorphic checking
 */
function createPatternSignature(s) {
    const charToId = new Map();
    const pattern = [];
    let nextId = 0;
    
    for (const char of s) {
        if (!charToId.has(char)) {
            charToId.set(char, nextId++);
        }
        pattern.push(charToId.get(char));
    }
    
    return pattern.join(',');
}
```

---

## ‚ö° Complexity Analysis

| Key Strategy | Time per Element | Total Time | Space |
|--------------|------------------|------------|-------|
| Sort key | O(k log k) | O(n * k log k) | O(n * k) |
| Count key | O(k) | O(n * k) | O(n * k) |
| Pattern signature | O(k) | O(n * k) | O(n * k) |
| Simple property | O(1) | O(n) | O(n) |

Where:
- n = number of elements
- k = size of each element (e.g., string length)

---

## üîÑ Common Grouping Problems

| Problem | Key Strategy | Complexity |
|---------|--------------|------------|
| Group Anagrams | Sorted or count | O(n * k log k) or O(n * k) |
| Isomorphic Strings | Pattern signature | O(n) |
| Word Pattern | Pattern + words | O(n) |
| Group Shifted Strings | Difference pattern | O(n * k) |
| Find Duplicates | Identity key | O(n) |
| Group by Sum | Sum value | O(n) |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Mutable Types as Keys

```python
# ‚ùå WRONG: Lists can't be dictionary keys
groups = {}
for s in strs:
    key = sorted(s)  # Returns a list!
    groups[key].append(s)  # TypeError!

# ‚úÖ CORRECT: Convert to tuple
groups = {}
for s in strs:
    key = tuple(sorted(s))  # Tuple is hashable
    if key not in groups:
        groups[key] = []
    groups[key].append(s)
```

### 2. Not Handling Empty Elements

```python
# ‚ùå WRONG: Empty string issues
def group_anagrams(strs):
    groups = {}
    for s in strs:
        if s:  # Skipping empty strings!
            key = tuple(sorted(s))
            # ...

# ‚úÖ CORRECT: Empty string is valid
def group_anagrams(strs):
    groups = defaultdict(list)
    for s in strs:
        key = tuple(sorted(s))  # Empty string ‚Üí ()
        groups[key].append(s)
    return list(groups.values())
```

### 3. Wrong Key for Pattern Problems

```python
# ‚ùå WRONG: Just counting characters for isomorphic
def isomorphic_key(s):
    return Counter(s)  # "ab" and "ba" have same count!

# ‚úÖ CORRECT: Pattern matters
def isomorphic_key(s):
    mapping = {}
    pattern = []
    idx = 0
    for c in s:
        if c not in mapping:
            mapping[c] = idx
            idx += 1
        pattern.append(mapping[c])
    return tuple(pattern)
```

### 4. Inefficient Key in JavaScript

```javascript
// ‚ùå WRONG: Objects as Map keys don't work as expected
const groups = new Map();
groups.set([1,0,1], 'value');
groups.get([1,0,1]);  // undefined! Different object reference

// ‚úÖ CORRECT: Convert to string
const groups = new Map();
const key = [1,0,1].join(',');
groups.set(key, 'value');
groups.get([1,0,1].join(','));  // 'value'
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Key Type | Link |
|---------|------------|----------|------|
| Group Anagrams | üü° Medium | Sorted/count | [LC 49](https://leetcode.com/problems/group-anagrams/) |
| Isomorphic Strings | üü¢ Easy | Pattern | [LC 205](https://leetcode.com/problems/isomorphic-strings/) |
| Word Pattern | üü¢ Easy | Pattern + word | [LC 290](https://leetcode.com/problems/word-pattern/) |
| Group Shifted Strings | üü° Medium | Difference | [LC 249](https://leetcode.com/problems/group-shifted-strings/) |
| Find Duplicate File | üü° Medium | Content | [LC 609](https://leetcode.com/problems/find-duplicate-file-in-system/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand the template, solve LC 49
- **Day 3:** Solve LC 205 and LC 290
- **Day 7:** Solve LC 249 (shifted strings)
- **Day 14:** Implement count-based key vs sorted
- **Day 30:** Mix of problems, < 15 min each

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interview</strong></summary>

**Recognize the pattern:**
> "This is a grouping problem. I'll use a hash map where the key is [the property] and the value is a list of matching elements."

**Explain key choice:**
> "For anagrams, I could sort each string as the key, giving O(n * k log k) time. Alternatively, I can use character counts for O(n * k)."

**Discuss trade-offs:**
> "Sorting is simpler to implement but slower for long strings. Character count is O(k) but uses more space for the key."

**Handle follow-ups:**
- "What if strings are very long?" ‚Üí Use count-based key
- "What if there are many groups?" ‚Üí Still O(n) space
- "Can you stream the results?" ‚Üí Use iterator pattern

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Group Anagrams common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Pattern matching |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask variations |
| Bloomberg | ‚≠ê‚≠ê‚≠ê‚≠ê | String problems |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand grouping concept | 15 min |
| Learn key strategies | 20 min |
| Solve LC 49 | 15-20 min |
| Master pattern | 3-4 problems |

---

> **üí° Key Insight:** The grouping pattern transforms O(n¬≤) pairwise comparisons into O(n) grouping by computing a canonical key for each element. The key must be the same for all equivalent elements.

> **üîó Related:** [Group Anagrams](./6.2-Group-Anagrams-LC49.md) | [Isomorphic Strings](./6.3-Isomorphic-Strings-LC205.md) | [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
