# BIT Operations & Applications

> **Advanced BIT operations: range updates, 2D queries, and practical applications.**
>
> From counting inversions to coordinate compression patterns.

---

## üìê Core Operations Recap

```python
class BIT:
    def update(self, i, delta):
        """Add delta at index i."""
        while i <= self.n:
            self.tree[i] += delta
            i += i & (-i)
    
    def prefix_sum(self, i):
        """Sum from 1 to i."""
        total = 0
        while i > 0:
            total += self.tree[i]
            i -= i & (-i)
        return total
```

---

## üîÑ Point Query with Range Update

### The Trick: Difference Array

For range updates with point queries, use a difference BIT:

```
Original:  [1, 2, 3, 4, 5]
Diff:      [1, 1, 1, 1, 1]  ‚Üê differences

range_add(2, 4, 10):  Add 10 to indices 2-4
Diff:      [1, 11, 1, 1, -9]
           ‚Üë     ‚Üë        ‚Üë
           unchanged       restore
           
To get value at index 3:
prefix_sum(diff, 3) = 1 + 11 + 1 = 13 = original[3] + 10 ‚úì
```

**Implementation:**
```python
class RangeUpdateBIT:
    """
    BIT supporting range add and point query.
    
    Stores difference array internally.
    """
    
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)
    
    def _update(self, i, delta):
        while i <= self.n:
            self.tree[i] += delta
            i += i & (-i)
    
    def range_add(self, l, r, delta):
        """Add delta to all elements in [l, r]."""
        self._update(l, delta)
        if r + 1 <= self.n:
            self._update(r + 1, -delta)
    
    def point_query(self, i):
        """Get value at index i."""
        total = 0
        while i > 0:
            total += self.tree[i]
            i -= i & (-i)
        return total


# Example
bit = RangeUpdateBIT(5)
bit.range_add(2, 4, 10)  # Add 10 to indices 2, 3, 4
print(bit.point_query(1))  # 0
print(bit.point_query(3))  # 10
print(bit.point_query(5))  # 0
```

---

## üìä Range Update + Range Query

### The Two-BIT Trick

For both range updates and range queries, use two BITs:

**Math derivation:**
```
Let D[i] = difference at i

Value at index i:
A[i] = Œ£ D[j] for j = 1 to i

Sum from 1 to i:
Œ£ A[k] for k = 1 to i
= Œ£ (Œ£ D[j] for j = 1 to k) for k = 1 to i
= Œ£ D[j] * (i - j + 1) for j = 1 to i
= (i + 1) * Œ£ D[j] - Œ£ (j * D[j])

So we need two BITs:
- BIT1 stores D[j]
- BIT2 stores j * D[j]
```

**Implementation:**
```python
class RangeRangeBIT:
    """BIT with O(log n) range update AND range query."""
    
    def __init__(self, n):
        self.n = n
        self.bit1 = [0] * (n + 1)  # Stores D[i]
        self.bit2 = [0] * (n + 1)  # Stores i * D[i]
    
    def _update(self, bit, i, delta):
        while i <= self.n:
            bit[i] += delta
            i += i & (-i)
    
    def _prefix(self, bit, i):
        total = 0
        while i > 0:
            total += bit[i]
            i -= i & (-i)
        return total
    
    def range_add(self, l, r, delta):
        """Add delta to all elements in [l, r]."""
        self._update(self.bit1, l, delta)
        self._update(self.bit1, r + 1, -delta)
        self._update(self.bit2, l, l * delta)
        self._update(self.bit2, r + 1, -(r + 1) * delta)
    
    def prefix_sum(self, i):
        """Sum of elements 1 to i."""
        return (i + 1) * self._prefix(self.bit1, i) - self._prefix(self.bit2, i)
    
    def range_sum(self, l, r):
        """Sum of elements l to r."""
        return self.prefix_sum(r) - self.prefix_sum(l - 1)
```

---

## üéØ Application: Count Inversions

**Problem:** Count pairs (i, j) where i < j but arr[i] > arr[j].

**Approach:** Process right to left, use BIT to count smaller elements seen so far.

```python
def count_inversions(arr):
    """
    Count inversions in O(n log n).
    
    Key insight: For each element, count how many 
    larger elements we've seen to its right.
    """
    # Coordinate compression
    sorted_arr = sorted(set(arr))
    rank = {v: i + 1 for i, v in enumerate(sorted_arr)}  # 1-indexed
    
    n = len(sorted_arr)
    bit = BIT(n)
    inversions = 0
    
    # Process right to left
    for num in reversed(arr):
        r = rank[num]
        # Count elements smaller than current (already seen = to its right)
        inversions += bit.prefix_sum(r - 1)
        # Add current element
        bit.update(r, 1)
    
    return inversions


# Example
arr = [3, 1, 2]
print(count_inversions(arr))  # 2: (3,1) and (3,2)
```

---

## üéØ Application: Count Smaller After Self

**Problem:** For each element, count how many smaller elements are to its right.

```python
def countSmaller(nums):
    """
    LC 315: Count of Smaller Numbers After Self
    
    Same as inversions but track per-element count.
    """
    # Coordinate compression
    sorted_nums = sorted(set(nums))
    rank = {v: i + 1 for i, v in enumerate(sorted_nums)}
    
    n = len(sorted_nums)
    bit = BIT(n)
    result = []
    
    for num in reversed(nums):
        r = rank[num]
        count = bit.prefix_sum(r - 1)  # Count smaller elements to right
        result.append(count)
        bit.update(r, 1)
    
    return result[::-1]


# Example
nums = [5, 2, 6, 1]
print(countSmaller(nums))  # [2, 1, 1, 0]
```

---

## üìê 2D BIT

For 2D range sum queries with point updates:

```python
class BIT2D:
    """2D Binary Indexed Tree for range sum queries."""
    
    def __init__(self, rows, cols):
        self.rows = rows
        self.cols = cols
        self.tree = [[0] * (cols + 1) for _ in range(rows + 1)]
    
    def update(self, r, c, delta):
        """Add delta at position (r, c)."""
        i = r
        while i <= self.rows:
            j = c
            while j <= self.cols:
                self.tree[i][j] += delta
                j += j & (-j)
            i += i & (-i)
    
    def prefix_sum(self, r, c):
        """Sum of rectangle from (1,1) to (r,c)."""
        total = 0
        i = r
        while i > 0:
            j = c
            while j > 0:
                total += self.tree[i][j]
                j -= j & (-j)
            i -= i & (-i)
        return total
    
    def range_sum(self, r1, c1, r2, c2):
        """Sum of rectangle from (r1,c1) to (r2,c2)."""
        return (self.prefix_sum(r2, c2) 
                - self.prefix_sum(r1 - 1, c2)
                - self.prefix_sum(r2, c1 - 1)
                + self.prefix_sum(r1 - 1, c1 - 1))


# Example
bit2d = BIT2D(3, 4)
# Initialize with matrix values
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]
for i, row in enumerate(matrix):
    for j, val in enumerate(row):
        bit2d.update(i + 1, j + 1, val)

print(bit2d.range_sum(1, 1, 2, 3))  # 1+2+3+5+6+7 = 24
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Coordinate Compression Errors

```python
# ‚ùå Wrong: Not handling duplicates
rank = {v: i for i, v in enumerate(sorted(arr))}

# ‚úÖ Correct: Use set to remove duplicates first
rank = {v: i + 1 for i, v in enumerate(sorted(set(arr)))}
```

### 2. Off-by-One in "Smaller Than"

```python
# ‚ùå Wrong: Including current element
count = bit.prefix_sum(rank[num])  # Includes elements = to num!

# ‚úÖ Correct: Strictly smaller
count = bit.prefix_sum(rank[num] - 1)
```

### 3. Forgetting Range Bounds Check

```python
# ‚ùå Wrong: May go out of bounds
def range_add(self, l, r, delta):
    self._update(l, delta)
    self._update(r + 1, -delta)  # r+1 might be > n!

# ‚úÖ Correct: Check bounds
def range_add(self, l, r, delta):
    self._update(l, delta)
    if r + 1 <= self.n:
        self._update(r + 1, -delta)
```

---

## üìù Practice Problems

| Problem | Difficulty | Key Technique |
|---------|------------|---------------|
| [Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/) | Medium | Basic BIT |
| [Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/) | Hard | Frequency + coordinate compression |
| [Reverse Pairs](https://leetcode.com/problems/reverse-pairs/) | Hard | Modified inversion count |
| [Range Sum Query 2D - Mutable](https://leetcode.com/problems/range-sum-query-2d-mutable/) | Hard | 2D BIT |

---

## ‚è±Ô∏è Time Estimates

| Operation | Time |
|-----------|------|
| Point update | O(log n) |
| Point query | O(log n) |
| Range update | O(log n) |
| Range query | O(log n) |
| 2D operations | O(log n √ó log m) |

---

> **üí° Key Insight:** BIT's power comes from its flexibility. By storing differences instead of values, we flip the roles of update and query. By using two BITs, we can handle both range updates and range queries.

> **üîó Related:** [BIT Fundamentals](./4.1-BIT-Fundamentals.md) | [BIT vs Segment Tree ‚Üí](./4.3-BIT-vs-Segment-Tree.md)

---

**Next:** [BIT vs Segment Tree ‚Üí](./4.3-BIT-vs-Segment-Tree.md)
