# LC 212: Word Search II

> **The ultimate Trie problem - combines Trie with grid backtracking. Master this and you've mastered Tries.**

---

## üìã Problem Statement

**LeetCode 212 - Hard**

Given an `m x n` board of characters and a list of strings `words`, return all words on the board.

Each word must be constructed from letters of sequentially adjacent cells (horizontally or vertically neighboring). The same cell may not be used more than once in a word.

```
board = [
  ["o","a","a","n"],
  ["e","t","a","e"],
  ["i","h","k","r"],
  ["i","f","l","v"]
]
words = ["oath","pea","eat","rain"]

Output: ["eat","oath"]
```

**Constraints:**
- m == board.length, n == board[i].length
- 1 <= m, n <= 12
- 1 <= words.length <= 3 √ó 10‚Å¥
- 1 <= words[i].length <= 10
- All words are unique

---

## üéØ Pattern Recognition

**This is the Trie + Backtracking pattern:**
- Naive: Search each word separately ‚Üí O(W √ó M √ó N √ó 4^L)
- Optimized: Build Trie, search all words at once ‚Üí O(M √ó N √ó 4^L)

**Key insight:** The Trie lets us search for ALL words simultaneously while pruning impossible paths early.

---

## üìê Approach

### Why Trie + Backtracking?

**Naive approach (Word Search I for each word):**
```
For each word (W words):
    For each cell (M √ó N cells):
        DFS to find word (4^L paths)
Total: O(W √ó M √ó N √ó 4^L) - Too slow for W = 30,000!
```

**Trie approach:**
```
Build Trie from all words
For each cell (M √ó N cells):
    DFS following Trie paths (4^L paths, but pruned)
    Find ALL matching words in single traversal!
Total: O(M √ó N √ó 4^L) - W doesn't multiply!
```

### Algorithm Steps

1. **Build Trie** from all words (store complete word at end node)
2. **For each cell** in grid:
   - Start DFS with Trie root
3. **DFS from cell:**
   - If char not in Trie children ‚Üí prune (return)
   - If found word ‚Üí add to result, mark as found
   - Mark cell visited
   - Explore 4 directions
   - Unmark cell (backtrack)

---

## üíª Solution

### Complete Solution

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.word = None  # Store complete word here


class Solution:
    """
    Time: O(M √ó N √ó 4^L) where L = max word length
    Space: O(W √ó L) for Trie + O(L) recursion stack
    """
    
    def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:
        # Step 1: Build Trie from all words
        root = self._build_trie(words)
        
        # Step 2: Search grid with backtracking
        result = []
        rows, cols = len(board), len(board[0])
        
        for r in range(rows):
            for c in range(cols):
                self._backtrack(board, r, c, root, result)
        
        return result
    
    def _build_trie(self, words: list[str]) -> TrieNode:
        """Build Trie from word list."""
        root = TrieNode()
        
        for word in words:
            node = root
            for char in word:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
            node.word = word  # Store complete word at end
        
        return root
    
    def _backtrack(self, board: list[list[str]], 
                   row: int, col: int,
                   node: TrieNode, result: list) -> None:
        """DFS from (row, col) following Trie paths."""
        rows, cols = len(board), len(board[0])
        
        # Boundary check
        if row < 0 or row >= rows or col < 0 or col >= cols:
            return
        
        char = board[row][col]
        
        # Pruning: If char not in Trie, no words possible
        if char not in node.children:
            return
        
        # Move to child node
        node = node.children[char]
        
        # Found a word!
        if node.word is not None:
            result.append(node.word)
            node.word = None  # Avoid duplicates
        
        # Mark cell as visited
        board[row][col] = '#'
        
        # Explore 4 directions
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            self._backtrack(board, row + dr, col + dc, node, result)
        
        # Backtrack: restore cell
        board[row][col] = char
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = new Map();
        this.word = null;
    }
}

class Solution {
    findWords(board, words) {
        // Build Trie
        const root = this._buildTrie(words);
        
        // Search grid
        const result = [];
        const rows = board.length;
        const cols = board[0].length;
        
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                this._backtrack(board, r, c, root, result);
            }
        }
        
        return result;
    }
    
    _buildTrie(words) {
        const root = new TrieNode();
        
        for (const word of words) {
            let node = root;
            for (const char of word) {
                if (!node.children.has(char)) {
                    node.children.set(char, new TrieNode());
                }
                node = node.children.get(char);
            }
            node.word = word;
        }
        
        return root;
    }
    
    _backtrack(board, row, col, node, result) {
        const rows = board.length;
        const cols = board[0].length;
        
        // Boundary check
        if (row < 0 || row >= rows || col < 0 || col >= cols) {
            return;
        }
        
        const char = board[row][col];
        
        // Pruning
        if (!node.children.has(char)) {
            return;
        }
        
        node = node.children.get(char);
        
        // Found word
        if (node.word !== null) {
            result.push(node.word);
            node.word = null;
        }
        
        // Mark visited
        board[row][col] = '#';
        
        // Explore
        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const [dr, dc] of directions) {
            this._backtrack(board, row + dr, col + dc, node, result);
        }
        
        // Backtrack
        board[row][col] = char;
    }
}
```

---

### Optimized with Trie Pruning

**Python:**
```python
class Solution:
    def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:
        root = self._build_trie(words)
        result = []
        rows, cols = len(board), len(board[0])
        
        for r in range(rows):
            for c in range(cols):
                self._backtrack(board, r, c, root, result)
        
        return result
    
    def _build_trie(self, words):
        root = TrieNode()
        for word in words:
            node = root
            for char in word:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
            node.word = word
        return root
    
    def _backtrack(self, board, row, col, parent, result):
        """Optimized version with Trie pruning."""
        rows, cols = len(board), len(board[0])
        
        if row < 0 or row >= rows or col < 0 or col >= cols:
            return
        
        char = board[row][col]
        
        if char not in parent.children:
            return
        
        node = parent.children[char]
        
        if node.word:
            result.append(node.word)
            node.word = None
        
        board[row][col] = '#'
        
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            self._backtrack(board, row + dr, col + dc, node, result)
        
        board[row][col] = char
        
        # Optimization: Remove empty nodes (prune dead branches)
        if not node.children and not node.word:
            del parent.children[char]
```

The optimization removes Trie nodes after they're no longer useful, preventing redundant traversals.

---

## ‚ö° Complexity Analysis

| Aspect | Complexity | Notes |
|--------|------------|-------|
| **Time** | O(M √ó N √ó 4^L) | L = max word length |
| **Space** | O(W √ó L + L) | Trie + recursion |

**Why this is efficient:**
- Without Trie: O(W √ó M √ó N √ó 4^L) - W multiplies everything
- With Trie: O(M √ó N √ó 4^L) - W only affects Trie building
- Pruning reduces actual paths explored significantly

**Comparison:**
| Approach | W=1 | W=10,000 |
|----------|-----|----------|
| Naive | 1√ó | 10,000√ó |
| Trie | 1√ó | ~1√ó (same grid traversal) |

---

## ‚ö†Ô∏è Edge Cases

| Case | Handling |
|------|----------|
| Single cell board | Works correctly |
| No words found | Return [] |
| Word longer than path | Pruned naturally |
| Same word twice in list | Trie handles deduplication |
| Word is prefix of another | Both found (continue after match) |

---

## üîç Walkthrough

```
Board:              Words: ["oath", "eat"]
["o","a","a","n"]
["e","t","a","e"]
["i","h","k","r"]
["i","f","l","v"]

Trie built:
    (root)
      /  \
     o    e
     |    |
     a    a
     |    |
     t    t ‚Üê word="eat"
     |
     h ‚Üê word="oath"

Starting at (0,0) 'o':
  'o' in trie? Yes
  'oa' path (0,1)? Yes
  'oat' path (1,1)? Yes
  'oath' path (2,1)? Yes, word found! ‚Üí result = ["oath"]

Starting at (1,0) 'e':
  'e' in trie? Yes
  'ea' path (0,0)? No (not 'a')
  'ea' path (1,1)? No (it's 't')
  'ea' from (2,2)... eventually find 'eat' ‚Üí result = ["oath", "eat"]
```

---

## üé§ Interview Tips

**What to say:**

1. **Recognize:** "This is multiple word search, so naive approach is too slow. I'll use Trie to search all words at once."

2. **Explain Trie benefit:** "Instead of searching each word separately (W multiplier), the Trie lets me traverse once and find all matches."

3. **Key insight:** "I store the complete word at the end node so I don't have to track the path."

4. **Pruning:** "Setting word to None after finding prevents duplicates. I can also delete empty nodes to avoid revisiting dead ends."

**Common follow-ups:**
- "Why store word instead of is_end?" ‚Üí Easy retrieval without tracking path
- "How to handle duplicates?" ‚Üí Set word to None after finding
- "Can we optimize more?" ‚Üí Node removal, early termination

---

## üìù Practice Checklist

- [ ] Solve in < 35 minutes
- [ ] Store word at node (not just is_end)
- [ ] Mark found words to prevent duplicates
- [ ] Don't forget to backtrack (restore cell)
- [ ] Explain O(W) improvement over naive

---

> **üí° Key Insight:** The Trie acts as a "smart dictionary" guiding your DFS - instead of searching for each word, you search once and the Trie tells you which words you've found. This is why complexity loses the W factor.

> **üîó Related:** [Trie + Backtracking Pattern](../03-Trie-Patterns/4.2-Trie-Plus-Backtracking.md) | [Word Search I (LC 79)](../../02-Recursion-Backtracking.md)
