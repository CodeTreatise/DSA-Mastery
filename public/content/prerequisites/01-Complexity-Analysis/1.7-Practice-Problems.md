# 1.7 Practice Problems

> **Test your understanding with these complexity analysis exercises.**
>
> ‚è±Ô∏è *Estimated time: 45-60 minutes for all problems*

---

## üìã How to Use This Section

1. **Read the code carefully** ‚Äî Don't rush
2. **Write your answer first** ‚Äî Before checking
3. **Explain your reasoning** ‚Äî Practice articulating WHY
4. **Check the solution** ‚Äî Understand any mistakes

Each problem includes:
- Code to analyze
- Multiple choice answer
- Detailed explanation

---

## üü¢ Level 1: Basic Loop Analysis

### Problem 1.1

```python
def mystery1(arr):
    total = 0
    for x in arr:
        total += x
    return total
```

**What is the time complexity?**
- A) O(1)
- B) O(log n)
- C) O(n)
- D) O(n¬≤)

<details>
<summary><strong>Answer</strong></summary>

**C) O(n)**

**Explanation:**
- The loop runs exactly `n` times (once per element)
- Each operation inside (`total += x`) is O(1)
- Total: n √ó O(1) = O(n)

</details>

---

### Problem 1.2

```python
def mystery2(n):
    for i in range(100):
        print(i)
```

**What is the time complexity?**
- A) O(1)
- B) O(100)
- C) O(n)
- D) O(100n)

<details>
<summary><strong>Answer</strong></summary>

**A) O(1)**

**Explanation:**
- The loop runs exactly 100 times, regardless of n
- O(100) = O(1) ‚Äî constants are dropped
- The input `n` isn't even used!

</details>

---

### Problem 1.3

```python
def mystery3(n):
    i = 1
    while i < n:
        print(i)
        i = i * 2
```

**What is the time complexity?**
- A) O(n)
- B) O(n/2)
- C) O(log n)
- D) O(2^n)

<details>
<summary><strong>Answer</strong></summary>

**C) O(log n)**

**Explanation:**
- `i` doubles each iteration: 1, 2, 4, 8, 16, ...
- To reach n, we need log‚ÇÇ(n) doublings
- Example: n=16 ‚Üí i goes 1, 2, 4, 8, 16 ‚Üí 4 iterations = log‚ÇÇ(16)

</details>

---

### Problem 1.4

```python
def mystery4(n):
    for i in range(n):
        for j in range(n):
            print(i, j)
```

**What is the time complexity?**
- A) O(n)
- B) O(2n)
- C) O(n + n)
- D) O(n¬≤)

<details>
<summary><strong>Answer</strong></summary>

**D) O(n¬≤)**

**Explanation:**
- Outer loop: n iterations
- Inner loop: n iterations **for each** outer iteration
- Total: n √ó n = n¬≤

</details>

---

### Problem 1.5

```python
def mystery5(arr):
    for x in arr:
        print(x)
    for x in arr:
        print(x * 2)
```

**What is the time complexity?**
- A) O(n)
- B) O(2n)
- C) O(n¬≤)
- D) O(n + n)

<details>
<summary><strong>Answer</strong></summary>

**A) O(n)**

**Explanation:**
- First loop: O(n)
- Second loop: O(n)
- Sequential loops ADD: O(n) + O(n) = O(2n) = O(n)
- We drop the constant 2

</details>

---

## üü° Level 2: Intermediate Analysis

### Problem 2.1

```python
def mystery6(arr):
    n = len(arr)
    for i in range(n):
        for j in range(i):
            print(arr[i], arr[j])
```

**What is the time complexity?**
- A) O(n)
- B) O(n log n)
- C) O(n¬≤)
- D) O(n¬≥)

<details>
<summary><strong>Answer</strong></summary>

**C) O(n¬≤)**

**Explanation:**
- When i=0: inner loop runs 0 times
- When i=1: inner loop runs 1 time
- When i=2: inner loop runs 2 times
- ...
- When i=n-1: inner loop runs n-1 times
- Total: 0 + 1 + 2 + ... + (n-1) = n(n-1)/2 = O(n¬≤)

</details>

---

### Problem 2.2

```python
def mystery7(arr):
    n = len(arr)
    for i in range(n):
        j = 1
        while j < n:
            print(i, j)
            j *= 2
```

**What is the time complexity?**
- A) O(n)
- B) O(n log n)
- C) O(n¬≤)
- D) O(log n)

<details>
<summary><strong>Answer</strong></summary>

**B) O(n log n)**

**Explanation:**
- Outer loop: n iterations
- Inner loop: j doubles each time ‚Üí log n iterations
- Total: n √ó log n = O(n log n)

</details>

---

### Problem 2.3

```python
def mystery8(arr):
    n = len(arr)
    for i in range(n):
        for j in range(10):
            print(arr[i])
```

**What is the time complexity?**
- A) O(n)
- B) O(10n)
- C) O(n¬≤)
- D) O(10)

<details>
<summary><strong>Answer</strong></summary>

**A) O(n)**

**Explanation:**
- Outer loop: n iterations
- Inner loop: always 10 iterations (constant!)
- Total: n √ó 10 = O(10n) = O(n)
- Constants are dropped

</details>

---

### Problem 2.4

```python
def mystery9(a, b):
    for x in a:
        print(x)
    for y in b:
        print(y)
```

**If a has n elements and b has m elements, what is the time complexity?**
- A) O(n)
- B) O(m)
- C) O(n + m)
- D) O(n √ó m)

<details>
<summary><strong>Answer</strong></summary>

**C) O(n + m)**

**Explanation:**
- First loop: O(n)
- Second loop: O(m)
- Sequential: O(n) + O(m) = O(n + m)
- We can't simplify further because n and m are independent

</details>

---

### Problem 2.5

```python
def mystery10(a, b):
    for x in a:
        for y in b:
            print(x, y)
```

**If a has n elements and b has m elements, what is the time complexity?**
- A) O(n + m)
- B) O(n √ó m)
- C) O(n¬≤)
- D) O(m¬≤)

<details>
<summary><strong>Answer</strong></summary>

**B) O(n √ó m)**

**Explanation:**
- Outer loop: n iterations
- Inner loop: m iterations for each outer
- Nested: O(n) √ó O(m) = O(n √ó m)
- NOT O(n¬≤) unless we know n = m!

</details>

---

## üî¥ Level 3: Advanced Analysis

### Problem 3.1

```python
def mystery11(arr):
    n = len(arr)
    for i in range(n):
        if arr[i] in arr:  # Note: checking membership
            print("found")
```

**What is the time complexity?**
- A) O(n)
- B) O(n log n)
- C) O(n¬≤)
- D) O(1)

<details>
<summary><strong>Answer</strong></summary>

**C) O(n¬≤)**

**Explanation:**
- Outer loop: n iterations
- `arr[i] in arr` is a **linear search**: O(n)
- Hidden cost! `in` on a list is O(n), not O(1)
- Total: n √ó O(n) = O(n¬≤)

**This is a common trap!** Use a set for O(1) membership.

</details>

---

### Problem 3.2

```python
def mystery12(n):
    i = n
    while i > 0:
        for j in range(n):
            print(i, j)
        i = i // 2
```

**What is the time complexity?**
- A) O(n)
- B) O(n log n)
- C) O(n¬≤)
- D) O(log n)

<details>
<summary><strong>Answer</strong></summary>

**B) O(n log n)**

**Explanation:**
- Outer loop: i halves each time ‚Üí log n iterations
- Inner loop: n iterations each time
- Total: log n √ó n = O(n log n)

</details>

---

### Problem 3.3

```python
def mystery13(n):
    i = n
    while i > 0:
        for j in range(i):
            print(i, j)
        i = i // 2
```

**What is the time complexity?**
- A) O(n)
- B) O(n log n)
- C) O(n¬≤)
- D) O(log n)

<details>
<summary><strong>Answer</strong></summary>

**A) O(n)**

**Explanation:**
- When i = n: inner loop runs n times
- When i = n/2: inner loop runs n/2 times
- When i = n/4: inner loop runs n/4 times
- ...
- Total: n + n/2 + n/4 + n/8 + ... = 2n (geometric series)
- O(2n) = O(n)

This is a tricky pattern! The sum of a halving geometric series is ~2n.

</details>

---

### Problem 3.4

```python
def mystery14(arr):
    n = len(arr)
    j = 0
    for i in range(n):
        while j < n and arr[j] < arr[i]:
            j += 1
```

**What is the time complexity?**
- A) O(n)
- B) O(n log n)
- C) O(n¬≤)
- D) O(n¬≥)

<details>
<summary><strong>Answer</strong></summary>

**A) O(n)**

**Explanation:**
- Key insight: `j` never decreases and never resets!
- Outer loop: n iterations
- Inner while loop: j goes from 0 to n **total** across all iterations
- Total work: O(n) for outer + O(n) for inner = O(n)

This is the **amortized analysis** pattern. Even though there are nested loops, `j` only moves forward.

</details>

---

## üß† Level 4: Recursion Analysis

### Problem 4.1

```python
def mystery15(n):
    if n <= 0:
        return
    print(n)
    mystery15(n - 1)
```

**What is the time complexity?**
- A) O(1)
- B) O(log n)
- C) O(n)
- D) O(2^n)

<details>
<summary><strong>Answer</strong></summary>

**C) O(n)**

**Explanation:**
- Recurrence: T(n) = T(n-1) + O(1)
- Calls: mystery15(n) ‚Üí mystery15(n-1) ‚Üí ... ‚Üí mystery15(0)
- Total: n calls, O(1) work each = O(n)

</details>

---

### Problem 4.2

```python
def mystery16(n):
    if n <= 0:
        return
    mystery16(n - 1)
    mystery16(n - 1)
```

**What is the time complexity?**
- A) O(n)
- B) O(n¬≤)
- C) O(2^n)
- D) O(n!)

<details>
<summary><strong>Answer</strong></summary>

**C) O(2^n)**

**Explanation:**
- Recurrence: T(n) = 2T(n-1) + O(1)
- Each call spawns 2 more calls
- Tree has 2^n leaves
- Total: O(2^n)

</details>

---

### Problem 4.3

```python
def mystery17(n):
    if n <= 1:
        return
    mystery17(n // 2)
```

**What is the time complexity?**
- A) O(1)
- B) O(log n)
- C) O(n)
- D) O(n log n)

<details>
<summary><strong>Answer</strong></summary>

**B) O(log n)**

**Explanation:**
- Recurrence: T(n) = T(n/2) + O(1)
- Calls: mystery17(n) ‚Üí mystery17(n/2) ‚Üí mystery17(n/4) ‚Üí ... ‚Üí mystery17(1)
- Total: log‚ÇÇ(n) calls, O(1) work each = O(log n)

</details>

---

### Problem 4.4

```python
def mystery18(n):
    if n <= 1:
        return
    for i in range(n):
        print(i)
    mystery18(n // 2)
    mystery18(n // 2)
```

**What is the time complexity?**
- A) O(n)
- B) O(n log n)
- C) O(n¬≤)
- D) O(2^n)

<details>
<summary><strong>Answer</strong></summary>

**B) O(n log n)**

**Explanation:**
- Recurrence: T(n) = 2T(n/2) + O(n)
- This is the **merge sort** pattern!
- Master Theorem: a=2, b=2, d=1 ‚Üí a = b^d ‚Üí Case 2
- Result: O(n^d log n) = O(n log n)

</details>

---

### Problem 4.5

```python
def mystery19(n):
    if n <= 1:
        return
    for i in range(n):
        print(i)
    mystery19(n - 1)
```

**What is the time complexity?**
- A) O(n)
- B) O(n log n)
- C) O(n¬≤)
- D) O(2^n)

<details>
<summary><strong>Answer</strong></summary>

**C) O(n¬≤)**

**Explanation:**
- Recurrence: T(n) = T(n-1) + O(n)
- At each level: n + (n-1) + (n-2) + ... + 1 = n(n+1)/2 = O(n¬≤)
- This is the **selection sort** pattern

</details>

---

## üíæ Level 5: Space Complexity

### Problem 5.1

```python
def mystery20(arr):
    result = []
    for x in arr:
        result.append(x * 2)
    return result
```

**What is the space complexity?**
- A) O(1)
- B) O(log n)
- C) O(n)
- D) O(n¬≤)

<details>
<summary><strong>Answer</strong></summary>

**C) O(n)**

**Explanation:**
- `result` grows to hold n elements
- Space: O(n) for the result array

</details>

---

### Problem 5.2

```python
def mystery21(arr):
    left, right = 0, len(arr) - 1
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1
```

**What is the space complexity?**
- A) O(1)
- B) O(log n)
- C) O(n)
- D) O(n¬≤)

<details>
<summary><strong>Answer</strong></summary>

**A) O(1)**

**Explanation:**
- Only using two pointer variables
- Modifying array in-place
- No extra data structures
- Space: O(1)

</details>

---

### Problem 5.3

```python
def mystery22(n):
    if n <= 0:
        return
    mystery22(n - 1)
```

**What is the space complexity?**
- A) O(1)
- B) O(log n)
- C) O(n)
- D) O(n¬≤)

<details>
<summary><strong>Answer</strong></summary>

**C) O(n)**

**Explanation:**
- Recursion depth: n
- Each call adds a stack frame
- Stack space: O(n)

Even though there's no explicit data structure, recursion uses stack space!

</details>

---

### Problem 5.4

```python
def mystery23(n):
    if n <= 1:
        return
    mystery23(n // 2)
    mystery23(n // 2)
```

**What is the space complexity?**
- A) O(1)
- B) O(log n)
- C) O(n)
- D) O(n¬≤)

<details>
<summary><strong>Answer</strong></summary>

**B) O(log n)**

**Explanation:**
- Even though there are 2 recursive calls, they don't exist simultaneously
- First call completes fully before second starts
- Maximum stack depth: log‚ÇÇ(n)
- Space: O(log n)

</details>

---

## üìä Scoring Guide

| Score | Level |
|-------|-------|
| 0-5 | Review basics ‚Äî re-read 1.1 and 1.2 |
| 6-10 | Getting there ‚Äî focus on loop patterns |
| 11-15 | Good understanding ‚Äî practice more recursion |
| 16-20 | Strong foundation ‚Äî ready for interviews |
| 21-23 | Excellent! ‚Äî you've mastered complexity analysis |

---

## üéØ Next Steps

### If You Struggled (< 15 correct)

1. Re-read [1.1 What Is Big O](./1.1-What-Is-Big-O.md)
2. Re-read [1.3 Analyzing Loops](./1.3-Analyzing-Loops.md)
3. Practice tracing through code with specific values
4. Come back and retry in a few days

### If You Did Well (‚â• 15 correct)

1. Move on to actual DSA topics
2. Analyze every algorithm you learn
3. Practice explaining complexity out loud
4. Try [LeetCode problems tagged "Time Complexity"](https://leetcode.com/tag/time-complexity/)

---

## üìù Self-Assessment Questions

Before moving on, can you:

- [ ] Explain the difference between O(n) and O(n¬≤) in simple terms?
- [ ] Identify when nested loops are NOT O(n¬≤)?
- [ ] Write the recurrence for a recursive function?
- [ ] Recognize the O(n log n) pattern (divide and conquer)?
- [ ] Account for hidden costs like `in` on a list?
- [ ] Calculate space complexity including recursion stack?

If you checked all boxes, you're ready for the next unit!

---

> **üí° Key Insight:** Complexity analysis is a skill that improves with practice. Every time you write or read code, ask yourself: "What's the complexity?" Make it a habit, and it will become second nature.

---

**Congratulations!** You've completed the Complexity Analysis module. 

**Return to:** [00-Prerequisites.md](../../00-Prerequisites.md) | **Next Unit:** [01-Arrays-Strings](../../01-Arrays-Strings/01-Arrays-Strings.md)
