# 4.3 Stack Using Queues (LC 225)

> **Grokking Pattern:** #7 Stacks - Design
>
> **Difficulty:** Easy | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê Common Interview Problem

---

## Problem Statement

Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `top`, `pop`, and `empty`).

Implement the `MyStack` class:
- `void push(int x)` - Pushes element x to the top of the stack
- `int pop()` - Removes the element on the top and returns it
- `int top()` - Returns the element on top
- `boolean empty()` - Returns true if the stack is empty

**You must use only standard queue operations.**

```
Example:
MyStack myStack = new MyStack();
myStack.push(1);    // stack: [1]
myStack.push(2);    // stack: [1, 2] (2 is top)
myStack.top();      // returns 2
myStack.pop();      // returns 2, stack: [1]
myStack.empty();    // returns false
```

[LeetCode 225 - Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Implement X using Y" (data structure conversion)
- Reversing access order
- Queue is FIFO, Stack is LIFO ‚Üí need to make newest accessible first

**Key insight:**
When we push, we need to make the new element accessible immediately (for LIFO).

**Two approaches:**
1. **Cost on push:** Rotate queue so new element is at front
2. **Cost on pop:** Rotate to find the last element

</details>

---

## ‚úÖ When to Use This Approach

- When only queue operations are allowed
- DFS simulation with queue-only language
- Understanding data structure internals

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Language has native stack | Unnecessary complexity | List/Array |
|" Need O(1) for all ops "| Best is O(n) push or pop | Native stack |
| High-frequency operations |" O(n) overhead "| Native structure |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md)
- [Queue Basics](../05-Queue-Fundamentals/5.1-Queue-Basics.md)
- LIFO vs FIFO ordering

**After mastering this:**
- [Queue Using Stacks](./4.2-Queue-Using-Stacks.md) - Reverse problem
- [Min Stack](./4.1-Min-Stack.md) - Similar design thinking

**Compare:**
- Queue using Stacks: Amortized O(1) possible
- Stack using Queues: O(n) for push OR pop (can't avoid)

</details>

---

## üìê How It Works

### Approach 1: O(n) Push, O(1) Pop (Recommended)

Make push expensive: rotate after each push so newest is at front.

```
push(1): queue = [1]
         (only one element, no rotation needed)

push(2): queue = [1, 2]
         Rotate: dequeue 1, enqueue 1
         queue = [2, 1]
         (now 2 is at front = top of stack)

push(3): queue = [2, 1, 3]
         Rotate n-1 times:
         - dequeue 2, enqueue 2: [1, 3, 2]
         - dequeue 1, enqueue 1: [3, 2, 1]
         queue = [3, 2, 1]
         (now 3 is at front = top of stack)

pop():   dequeue front ‚Üí returns 3
         queue = [2, 1]

top():   peek front ‚Üí returns 2
```

### Approach 2: O(1) Push, O(n) Pop

Make pop expensive: rotate n-1 elements to find the last one.

```
push(1): queue = [1]
push(2): queue = [1, 2]
push(3): queue = [1, 2, 3]

pop():   Rotate n-1 times to get last element to front:
         - dequeue 1, enqueue 1: [2, 3, 1]
         - dequeue 2, enqueue 2: [3, 1, 2]
         - Now dequeue 3 ‚Üí returns 3
         queue = [1, 2]
```

### Approach 3: Single Queue

Can use just one queue with rotation (both approaches work with one queue).

---

## üíª Code Implementation

### Solution 1: O(n) Push (Recommended - Simpler Logic)

**Python:**
```python
from collections import deque

class MyStack:
    """
    Stack implemented with a single queue.
    
    Approach: O(n) push, O(1) pop
    After each push, rotate queue so new element is at front.
    
    Time: push O(n), pop O(1), top O(1), empty O(1)
    Space: O(n)
    """
    
    def __init__(self):
        self.queue = deque()
    
    def push(self, x: int) -> None:
        """Push element and rotate so it's at front."""
        self.queue.append(x)
        
        # Rotate: move all previous elements behind the new one
        for _ in range(len(self.queue) - 1):
            self.queue.append(self.queue.popleft())
    
    def pop(self) -> int:
        """Remove and return top. O(1)."""
        return self.queue.popleft()
    
    def top(self) -> int:
        """Return top without removing. O(1)."""
        return self.queue[0]
    
    def empty(self) -> bool:
        """Check if empty. O(1)."""
        return len(self.queue) == 0


class MyStackTwoQueues:
    """
    Using two queues (as originally asked in problem).
    
    Same O(n) push approach, just uses helper queue for clarity.
    """
    
    def __init__(self):
        self.main = deque()
        self.helper = deque()
    
    def push(self, x: int) -> None:
        # Add new element to helper
        self.helper.append(x)
        
        # Move all from main to helper
        while self.main:
            self.helper.append(self.main.popleft())
        
        # Swap: helper becomes main
        self.main, self.helper = self.helper, self.main
    
    def pop(self) -> int:
        return self.main.popleft()
    
    def top(self) -> int:
        return self.main[0]
    
    def empty(self) -> bool:
        return len(self.main) == 0
```

**JavaScript:**
```javascript
/**
 * Stack using single queue - O(n) push approach.
 */
class MyStack {
    constructor() {
        this.queue = [];
    }
    
    /**
     * Push element and rotate. O(n)
     */
    push(x) {
        this.queue.push(x);
        
        // Rotate: move all previous elements behind new one
        for (let i = 0; i < this.queue.length - 1; i++) {
            this.queue.push(this.queue.shift());
        }
    }
    
    /**
     * Pop top element. O(1)
     */
    pop() {
        return this.queue.shift();
    }
    
    /**
     * Get top element. O(1)
     */
    top() {
        return this.queue[0];
    }
    
    /**
     * Check if empty. O(1)
     */
    empty() {
        return this.queue.length === 0;
    }
}

/**
 * Two queues version for clarity.
 */
class MyStackTwoQueues {
    constructor() {
        this.main = [];
        this.helper = [];
    }
    
    push(x) {
        // Add to helper
        this.helper.push(x);
        
        // Move all from main to helper
        while (this.main.length > 0) {
            this.helper.push(this.main.shift());
        }
        
        // Swap
        [this.main, this.helper] = [this.helper, this.main];
    }
    
    pop() {
        return this.main.shift();
    }
    
    top() {
        return this.main[0];
    }
    
    empty() {
        return this.main.length === 0;
    }
}
```

### Solution 2: O(n) Pop Alternative

**Python:**
```python
from collections import deque

class MyStackPopHeavy:
    """
    Stack with O(1) push, O(n) pop.
    
    Better when: many pushes, few pops
    """
    
    def __init__(self):
        self.queue = deque()
    
    def push(self, x: int) -> None:
        """Just add to back. O(1)."""
        self.queue.append(x)
    
    def pop(self) -> int:
        """Rotate n-1 elements, then pop. O(n)."""
        # Move n-1 elements to the back
        for _ in range(len(self.queue) - 1):
            self.queue.append(self.queue.popleft())
        # Now the last element (stack top) is at front
        return self.queue.popleft()
    
    def top(self) -> int:
        """Same rotation as pop, but re-add. O(n)."""
        for _ in range(len(self.queue) - 1):
            self.queue.append(self.queue.popleft())
        val = self.queue[0]
        # Rotate one more to restore
        self.queue.append(self.queue.popleft())
        return val
    
    def empty(self) -> bool:
        return len(self.queue) == 0
```

---

## ‚ö° Complexity Analysis

### Approach 1: O(n) Push

| Operation | Time | Notes |
|-----------|------|-------|
| push |" O(n) "| Rotate n-1 elements |
| pop |" O(1) "| Direct dequeue |
| top |" O(1) "| Direct peek |
| empty |" O(1) "| Size check |

### Approach 2: O(n) Pop

| Operation | Time | Notes |
|-----------|------|-------|
| push |" O(1) "| Direct enqueue |
| pop |" O(n) "| Rotate n-1 elements |
| top |" O(n) "| Rotate n-1, peek, rotate 1 |
| empty |" O(1) "| Size check |

### Which to Choose?

- **Approach 1 (O(n) push):** Better when pops/tops are frequent
- **Approach 2 (O(n) pop):** Better when pushes are frequent

### Comparison with Queue Using Stacks

| Implementation | Best Possible |
|----------------|---------------|
| Queue using Stacks |" Amortized O(1) all "|
| Stack using Queues |" O(n) for push OR pop "|

**Why can't Stack using Queues achieve O(1)?**
- Queue maintains order ‚Üí to access last element, must traverse
- Stack using Queues: one operation must be O(n)

---

## üîÑ Variations

| Variation | Difference | Notes |
|-----------|------------|---------|
| One queue vs two | Same complexity | One queue is cleaner |
|" O(n) push vs O(n) pop "| Trade-off | Choose based on usage |
| With size tracking | Add counter |" Avoids O(n) size calls "|

---

## ‚ö†Ô∏è Common Mistakes

### 1. Off-by-One in Rotation Count

```python
# ‚ùå WRONG: Rotating too many times
for _ in range(len(self.queue)):
    self.queue.append(self.queue.popleft())

# ‚úÖ CORRECT: Rotate n-1 times
for _ in range(len(self.queue) - 1):
    self.queue.append(self.queue.popleft())
```

### 2. Forgetting to Rotate in Top (Pop-Heavy Approach)

```python
# ‚ùå WRONG: Returns front, not top
def top(self):
    return self.queue[0]

# ‚úÖ CORRECT: Rotate to find top (in pop-heavy approach)
def top(self):
    for _ in range(len(self.queue) - 1):
        self.queue.append(self.queue.popleft())
    val = self.queue[0]
    self.queue.append(self.queue.popleft())  # Restore
    return val
```

### 3. Not Swapping in Two-Queue Version

```python
# ‚ùå WRONG: Keeps adding to helper
def push(self, x):
    self.helper.append(x)
    while self.main:
        self.helper.append(self.main.popleft())
    # Forgot to swap!

# ‚úÖ CORRECT: Swap queues
def push(self, x):
    self.helper.append(x)
    while self.main:
        self.helper.append(self.main.popleft())
    self.main, self.helper = self.helper, self.main
```

---

## üìù Practice Problems (Progressive)

### This Problem
- [ ] [Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/) - LC 225 ‚≠ê

### Related Problems
- [ ] [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) - LC 232
- [ ] [Min Stack](https://leetcode.com/problems/min-stack/) - LC 155
- [ ] [Design Circular Queue](https://leetcode.com/problems/design-circular-queue/) - LC 622

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement push-heavy version
**Day 3:** Implement pop-heavy version
**Day 7:** Compare with Queue Using Stacks
**Day 14:** Implement without notes
**Day 21:** Explain why amortized O(1) isn't possible

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Clarify the constraint:**
> "So I can only use queue operations: enqueue (push to back), dequeue (pop from front), peek front, and size/empty?"

**Explain the trade-off:**
> "Unlike Queue Using Stacks where we can get amortized O(1), here one operation must be O(n). I'll make push O(n) so pop and top are O(1), which is usually preferable."

**Describe the rotation:**
> "After pushing a new element, I rotate the queue by dequeuing and re-enqueuing n-1 elements. This moves the new element to the front, simulating stack top."

**Single vs two queues:**
> "The problem says two queues, but one queue suffices with the same approach. Two queues just makes the swap clearer."

**Comparison question:**
> "Queue Using Stacks can achieve amortized O(1) because stacks allow lazy transfer. With queues, we can't delay the rotation - we must do it to maintain LIFO access."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common pair with LC 232 |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Frequently asked |
| Google | ‚≠ê‚≠ê‚≠ê | May ask analysis |
| Bloomberg | ‚≠ê‚≠ê‚≠ê | Design focus |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | LIFO using FIFO |
| Explain approach | 3-5 min | Rotation concept |
| Implement | 8-10 min | One approach |
| Test | 3-5 min | Trace through ops |
| Interview target | 18-22 min | Including explanation |

---

> **üí° Key Insight:** Unlike Queue Using Stacks, Stack Using Queues cannot achieve amortized O(1) for all operations. The fundamental reason is that a queue maintains insertion order, and to access the most recently added element (stack top), we must traverse past all others. Choose the trade-off (O(n) push vs O(n) pop) based on expected usage patterns.

---

## üîó Related

- [Queue Using Stacks](./4.2-Queue-Using-Stacks.md) - Reverse problem (can do amortized O(1))
- [Min Stack](./4.1-Min-Stack.md) - Related design
- [Queue Basics](../05-Queue-Fundamentals/5.1-Queue-Basics.md) - Foundation
