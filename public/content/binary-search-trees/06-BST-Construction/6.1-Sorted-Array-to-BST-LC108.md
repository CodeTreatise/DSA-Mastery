# 6.1 Convert Sorted Array to BST (LC 108)

## Problem Statement

[LeetCode 108 - Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)

Given an integer array `nums` sorted in ascending order, convert it to a height-balanced BST (depth of subtrees differs by at most 1).

```
Input: nums = [-10, -3, 0, 5, 9]

Output (one valid answer):
        0
       / \
     -3   9
     /   /
   -10  5

The middle element becomes root, left half becomes left subtree,
right half becomes right subtree.
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a Divide and Conquer Construction problem:**
- Build tree from sorted sequence
- Need balanced result
- Recursive subdivision

**Keywords:**
- "sorted array to BST"
- "height-balanced"
- "construct tree from sorted"

**Pattern:** Choose middle as root, recurse on halves (Divide & Conquer).

</details>

---

## ‚úÖ When to Use

- Building BST from sorted data
- Need guaranteed balance
- Constructing search-optimized structure

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Unsorted input | Won't produce valid BST | Sort first, or use insertion |
| Need specific structure | This gives one valid tree | Manual construction |
| Dynamic updates | Static construction | Self-balancing tree |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
- [Divide & Conquer](../../02-Recursion-Backtracking/03-Divide-Conquer/3.1-DC-Basics.md)
- Array middle element selection

**After mastering this:**
- [Preorder to BST (LC 1008)](./6.2-Preorder-to-BST-LC1008.md)
- [Sorted List to BST (LC 109)](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)

**Combines with:**
- Binary search (choosing middle)
- Recursive tree construction

</details>

---

## üìê How It Works

### The Key Insight

```
Sorted array: [-10, -3, 0, 5, 9]
                     ‚Üë
                   middle

For a height-balanced BST:
- Middle element becomes root
- Left half becomes left subtree
- Right half becomes right subtree

This is exactly binary search, but building a tree!
```

### Visualization

```
nums = [-10, -3, 0, 5, 9]
         0   1  2  3  4

Step 1: mid = 2, root = 0
        Left: [0,1], Right: [3,4]

Step 2: Left subtree from [0,1]
        mid = 0, root = -10
        Left: [], Right: [1,1]
        
        Right subtree from [3,4]
        mid = 3, root = 5
        Left: [], Right: [4,4]

Step 3: Continue recursively...

Result:
        0
       / \
     -3   5
     /     \
   -10      9
```

### Tree Construction Process

```
buildTree(0, 4):
    mid = 2, node = 0
    left = buildTree(0, 1)
    right = buildTree(3, 4)

buildTree(0, 1):
    mid = 0, node = -10
    left = buildTree(0, -1) = null
    right = buildTree(1, 1)
    
buildTree(1, 1):
    mid = 1, node = -3
    left = buildTree(1, 0) = null
    right = buildTree(2, 1) = null

... and so on
```

---

## üíª Code Implementation

### Recursive (Standard)

**Python:**
```python
def sortedArrayToBST(self, nums: list[int]) -> Optional[TreeNode]:
    """
    Convert sorted array to height-balanced BST.
    
    Time: O(n) - visit each element once
    Space: O(log n) - recursion depth for balanced tree
    
    Pattern: Divide & Conquer, middle as root
    """
    def build(left: int, right: int) -> Optional[TreeNode]:
        if left > right:
            return None
        
        # Choose middle element as root
        mid = (left + right) // 2
        
        # Create node
        node = TreeNode(nums[mid])
        
        # Recursively build subtrees
        node.left = build(left, mid - 1)
        node.right = build(mid + 1, right)
        
        return node
    
    return build(0, len(nums) - 1)
```

**JavaScript:**
```javascript
var sortedArrayToBST = function(nums) {
    // Divide & Conquer: middle as root
    
    function build(left, right) {
        if (left > right) return null;
        
        const mid = Math.floor((left + right) / 2);
        
        const node = new TreeNode(nums[mid]);
        node.left = build(left, mid - 1);
        node.right = build(mid + 1, right);
        
        return node;
    }
    
    return build(0, nums.length - 1);
};
```

### Alternative: Slicing (Less Efficient)

**Python:**
```python
def sortedArrayToBST(self, nums: list[int]) -> Optional[TreeNode]:
    """
    Using array slicing (creates copies - O(n) extra space per level).
    Clean but less efficient.
    """
    if not nums:
        return None
    
    mid = len(nums) // 2
    
    node = TreeNode(nums[mid])
    node.left = self.sortedArrayToBST(nums[:mid])      # Left half
    node.right = self.sortedArrayToBST(nums[mid + 1:])  # Right half
    
    return node
```

### Iterative (Using Stack)

**Python:**
```python
def sortedArrayToBST(self, nums: list[int]) -> Optional[TreeNode]:
    """
    Iterative approach using stack.
    
    Time: O(n), Space: O(log n) for stack
    """
    if not nums:
        return None
    
    # Stack holds (node, left, right) tuples
    root = TreeNode(0)  # Placeholder
    stack = [(root, 0, len(nums) - 1, 'root')]
    
    while stack:
        parent, left, right, direction = stack.pop()
        
        if left > right:
            continue
        
        mid = (left + right) // 2
        node = TreeNode(nums[mid])
        
        if direction == 'root':
            root = node
        elif direction == 'left':
            parent.left = node
        else:
            parent.right = node
        
        # Push children to process
        stack.append((node, mid + 1, right, 'right'))
        stack.append((node, left, mid - 1, 'left'))
    
    return root
```

---

## ‚ö° Complexity Analysis

| Metric | Complexity | Notes |
|--------|------------|-------|
| Time |" O(n) "| Visit each element exactly once |
| Space (indices) |" O(log n) "| Recursion depth of balanced tree |
| Space (slicing) |" O(n log n) "| Creates array copies |

**Why O(n) time:**
- Each of n elements becomes exactly one node
- O(1) work per node (create, assign children)

**Why O(log n) space:**
- Tree is balanced ‚Üí height is O(log n)
- Recursion stack depth = tree height

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **Sorted List to BST** | No random access | LC 109 |
| **Left-biased middle** | `mid = left + (right - left) // 2` | Same result |
| **Right-biased middle** | `mid = left + (right - left + 1) // 2` | Different valid tree |
| **Count unique BSTs** | DP problem | LC 96 |

### Sorted Linked List to BST (LC 109)

```python
def sortedListToBST(head: ListNode) -> TreeNode:
    """
    For linked list: either convert to array first,
    or use slow/fast pointers to find middle.
    """
    # Convert to array approach
    vals = []
    while head:
        vals.append(head.val)
        head = head.next
    
    # Then use same algorithm
    def build(left, right):
        if left > right:
            return None
        mid = (left + right) // 2
        node = TreeNode(vals[mid])
        node.left = build(left, mid - 1)
        node.right = build(mid + 1, right)
        return node
    
    return build(0, len(vals) - 1)
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Off-by-One in Mid Calculation

```python
# ‚ùå Wrong: Can cause infinite recursion
mid = (left + right + 1) // 2  # With certain ranges, this loops

# ‚úÖ Correct: Standard middle
mid = (left + right) // 2
# Or for large numbers (avoid overflow in other languages):
mid = left + (right - left) // 2
```

### 2. Wrong Base Case

```python
# ‚ùå Wrong: Misses single-element case
if left >= right:
    return None  # Skips when left == right!

# ‚úÖ Correct: Only skip when left > right
if left > right:
    return None
```

### 3. Not Excluding Mid from Recursive Calls

```python
# ‚ùå Wrong: Includes mid in subtrees (infinite loop)
node.left = build(left, mid)      # Should be mid - 1
node.right = build(mid, right)    # Should be mid + 1

# ‚úÖ Correct: Exclude mid
node.left = build(left, mid - 1)
node.right = build(mid + 1, right)
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn pattern)
- [ ] [Sorted Array to BST (LC 108)](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/) - This problem

### Medium (Apply pattern)
- [ ] [Sorted List to BST (LC 109)](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/) - Linked list version
- [ ] [Preorder to BST (LC 1008)](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/) - Different input
- [ ] [Balance a BST (LC 1382)](https://leetcode.com/problems/balance-a-binary-search-tree/) - Rebuild unbalanced

### Hard (Master)
- [ ] [Unique BST II (LC 95)](https://leetcode.com/problems/unique-binary-search-trees-ii/) - Generate all structures

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement with index approach
- **Day 3:** Trace through example
- **Day 7:** Implement with slicing (compare)
- **Day 14:** Solve LC 109 (linked list)
- **Day 30:** Solve LC 1382 (balance BST)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"For a height-balanced BST, I need equal-ish nodes on each side. The middle element of a sorted array naturally has this property. So I'll use divide and conquer: middle becomes root, left half becomes left subtree, right half becomes right subtree."

**Key points:**
1. "Middle element ensures balance"
2. "This is like binary search, but building instead of searching"
3. "Time O(n), space O(log n) for recursion"

**Follow-up: Why balanced?**
"Because we always pick the middle, each subtree has at most half the elements. This guarantees the height difference between subtrees is at most 1."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common easy question |
| Meta | ‚≠ê‚≠ê‚≠ê | Tree construction |
| Google | ‚≠ê‚≠ê‚≠ê | May ask follow-ups |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Frequently asked |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Clear goal |
| Explain approach | 2-3 min | D&C with middle |
| Code solution | 5-8 min | Short code |
| Trace example | 3-5 min | Show correctness |
| Total interview time | 15-20 min | Easy difficulty |

---

## üí° Key Insight

> **Middle element = balanced root.** Just as binary search finds elements by halving the search space, building a balanced BST requires halving the input at each level. The middle element naturally creates equal-sized subtrees.

---

## üîó Related

- **Next:** [Preorder to BST (LC 1008)](./6.2-Preorder-to-BST-LC1008.md)
- **Similar:** [Sorted List to BST (LC 109)](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)
- **Pattern:** [Divide & Conquer](../../02-Recursion-Backtracking/03-Divide-Conquer/3.1-DC-Basics.md)
- **Uses:** [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
