# LC 208: Implement Trie (Prefix Tree)

> **The foundational Trie problem - master this and you've mastered 50% of Trie interviews.**

---

## ğŸ“‹ Problem Statement

**LeetCode 208 - Medium**

Implement a trie with `insert`, `search`, and `startsWith` methods.

```
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // return True
trie.search("app");     // return False
trie.startsWith("app"); // return True
trie.insert("app");
trie.search("app");     // return True
```

**Constraints:**
- 1 <= word.length, prefix.length <= 2000
- word and prefix consist only of lowercase English letters
- At most 3 Ã— 10â´ calls to insert, search, and startsWith

---

## ğŸ¯ Pattern Recognition

**This is the classic "Implement Data Structure" pattern:**
- Design classes (TrieNode + Trie)
- Implement core operations
- Handle edge cases

**Key insight:** This problem tests if you understand the Trie structure fundamentally.

---

## ğŸ“ Approach

### Key Observations

1. **TrieNode stores:**
   - Children (mapping char â†’ child node)
   - End marker (is this the end of a word?)

2. **Insert:** Create path, mark end
3. **Search:** Follow path, check end marker
4. **StartsWith:** Follow path, no end check

### Algorithm Steps

**Insert:**
```
1. Start at root
2. For each character:
   - If child doesn't exist, create it
   - Move to child
3. Mark current node as end of word
```

**Search:**
```
1. Traverse trie following word
2. If any character missing â†’ False
3. If traversal complete â†’ return node.is_end
```

**StartsWith:**
```
1. Same as search, but...
2. If traversal complete â†’ return True (no is_end check)
```

---

## ğŸ’» Solution

### Solution 1: HashMap Children (Flexible)

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = {}  # char -> TrieNode
        self.is_end = False


class Trie:
    """
    Time Complexity:
        - insert: O(m) where m = word length
        - search: O(m)
        - startsWith: O(m)
    
    Space Complexity:
        - O(n Ã— m) for n words of avg length m
    """
    
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def search(self, word: str) -> bool:
        node = self._traverse(word)
        return node is not None and node.is_end
    
    def startsWith(self, prefix: str) -> bool:
        return self._traverse(prefix) is not None
    
    def _traverse(self, s: str) -> TrieNode:
        """Helper to navigate trie."""
        node = self.root
        for char in s:
            if char not in node.children:
                return None
            node = node.children[char]
        return node
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = new Map();
        this.isEnd = false;
    }
}

class Trie {
    constructor() {
        this.root = new TrieNode();
    }
    
    insert(word) {
        let node = this.root;
        for (const char of word) {
            if (!node.children.has(char)) {
                node.children.set(char, new TrieNode());
            }
            node = node.children.get(char);
        }
        node.isEnd = true;
    }
    
    search(word) {
        const node = this._traverse(word);
        return node !== null && node.isEnd;
    }
    
    startsWith(prefix) {
        return this._traverse(prefix) !== null;
    }
    
    _traverse(s) {
        let node = this.root;
        for (const char of s) {
            if (!node.children.has(char)) {
                return null;
            }
            node = node.children.get(char);
        }
        return node;
    }
}
```

---

### Solution 2: Array[26] Children (Optimized)

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.is_end = False


class Trie:
    """
    Optimized for lowercase English letters only.
    Slightly faster due to array indexing vs hash lookup.
    """
    
    def __init__(self):
        self.root = TrieNode()
    
    def _char_index(self, c: str) -> int:
        return ord(c) - ord('a')
    
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            idx = self._char_index(char)
            if node.children[idx] is None:
                node.children[idx] = TrieNode()
            node = node.children[idx]
        node.is_end = True
    
    def search(self, word: str) -> bool:
        node = self._traverse(word)
        return node is not None and node.is_end
    
    def startsWith(self, prefix: str) -> bool:
        return self._traverse(prefix) is not None
    
    def _traverse(self, s: str) -> TrieNode:
        node = self.root
        for char in s:
            idx = self._char_index(char)
            if node.children[idx] is None:
                return None
            node = node.children[idx]
        return node
```

---

## âš¡ Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| **insert** | O(m) | O(m) worst case |
| **search** | O(m) | O(1) |
| **startsWith** | O(m) | O(1) |
| **Total trie** | - | O(n Ã— m) |

**Where:**
- m = length of word/prefix
- n = number of words inserted

---

## âš ï¸ Edge Cases

| Case | Handling |
|------|----------|
| Empty string | Insert marks root as end; search/starts returns accordingly |
| Single character | Works like any word |
| Very long words | O(m) is still efficient |
| Repeated inserts | Idempotent, just re-marks is_end |

---

## ğŸ” Walkthrough

```
trie = Trie()
trie.insert("apple")

Trie after insert("apple"):
    (root)
       â”‚
       a
       â”‚
       p
       â”‚
       p
       â”‚
       l
       â”‚
       e â† is_end = True

trie.search("apple")  â†’  True  (path exists, is_end = True)
trie.search("app")    â†’  False (path exists, is_end = False)
trie.startsWith("app") â†’ True  (path exists, don't check is_end)

trie.insert("app")

Trie after insert("app"):
    (root)
       â”‚
       a
       â”‚
       p
       â”‚
       p â† is_end = True (now!)
       â”‚
       l
       â”‚
       e â† is_end = True

trie.search("app") â†’ True (now is_end = True at 'p')
```

---

## ğŸ¤ Interview Tips

**What to say when given this problem:**

1. **Clarify:** "So we need insert, search, and prefix checking. All lowercase letters?"

2. **Structure:** "I'll use a TrieNode class with children and an is_end marker. The Trie class holds the root."

3. **Explain insert:** "I traverse creating nodes as needed, then mark the end."

4. **Explain search vs startsWith:** "The difference is search checks is_end, startsWith doesn't."

5. **Optimize:** "I'll add a _traverse helper to avoid code duplication."

**Common follow-ups:**
- "Add delete operation" â†’ See [Delete Operation](../02-Trie-Operations/3.4-Delete-Operation.md)
- "Support wildcards" â†’ See [Wildcard Search](../03-Trie-Patterns/4.1-Wildcard-Search.md)
- "Get all words with prefix" â†’ See [Collect Pattern](../03-Trie-Patterns/4.3-Collect-All-Words.md)

---

## ğŸ“ Practice Checklist

- [ ] Solve in < 15 minutes
- [ ] Explain complexity correctly
- [ ] Handle edge cases
- [ ] Mention both HashMap and Array approaches
- [ ] Extend with delete if asked

---

> **ğŸ’¡ Key Insight:** The _traverse helper is crucial - it eliminates code duplication between search and startsWith. The only difference between them is the is_end check at the end.

> **ğŸ”— Related:** [TrieNode Structure](../01-Trie-Fundamentals/2.1-TrieNode-Structure.md) | [Trie Class Design](../01-Trie-Fundamentals/2.2-Trie-Class-Design.md)
