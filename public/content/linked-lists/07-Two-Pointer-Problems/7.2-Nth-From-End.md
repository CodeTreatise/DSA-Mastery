# 7.2 Remove Nth Node From End of List (LC 19)

> **Grokking Pattern:** Two Pointers with Fixed Gap
>
> **Difficulty:** Medium | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very High

---

## Problem Statement

Given the head of a linked list, remove the **n-th node from the end** of the list and return its head.

```
Input:  1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5, n = 2
Output: 1 ‚Üí 2 ‚Üí 3 ‚Üí 5

(Remove 4, which is 2nd from end)
```

[LeetCode 19 - Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "From the end" without knowing length
- Need to remove/access a node at position relative to end
- One-pass solution requested

**Keywords:**
- "nth from end", "kth last", "remove from end"

**The Pattern:**
- Create a gap of n between two pointers
- When front reaches end, back is at target position

</details>

---

## ‚úÖ When to Use This Approach

- Removing nth node from end in one pass
- Finding nth node from end
- Any "from the end" position problem

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Know the length | Two-pass simpler | Calculate position directly |
| Array instead | Direct indexing | `arr[len - n]` |
| Multiple removals | Different pattern | Count and batch process |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Linked List Basics](../01-Singly-LL/1.1-Basics.md)
- [Two Pointers concept](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md)

**After mastering this:**
- [Intersection of Two Linked Lists](./7.3-Intersection.md)
- Rotate List (LC 61)
- Split Linked List in Parts (LC 725)

**Combines with:**
- Dummy node for edge cases (removing head)

</details>

---

## üìê How It Works

### The Key Insight

If we maintain a gap of `n` nodes between two pointers:
- When the front pointer reaches the end (null)
- The back pointer is `n` nodes from the end

But for **removal**, we need the node **before** the target, so we use `n+1` gap or a dummy node.

### Visualization

```
Remove n=2 (second from end)

Start with gap of n=2:
[1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí [5] ‚Üí null
 ‚Üë                 ‚Üë
slow              fast (2 nodes ahead)

Move both until fast reaches null:
[1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí [5] ‚Üí null
             ‚Üë                 ‚Üë
           slow              fast‚Üínull

slow.next is the node to remove (4)
slow.next = slow.next.next ‚Üí skip node 4
```

### With Dummy Node (Handles Edge Case of Removing Head)

```
n=5, remove head:
dummy ‚Üí [1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí [5] ‚Üí null
  ‚Üë                              ‚Üë
 slow                          fast

After moving:
dummy ‚Üí [1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí [5] ‚Üí null
  ‚Üë                                      ‚Üë
 slow                                 fast‚Üínull

slow.next = slow.next.next ‚Üí removes node 1
```

---

## üíª Code Implementation

### One-Pass Solution with Dummy Node

**Python:**

```python
def remove_nth_from_end(head: ListNode, n: int) -> ListNode:
    """
    Remove nth node from end in one pass.
    
    Pattern: Two Pointers with Fixed Gap + Dummy Node
    Time: O(L), Space: O(1) where L = list length
    """
    # Dummy node handles edge case of removing head
    dummy = ListNode(0)
    dummy.next = head
    
    slow = dummy
    fast = dummy
    
    # Move fast n+1 steps ahead
    # (n+1 so slow ends up BEFORE the node to remove)
    for _ in range(n + 1):
        fast = fast.next
    
    # Move both until fast reaches null
    while fast:
        slow = slow.next
        fast = fast.next
    
    # Remove the nth node
    slow.next = slow.next.next
    
    return dummy.next
```

**JavaScript:**

```javascript
function removeNthFromEnd(head, n) {
    const dummy = new ListNode(0);
    dummy.next = head;
    
    let slow = dummy;
    let fast = dummy;
    
    // Move fast n+1 steps ahead
    for (let i = 0; i <= n; i++) {
        fast = fast.next;
    }
    
    // Move both until fast is null
    while (fast) {
        slow = slow.next;
        fast = fast.next;
    }
    
    // Remove the node
    slow.next = slow.next.next;
    
    return dummy.next;
}
```

### Two-Pass Solution (Alternative)

```python
def remove_nth_from_end_two_pass(head: ListNode, n: int) -> ListNode:
    """
    Two-pass solution: count length, then remove.
    Sometimes easier to understand.
    """
    # First pass: count nodes
    length = 0
    current = head
    while current:
        length += 1
        current = current.next
    
    # Special case: remove head
    if n == length:
        return head.next
    
    # Second pass: traverse to (length - n - 1)th node
    current = head
    for _ in range(length - n - 1):
        current = current.next
    
    # Remove the next node
    current.next = current.next.next
    
    return head
```

---

## ‚ö° Complexity Analysis

| Metric | Value | Explanation |
|--------|-------|-------------|
| Time |" O(L) "| L = list length, one pass |
| Space |" O(1) "| Only two pointers + dummy |

**Why one-pass works:**
- Fast pointer travels L nodes
- Slow pointer travels L - n - 1 nodes
- Total traversal: still O(L)

---

## üîÑ Variations

| Variation | Difference | Approach |
|-----------|------------|----------|
| Find (not remove) nth from end | Return node, not delete | Stop at target, don't skip |
| Remove all occurrences | Multiple removals | Traverse full list |
| Kth from end in DLL | Doubly linked | Can start from tail |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting Edge Case of Removing Head

```python
# ‚ùå Without dummy - needs special case
def remove_bad(head, n):
    # What if n == length? We need to remove head!
    # Lots of edge case code needed...

# ‚úÖ With dummy - uniform handling
def remove_good(head, n):
    dummy = ListNode(0)
    dummy.next = head
    # Same code works for all cases!
```

### 2. Off-by-One in Gap Size

```python
# ‚ùå Wrong gap - slow ends up AT the node to remove
for _ in range(n):  # Only n steps
    fast = fast.next
# slow.next.next crashes because we need slow BEFORE target

# ‚úÖ Correct gap - slow ends up BEFORE node to remove
for _ in range(n + 1):  # n+1 steps
    fast = fast.next
# Now slow.next is the node to remove
```

### 3. Not Returning dummy.next

```python
# ‚ùå Wrong - returns original head (might be removed!)
return head

# ‚úÖ Correct - return potentially new head
return dummy.next
```

---

## üìù Practice Problems (Progressive)

### Medium (This problem)
- [ ] [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) - LC 19 ‚≠ê

### Related
- [ ] [Delete the Middle Node of a Linked List](https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/) - LC 2095
- [ ] [Swapping Nodes in a Linked List](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/) - LC 1721
- [ ] [Rotate List](https://leetcode.com/problems/rotate-list/) - LC 61

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement one-pass solution with dummy node
- **Day 3:** Implement two-pass solution, compare clarity
- **Day 7:** Solve without reference, handle edge cases
- **Day 14:** Apply to related problems (LC 61, LC 1721)
- **Day 30:** Review gap calculation (why n+1)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
> "I'll use two pointers with a fixed gap. First, I'll move fast n+1 steps ahead. Then move both until fast is null. Slow will be right before the node to remove."

**Explain dummy node:**
> "I'm using a dummy head to handle the edge case where we remove the first node. This way I don't need special case code."

**Complexity explanation:**
> "Time is O(L) for one pass through the list. Space is O(1) with just two pointers."

**Common follow-ups:**
- "Why n+1 instead of n?" ‚Üí Need to stop BEFORE target node
- "What if n is invalid?" ‚Üí Add check: if fast becomes null during initial move
- "Two-pass solution?" ‚Üí Count length first, then traverse to L-n-1

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | One-pass preferred |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask follow-ups |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Classic question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand | 3-5 min | Gap concept |
| Implement one-pass | 5-10 min | With dummy node |
| Handle edge cases | 2-3 min | Single node, remove head |
| Interview target | 10-15 min | Including explanation |

---

> **üí° Key Insight:** When you need to find position X from the end, create a gap of X between two pointers. When front reaches end, back is at position X from end. For deletion, make the gap X+1 to land on the node BEFORE the target.

---

## üîó Related

- [Find Nth from End](../01-Singly-LL/1.3-Basic-Problems.md) - Finding without removing
- [Two Pointers Pattern](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md) - General technique
- [Intersection of Two Lists](./7.3-Intersection.md) - Similar gap technique
