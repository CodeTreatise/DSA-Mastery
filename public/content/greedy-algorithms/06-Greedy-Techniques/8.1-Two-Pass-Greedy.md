# 8.1 Two-Pass Greedy Technique

> **Definition:** Two-pass greedy processes data in two opposite directions (left-to-right then right-to-left), combining results to satisfy constraints from both sides.

---

## üéØ Pattern Recognition

**When to use Two-Pass Greedy:**

| Signal | Example |
|--------|---------|
| Constraints involve BOTH neighbors | "More than left AND right neighbor" |
| "Before AND after" relationships | "Depends on what comes before and after" |
| One direction isn't enough | Information propagates both ways |
| Merging/combining from both ends | Max of left-view and right-view |

**Keywords:** "neighbors", "both sides", "left and right", "previous and next"

---

## ‚úÖ When to Use

- Candy distribution (neighbors must differ)
- Trapping rain water (walls on both sides)
- Product of array except self (prefix √ó suffix)
- Maximum values from both directions

## ‚ùå When NOT to Use

- Single direction suffices
- No bidirectional dependencies
- Order doesn't matter

---

## üìê The Two-Pass Framework

### General Template

```python
def two_pass_greedy(arr):
    n = len(arr)
    result = [initial_value] * n
    
    # Pass 1: Left to Right
    # Process forward dependencies
    for i in range(1, n):
        # Update result[i] based on result[i-1] and arr[i], arr[i-1]
        result[i] = forward_logic(result[i-1], arr[i], arr[i-1])
    
    # Pass 2: Right to Left  
    # Process backward dependencies, combine with existing
    for i in range(n - 2, -1, -1):
        # Update result[i] considering result[i+1]
        result[i] = combine(result[i], backward_logic(result[i+1], arr[i], arr[i+1]))
    
    return result
```

---

## üíª Classic Examples

### 1. Candy Distribution (LeetCode 135)

```python
def candy(ratings: list[int]) -> int:
    """
    Two-pass: Satisfy left neighbors, then right neighbors.
    """
    n = len(ratings)
    candies = [1] * n
    
    # Pass 1: Left to Right (handle left neighbors)
    for i in range(1, n):
        if ratings[i] > ratings[i - 1]:
            candies[i] = candies[i - 1] + 1
    
    # Pass 2: Right to Left (handle right neighbors)
    for i in range(n - 2, -1, -1):
        if ratings[i] > ratings[i + 1]:
            candies[i] = max(candies[i], candies[i + 1] + 1)
    
    return sum(candies)
```

### 2. Trapping Rain Water (LeetCode 42)

```python
def trap(height: list[int]) -> int:
    """
    Two-pass: Calculate max height from left and right.
    Water at position i = min(left_max, right_max) - height[i]
    """
    n = len(height)
    if n == 0:
        return 0
    
    left_max = [0] * n
    right_max = [0] * n
    
    # Pass 1: Left to Right (max height to the left)
    left_max[0] = height[0]
    for i in range(1, n):
        left_max[i] = max(left_max[i - 1], height[i])
    
    # Pass 2: Right to Left (max height to the right)
    right_max[n - 1] = height[n - 1]
    for i in range(n - 2, -1, -1):
        right_max[i] = max(right_max[i + 1], height[i])
    
    # Calculate water
    water = 0
    for i in range(n):
        water += min(left_max[i], right_max[i]) - height[i]
    
    return water
```

```javascript
function trap(height) {
    const n = height.length;
    if (n === 0) return 0;
    
    const leftMax = new Array(n);
    const rightMax = new Array(n);
    
    // Left to right
    leftMax[0] = height[0];
    for (let i = 1; i < n; i++) {
        leftMax[i] = Math.max(leftMax[i - 1], height[i]);
    }
    
    // Right to left
    rightMax[n - 1] = height[n - 1];
    for (let i = n - 2; i >= 0; i--) {
        rightMax[i] = Math.max(rightMax[i + 1], height[i]);
    }
    
    // Calculate water
    let water = 0;
    for (let i = 0; i < n; i++) {
        water += Math.min(leftMax[i], rightMax[i]) - height[i];
    }
    
    return water;
}
```

### 3. Product of Array Except Self (LeetCode 238)

```python
def productExceptSelf(nums: list[int]) -> list[int]:
    """
    Two-pass: prefix products √ó suffix products.
    """
    n = len(nums)
    result = [1] * n
    
    # Pass 1: Left to Right (prefix products)
    prefix = 1
    for i in range(n):
        result[i] = prefix
        prefix *= nums[i]
    
    # Pass 2: Right to Left (multiply by suffix products)
    suffix = 1
    for i in range(n - 1, -1, -1):
        result[i] *= suffix
        suffix *= nums[i]
    
    return result
```

---

## üìê Visual Explanation

### Candy Example

```
ratings: [1, 3, 2, 2, 1]

=== Pass 1: L‚ÜíR ===
Handle: "If I'm higher than LEFT, I need more"

ratings: 1   3   2   2   1
         ‚Üó
candies: 1   2   ?   ?   ?  (3>1, so 2)

ratings: 1   3   2   2   1
             ‚Üò
candies: 1   2   1   ?   ?  (2<3, reset to 1)

After L‚ÜíR: [1, 2, 1, 1, 1]

=== Pass 2: R‚ÜíL ===
Handle: "If I'm higher than RIGHT, I need more (but keep max)"

ratings: 1   3   2   2   1
                     ‚Üò
                 2>1, so candies[3] = max(1, 1+1) = 2

Wait, ratings[3]=2, ratings[4]=1... 2>1 ‚úì

Let me redo:
i=3: ratings[3]=2 > ratings[4]=1 ‚Üí candies[3] = max(1, 1+1) = 2
i=2: ratings[2]=2 = ratings[3]=2 ‚Üí no change, stays 1
i=1: ratings[1]=3 > ratings[2]=2 ‚Üí candies[1] = max(2, 1+1) = 2 (already 2)
i=0: ratings[0]=1 < ratings[1]=3 ‚Üí no change

After R‚ÜíL: [1, 2, 1, 2, 1]

Sum: 7
```

### Trapping Rain Water Example

```
height: [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]

left_max:  [0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3]
right_max: [3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1]

water at i = min(left, right) - height
i=2: min(1,3) - 0 = 1
i=4: min(2,3) - 1 = 1
i=5: min(2,3) - 0 = 2
i=6: min(2,3) - 1 = 1
i=9: min(3,2) - 1 = 1

Total: 1+1+2+1+1 = 6
```

---

## ‚ö° Complexity Analysis

| Problem | Time | Space | Can Optimize Space? |
|---------|------|-------|---------------------|
| Candy | O(n) | O(n) | O(1) possible (complex) |
| Trapping Rain | O(n) | O(n) | O(1) with two pointers |
| Product Except Self | O(n) | O(1)* | Yes (output doesn't count) |

*Output array doesn't count as extra space per problem statement.

---

## üîÑ Space Optimization: Two Pointers

For some two-pass problems, we can use two pointers instead:

```python
def trap_optimized(height: list[int]) -> int:
    """
    O(1) space using two pointers.
    Key insight: We only need max from the smaller side.
    """
    left, right = 0, len(height) - 1
    left_max = right_max = 0
    water = 0
    
    while left < right:
        if height[left] < height[right]:
            # Left side is limiting factor
            if height[left] >= left_max:
                left_max = height[left]
            else:
                water += left_max - height[left]
            left += 1
        else:
            # Right side is limiting factor
            if height[right] >= right_max:
                right_max = height[right]
            else:
                water += right_max - height[right]
            right -= 1
    
    return water
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Using Max in Second Pass

```python
# ‚ùå Wrong: Overwriting first pass result
candies[i] = candies[i + 1] + 1

# ‚úÖ Correct: Keep the maximum
candies[i] = max(candies[i], candies[i + 1] + 1)
```

### 2. Wrong Loop Direction

```python
# ‚ùå Wrong: Same direction twice
for i in range(n):  # Both forward
    ...
for i in range(n):
    ...

# ‚úÖ Correct: Opposite directions
for i in range(n):       # Forward
    ...
for i in range(n-1, -1, -1):  # Backward
    ...
```

### 3. Off-by-One in Range

```python
# ‚ùå Wrong: Missing first/last element
for i in range(1, n):     # Pass 1 OK
for i in range(n - 2, 0, -1):  # Misses index 0!

# ‚úÖ Correct
for i in range(n - 2, -1, -1):  # Includes index 0
```

---

## üìù Practice Problems

| Problem | Difficulty | Pattern Variant |
|---------|------------|-----------------|
| [Candy](https://leetcode.com/problems/candy/) | Hard | Classic two-pass |
| [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/) | Hard | Max from both sides |
| [Product Except Self](https://leetcode.com/problems/product-of-array-except-self/) | Medium | Prefix √ó Suffix |
| [Best Time Buy Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/) | Hard | Two transactions |
| [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/) | Medium | Kadane + reverse |

---

## üé§ Interview Tips

<details>
<summary><strong>How to Identify and Communicate</strong></summary>

**Recognition phrase:**
"I notice this problem has bidirectional dependencies - each element depends on both what comes before AND after. This suggests a two-pass approach."

**Explanation:**
"In the first pass, I'll process left-to-right to capture forward dependencies. In the second pass, I'll process right-to-left and combine with the first pass results using [max/min/product/etc.]."

**When asked about space optimization:**
"The two-pass approach uses O(n) space, but for some problems like trapping rain water, we can optimize to O(1) using two pointers, since we only need the limiting factor from either side."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Recognize two-pass needed | 2-3 min |
| Implement basic solution | 5-7 min |
| Optimize to O(1) space | 5-8 min |
| **Total** | **12-18 min** |

---

> **üí° Key Insight:** When constraints involve both directions, process each direction separately then combine. The "combine" operation (usually max or min) ensures both constraints are satisfied.

> **üîó Related:** [Candy Problem](../05-Classic-Greedy/7.2-Classic-Practice/Candy.md) | [Interval Greedy](../02-Interval-Pattern/4.1-Interval-Greedy-Overview.md)
