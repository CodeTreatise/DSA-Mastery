# 2.3 - Advanced Binary Search

> **Hard Binary Search Problems**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - Google favorite  
> **Prerequisites:** All previous binary search patterns

---

## Overview

This file covers the most challenging binary search problems that require creative application of the pattern:

1. **Median of Two Sorted Arrays** (LC 4) - The hardest LeetCode problem
2. **Find Kth Smallest in Two Sorted Arrays** - Generalization
3. **Split Array Largest Sum** (alternative approach to LC 410)

These problems combine binary search with other insights.

---

## üéØ Pattern Recognition

<details>
<summary><strong>Identifying Advanced Binary Search Problems</strong></summary>

**Keywords:**
- "Median of sorted arrays"
- "Kth smallest from multiple arrays"
- "Minimize the maximum"
- "Partition arrays"

**Common traits:**
- Multiple sorted arrays
- Need to find a specific position (median, kth)
- O(log n) required, brute force won't pass
- Requires partitioning insight

</details>

---

## Problem 1: Median of Two Sorted Arrays (LC 4)

### ‚úÖ When to Use

- Two sorted arrays, find median
- O(log(m+n)) or O(log(min(m,n))) required
- Can't merge arrays (would be O(m+n))

### ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Arrays fit in memory | Merge and find |" Simpler O(m+n) "|
| Need all elements | Full merge | Binary search finds one position |
| Unsorted arrays | Sort first | Median needs sorted data |

---

### üìê How It Works

**Key Insight:** We need to partition BOTH arrays such that:
- Left partition has (m+n+1)/2 elements
- All elements in left ‚â§ all elements in right

```
nums1: [1, 3 | 8, 9, 15]    partition at index 2
nums2: [7, 11, 18 | 19, 21, 25]   partition at index 3

Left partition: [1, 3, 7, 11, 18]  (5 elements)
Right partition: [8, 9, 15, 19, 21, 25]  (6 elements)

Check: max(left) ‚â§ min(right)?
       max(3, 18) = 18 ‚â§ min(8, 19) = 8?  NO! 18 > 8

Need to adjust partitions...
```

**Binary search on partition position in smaller array:**

```
nums1: [1, 3, 8, 9, 15]       (m=5)
nums2: [7, 11, 18, 19, 21, 25] (n=6)

Total = 11, need (11+1)/2 = 6 elements on left

Binary search on nums1's partition:
- If partition1 = 2: left from nums1 = [1, 3], need 4 from nums2
- partition2 = 6 - 2 = 4: left from nums2 = [7, 11, 18, 19]

Check valid:
- nums1[1] = 3 ‚â§ nums2[4] = 21? YES
- nums2[3] = 19 ‚â§ nums1[2] = 8? NO! 19 > 8

Partition1 is too small, need more from nums1
```

### Visualization

```
Goal: Split both arrays so left half ‚â§ right half

nums1: [ ... left1 ... | ... right1 ... ]
nums2: [ ... left2 ... | ... right2 ... ]

Valid partition when:
  max(left1, left2) ‚â§ min(right1, right2)

          L1      R1
nums1:  [1, 3] | [8, 9, 15]
nums2: [7, 11] | [18, 19, 21, 25]
          L2      R2

Check: max(3, 11) ‚â§ min(8, 18)
       11 ‚â§ 8?  NO ‚Üí Move partition1 right

nums1: [1, 3, 8] | [9, 15]
nums2:       [7] | [11, 18, 19, 21, 25]

Check: max(8, 7) ‚â§ min(9, 11)
       8 ‚â§ 9?  YES! Valid partition.

Median = (max(8, 7) + min(9, 11)) / 2 = (8 + 9) / 2 = 8.5
```

---

### üíª Code Implementation

**Python:**
```python
def find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:
    """
    Find median of two sorted arrays.
    
    Approach: Binary search on partition position.
    
    Time: O(log(min(m, n))), Space: O(1)
    """
    # Ensure nums1 is the smaller array
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    
    m, n = len(nums1), len(nums2)
    total = m + n
    half = (total + 1) // 2  # Elements needed in left partition
    
    left, right = 0, m
    
    while left <= right:
        partition1 = (left + right) // 2  # Elements from nums1 in left
        partition2 = half - partition1     # Elements from nums2 in left
        
        # Edge values (use inf/-inf for out of bounds)
        left1 = nums1[partition1 - 1] if partition1 > 0 else float('-inf')
        right1 = nums1[partition1] if partition1 < m else float('inf')
        left2 = nums2[partition2 - 1] if partition2 > 0 else float('-inf')
        right2 = nums2[partition2] if partition2 < n else float('inf')
        
        # Check if valid partition
        if left1 <= right2 and left2 <= right1:
            # Found valid partition
            if total % 2 == 1:
                # Odd total: median is max of left partition
                return max(left1, left2)
            else:
                # Even total: average of max(left) and min(right)
                return (max(left1, left2) + min(right1, right2)) / 2
        elif left1 > right2:
            # Too many elements from nums1, reduce partition1
            right = partition1 - 1
        else:
            # Too few elements from nums1, increase partition1
            left = partition1 + 1
    
    return 0.0  # Should never reach here


# Examples
print(find_median_sorted_arrays([1, 3], [2]))       # 2.0
print(find_median_sorted_arrays([1, 2], [3, 4]))    # 2.5
print(find_median_sorted_arrays([0, 0], [0, 0]))    # 0.0
print(find_median_sorted_arrays([], [1]))           # 1.0
```

**JavaScript:**
```javascript
function findMedianSortedArrays(nums1, nums2) {
    // Ensure nums1 is smaller
    if (nums1.length > nums2.length) {
        [nums1, nums2] = [nums2, nums1];
    }
    
    const m = nums1.length;
    const n = nums2.length;
    const total = m + n;
    const half = Math.floor((total + 1) / 2);
    
    let left = 0;
    let right = m;
    
    while (left <= right) {
        const partition1 = Math.floor((left + right) / 2);
        const partition2 = half - partition1;
        
        const left1 = partition1 > 0 ? nums1[partition1 - 1] : -Infinity;
        const right1 = partition1 < m ? nums1[partition1] : Infinity;
        const left2 = partition2 > 0 ? nums2[partition2 - 1] : -Infinity;
        const right2 = partition2 < n ? nums2[partition2] : Infinity;
        
        if (left1 <= right2 && left2 <= right1) {
            if (total % 2 === 1) {
                return Math.max(left1, left2);
            } else {
                return (Math.max(left1, left2) + Math.min(right1, right2)) / 2;
            }
        } else if (left1 > right2) {
            right = partition1 - 1;
        } else {
            left = partition1 + 1;
        }
    }
    
    return 0;
}

// Examples
console.log(findMedianSortedArrays([1, 3], [2]));     // 2.0
console.log(findMedianSortedArrays([1, 2], [3, 4]));  // 2.5
```

---

## Problem 2: Find Kth Element in Two Sorted Arrays

Generalization of the median problem.

```python
def find_kth_element(nums1: list[int], nums2: list[int], k: int) -> int:
    """
    Find the kth smallest element in two sorted arrays.
    
    Approach: Eliminate k/2 elements at each step.
    
    Time: O(log(k)), Space: O(log k) for recursion
    """
    m, n = len(nums1), len(nums2)
    
    # Ensure nums1 is not longer than nums2
    if m > n:
        return find_kth_element(nums2, nums1, k)
    
    # Base cases
    if m == 0:
        return nums2[k - 1]
    if k == 1:
        return min(nums1[0], nums2[0])
    
    # Compare k/2-th elements
    i = min(m, k // 2)
    j = min(n, k // 2)
    
    if nums1[i - 1] < nums2[j - 1]:
        # Discard first i elements of nums1
        return find_kth_element(nums1[i:], nums2, k - i)
    else:
        # Discard first j elements of nums2
        return find_kth_element(nums1, nums2[j:], k - j)


# Examples
print(find_kth_element([1, 3, 5], [2, 4, 6], 4))  # 4
print(find_kth_element([1, 2], [3, 4, 5, 6], 3))  # 3
```

---

## Problem 3: Aggressive Cows / Magnetic Force Between Two Balls (LC 1552)

Binary search on answer: maximize minimum distance.

```python
def max_distance(positions: list[int], m: int) -> int:
    """
    Place m balls to maximize minimum distance between any two.
    
    Approach: Binary search on the minimum distance.
    
    Time: O(n log(max - min)), Space: O(1)
    """
    positions.sort()
    
    def can_place(min_dist: int) -> bool:
        """Check if we can place m balls with at least min_dist apart."""
        count = 1
        last_pos = positions[0]
        
        for pos in positions[1:]:
            if pos - last_pos >= min_dist:
                count += 1
                last_pos = pos
                if count == m:
                    return True
        
        return count >= m
    
    # Binary search on minimum distance
    lo = 1  # Minimum possible distance
    hi = positions[-1] - positions[0]  # Maximum possible distance
    result = 1
    
    while lo <= hi:
        mid = lo + (hi - lo) // 2
        
        if can_place(mid):
            result = mid  # This distance works, try larger
            lo = mid + 1
        else:
            hi = mid - 1  # Too large, try smaller
    
    return result


# Example
print(max_distance([1, 2, 3, 4, 7], 3))  # 3 (place at 1, 4, 7)
print(max_distance([5, 4, 3, 2, 1, 1000000000], 2))  # 999999999
```

---

## ‚ö° Complexity Analysis

| Problem | Time | Space | Notes |
|---------|------|-------|-------|
| Median of Two Arrays |" O(log min(m,n)) "| O(1) | Binary search on smaller |
| Kth Element |" O(log k) "| O(log k) | Recursive elimination |
| Aggressive Cows |" O(n log n + n log D) "| O(1) | Sort + binary search |

**Why O(log min(m,n)) for median?**
- Binary search on partition position
- Only search in smaller array (swap if needed)
- Each iteration halves the search space

---

## üîÑ Variations

| Problem | Key Insight | LeetCode |
|---------|-------------|----------|
| Median of Two Arrays | Partition both arrays | LC 4 |
| Kth Smallest in Sorted Arrays | Eliminate k/2 at a time | Practice |
| Aggressive Cows / Magnetic Force | Maximize minimum | LC 1552 |
| Find Duplicate Number | Cycle detection or binary search | LC 287 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Median: Wrong Partition Calculation

‚ùå **Wrong:**
```python
partition2 = half - partition1 - 1  # Off by one
```

‚úÖ **Correct:**
```python
partition2 = half - partition1  # Exact complement
```

### 2. Median: Not Handling Edge Cases

‚ùå **Wrong:**
```python
left1 = nums1[partition1 - 1]  # IndexError when partition1 = 0
```

‚úÖ **Correct:**
```python
left1 = nums1[partition1 - 1] if partition1 > 0 else float('-inf')
```

### 3. Median: Not Ensuring Smaller Array First

‚ùå **Wrong:**
```python
def find_median(nums1, nums2):
    m, n = len(nums1), len(nums2)
    # If nums1 is larger, partition2 might go negative!
```

‚úÖ **Correct:**
```python
def find_median(nums1, nums2):
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1  # Swap!
```

### 4. Aggressive Cows: Wrong Binary Search Direction

‚ùå **Wrong:**
```python
if can_place(mid):
    hi = mid - 1  # Wrong! We want to maximize
```

‚úÖ **Correct:**
```python
if can_place(mid):
    result = mid
    lo = mid + 1  # Try for larger distance
```

---

## üìù Practice Problems

### Hard

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Median of Two Sorted Arrays | Partition insight | [LC 4](https://leetcode.com/problems/median-of-two-sorted-arrays/) |
| Find K-th Smallest Pair Distance | Binary search + count | [LC 719](https://leetcode.com/problems/find-k-th-smallest-pair-distance/) |
| Magnetic Force Between Two Balls | Maximize minimum | [LC 1552](https://leetcode.com/problems/magnetic-force-between-two-balls/) |
| Split Array Largest Sum | Minimize maximum | [LC 410](https://leetcode.com/problems/split-array-largest-sum/) |
| Kth Smallest Number in Multiplication Table | Binary search | [LC 668](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: Understand median partition concept with diagrams
- Day 3: Implement LC 4 from scratch (expect struggles)
- Day 5: Redo LC 4, understand edge cases

**Week 2:**
- Day 8: LC 1552 Magnetic Force
- Day 10: LC 410 Split Array (if not done in Search on Answer)
- Day 14: Review all, explain partition to someone

**Key insight to remember:**
"Binary search on partition position. Valid when max(left) ‚â§ min(right)."

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**For Median of Two Arrays:**

> "This is one of the hardest LeetCode problems. The key insight is to binary search on the partition position, not on values."

> "I need to partition both arrays such that all elements in the left partition are ‚â§ all elements in the right partition. The number of elements in the left partition is (m+n+1)/2."

> "I'll binary search on where to partition the smaller array. The partition for the larger array is determined by the first choice."

**What to draw:**
```
nums1: [....left1....] | [...right1...]
nums2: [....left2....] | [...right2...]

Valid when: max(left1, left2) ‚â§ min(right1, right2)
```

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Classic hard |
| Amazon | ‚≠ê‚≠ê‚≠ê | Occasionally |
| Meta | ‚≠ê‚≠ê‚≠ê | Less frequent |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand median partition | 45-60 min | Critical concept |
| First LC 4 attempt | 60-90 min | Expect struggles |
| Master LC 4 | 2-3 attempts | Over multiple days |
| LC 1552 Magnetic Force | 30-40 min | If search-on-answer is solid |
| Full mastery | 1-2 weeks | Review periodically |

---

## üí° Key Insight

> **Median of Two Sorted Arrays:**
>
> Don't merge arrays. Binary search on the PARTITION POSITION.
>
> If partition1 elements from nums1 are in the left half, then
> partition2 = half - partition1 elements from nums2 are needed.
>
> Valid partition: max(left1, left2) ‚â§ min(right1, right2)
>
> This is the hardest binary search problem. Master the simpler patterns first!

---

## üîó Related

- [Binary Search Basics](./2.1-Binary-Search-Basics.md) - Foundation
- [Search on Answer](./2.2-Binary-Search-Patterns/04-Search-On-Answer.md) - Optimization pattern
- [Boundary Search](./2.2-Binary-Search-Patterns/02-Boundary-Search.md) - Finding positions
