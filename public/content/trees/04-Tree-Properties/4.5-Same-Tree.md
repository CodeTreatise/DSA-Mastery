# 4.5 - Same Tree (LC 100)

> **Grokking Pattern:** #11 Tree DFS (Comparison Pattern)
>
> **Difficulty:** Easy | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê Common

---

## Problem Statement

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are **structurally identical**, and the nodes have the **same value**.

```
Input: p = [1,2,3], q = [1,2,3]
    1         1
   / \       / \
  2   3     2   3

Output: true
```

```
Input: p = [1,2], q = [1,null,2]
    1         1
   /           \
  2             2

Output: false (different structure)
```

[LeetCode 100 - Same Tree](https://leetcode.com/problems/same-tree/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Are two trees identical?"
- Compare structure AND values
- "Subtree" problems often use this

**Key insight:**
Two trees are the same if:
1. Both roots are null ‚Üí true
2. One null, one not ‚Üí false
3. Values differ ‚Üí false
4. Recursively: left subtrees same AND right subtrees same

</details>

---

## ‚úÖ When to Use

- Comparing two trees for equality
- As helper function for subtree problems
- Testing tree copy correctness

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Check if mirror | Different comparison | Symmetric Tree |
| Find subtree | Need search + compare | Subtree of Another Tree |
| Compare with transformations | More complex | Custom comparison |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [DFS Concept](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
- Basic recursion

**After mastering this:**
- [Symmetric Tree](./4.6-Symmetric-Tree.md) - Compare left/right mirrored
- [Subtree of Another Tree](../../related/subtree.md) - Uses Same Tree as helper

**Related:**
- This is a fundamental building block for many tree comparisons

</details>

---

## üìê How It Works

### Decision Tree

```
isSameTree(p, q):
‚îÇ
‚îú‚îÄ‚îÄ Both null? ‚Üí return true
‚îÇ
‚îú‚îÄ‚îÄ One null? ‚Üí return false
‚îÇ
‚îú‚îÄ‚îÄ Values differ? ‚Üí return false
‚îÇ
‚îî‚îÄ‚îÄ Both exist with same value:
    ‚îî‚îÄ‚îÄ return isSameTree(p.left, q.left) 
        AND isSameTree(p.right, q.right)
```

### Visualization

```
Compare:
    1           1
   / \         / \
  2   3       2   3

Step 1: p=1, q=1 ‚Üí values match, check children
Step 2: p.left=2, q.left=2 ‚Üí values match, check children
Step 3: p.left.left=null, q.left.left=null ‚Üí both null, true
Step 4: p.left.right=null, q.left.right=null ‚Üí both null, true
Step 5: p.right=3, q.right=3 ‚Üí values match, check children
Step 6: p.right.left=null, q.right.left=null ‚Üí both null, true
Step 7: p.right.right=null, q.right.right=null ‚Üí both null, true

All checks passed ‚Üí true
```

---

## üíª Code Implementation

### Solution 1: Recursive DFS

**Python:**
```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def is_same_tree(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
    """
    Check if two trees are identical.
    
    Time: O(n), Space: O(h)
    """
    # Both null ‚Üí same
    if not p and not q:
        return True
    
    # One null, one not ‚Üí different
    if not p or not q:
        return False
    
    # Values must match AND subtrees must match
    return (p.val == q.val and 
            is_same_tree(p.left, q.left) and 
            is_same_tree(p.right, q.right))
```

**JavaScript:**
```javascript
function isSameTree(p, q) {
    // Both null
    if (!p && !q) return true;
    
    // One null
    if (!p || !q) return false;
    
    // Compare values and recurse
    return p.val === q.val && 
           isSameTree(p.left, q.left) && 
           isSameTree(p.right, q.right);
}
```

### Solution 2: Iterative with Stack

**Python:**
```python
def is_same_tree_iterative(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
    """
    Iterative comparison using stack.
    
    Time: O(n), Space: O(n)
    """
    stack = [(p, q)]
    
    while stack:
        node1, node2 = stack.pop()
        
        # Both null ‚Üí continue
        if not node1 and not node2:
            continue
        
        # One null or values differ
        if not node1 or not node2 or node1.val != node2.val:
            return False
        
        # Add children pairs to stack
        stack.append((node1.left, node2.left))
        stack.append((node1.right, node2.right))
    
    return True
```

**JavaScript:**
```javascript
function isSameTreeIterative(p, q) {
    const stack = [[p, q]];
    
    while (stack.length > 0) {
        const [node1, node2] = stack.pop();
        
        if (!node1 && !node2) continue;
        if (!node1 || !node2 || node1.val !== node2.val) {
            return false;
        }
        
        stack.push([node1.left, node2.left]);
        stack.push([node1.right, node2.right]);
    }
    
    return true;
}
```

### Solution 3: BFS with Queue

**Python:**
```python
from collections import deque

def is_same_tree_bfs(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
    """
    BFS comparison using queue.
    
    Time: O(n), Space: O(w)
    """
    queue = deque([(p, q)])
    
    while queue:
        node1, node2 = queue.popleft()
        
        if not node1 and not node2:
            continue
        
        if not node1 or not node2 or node1.val != node2.val:
            return False
        
        queue.append((node1.left, node2.left))
        queue.append((node1.right, node2.right))
    
    return True
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Recursive |" O(n) "| O(h) | h = min height |
| Iterative |" O(n) "| O(n) | Stack size |
| BFS |" O(n) "| O(w) | Queue width |

**Note:** n is the smaller of the two trees' sizes. We stop early if mismatch found.

---

## üîÑ Variations

| Variation | Difference | LeetCode |
|-----------|------------|----------|
| Symmetric Tree | Compare p.left with p.right mirrored | LC 101 |
| Subtree of Another | Check if one tree contains the other | LC 572 |
| Leaf-Similar Trees | Only compare leaf sequences | LC 872 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Order of Null Checks

```python
# ‚ùå WRONG: Crashes if p is None
def is_same(p, q):
    if p.val != q.val:  # NoneType has no attribute 'val'
        return False
    if not p and not q:
        return True

# ‚úÖ CORRECT: Check null first
def is_same(p, q):
    if not p and not q:
        return True
    if not p or not q:
        return False
    if p.val != q.val:
        return False
```

### 2. Forgetting to Compare Both Subtrees

```python
# ‚ùå WRONG: Only checking left subtree
def is_same(p, q):
    if not p and not q:
        return True
    if not p or not q:
        return False
    return p.val == q.val and is_same(p.left, q.left)
    # Missing right subtree check!

# ‚úÖ CORRECT: Check both
return p.val == q.val and is_same(p.left, q.left) and is_same(p.right, q.right)
```

### 3. Using `==` on TreeNode Objects

```python
# ‚ùå WRONG: Object comparison, not value
return p == q  # This compares object references!

# ‚úÖ CORRECT: Compare values and structure
return p.val == q.val and is_same(p.left, q.left) and is_same(p.right, q.right)
```

---

## üìù Practice Problems

### This Problem
- [ ] [Same Tree](https://leetcode.com/problems/same-tree/) - LC 100

### Use Same Tree as Helper
- [ ] [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/) - LC 101
- [ ] [Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/) - LC 572
- [ ] [Leaf-Similar Trees](https://leetcode.com/problems/leaf-similar-trees/) - LC 872

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement recursive solution
**Day 3:** Implement iterative (both DFS and BFS)
**Day 7:** Solve Symmetric Tree (modified comparison)
**Day 14:** Solve Subtree of Another Tree (uses Same Tree)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Explaining approach:**
> "Two trees are the same if both are null, or if they have the same value and their left and right subtrees are respectively the same. I'll check this recursively."

**Handling edge cases:**
> "I'll handle null cases first: both null means true, one null means false. Then I compare values and recurse on children."

**Follow-up - Subtree:**
> "For the subtree problem, I'd use this as a helper function. For each node in the main tree, check if the subtree starting there equals the given subtree."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Often paired with Symmetric |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask iterative version |
| Google | ‚≠ê‚≠ê‚≠ê | Used as helper for harder problems |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Classic warm-up |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Recursive solution | 3-5 min | Very straightforward |
| Iterative solution | 5-7 min | If asked |
| Explain edge cases | 2 min | Null handling |

---

> **üí° Key Insight:** Same Tree is a fundamental building block. The pattern of checking "both null ‚Üí true, one null ‚Üí false, then compare values and recurse" appears in many tree comparison problems. Master this pattern once, apply it everywhere.

---

## üîó Related

- [Symmetric Tree](./4.6-Symmetric-Tree.md)
- [Subtree of Another Tree](../../related/subtree.md)
- [DFS Concept](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
