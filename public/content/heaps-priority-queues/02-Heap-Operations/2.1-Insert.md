# 2.1 Insert (Push) Operation

## Definition

**Insert (Push)** adds a new element to the heap while maintaining both the **complete tree structure** and the **heap property**.

```
Algorithm:
1. Add element at the END of the array (maintains completeness)
2. BUBBLE UP: Compare with parent, swap if property violated
3. Repeat until property restored or reach root

Insert 2 into Max-Heap:

Before:      After add:     After bubble up:
   10            10               10
  /  \          /  \             /  \
 7    8   ‚Üí    7    8      ‚Üí    7    8
/ \           / \  /           / \  /
3  5         3  5 2           3  5 2

Add at end    Compare 2<8?    2<8, stop
(index 5)     Yes, done!      (property satisfied)
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>When Insert Is Used</strong></summary>

**Common scenarios:**
- Building a heap incrementally
- Priority queue: adding new tasks
- Streaming data: maintaining K elements
- Scheduling: adding new jobs

**Key insight:**
```
Insert adds at the END ‚Üí O(1) for placement
Then fixes heap property ‚Üí O(log n) worst case
Total: O(log n)
```

</details>

---

## ‚úÖ When to Use

| Scenario | Why Insert? |
|----------|-------------|
| Build heap one element at a time | Incremental approach |
| Add to existing heap | Maintain structure |
| Priority queue enqueue | Standard operation |
| Top K with stream | Add new elements |

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|---------------------|
| Build heap from array |" Use heapify O(n) "|
| Need to insert at specific position | Wrong data structure |
| Bulk insert many elements | Heapify is faster |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Array Representation](../01-Heap-Fundamentals/1.4-Array-Representation.md)
- [Heap Property](../01-Heap-Fundamentals/1.2-Heap-Property.md)
- Parent/child index formulas

**After mastering this:**
- [Extract Operation](./2.2-Extract.md)
- [Heapify](./2.4-Heapify.md)
- [Priority Queue](../03-Priority-Queue/3.1-PQ-Basics.md)

**Related:**
- Bubble up (sift up, percolate up)
- Heap sort insertion phase

</details>

---

## üìê How It Works

### Step-by-Step Algorithm

```
INSERT(heap, value):
    1. Append value to end of heap array
    2. Set i = last index (new element position)
    3. BUBBLE_UP(heap, i)

BUBBLE_UP(heap, i):
    While i > 0:
        parent = (i - 1) // 2
        If heap[parent] vs heap[i] violates property:
            Swap heap[parent] and heap[i]
            i = parent
        Else:
            Break  // Property satisfied
```

### Visual Example: Insert into Min-Heap

```
Insert 1 into min-heap [3, 5, 4, 7, 8]:

Initial heap:           Tree view:
[3, 5, 4, 7, 8]              3
                            / \
                           5   4
                          / \
                         7   8

Step 1: Append 1 at end
[3, 5, 4, 7, 8, 1]           3
                            / \
                           5   4
                          /\  /
                         7 8 1   ‚Üê New position (index 5)

Step 2: Bubble up
Compare with parent (index 2, value 4):
  1 < 4 ‚Üí Swap!
[3, 5, 1, 7, 8, 4]           3
                            / \
                           5   1   ‚Üê Swapped
                          /\  /
                         7 8 4

Compare with parent (index 0, value 3):
  1 < 3 ‚Üí Swap!
[1, 5, 3, 7, 8, 4]           1     ‚Üê Now root
                            / \
                           5   3
                          /\  /
                         7 8 4

No more parent, done!
```

### Bubble Up Path

```
Bubble up follows path from inserted position to root:

         0            Path length = height of tree
        / \                       = O(log n)
       1   2
      /\   /\
     3 4  5 6
    ...

Insert at index 6:
  Path: 6 ‚Üí 2 ‚Üí 0 (at most 3 steps for 7 elements)
```

---

## üíª Code Implementation

### Min-Heap Insert

**Python:**
```python
import heapq

def insert_min_heap(heap: list[int], value: int) -> None:
    """
    Insert value into min-heap.
    Uses Python's heapq which is a min-heap.
    
    Time: O(log n)
    Space: O(1)
    """
    heapq.heappush(heap, value)


# Manual implementation for understanding:
def insert_min_heap_manual(heap: list[int], value: int) -> None:
    """
    Manual insert with bubble up.
    """
    # Step 1: Add at end
    heap.append(value)
    
    # Step 2: Bubble up
    i = len(heap) - 1
    while i > 0:
        parent = (i - 1) // 2
        if heap[parent] > heap[i]:  # Min-heap: parent should be smaller
            heap[parent], heap[i] = heap[i], heap[parent]
            i = parent
        else:
            break  # Property satisfied


# Example:
heap = [1, 3, 2, 7, 4]
insert_min_heap_manual(heap, 0)
print(heap)  # [0, 3, 1, 7, 4, 2]  ‚Üê 0 bubbled to root
```

**JavaScript:**
```javascript
function insertMinHeap(heap, value) {
    // Step 1: Add at end
    heap.push(value);
    
    // Step 2: Bubble up
    let i = heap.length - 1;
    while (i > 0) {
        const parent = Math.floor((i - 1) / 2);
        if (heap[parent] > heap[i]) {
            [heap[parent], heap[i]] = [heap[i], heap[parent]];
            i = parent;
        } else {
            break;
        }
    }
}

// Example:
const heap = [1, 3, 2, 7, 4];
insertMinHeap(heap, 0);
console.log(heap);  // [0, 3, 1, 7, 4, 2]
```

### Max-Heap Insert

**Python:**
```python
def insert_max_heap(heap: list[int], value: int) -> None:
    """
    Insert into max-heap.
    Python heapq is min-heap, so we negate values.
    
    Time: O(log n)
    """
    heapq.heappush(heap, -value)


def insert_max_heap_manual(heap: list[int], value: int) -> None:
    """Manual max-heap insert."""
    heap.append(value)
    
    i = len(heap) - 1
    while i > 0:
        parent = (i - 1) // 2
        if heap[parent] < heap[i]:  # Max-heap: parent should be larger
            heap[parent], heap[i] = heap[i], heap[parent]
            i = parent
        else:
            break


# Example:
heap = [10, 7, 8, 3, 5]
insert_max_heap_manual(heap, 15)
print(heap)  # [15, 7, 10, 3, 5, 8]  ‚Üê 15 bubbled to root
```

**JavaScript:**
```javascript
function insertMaxHeap(heap, value) {
    heap.push(value);
    
    let i = heap.length - 1;
    while (i > 0) {
        const parent = Math.floor((i - 1) / 2);
        if (heap[parent] < heap[i]) {  // Parent should be larger
            [heap[parent], heap[i]] = [heap[i], heap[parent]];
            i = parent;
        } else {
            break;
        }
    }
}
```

### Insert with Custom Comparison

**Python:**
```python
import heapq

def insert_with_priority(heap: list, item: any, priority: int) -> None:
    """
    Insert item with given priority.
    Use negative priority for max-heap behavior.
    
    Tuple comparison: (priority, tiebreaker, item)
    """
    heapq.heappush(heap, (priority, id(item), item))


# Example: Task scheduling
tasks = []
insert_with_priority(tasks, "Low priority task", 3)
insert_with_priority(tasks, "High priority task", 1)
insert_with_priority(tasks, "Medium task", 2)

while tasks:
    priority, _, task = heapq.heappop(tasks)
    print(f"Priority {priority}: {task}")

# Output:
# Priority 1: High priority task
# Priority 2: Medium task
# Priority 3: Low priority task
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Best |" O(1) "| O(1) | Element belongs at leaf |
| Average |" O(log n) "| O(1) | Half-height on average |
| Worst |" O(log n) "| O(1) | Bubbles to root |

**Why O(log n)?**
```
Bubble up path = root to inserted position
Maximum path length = height of tree
Height of complete tree with n nodes = ‚åälog‚ÇÇ(n)‚åã

Example: n = 1,000,000
Height = ‚åälog‚ÇÇ(1,000,000)‚åã = 19 comparisons max
```

---

## üîÑ Variations

| Variation | Difference | Use Case |
|-----------|------------|----------|
| **heappush** | Python's built-in | Most common |
| **heappushpop** | Push then pop | Efficient for bounded heaps |
| **Batch insert** | Insert multiple | Consider heapify instead |
| **Insert with priority** | Tuple (priority, value) | Priority queue |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Comparison for Heap Type

```python
# ‚ùå Wrong: Using min-heap comparison for max-heap
while i > 0:
    parent = (i - 1) // 2
    if heap[parent] > heap[i]:  # This is for MIN-heap!
        swap...

# ‚úÖ Correct: For MAX-heap, parent should be larger
while i > 0:
    parent = (i - 1) // 2
    if heap[parent] < heap[i]:  # MAX-heap comparison
        swap...
```

### 2. Off-by-One in Index Calculation

```python
# ‚ùå Wrong: 1-indexed formula with 0-indexed array
parent = i // 2  # Wrong for 0-indexed!

# ‚úÖ Correct: 0-indexed formula
parent = (i - 1) // 2
```

### 3. Forgetting to Update Index After Swap

```python
# ‚ùå Wrong: Not moving to parent position
while i > 0:
    parent = (i - 1) // 2
    if heap[parent] > heap[i]:
        heap[parent], heap[i] = heap[i], heap[parent]
        # Missing: i = parent

# ‚úÖ Correct: Update i to continue bubbling
while i > 0:
    parent = (i - 1) // 2
    if heap[parent] > heap[i]:
        heap[parent], heap[i] = heap[i], heap[parent]
        i = parent  # Move up the tree
    else:
        break
```

### 4. Not Breaking When Property Satisfied

```python
# ‚ùå Wrong: Always going to root (wastes time)
while i > 0:
    parent = (i - 1) // 2
    if heap[parent] > heap[i]:
        heap[parent], heap[i] = heap[i], heap[parent]
    i = parent  # Continues even when not needed!

# ‚úÖ Correct: Break when property satisfied
while i > 0:
    parent = (i - 1) // 2
    if heap[parent] > heap[i]:
        heap[parent], heap[i] = heap[i], heap[parent]
        i = parent
    else:
        break  # Stop early if no violation
```

---

## üìù Practice Problems (Progressive)

### Easy (Understand insert)
- [ ] Implement min-heap insert from scratch
- [ ] Implement max-heap insert from scratch
- [ ] [Last Stone Weight (LC 1046)](https://leetcode.com/problems/last-stone-weight/)

### Medium (Apply insert)
- [ ] [Kth Largest in Stream (LC 703)](https://leetcode.com/problems/kth-largest-element-in-a-stream/)
- [ ] [Top K Frequent Elements (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/)

### Hard (Master insert)
- [ ] [Find Median from Stream (LC 295)](https://leetcode.com/problems/find-median-from-data-stream/)
- [ ] [Merge K Sorted Lists (LC 23)](https://leetcode.com/problems/merge-k-sorted-lists/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement insert for min-heap
- **Day 3:** Implement insert for max-heap
- **Day 7:** Trace through insert with example
- **Day 14:** Solve LC 703 using insert
- **Day 30:** Explain time complexity derivation

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Explain This in Interviews</strong></summary>

**Describing the operation:**
"Insert adds the new element at the end of the array to maintain the complete tree property. Then it bubbles up - comparing with parent and swapping if the heap property is violated - until the property is restored."

**Complexity explanation:**
"It's O(log n) because we only traverse from the insertion point to the root, which is at most the tree height. For a complete binary tree, height is log n."

**When asked about alternatives:**
"For a single insert, O(log n) is optimal. But if I need to build a heap from scratch, heapify in O(n) is better than n inserts at O(n log n)."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 10-15 min | Draw examples |
| Implement from scratch | 15-20 min | Bubble up logic |
| Debug off-by-one | 5-10 min | Common issue |
| Solve LC 703 | 20-25 min | Apply insert |

---

## üí° Key Insight

> **Insert adds at the end (O(1)) then fixes upward (O(log n)).** The key is that adding at the end preserves the complete tree structure, and we only need to fix the single path from the new position to the root. This path has at most log n nodes, so the total operation is O(log n).

---

## üîó Related

- **Previous:** [Array Representation](../01-Heap-Fundamentals/1.4-Array-Representation.md)
- **Next:** [Extract Operation](./2.2-Extract.md)
- **Related:** [Heapify](./2.4-Heapify.md) | [Priority Queue](../03-Priority-Queue/3.1-PQ-Basics.md)
