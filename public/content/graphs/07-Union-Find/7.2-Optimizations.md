# 7.2 Union-Find Optimizations

> **Path Compression + Union by Rank = Nearly O(1) operations**
>
> üéØ **Impact:** Transforms O(n) operations to O(Œ±(n)) ‚âà O(1) amortized

---

## Overview

The basic Union-Find has O(n) worst-case operations. Two optimizations make it nearly constant time:

1. **Path Compression**: Flatten the tree during Find
2. **Union by Rank/Size**: Attach smaller tree under larger tree

Together, they achieve **O(Œ±(n))** time per operation, where Œ± is the **inverse Ackermann function** - effectively constant for all practical inputs.

---

## üìê Optimization 1: Path Compression

### The Problem

Without optimization, trees can become long chains:
```
0 ‚Üê 1 ‚Üê 2 ‚Üê 3 ‚Üê 4
Find(4) = 4 hops
```

### The Solution

During Find, make every node point directly to the root:
```
After Find(4):
    0
  / | \ \
 1  2  3  4
Find(4) = 1 hop (next time)
```

### Implementation

```python
def find(self, x: int) -> int:
    """Find with path compression."""
    if self.parent[x] != x:
        self.parent[x] = self.find(self.parent[x])  # Recursively compress
    return self.parent[x]
```

**Iterative version (avoids stack overflow):**
```python
def find(self, x: int) -> int:
    """Iterative path compression."""
    root = x
    # First, find the root
    while self.parent[root] != root:
        root = self.parent[root]
    # Then, compress the path
    while self.parent[x] != root:
        next_x = self.parent[x]
        self.parent[x] = root
        x = next_x
    return root
```

---

## üìê Optimization 2: Union by Rank

### The Problem

Always attaching tree B under tree A can create tall trees:
```
Union(0,1), Union(0,2), Union(0,3)...
Results in: 0 ‚Üê 1 ‚Üê 2 ‚Üê 3 ‚Üê 4...
```

### The Solution

Track tree "rank" (approximate height). Attach the shorter tree under the taller tree:
```
Rank 2:    0          Rank 1:  5
          / \                   |
         1   2                  6
         |
         3

Union(3, 6): Attach rank-1 tree under rank-2 tree
Result:
          0
         /|\
        1 2 5
        |   |
        3   6
```

### Implementation

```python
class UnionFind:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.rank = [0] * n  # Approximate height of tree
        self.count = n
    
    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x: int, y: int) -> bool:
        root_x, root_y = self.find(x), self.find(y)
        
        if root_x == root_y:
            return False
        
        # Union by rank: attach smaller tree under larger
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            # Same rank: pick one, increment its rank
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
        
        self.count -= 1
        return True
```

---

## üìê Alternative: Union by Size

Instead of rank (height), track actual set size:

```python
class UnionFindBySize:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.size = [1] * n  # Size of each set
        self.count = n
    
    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x: int, y: int) -> bool:
        root_x, root_y = self.find(x), self.find(y)
        
        if root_x == root_y:
            return False
        
        # Union by size: attach smaller tree under larger
        if self.size[root_x] < self.size[root_y]:
            self.parent[root_x] = root_y
            self.size[root_y] += self.size[root_x]
        else:
            self.parent[root_y] = root_x
            self.size[root_x] += self.size[root_y]
        
        self.count -= 1
        return True
    
    def get_size(self, x: int) -> int:
        """Return size of the set containing x."""
        return self.size[self.find(x)]
```

---

## üíª Complete Optimized Implementation

**Python:**
```python
from typing import List

class UnionFind:
    """
    Optimized Union-Find with path compression and union by rank.
    
    Time: O(Œ±(n)) per operation ‚âà O(1) amortized
    Space: O(n)
    """
    
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.count = n
    
    def find(self, x: int) -> int:
        """Find with path compression."""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x: int, y: int) -> bool:
        """Union by rank."""
        root_x, root_y = self.find(x), self.find(y)
        
        if root_x == root_y:
            return False
        
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
        
        self.count -= 1
        return True
    
    def connected(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)


# Example: Number of connected components after adding edges
def count_components(n: int, edges: List[List[int]]) -> int:
    uf = UnionFind(n)
    for u, v in edges:
        uf.union(u, v)
    return uf.count


# Example: Find redundant edge (cycle detection)
def find_redundant_connection(edges: List[List[int]]) -> List[int]:
    n = len(edges)
    uf = UnionFind(n + 1)  # 1-indexed nodes
    
    for u, v in edges:
        if not uf.union(u, v):
            return [u, v]  # This edge creates a cycle
    
    return []
```

**JavaScript:**
```javascript
class UnionFind {
    constructor(n) {
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.rank = new Array(n).fill(0);
        this.count = n;
    }
    
    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);  // Path compression
        }
        return this.parent[x];
    }
    
    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);
        
        if (rootX === rootY) return false;
        
        // Union by rank
        if (this.rank[rootX] < this.rank[rootY]) {
            this.parent[rootX] = rootY;
        } else if (this.rank[rootX] > this.rank[rootY]) {
            this.parent[rootY] = rootX;
        } else {
            this.parent[rootY] = rootX;
            this.rank[rootX]++;
        }
        
        this.count--;
        return true;
    }
    
    connected(x, y) {
        return this.find(x) === this.find(y);
    }
}
```

---

## ‚ö° Complexity Analysis

| Version | Find | Union | Amortized |
|---------|------|-------|-----------|
| Basic | O(n) | O(n) | O(n) |
| Path Compression only | O(log n) | O(log n) | O(log n) |
| Union by Rank only | O(log n) | O(log n) | O(log n) |
| **Both optimizations** | O(Œ±(n)) | O(Œ±(n)) | **‚âà O(1)** |

**What is Œ±(n)?**
- Inverse Ackermann function
- Grows EXTREMELY slowly
- Œ±(n) ‚â§ 4 for all practical n (up to 10^80)
- Effectively constant time

---

## üîÑ Visual Trace: Path Compression

```
Before Find(4):
    0
    |
    1
    |
    2
    |
    3
    |
    4

Find(4):
  4.parent = 3 ‚Üí 2 ‚Üí 1 ‚Üí 0 (root)
  As we unwind, set each parent to 0

After Find(4):
      0
   /||\\\
  1 2 3 4

Next Find(4): just 1 hop!
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting Path Compression

```python
# ‚ùå Wrong: No compression
def find(self, x):
    while self.parent[x] != x:
        x = self.parent[x]
    return x  # Tree stays tall!

# ‚úÖ Correct: Compress while finding
def find(self, x):
    if self.parent[x] != x:
        self.parent[x] = self.find(self.parent[x])
    return self.parent[x]
```

### 2. Union by Rank: Forgetting to Increment

```python
# ‚ùå Wrong: Equal ranks but no increment
if self.rank[root_x] == self.rank[root_y]:
    self.parent[root_y] = root_x
    # Forgot to increment rank!

# ‚úÖ Correct: Increment when equal
if self.rank[root_x] == self.rank[root_y]:
    self.parent[root_y] = root_x
    self.rank[root_x] += 1  # Tree got taller
```

### 3. Updating Size at Wrong Node

```python
# ‚ùå Wrong: Update size at child
self.size[root_y] += self.size[root_x]  # root_y is now child!

# ‚úÖ Correct: Update size at new root
if self.size[root_x] < self.size[root_y]:
    self.parent[root_x] = root_y
    self.size[root_y] += self.size[root_x]  # root_y is new root
```

---

## üé§ Interview Tips

<details>
<summary><strong>What to Say About Optimizations</strong></summary>

**Quick mention:**
> "I'll use Union-Find with path compression and union by rank, giving us O(Œ±(n)) amortized time per operation - essentially constant."

**If asked to explain:**
> "Path compression flattens the tree during Find by making every node point directly to the root. Union by rank ensures we always attach the shorter tree under the taller one, keeping trees balanced."

**If asked about Œ±(n):**
> "The inverse Ackermann function. It grows so slowly that for all practical purposes - even the number of atoms in the universe - Œ±(n) is at most 4. So it's effectively O(1)."

</details>

---

> **üí° Key Insight:** Path compression is the "lazy" optimization - we only flatten paths we actually traverse. Union by rank is the "eager" optimization - we maintain balance at every union. Together, they're incredibly powerful.

---

**Next:** [Applications & Patterns ‚Üí](./7.3-Applications.md)
