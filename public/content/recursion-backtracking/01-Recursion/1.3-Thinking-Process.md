# 1.3 Thinking Recursively

> **Mental Model for Recursive Problem Solving**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - This is how experts approach recursive problems  
> **Prerequisites:** [1.1 Recursion Basics](./1.1-Recursion-Basics.md), [1.2 Patterns](./1.2-Recursion-Patterns.md)

---

## Overview

The biggest challenge with recursion isn't writing the code‚Äîit's **thinking recursively**. This lesson teaches you the mental model experts use to approach recursive problems without getting lost in the details.

> **üí° The Recursive Leap of Faith:**  
> "Assume your recursive call works correctly. How do you use that result to solve the current problem?"

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Think Recursively</strong></summary>

**Problem characteristics:**
- Can be broken into **smaller identical subproblems**
- Has a **natural base case** (simplest scenario)
- Has **self-similar structure** (parts look like the whole)
- "All", "every", "count ways", "generate all"

**Ask yourself:**
1. What's the simplest case where I know the answer directly?
2. If someone gave me the answer for a smaller version, could I use it?

</details>

---

## ‚úÖ The 5-Step Recursive Thinking Process

| Step | Question | Action |
|------|----------|--------|
| 1. **What's the base case?** | What's the simplest input? | Define stopping condition |
| 2. **What's the recursive case?** | How do I break it down? | Define subproblem |
| 3. **Assume the recursive call works** | Trust it gives correct answer | Leap of faith |
| 4. **How do I use the result?** | Combine with current work | Build solution |
| 5. **Is progress being made?** | Does problem get smaller? | Ensure termination |

---

## ‚ùå Common Thinking Mistakes

| Mistake | Problem | Fix |
|---------|---------|-----|
| Tracing all calls mentally | Gets overwhelming | Use leap of faith |
| Starting with recursive case | Missing base case | Start with base case |
| Making problem bigger | Infinite recursion | Ensure problem shrinks |
| Forgetting return values | Lost results | Track what you return |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Recursion Basics](./1.1-Recursion-Basics.md) - Mechanics
- [Recursion Patterns](./1.2-Recursion-Patterns.md) - Common patterns

**After mastering this:**
- [Basic Problems](./1.4-Basic-Problems/) - Apply thinking
- [Backtracking](../02-Backtracking/2.2-Backtracking-Template.md) - Advanced application

</details>

---

## üìê The Leap of Faith

The key to recursive thinking is **trust**:

1. You're solving a problem for input size **n**
2. You assume (have faith) that your function works for size **n-1**
3. You only need to figure out how to go from **n-1** to **n**

### Example: Factorial

**Problem:** Calculate n!

**Step 1: What's the base case?**
- Simplest input: n = 0 or n = 1
- Answer: 1 (0! = 1! = 1)

**Step 2: What's the recursive case?**
- n! = n * (n-1)!
- Subproblem: calculate (n-1)!

**Step 3: Leap of faith**
- ASSUME `factorial(n-1)` gives correct answer
- Don't trace through it!

**Step 4: How do I use the result?**
- Multiply n by the result of factorial(n-1)

**Step 5: Is progress being made?**
- n ‚Üí n-1, decreasing toward base case ‚úì

```python
def factorial(n):
    if n <= 1:          # Step 1: Base case
        return 1
    
    sub_result = factorial(n - 1)  # Steps 2-3: Trust this works
    return n * sub_result          # Step 4: Use the result
```

---

## üìê Visualization: Thinking Without Tracing

### Wrong approach (exhausting): Trace everything

```
factorial(4)
‚îî‚îÄ‚îÄ 4 * factorial(3)
        ‚îî‚îÄ‚îÄ 3 * factorial(2)
                ‚îî‚îÄ‚îÄ 2 * factorial(1)
                        ‚îî‚îÄ‚îÄ 1
                ‚îî‚îÄ‚îÄ 2 * 1 = 2
        ‚îî‚îÄ‚îÄ 3 * 2 = 6
‚îî‚îÄ‚îÄ 4 * 6 = 24
```

### Right approach (simple): Leap of faith

```
factorial(4):
  - Base case? No, n=4 > 1
  - Leap of faith: factorial(3) returns 6 (TRUST IT)
  - Use result: 4 * 6 = 24 ‚úì
```

You don't need to verify that factorial(3) = 6. Just trust it.

---

## üíª Worked Examples

### Example 1: Reverse a String

**Problem:** Reverse "hello" ‚Üí "olleh"

**Step 1: Base case**
- Empty string or single character ‚Üí return as is

**Step 2: Recursive case**
- Move first character to end
- Reverse the rest

**Step 3-4: Leap of faith + use result**
- `reverse("ello")` returns "olle" (TRUST IT)
- "olle" + "h" = "olleh" ‚úì

```python
def reverse_string(s: str) -> str:
    """Reverse string recursively."""
    # Base case
    if len(s) <= 1:
        return s
    
    # Leap of faith: reverse(s[1:]) works correctly
    reversed_rest = reverse_string(s[1:])
    
    # Use the result
    return reversed_rest + s[0]

# Think: reverse("hello")
# Leap of faith: reverse("ello") = "olle"
# Result: "olle" + "h" = "olleh"
```

```javascript
function reverseString(s) {
    if (s.length <= 1) return s;
    return reverseString(s.slice(1)) + s[0];
}
```

### Example 2: Count Nodes in Binary Tree

**Problem:** Count all nodes in a binary tree

**Step 1: Base case**
- Empty tree (null root) ‚Üí 0 nodes

**Step 2: Recursive case**
- Count left subtree + count right subtree + 1 (current node)

**Step 3-4: Leap of faith + use result**
- `count(left)` returns correct count for left (TRUST IT)
- `count(right)` returns correct count for right (TRUST IT)
- Add 1 for current node

```python
def count_nodes(root) -> int:
    """Count nodes in binary tree."""
    # Base case
    if root is None:
        return 0
    
    # Leap of faith: both recursive calls work correctly
    left_count = count_nodes(root.left)
    right_count = count_nodes(root.right)
    
    # Use results
    return 1 + left_count + right_count
```

```javascript
function countNodes(root) {
    if (!root) return 0;
    return 1 + countNodes(root.left) + countNodes(root.right);
}
```

### Example 3: Generate All Subsets

**Problem:** Generate all subsets of [1, 2, 3]

**Step 1: Base case**
- No elements left ‚Üí return [[]] (set containing empty set)

**Step 2: Recursive case**
- For each element: include it OR exclude it
- This creates a decision tree

**Step 3-4: Leap of faith + use result**
- `subsets([2,3])` returns all subsets without 1 (TRUST IT)
- For each subset in result:
  - Keep it as is (excluding 1)
  - Add 1 to it (including 1)

```python
def subsets(nums: list[int]) -> list[list[int]]:
    """Generate all subsets."""
    # Base case
    if not nums:
        return [[]]
    
    first = nums[0]
    rest = nums[1:]
    
    # Leap of faith: subsets(rest) gives all subsets of rest
    rest_subsets = subsets(rest)
    
    # Use result: add 'first' to each subset in rest_subsets
    with_first = [[first] + subset for subset in rest_subsets]
    
    return rest_subsets + with_first

# Think: subsets([1,2,3])
# Leap of faith: subsets([2,3]) = [[], [2], [3], [2,3]]
# Add 1 to each: [[1], [1,2], [1,3], [1,2,3]]
# Combine: [[], [2], [3], [2,3], [1], [1,2], [1,3], [1,2,3]]
```

```javascript
function subsets(nums) {
    if (nums.length === 0) return [[]];
    
    const [first, ...rest] = nums;
    const restSubsets = subsets(rest);
    const withFirst = restSubsets.map(subset => [first, ...subset]);
    
    return [...restSubsets, ...withFirst];
}
```

---

## ‚ö° Complexity Thinking

When analyzing recursive complexity:

1. **Time:** How many recursive calls * work per call
2. **Space:** Maximum depth of recursion (call stack)

### Quick Formulas

| Pattern | Time | Space |
|---------|------|-------|
| Linear (one call, constant work) |" O(n) "| O(n) |
| Binary tree (two calls) |" O(2‚Åø) "| O(n) |
| Binary search (one call, halving) |" O(log n) "| O(log n) |
| Tree traversal |" O(n) "| O(height) |

---

## üîÑ Variations in Thinking

| Variation | Approach | Example |
|-----------|----------|---------|
| **Accumulator** | Carry result through calls | Tail recursion |
| **Helper function** | Add parameters to main function | Index tracking |
| **Multiple returns** | Return tuple/array | Min and max simultaneously |
| **Memoization** | Cache intermediate results | Fibonacci |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Trying to Trace All Calls

‚ùå **Wrong thinking:**
```
"Let me trace through factorial(5)...
factorial(5) calls factorial(4)
factorial(4) calls factorial(3)
factorial(3) calls... *head explodes*"
```

‚úÖ **Correct thinking:**
```
"factorial(5):
 - Base case? No.
 - I trust factorial(4) returns 24.
 - So I return 5 * 24 = 120. Done."
```

### 2. Not Returning the Recursive Result

‚ùå **Wrong:**
```python
def sum_list(arr, i=0):
    if i == len(arr):
        return 0
    sum_list(arr, i + 1) + arr[i]  # Forgot return!
```

‚úÖ **Correct:**
```python
def sum_list(arr, i=0):
    if i == len(arr):
        return 0
    return sum_list(arr, i + 1) + arr[i]
```

### 3. Base Case Returns Wrong Type

‚ùå **Wrong:**
```python
def get_all_values(tree):
    if tree is None:
        return None  # Should return empty list!
    # Later: some_list + None causes error
```

‚úÖ **Correct:**
```python
def get_all_values(tree):
    if tree is None:
        return []  # Empty list, not None
```

### 4. Not Making the Problem Smaller

‚ùå **Wrong:**
```python
def broken(n):
    if n == 0:
        return 0
    return broken(n)  # n never changes!
```

‚úÖ **Correct:**
```python
def fixed(n):
    if n == 0:
        return 0
    return fixed(n - 1)  # n decreases
```

---

## üìù Practice Problems

### Beginner (Build intuition)

| Problem | Thinking Focus | LeetCode |
|---------|----------------|----------|
| Sum 1 to N | Simple base/recursive case | - |
| Reverse String | First element + rest | [LC 344](https://leetcode.com/problems/reverse-string/) |
| Power of Two | Halving pattern | [LC 231](https://leetcode.com/problems/power-of-two/) |

### Easy (Apply leap of faith)

| Problem | Thinking Focus | LeetCode |
|---------|----------------|----------|
| Max Depth of Tree | Trust left and right | [LC 104](https://leetcode.com/problems/maximum-depth-of-binary-tree/) |
| Same Tree | Trust subtree comparison | [LC 100](https://leetcode.com/problems/same-tree/) |
| Merge Two Sorted Lists | Trust merge of smaller | [LC 21](https://leetcode.com/problems/merge-two-sorted-lists/) |

### Medium (Complex combinations)

| Problem | Thinking Focus | LeetCode |
|---------|----------------|----------|
| Subsets | Include/exclude pattern | [LC 78](https://leetcode.com/problems/subsets/) |
| Flatten Nested List | Recursive structure | [LC 341](https://leetcode.com/problems/flatten-nested-list-iterator/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Practice the mental model:**
- Day 1: Solve 2 problems, write out the 5 steps
- Day 3: Solve without writing steps, think them
- Day 7: Explain your thinking out loud
- Day 14: Teach the leap of faith to someone

**Key skill:** Stop when you want to trace. Take the leap.

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate Recursive Thinking</strong></summary>

**When explaining your approach:**
> "I'll think about this recursively. My base case is [X]. For the recursive case, I'll assume my function works for smaller inputs, and I'll use that result to solve the current case."

**When asked "how does this work?":**
> "Let me walk through one level. For input n, the base case is [X]. Otherwise, I call myself on [smaller input], and I trust that gives me the right answer. Then I [combine/modify] that result for my answer."

**DON'T do this:**
> "So first factorial(5) calls factorial(4), which calls factorial(3), which calls factorial(2)..." *interviewer falls asleep*

**DO this:**
> "For factorial(5), the base case is n‚â§1 returns 1. Otherwise, I trust factorial(4) gives 24, and I return 5*24=120."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand leap of faith | 15-20 min | Key insight |
| Practice 5-step process | 30-45 min | 3-4 problems |
| Build intuition | 2-3 hours | Many small problems |
| Automatic thinking | 1-2 weeks | Daily practice |

---

## üí° Key Insight

> **Recursion is about trust, not tracing.**
>
> The expert's secret: They don't trace through all the calls. They:
> 1. Identify the base case
> 2. **Trust** the recursive call works for smaller input
> 3. Figure out how to use that result for current input
>
> This is the "Leap of Faith" ‚Äî the most important skill in recursive thinking.

---

## üîó Related

- [Recursion Basics](./1.1-Recursion-Basics.md) - Mechanics
- [Recursion Patterns](./1.2-Recursion-Patterns.md) - Pattern recognition
- [Basic Problems](./1.4-Basic-Problems/) - Apply thinking
- [Backtracking Template](../02-Backtracking/2.2-Backtracking-Template.md) - Advanced application
