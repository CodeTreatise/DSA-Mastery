# 6.1 Scheduling Greedy Overview

> **Definition:** Scheduling problems involve ordering jobs/tasks to optimize some objective‚Äîmaximize profit, minimize delay, or complete the most jobs before deadlines.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Scheduling Problems</strong></summary>

**Look for these signals:**
- Jobs with deadlines and profits/penalties
- Tasks with durations to sequence
- "Maximum profit", "minimum penalty"
- "Schedule to meet deadlines"
- Resources to allocate over time

**Visual Pattern:**
```
Jobs with deadlines:
Job A: profit=100, deadline=2
Job B: profit=50,  deadline=1
Job C: profit=60,  deadline=2

Timeline slots: [Slot 1] [Slot 2]
Question: Which jobs to schedule for max profit?
```

**Keywords:**
- "deadline", "schedule", "job sequencing"
- "penalty", "profit", "lateness"
- "minimize waiting time", "maximize completed"

</details>

---

## ‚úÖ When to Use Scheduling Greedy

| Problem Type | Greedy Strategy | Sort By |
|--------------|-----------------|---------|
| Jobs with deadlines + profits | Max profit first | Profit descending |
| Minimize total waiting | Shortest job first | Duration ascending |
| Minimize max lateness | Earliest deadline first | Deadline ascending |
| Maximize jobs before deadline | Sort by deadline | Deadline ascending |
| CPU scheduling (SJF) | Shortest job first | Duration ascending |

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Precedence constraints | Dependencies matter | Topological sort + DP |
| Multiple resources | Complex allocation | Integer programming |
| Weighted jobs with overlap | Can't just pick by weight | DP (weighted job scheduling) |
| Finding all schedules | Not finding one | Backtracking |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Greedy Fundamentals](../01-Greedy-Fundamentals/1.1-What-Is-Greedy.md)
- [Interval Patterns](../02-Interval-Pattern/4.1-Interval-Greedy-Overview.md)
- Sorting with custom comparators

**After mastering this:**
- Weighted Job Scheduling (DP)
- Task Scheduler (with cooldowns)
- OS scheduling algorithms

**Combines with:**
- Heaps for priority-based scheduling
- Union-Find for resource allocation
- Interval problems

</details>

---

## üìê The Core Scheduling Patterns

### Pattern 1: Job Sequencing with Deadlines

```
Problem: N jobs, each with profit and deadline.
         Only one job can run per time slot.
         Maximize total profit.

Greedy: Sort by profit (descending)
        For each job, place in latest available slot before deadline

Example:
Job A: profit=100, deadline=2
Job B: profit=50,  deadline=1  
Job C: profit=60,  deadline=2

Sort by profit: A(100), C(60), B(50)
Place: A in slot 2, C in slot 1, skip B (slot 1 taken)
Profit: 100 + 60 = 160
```

---

### Pattern 2: Minimize Total Waiting Time (SJF)

```
Problem: N jobs with durations, all arrive at time 0
         Minimize total waiting time (sum of start times)

Greedy: Shortest Job First
        Total waiting = sum(duration[i] * (n - i - 1))

Example:
Jobs: [3, 1, 2]  (durations)
Sort: [1, 2, 3]

Execution:
  Job 1 (dur=1): wait=0, finish=1
  Job 2 (dur=2): wait=1, finish=3
  Job 3 (dur=3): wait=3, finish=6

Total waiting: 0 + 1 + 3 = 4 (minimum!)
```

---

### Pattern 3: Minimize Maximum Lateness (EDF)

```
Problem: N jobs with duration and deadline
         All must be done (no skipping)
         Minimize the maximum lateness

Greedy: Earliest Deadline First
        Schedule jobs in deadline order

Example:
Jobs: [(dur=2, deadline=4), (dur=1, deadline=2), (dur=3, deadline=6)]
Sort by deadline: (1,2), (2,4), (3,6)

Schedule:
  Job B: time 0-1, lateness = 1-2 = -1 (early)
  Job A: time 1-3, lateness = 3-4 = -1 (early)
  Job C: time 3-6, lateness = 6-6 = 0 (on time)

Max lateness: 0 (optimal!)
```

---

## üíª Core Templates

### Template 1: Job Sequencing with Deadlines

```python
def job_sequencing(jobs: list[tuple[int, int]]) -> tuple[int, list[int]]:
    """
    Maximize profit by scheduling jobs with deadlines.
    
    Args:
        jobs: List of (profit, deadline) tuples
    
    Returns:
        (max_profit, scheduled_job_indices)
    
    Time: O(n¬≤ or n*d), Space: O(d) where d = max deadline
    """
    # Sort by profit descending
    indexed_jobs = [(profit, deadline, i) for i, (profit, deadline) in enumerate(jobs)]
    indexed_jobs.sort(reverse=True)  # By profit descending
    
    max_deadline = max(d for _, d, _ in indexed_jobs) if jobs else 0
    
    # Slots: slot[i] = True means slot i+1 is free
    slots = [True] * max_deadline
    result = []
    total_profit = 0
    
    for profit, deadline, orig_idx in indexed_jobs:
        # Find latest free slot before or at deadline
        for slot in range(min(deadline, max_deadline) - 1, -1, -1):
            if slots[slot]:
                slots[slot] = False
                result.append(orig_idx)
                total_profit += profit
                break
    
    return total_profit, result
```

```javascript
function jobSequencing(jobs) {
    // jobs = [[profit, deadline], ...]
    const indexed = jobs.map((job, i) => [...job, i]);
    indexed.sort((a, b) => b[0] - a[0]); // Sort by profit desc
    
    const maxDeadline = Math.max(...jobs.map(j => j[1]));
    const slots = new Array(maxDeadline).fill(true);
    const result = [];
    let totalProfit = 0;
    
    for (const [profit, deadline, origIdx] of indexed) {
        for (let slot = Math.min(deadline, maxDeadline) - 1; slot >= 0; slot--) {
            if (slots[slot]) {
                slots[slot] = false;
                result.push(origIdx);
                totalProfit += profit;
                break;
            }
        }
    }
    
    return [totalProfit, result];
}
```

---

### Template 2: Minimize Waiting Time (SJF)

```python
def min_waiting_time(durations: list[int]) -> int:
    """
    Schedule jobs to minimize total waiting time.
    
    Shortest Job First (SJF) is optimal.
    
    Time: O(n log n), Space: O(1)
    """
    durations.sort()  # Shortest first
    
    total_wait = 0
    current_wait = 0
    
    for i in range(len(durations) - 1):  # Last job waits for all previous
        current_wait += durations[i]
        total_wait += current_wait
    
    return total_wait


def min_waiting_time_formula(durations: list[int]) -> int:
    """
    Alternative formula-based approach.
    
    Wait for job i = sum of all jobs before it
    Total = sum(duration[i] * (n - i - 1)) for sorted array
    """
    durations.sort()
    n = len(durations)
    
    total = 0
    for i, dur in enumerate(durations):
        # This job makes (n - i - 1) jobs wait
        total += dur * (n - i - 1)
    
    return total
```

```javascript
function minWaitingTime(durations) {
    durations.sort((a, b) => a - b);
    
    let totalWait = 0;
    let currentWait = 0;
    
    for (let i = 0; i < durations.length - 1; i++) {
        currentWait += durations[i];
        totalWait += currentWait;
    }
    
    return totalWait;
}
```

---

### Template 3: Minimize Maximum Lateness (EDF)

```python
def min_max_lateness(jobs: list[tuple[int, int]]) -> int:
    """
    Schedule all jobs to minimize maximum lateness.
    
    Args:
        jobs: List of (duration, deadline) tuples
    
    Returns:
        Minimum possible maximum lateness
    
    Time: O(n log n), Space: O(1)
    """
    # Sort by deadline (Earliest Deadline First)
    jobs.sort(key=lambda x: x[1])
    
    current_time = 0
    max_lateness = 0
    
    for duration, deadline in jobs:
        current_time += duration
        lateness = current_time - deadline  # Can be negative (early)
        max_lateness = max(max_lateness, lateness)
    
    return max_lateness
```

```javascript
function minMaxLateness(jobs) {
    // jobs = [[duration, deadline], ...]
    jobs.sort((a, b) => a[1] - b[1]); // Sort by deadline
    
    let currentTime = 0;
    let maxLateness = 0;
    
    for (const [duration, deadline] of jobs) {
        currentTime += duration;
        const lateness = currentTime - deadline;
        maxLateness = Math.max(maxLateness, lateness);
    }
    
    return maxLateness;
}
```

---

## ‚ö° Complexity Analysis

| Problem | Time | Space | Strategy |
|---------|------|-------|----------|
| Job Sequencing | O(n¬≤) or O(n log n)* | O(n) | Sort by profit |
| Minimize Waiting | O(n log n) | O(1) | Sort by duration |
| Minimize Max Lateness | O(n log n) | O(1) | Sort by deadline |
| Task Scheduler | O(n) | O(1) | Count frequencies |

*O(n log n) with Union-Find for slot finding

---

## üîÑ Problem Variations

| Variation | Key Difference | Strategy |
|-----------|---------------|----------|
| With profits, deadlines | Maximize profit | Sort by profit desc |
| With penalties, deadlines | Minimize penalty | Same as profit max |
| All jobs must run | Minimize lateness | EDF scheduling |
| Min wait time | Sum of start times | Shortest job first |
| With cooldowns | Task Scheduler | Frequency + idle slots |
| Preemptive | Can interrupt | Shortest Remaining Time |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Sorting Criterion

```python
# ‚ùå WRONG: Sort by deadline for profit maximization
jobs.sort(key=lambda x: x[1])  # Wrong for profit max!

# ‚úÖ CORRECT: Sort by profit for profit maximization
jobs.sort(key=lambda x: x[0], reverse=True)
```

### 2. Not Finding Latest Slot

```python
# ‚ùå WRONG: Place in first available slot
for slot in range(deadline):
    if slots[slot]:
        slots[slot] = False
        break

# ‚úÖ CORRECT: Place in LATEST available slot
for slot in range(min(deadline, max_deadline) - 1, -1, -1):
    if slots[slot]:
        slots[slot] = False
        break
```

### 3. Confusing Lateness Types

```python
# Lateness: finish_time - deadline (can be negative)
# Tardiness: max(0, finish_time - deadline) (always >= 0)
# Make sure you understand which one the problem asks for!
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the patterns)
- [ ] [Minimum Waiting Time](https://www.algoexpert.io/questions/minimum-waiting-time) - SJF
- [ ] [Tandem Bicycle](https://www.algoexpert.io/questions/tandem-bicycle) - Pairing optimization

### Medium (Apply variations)
- [ ] [Task Scheduler](https://leetcode.com/problems/task-scheduler/) - With cooldowns
- [ ] [Course Schedule III](https://leetcode.com/problems/course-schedule-iii/) - Max courses with deadlines
- [ ] [Two City Scheduling](https://leetcode.com/problems/two-city-scheduling/) - Assignment

### Hard (Complex constraints)
- [ ] [Maximum Profit in Job Scheduling](https://leetcode.com/problems/maximum-profit-in-job-scheduling/) - DP needed
- [ ] [Single-Threaded CPU](https://leetcode.com/problems/single-threaded-cpu/) - Simulation + heap

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: Job Sequencing concept + implementation
- Day 3: Task Scheduler
- Day 7: Course Schedule III

**Week 2:**
- Day 1: Explain when to use which sort criterion
- Day 3: Two City Scheduling
- Day 7: Maximum Profit in Job Scheduling (DP)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Communication Strategy</strong></summary>

**Company Frequency:**
| Company | Frequency | Common Problems |
|---------|-----------|-----------------|
| Amazon | ‚≠ê‚≠ê‚≠ê | Task Scheduler, scheduling |
| Google | ‚≠ê‚≠ê | Custom scheduling problems |
| Meta | ‚≠ê‚≠ê | Resource allocation |
| Microsoft | ‚≠ê‚≠ê‚≠ê | OS-style scheduling |

**Interview Communication:**

```
"This is a scheduling problem. Let me identify the objective:

1. Maximize profit ‚Üí Sort by profit descending
2. Minimize waiting ‚Üí Shortest Job First
3. Minimize lateness ‚Üí Earliest Deadline First
4. With cooldowns ‚Üí Use frequency counting

For this problem, I'll use [X] approach..."
```

**Key questions to ask:**
- "Can jobs be interrupted (preemptive)?"
- "Are there dependencies between jobs?"
- "Is it one resource or multiple?"

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Recognize scheduling type | 30 sec |
| Choose sort criterion | 1 min |
| Implement | 8-12 min |
| Debug edge cases | 2-3 min |
| **Total** | **12-16 min** |

---

> **üí° Key Insight:** Scheduling problems boil down to ONE question: "What should I prioritize when ordering jobs?" The answer (profit, duration, deadline) determines your sort criterion.

> **üîó Related:** [Interval Pattern](../02-Interval-Pattern/4.1-Interval-Greedy-Overview.md) | [Classic Greedy](../05-Classic-Greedy/7.1-Classic-Problems-Overview.md)
