# String DP Patterns

> **String manipulation + Dynamic Programming = Powerful problem-solving.** String DP problems involve building/matching/transforming strings optimally. They often combine interval DP concepts with string-specific insights.

---

## ðŸ“‹ Overview

String DP problems fall into several categories:

| Category | Example Problems | Key Insight |
|----------|-----------------|-------------|
| **Matching** | Wildcard, Regex | Two-pointer states |
| **Building** | Distinct Subsequences | Count ways |
| **Interleaving** | Interleaving String | Merge two into one |
| **Decoding** | Decode Ways | Linear DP with conditions |
| **Transformation** | Edit Distance | Multi-operation choice |

---

## ðŸŽ¯ Pattern Recognition

**String DP signals:**
- "Match pattern to string"
- "Count subsequences/substrings"
- "Transform one string to another"
- "Interleave/merge strings"
- "Decode/encode strings"

**Keywords:**
- "wildcard", "regex", "pattern"
- "distinct subsequences"
- "interleaving"
- "number of ways", "can form"

---

## ðŸ“ Core String DP Patterns

### Pattern 1: Wildcard Matching (LC 44)

**Problem:** Match string `s` with pattern `p` containing `?` (any single char) and `*` (any sequence).

**State:** `dp[i][j]` = does `s[0..i-1]` match `p[0..j-1]`?

**Recurrence:**
```python
if p[j-1] == s[i-1] or p[j-1] == '?':
    dp[i][j] = dp[i-1][j-1]  # Characters match
elif p[j-1] == '*':
    dp[i][j] = dp[i][j-1] or dp[i-1][j]  # Empty or extend
```

```python
def is_match_wildcard(s: str, p: str) -> bool:
    """
    Wildcard matching with ? and *.
    Time: O(mn), Space: O(mn) â†’ O(n)
    """
    m, n = len(s), len(p)
    
    # dp[i][j] = s[:i] matches p[:j]
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    
    # Empty string matches pattern of only *s
    for j in range(1, n + 1):
        if p[j - 1] == '*':
            dp[0][j] = dp[0][j - 1]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == s[i - 1] or p[j - 1] == '?':
                dp[i][j] = dp[i - 1][j - 1]
            elif p[j - 1] == '*':
                # * matches empty (dp[i][j-1]) OR
                # * matches one more char (dp[i-1][j])
                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
    
    return dp[m][n]
```

```javascript
function isMatchWildcard(s, p) {
    const m = s.length, n = p.length;
    const dp = Array.from({length: m + 1}, () => new Array(n + 1).fill(false));
    dp[0][0] = true;
    
    // Empty string vs pattern of *s
    for (let j = 1; j <= n; j++) {
        if (p[j - 1] === '*') dp[0][j] = dp[0][j - 1];
    }
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (p[j - 1] === s[i - 1] || p[j - 1] === '?') {
                dp[i][j] = dp[i - 1][j - 1];
            } else if (p[j - 1] === '*') {
                dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
            }
        }
    }
    
    return dp[m][n];
}
```

---

### Pattern 2: Regular Expression Matching (LC 10)

**Problem:** Match with `.` (any single char) and `*` (zero or more of preceding).

**Key difference from wildcard:** `*` depends on the preceding character!

```python
def is_match_regex(s: str, p: str) -> bool:
    """
    Regex matching with . and *.
    * means zero or more of PRECEDING element.
    """
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    
    # Empty string can match a* patterns
    for j in range(2, n + 1):
        if p[j - 1] == '*':
            dp[0][j] = dp[0][j - 2]  # Skip "x*" entirely
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == s[i - 1] or p[j - 1] == '.':
                dp[i][j] = dp[i - 1][j - 1]
            elif p[j - 1] == '*':
                # Option 1: Zero occurrences of preceding
                dp[i][j] = dp[i][j - 2]
                
                # Option 2: One+ occurrences (if preceding matches)
                if p[j - 2] == s[i - 1] or p[j - 2] == '.':
                    dp[i][j] = dp[i][j] or dp[i - 1][j]
    
    return dp[m][n]
```

**Wildcard vs Regex:**
| Feature | Wildcard (`*`) | Regex (`*`) |
|---------|----------------|-------------|
| `*` means | Any sequence | Zero+ of preceding |
| Independent? | Yes | No (needs char before) |
| Base case | `*` matches empty | `x*` matches empty |

---

### Pattern 3: Distinct Subsequences (LC 115)

**Problem:** Count how many times `t` appears as a subsequence of `s`.

**State:** `dp[i][j]` = number of ways to form `t[0..j-1]` from `s[0..i-1]`

```python
def num_distinct(s: str, t: str) -> int:
    """
    Count distinct subsequences.
    Time: O(mn), Space: O(n)
    """
    m, n = len(s), len(t)
    
    # dp[j] = ways to form t[:j] from s[:i] (rolling)
    dp = [0] * (n + 1)
    dp[0] = 1  # Empty t can be formed 1 way
    
    for i in range(1, m + 1):
        # Process right to left (like 0/1 knapsack)
        for j in range(min(i, n), 0, -1):
            if s[i - 1] == t[j - 1]:
                dp[j] += dp[j - 1]  # Use or skip s[i-1]
    
    return dp[n]
```

**Insight:** When `s[i] == t[j]`:
- Include: `dp[i-1][j-1]` (both chars used)
- Skip: `dp[i-1][j]` (skip s[i], still need t[j])
- Total: `dp[i-1][j-1] + dp[i-1][j]`

---

### Pattern 4: Interleaving String (LC 97)

**Problem:** Can `s3` be formed by interleaving `s1` and `s2`?

**State:** `dp[i][j]` = can `s1[0..i-1]` + `s2[0..j-1]` interleave to form `s3[0..i+j-1]`?

```python
def is_interleave(s1: str, s2: str, s3: str) -> bool:
    """
    Check if s3 is interleaving of s1 and s2.
    Time: O(mn), Space: O(n)
    """
    m, n = len(s1), len(s2)
    if m + n != len(s3):
        return False
    
    # dp[j] = can form s3[:i+j] from s1[:i] and s2[:j]
    dp = [False] * (n + 1)
    
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0 and j == 0:
                dp[j] = True
            elif i == 0:
                dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]
            elif j == 0:
                dp[j] = dp[j] and s1[i - 1] == s3[i - 1]
            else:
                dp[j] = ((dp[j] and s1[i - 1] == s3[i + j - 1]) or
                         (dp[j - 1] and s2[j - 1] == s3[i + j - 1]))
    
    return dp[n]
```

**Visualization:**
```
s1 = "aab", s2 = "xyz", s3 = "axaybz"

     ""  x   y   z
""   T   F   F   F
a    T   T   F   F   
a    T   T   T   F
b    T   T   T   T

s3[k] must come from s1[i-1] or s2[j-1] where k = i+j-1
```

---

### Pattern 5: Word Break Problems

**Word Break I (LC 139):** Can string be segmented?

```python
def word_break(s: str, word_dict: list[str]) -> bool:
    """
    Check if s can be segmented into dictionary words.
    """
    words = set(word_dict)
    n = len(s)
    dp = [False] * (n + 1)
    dp[0] = True  # Empty string
    
    for i in range(1, n + 1):
        for j in range(i):
            if dp[j] and s[j:i] in words:
                dp[i] = True
                break
    
    return dp[n]
```

**Word Break II (LC 140):** Return all segmentations.

```python
def word_break_ii(s: str, word_dict: list[str]) -> list[str]:
    """
    Return all possible sentences.
    """
    words = set(word_dict)
    memo = {}
    
    def backtrack(start: int) -> list[list[str]]:
        if start in memo:
            return memo[start]
        
        if start == len(s):
            return [[]]
        
        result = []
        for end in range(start + 1, len(s) + 1):
            word = s[start:end]
            if word in words:
                for rest in backtrack(end):
                    result.append([word] + rest)
        
        memo[start] = result
        return result
    
    return [' '.join(words) for words in backtrack(0)]
```

---

## ðŸ”„ Comparison Chart

| Problem | State | Transition | Complexity |
|---------|-------|------------|------------|
| **Wildcard** | `dp[i][j]` match? | ?, *, exact | O(mn) |
| **Regex** | `dp[i][j]` match? | ., x*, exact | O(mn) |
| **Distinct Subseq** | `dp[i][j]` count | include+skip | O(mn) |
| **Interleave** | `dp[i][j]` possible? | from s1 or s2 | O(mn) |
| **Word Break** | `dp[i]` possible? | check all words | O(nÂ²) or O(nW) |

---

## âš ï¸ Common Mistakes

### 1. Wildcard vs Regex * Confusion

**âŒ Wrong (treating regex * like wildcard):**
```python
# Regex: * depends on preceding!
if p[j-1] == '*':
    dp[i][j] = dp[i][j-1] or dp[i-1][j]  # Wrong!
```

**âœ… Correct:**
```python
if p[j-1] == '*':
    dp[i][j] = dp[i][j-2]  # Zero of preceding
    if p[j-2] == s[i-1] or p[j-2] == '.':
        dp[i][j] = dp[i][j] or dp[i-1][j]  # More of preceding
```

### 2. Off-by-One in Interleaving

```python
# s3[k] corresponds to s1[i] and s2[j] where k = i + j - 1
# NOT k = i + j!
```

### 3. Forgetting Base Cases

```python
# Distinct Subsequences: dp[i][0] = 1 for all i
# (empty target can always be formed)

# Word Break: dp[0] = True
# (empty prefix is valid)
```

---

## ðŸ“ Practice Problems

### Easy
- [ ] [392. Is Subsequence](https://leetcode.com/problems/is-subsequence/) - Foundation

### Medium
- [ ] [139. Word Break](https://leetcode.com/problems/word-break/) - Segmentation
- [ ] [97. Interleaving String](https://leetcode.com/problems/interleaving-string/) - Merge check
- [ ] [583. Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/) - LCS variant

### Hard
- [ ] [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/) - Complex *
- [ ] [44. Wildcard Matching](https://leetcode.com/problems/wildcard-matching/) - Simple *
- [ ] [115. Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/) - Counting
- [ ] [140. Word Break II](https://leetcode.com/problems/word-break-ii/) - All solutions

---

## âš¡ Space Optimization

Most 2D string DP can be optimized to 1D:

```python
# 2D â†’ 1D transformation
# When dp[i][j] only depends on dp[i-1][j-1], dp[i-1][j], dp[i][j-1]

# Original
dp = [[0] * (n+1) for _ in range(m+1)]
for i in range(1, m+1):
    for j in range(1, n+1):
        # Use dp[i-1][j-1], dp[i-1][j], dp[i][j-1]

# Optimized
dp = [0] * (n+1)
for i in range(1, m+1):
    prev = dp[0]  # Save dp[i-1][j-1] before overwriting
    for j in range(1, n+1):
        temp = dp[j]  # Will become dp[i-1][j-1] for next j
        # dp[j] is dp[i-1][j], dp[j-1] is dp[i][j-1]
        prev = temp
```

---

## ðŸŽ¤ Interview Context

**Company Frequency:**
| Problem Type | Google | Meta | Amazon |
|--------------|--------|------|--------|
| Wildcard/Regex | â­â­â­â­ | â­â­â­ | â­â­ |
| Word Break | â­â­â­ | â­â­â­â­ | â­â­â­â­ |
| Distinct Subseq | â­â­â­ | â­â­ | â­â­ |
| Interleaving | â­â­ | â­â­â­ | â­â­ |

**Time allocation:**
| Problem | Target Time |
|---------|-------------|
| Word Break I | 15-20 min |
| Wildcard | 25-30 min |
| Regex | 30-35 min |
| Distinct Subseq | 20-25 min |

---

## ðŸ’¡ Key Insights

1. **Wildcard `*`** = any sequence (independent)
2. **Regex `*`** = zero or more of PRECEDING (dependent)
3. **Distinct Subsequences** = include + skip counting
4. **Interleaving** = which string does current char come from?
5. **Word Break** = try all possible word endings

> **ðŸ”— Related:** [Edit Distance](../06-LCS-Pattern/6.6-LCS-Practice/02-Edit-Distance-LC72.md) | [LCS Pattern](../06-LCS-Pattern/6.5-LCS-Fundamentals.md) | [Decode Ways](../02-Fibonacci-Pattern/4.4-Fibonacci-Practice/03-Decode-Ways-LC91.md)
