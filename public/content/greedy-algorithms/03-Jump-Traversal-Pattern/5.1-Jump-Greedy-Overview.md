# 5.1 Jump/Traversal Greedy Overview

> **Definition:** Jump and traversal problems involve moving through an array or graph where each position determines how far you can go next. Greedy approaches track the maximum reachable position or optimal path.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Jump/Traversal Problems</strong></summary>

**Look for these signals:**
- Array where `arr[i]` = max jump distance from position i
- "Can you reach the end?"
- "Minimum jumps to reach the end"
- Circular traversal (gas stations, tokens)
- "Can complete the loop?"

**Visual Pattern:**
```
Array:   [2, 3, 1, 1, 4]
Index:    0  1  2  3  4

From index 0: can jump 1 or 2 positions (value = 2)
From index 1: can jump 1, 2, or 3 positions (value = 3)

Question: Can we reach index 4 starting from index 0?
```

**Keywords:**
- "jump", "reach", "traverse"
- "gas station", "circular route"
- "minimum steps", "can reach"

</details>

---

## ‚úÖ When to Use Jump Greedy

| Problem Type | Greedy Strategy | Track |
|--------------|-----------------|-------|
| Can reach destination? | Extend max reach | `max_reachable` |
| Minimum jumps | BFS-style levels | `current_end`, `farthest` |
| Circular traversal | Running surplus | `tank`, `start_index` |
| Token/resource problems | Balance tracking | `balance`, `deficit` |

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Variable costs per jump | Need to minimize total cost | DP |
| Must visit all positions | Not just reaching end | Backtracking |
| Weighted graph | Greedy may miss optimal | Dijkstra/DP |
| Count all paths | Not finding one path | DP |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Greedy Fundamentals](../01-Greedy-Fundamentals/1.1-What-Is-Greedy.md)
- Array traversal basics
- BFS concepts (for min jumps)

**After mastering this:**
- Frog Jump (DP variant)
- Shortest path algorithms
- Graph traversal

**Combines with:**
- Two pointers
- Prefix sums
- BFS for optimal jumps

</details>

---

## üìê The Three Core Jump Patterns

### Pattern 1: Reachability (Can Reach?)

```
Track: max_reachable = farthest index we can reach

For each index i:
  - If i > max_reachable: can't reach here, return False
  - Update: max_reachable = max(max_reachable, i + nums[i])
  - If max_reachable >= last: can reach!

Visual:
nums = [2, 3, 1, 1, 4]
idx     0  1  2  3  4

i=0: max_reach = max(0, 0+2) = 2
i=1: max_reach = max(2, 1+3) = 4 ‚â• 4 ‚úì Can reach!
```

---

### Pattern 2: Minimum Jumps (BFS-Style Levels)

```
Track: current_end = farthest we can reach with current jumps
       farthest = farthest we can reach with one more jump

For each index i:
  - Update farthest = max(farthest, i + nums[i])
  - If i == current_end (reached boundary):
    ‚Üí jumps++
    ‚Üí current_end = farthest

Visual:
nums = [2, 3, 1, 1, 4]
         ‚îî‚îÄLevel 0‚îÄ‚îò ‚îîLevel 1‚îò

Jump 0: At index 0
Jump 1: Can reach indices 1,2
Jump 2: From 1 or 2, can reach index 4
```

---

### Pattern 3: Circular Traversal (Running Surplus)

```
Track: tank = current fuel balance
       start = candidate starting position
       total_surplus = sum(gas) - sum(cost)

Key insight: 
- If total gas ‚â• total cost, solution exists
- Start from where running deficit resets to 0

Visual:
gas  = [1, 2, 3, 4, 5]
cost = [3, 4, 5, 1, 2]
diff = [-2,-2,-2,+3,+3]

Running sum shows where to start!
```

---

## üíª Core Templates

### Template 1: Jump Game (Reachability)

```python
def can_jump(nums: list[int]) -> bool:
    """
    LeetCode 55: Jump Game
    
    Can we reach the last index?
    
    Time: O(n), Space: O(1)
    """
    max_reach = 0
    
    for i in range(len(nums)):
        # Can't reach this position
        if i > max_reach:
            return False
        
        # Update how far we can reach
        max_reach = max(max_reach, i + nums[i])
        
        # Early termination
        if max_reach >= len(nums) - 1:
            return True
    
    return True
```

```javascript
function canJump(nums) {
    let maxReach = 0;
    
    for (let i = 0; i < nums.length; i++) {
        if (i > maxReach) return false;
        maxReach = Math.max(maxReach, i + nums[i]);
        if (maxReach >= nums.length - 1) return true;
    }
    
    return true;
}
```

---

### Template 2: Minimum Jumps

```python
def jump(nums: list[int]) -> int:
    """
    LeetCode 45: Jump Game II
    
    Minimum jumps to reach last index.
    
    Time: O(n), Space: O(1)
    """
    if len(nums) <= 1:
        return 0
    
    jumps = 0
    current_end = 0    # Farthest we can reach with current jumps
    farthest = 0       # Farthest we can reach with one more jump
    
    for i in range(len(nums) - 1):  # Don't need to jump from last
        farthest = max(farthest, i + nums[i])
        
        # Reached the boundary of current level
        if i == current_end:
            jumps += 1
            current_end = farthest
            
            # Early termination
            if current_end >= len(nums) - 1:
                break
    
    return jumps
```

```javascript
function jump(nums) {
    if (nums.length <= 1) return 0;
    
    let jumps = 0;
    let currentEnd = 0;
    let farthest = 0;
    
    for (let i = 0; i < nums.length - 1; i++) {
        farthest = Math.max(farthest, i + nums[i]);
        
        if (i === currentEnd) {
            jumps++;
            currentEnd = farthest;
            if (currentEnd >= nums.length - 1) break;
        }
    }
    
    return jumps;
}
```

---

### Template 3: Gas Station (Circular)

```python
def can_complete_circuit(gas: list[int], cost: list[int]) -> int:
    """
    LeetCode 134: Gas Station
    
    Find starting index to complete circular route.
    
    Time: O(n), Space: O(1)
    """
    total_tank = 0   # Total surplus over entire trip
    current_tank = 0 # Current running tank
    start = 0        # Candidate start position
    
    for i in range(len(gas)):
        surplus = gas[i] - cost[i]
        total_tank += surplus
        current_tank += surplus
        
        # Can't reach next station from current start
        if current_tank < 0:
            start = i + 1      # Try starting from next station
            current_tank = 0   # Reset tank
    
    # If total gas >= total cost, we can complete from 'start'
    return start if total_tank >= 0 else -1
```

```javascript
function canCompleteCircuit(gas, cost) {
    let totalTank = 0;
    let currentTank = 0;
    let start = 0;
    
    for (let i = 0; i < gas.length; i++) {
        const surplus = gas[i] - cost[i];
        totalTank += surplus;
        currentTank += surplus;
        
        if (currentTank < 0) {
            start = i + 1;
            currentTank = 0;
        }
    }
    
    return totalTank >= 0 ? start : -1;
}
```

---

## ‚ö° Complexity Analysis

| Problem | Time | Space | Key Insight |
|---------|------|-------|-------------|
| Can Reach | O(n) | O(1) | Track max_reachable |
| Min Jumps | O(n) | O(1) | BFS without queue |
| Gas Station | O(n) | O(1) | Running surplus |
| Video Stitching | O(n log n) | O(1) | Sort + greedy extend |

---

## üîÑ Problem Variations

| Variation | Modification | Strategy |
|-----------|--------------|----------|
| Can reach (forward only) | Basic | Track max reach |
| Reach with costs | Each jump has cost | DP |
| Min jumps | Count jumps | BFS levels |
| Circular route | Gas stations | Running surplus |
| Video stitching | Intervals to cover range | Sort by start |
| Frog jump | Specific jump distances | DP + hash set |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Off-by-One in Loop Bounds

```python
# For minimum jumps:
# ‚ùå WRONG: Include last index
for i in range(len(nums)):

# ‚úÖ CORRECT: Stop before last (don't need to jump from there)
for i in range(len(nums) - 1):
```

### 2. Not Handling Edge Cases

```python
# ‚ùå WRONG: Crashes on single element
def jump(nums):
    jumps = 0
    ...  # Assumes length > 1

# ‚úÖ CORRECT: Handle explicitly
def jump(nums):
    if len(nums) <= 1:
        return 0
```

### 3. Confusing Reach and Min Jumps

```python
# Reach: just check if possible
# Min Jumps: must count minimum

# For reach: stop as soon as max_reach >= target
# For min jumps: count level transitions
```

### 4. Gas Station Logic

```python
# ‚ùå WRONG: Checking at each station if we can complete
# (This is O(n¬≤))

# ‚úÖ CORRECT: Track running surplus, reset on negative
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)
- [ ] [Jump Game](https://leetcode.com/problems/jump-game/) - Basic reachability
- [ ] [Jump Game VII](https://leetcode.com/problems/jump-game-vii/) - With constraints

### Medium (Apply variations)
- [ ] [Jump Game II](https://leetcode.com/problems/jump-game-ii/) - Minimum jumps
- [ ] [Gas Station](https://leetcode.com/problems/gas-station/) - Circular route
- [ ] [Video Stitching](https://leetcode.com/problems/video-stitching/) - Interval coverage

### Hard (Complex constraints)
- [ ] [Jump Game IV](https://leetcode.com/problems/jump-game-iv/) - BFS needed
- [ ] [Frog Jump](https://leetcode.com/problems/frog-jump/) - DP + constraints

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: Jump Game (reachability)
- Day 3: Jump Game II (min jumps)
- Day 7: Gas Station

**Week 2:**
- Day 1: Video Stitching
- Day 3: Explain all patterns without notes
- Day 7: Attempt Jump Game IV

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Communication Strategy</strong></summary>

**Company Frequency:**
| Company | Frequency | Common Problems |
|---------|-----------|-----------------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Jump Game, Gas Station |
| Google | ‚≠ê‚≠ê‚≠ê | May add constraints |
| Meta | ‚≠ê‚≠ê‚≠ê | Classic versions |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Standard problems |

**Interview Communication:**

```
"This is a jump/traversal problem. Let me identify the type:

1. If asking 'can we reach?' ‚Üí Track max reachable index
2. If asking 'minimum jumps?' ‚Üí BFS-style levels
3. If circular ‚Üí Track running surplus

For this problem, I'll use [X] approach..."
```

**Key questions to ask:**
- "Is it guaranteed we can reach?"
- "Are there any obstacles?"
- "Is it forward-only or bidirectional?"

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Recognize pattern | 30 sec |
| Choose approach | 1 min |
| Implement | 5-8 min |
| Debug edge cases | 2-3 min |
| **Total** | **8-12 min** |

---

> **üí° Key Insight:** Jump problems are about tracking "reach" - how far can we go from here? The greedy choice is always to extend your reach as far as possible, because having more options is never worse.

> **üîó Related:** [Jump Game Practice](./5.2-Jump-Practice/Jump-Game.md) | [Gas Station](./5.2-Jump-Practice/Gas-Station.md) | [Interval Pattern](../02-Interval-Pattern/4.1-Interval-Greedy-Overview.md)
