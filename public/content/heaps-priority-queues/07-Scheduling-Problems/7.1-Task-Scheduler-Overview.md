# 7.1 Scheduling Problems Overview

## Definition

**Scheduling problems** involve allocating resources (CPU, rooms, workers) to tasks over time, often with constraints like cooldowns, deadlines, or capacity limits. Heaps provide efficient solutions by enabling quick access to the "best next task."

```
Common Scheduling Scenarios:

1. Task Scheduler (LC 621)
   - Tasks with cooldown between same types
   - Minimize total time
   
2. Meeting Rooms II (LC 253)
   - Meetings with start/end times
   - Minimize rooms needed

3. Reorganize String (LC 767)
   - Characters with "no adjacent same" constraint
   - Check if possible, construct result
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Heaps for Scheduling</strong></summary>

**Key signals:**
- "Schedule tasks"
- "Minimum time/resources"
- "Cooldown period"
- "No two same items adjacent"
- "Meeting room allocation"

**Why heap?**
```
Greedy scheduling often needs:
  - "Which task has most remaining work?"
  - "Which room is available soonest?"
  - "What's the highest frequency item?"

Heap gives O(log n) access to these extremes.
```

**Common heap usage:**
- Max-heap: Pick task with most occurrences
- Min-heap: Track when resources become free
- Two heaps: Track available vs cooling tasks

</details>

---

## ‚úÖ When to Use This Pattern

| Problem Type | Heap Type | Purpose |
|--------------|-----------|---------|
| Task with cooldown | Max-heap + queue | Most frequent task first |
| Meeting rooms | Min-heap | Track earliest ending meeting |
| No adjacent same | Max-heap | Alternate between most frequent |
| Job scheduling | Min/Max heap | Priority-based selection |

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|---------------------|
| Simple FIFO scheduling | Queue |
| Exact time slots needed | Interval DP |
| Dependencies between tasks | Topological sort |

---

## üìê Problem Templates

### Template 1: Cooldown Scheduling (Task Scheduler)

```python
import heapq
from collections import Counter

def task_scheduler_template(tasks, cooldown):
    """
    Template: Schedule tasks with cooldown constraint.
    
    Strategy:
    - Max-heap of (remaining_count)
    - Track cooling tasks with (available_time, count)
    - Each time step: pop from heap, add to cooling, check cooling
    """
    count = Counter(tasks)
    max_heap = [-c for c in count.values()]
    heapq.heapify(max_heap)
    
    time = 0
    cooling = []  # (available_time, remaining_count)
    
    while max_heap or cooling:
        time += 1
        
        # Move cooled tasks back to heap
        while cooling and cooling[0][0] <= time:
            _, remaining = heapq.heappop(cooling)
            heapq.heappush(max_heap, remaining)
        
        if max_heap:
            remaining = -heapq.heappop(max_heap)
            remaining -= 1
            if remaining > 0:
                heapq.heappush(cooling, (time + cooldown, -remaining))
        # else: idle time
    
    return time
```

### Template 2: Resource Allocation (Meeting Rooms)

```python
import heapq

def meeting_rooms_template(meetings):
    """
    Template: Minimum resources for overlapping intervals.
    
    Strategy:
    - Sort by start time
    - Min-heap of end times (when rooms free)
    - For each meeting: reuse room if possible, else new room
    """
    if not meetings:
        return 0
    
    meetings.sort(key=lambda x: x[0])  # Sort by start
    
    # Min-heap of end times
    end_times = [meetings[0][1]]
    
    for start, end in meetings[1:]:
        if start >= end_times[0]:
            # Reuse room - update end time
            heapq.heapreplace(end_times, end)
        else:
            # Need new room
            heapq.heappush(end_times, end)
    
    return len(end_times)
```

### Template 3: Alternating Selection (Reorganize String)

```python
import heapq
from collections import Counter

def reorganize_template(items):
    """
    Template: Arrange items with no adjacent same.
    
    Strategy:
    - Max-heap of (count, item)
    - Each step: pop top, use it, push back if remaining
    - Keep track of "last used" to avoid adjacent
    """
    count = Counter(items)
    max_heap = [(-c, item) for item, c in count.items()]
    heapq.heapify(max_heap)
    
    result = []
    prev_count, prev_item = 0, None
    
    while max_heap:
        neg_count, item = heapq.heappop(max_heap)
        result.append(item)
        
        # Push back previous item if it has remaining
        if prev_count < 0:
            heapq.heappush(max_heap, (prev_count, prev_item))
        
        # Update prev to current
        prev_count = neg_count + 1  # +1 because we used one
        prev_item = item
    
    # If result length != original, impossible
    return ''.join(result) if len(result) == len(items) else ""
```

### JavaScript Equivalents

**Template 1: Cooldown Scheduling**

```javascript
class MaxHeap {
    constructor() { this.heap = []; }
    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }
    pop() {
        if (this.heap.length === 0) return null;
        const top = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return top;
    }
    peek() { return this.heap[0]; }
    size() { return this.heap.length; }
    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.heap[parent] >= this.heap[i]) break;
            [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
            i = parent;
        }
    }
    _bubbleDown(i) {
        while (true) {
            let largest = i;
            const left = 2 * i + 1, right = 2 * i + 2;
            if (left < this.heap.length && this.heap[left] > this.heap[largest]) largest = left;
            if (right < this.heap.length && this.heap[right] > this.heap[largest]) largest = right;
            if (largest === i) break;
            [this.heap[i], this.heap[largest]] = [this.heap[largest], this.heap[i]];
            i = largest;
        }
    }
}

function taskSchedulerTemplate(tasks, cooldown) {
    // Count frequencies
    const count = new Map();
    for (const task of tasks) {
        count.set(task, (count.get(task) || 0) + 1);
    }
    
    // Max-heap of counts
    const maxHeap = new MaxHeap();
    for (const c of count.values()) maxHeap.push(c);
    
    let time = 0;
    const cooling = []; // [availableTime, remaining]
    
    while (maxHeap.size() > 0 || cooling.length > 0) {
        time++;
        
        // Move cooled tasks back
        while (cooling.length > 0 && cooling[0][0] <= time) {
            const [, remaining] = cooling.shift();
            maxHeap.push(remaining);
        }
        
        if (maxHeap.size() > 0) {
            const remaining = maxHeap.pop() - 1;
            if (remaining > 0) {
                cooling.push([time + cooldown + 1, remaining]);
            }
        }
    }
    
    return time;
}
```

**Template 2: Resource Allocation**

```javascript
class MinHeap {
    constructor() { this.heap = []; }
    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }
    pop() {
        if (this.heap.length === 0) return null;
        const top = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return top;
    }
    peek() { return this.heap[0]; }
    size() { return this.heap.length; }
    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.heap[parent] <= this.heap[i]) break;
            [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
            i = parent;
        }
    }
    _bubbleDown(i) {
        while (true) {
            let smallest = i;
            const left = 2 * i + 1, right = 2 * i + 2;
            if (left < this.heap.length && this.heap[left] < this.heap[smallest]) smallest = left;
            if (right < this.heap.length && this.heap[right] < this.heap[smallest]) smallest = right;
            if (smallest === i) break;
            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
            i = smallest;
        }
    }
}

function meetingRoomsTemplate(meetings) {
    if (meetings.length === 0) return 0;
    
    meetings.sort((a, b) => a[0] - b[0]); // Sort by start
    
    const endTimes = new MinHeap();
    endTimes.push(meetings[0][1]);
    
    for (let i = 1; i < meetings.length; i++) {
        const [start, end] = meetings[i];
        if (start >= endTimes.peek()) {
            endTimes.pop(); // Reuse room
        }
        endTimes.push(end);
    }
    
    return endTimes.size();
}
```

---

## üíª Quick Reference

### Problem Comparison

| Problem | Heap Type | Key Data Structure |
|---------|-----------|-------------------|
| Task Scheduler | Max + Queue | Track cooldowns |
| Meeting Rooms II | Min | End times |
| Reorganize String | Max | Counts + prev tracking |
| CPU Scheduler | Min | (start_time, task) |

---

## ‚ö° Complexity Analysis

| Problem | Time | Space | Bottleneck |
|---------|------|-------|------------|
| Task Scheduler |" O(n) or O(n log 26) "| O(1) - O(26) |" Math formula is O(n), heap is O(n log 26) "|
| Meeting Rooms II |" O(n log n) "| O(n) | Sorting dominates |
| Reorganize String |" O(n log k) "| O(k) | k = unique chars (‚â§26) |

**Why these complexities?**
- **Task Scheduler:** Math formula counts in O(n); heap processes each task O(log 26) = O(1)
- **Meeting Rooms:** Sort O(n log n) + heap ops O(n log n) = O(n log n)
- **Reorganize:** Each char processed once, heap op O(log k) where k ‚â§ 26

---

## üîÑ Variations

| Variation | Difference | Example Problem |
|-----------|------------|-----------------|
| With cooldown | Track cooling queue separately | Task Scheduler |
| Resource allocation | Min-heap of end times | Meeting Rooms II |
| No adjacent same | Previous tracking | Reorganize String |
| K distance apart | Extended cooldown | Rearrange String K Distance Apart (LC 358) |
| With deadlines | Priority by deadline | Course Schedule III (LC 630) |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Priority Queue Basics](../03-Priority-Queue/3.1-PQ-Basics.md)
- [Heap Operations](../02-Heap-Operations/2.1-Insert.md)
- Greedy algorithms concept

**Problems in this section:**
- [Task Scheduler (LC 621)](./7.2-Task-Scheduler-LC621.md)
- [Meeting Rooms II (LC 253)](./7.3-Meeting-Rooms-II-LC253.md)
- [Reorganize String (LC 767)](./7.4-Reorganize-String-LC767.md)

**Related patterns:**
- [Top K Pattern](../04-Top-K-Pattern/4.1-Top-K-Overview.md)
- [Two Heaps Pattern](../05-Two-Heaps-Pattern/5.1-Two-Heaps-Overview.md)

</details>

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting Cooldown Tracking

```python
# ‚ùå Wrong: Just using max-heap without cooldown
while max_heap:
    task = heappop(max_heap)
    # Where does task go after cooldown?

# ‚úÖ Correct: Track cooldown separately
cooling_queue = []  # (available_time, task)
```

### 2. Not Handling Empty Heap (Idle Time)

```python
# ‚ùå Wrong: Assuming heap always has tasks
for each time step:
    task = heappop(max_heap)  # Error if empty!

# ‚úÖ Correct: Check if heap empty (idle)
if max_heap:
    task = heappop(max_heap)
else:
    # Idle - just increment time
```

### 3. Wrong Heap Type for Problem

```python
# ‚ùå Wrong: Min-heap for task frequency
min_heap = [count for count in counts]  # Gets LEAST frequent first!

# ‚úÖ Correct: Max-heap for greedy (most frequent first)
max_heap = [-count for count in counts]
```

---

## üìù Practice Problems (Progressive)

### Easy (Foundation)
- [ ] [Last Stone Weight (LC 1046)](https://leetcode.com/problems/last-stone-weight/)

### Medium (Core scheduling)
- [ ] [Task Scheduler (LC 621)](https://leetcode.com/problems/task-scheduler/) ‚≠ê
- [ ] [Meeting Rooms II (LC 253)](https://leetcode.com/problems/meeting-rooms-ii/) ‚≠ê
- [ ] [Reorganize String (LC 767)](https://leetcode.com/problems/reorganize-string/) ‚≠ê
- [ ] [Distant Barcodes (LC 1054)](https://leetcode.com/problems/distant-barcodes/)

### Hard (Advanced)
- [ ] [Course Schedule III (LC 630)](https://leetcode.com/problems/course-schedule-iii/)
- [ ] [Maximum Performance of a Team (LC 1383)](https://leetcode.com/problems/maximum-performance-of-a-team/)

---

## üé§ Interview Context

<details>
<summary><strong>How to Approach Scheduling Problems</strong></summary>

**Identification:**
"When I see tasks with constraints like cooldowns or limited resources, I think about greedy scheduling with heaps."

**Strategy discussion:**
"For cooldown problems, I use a max-heap to always pick the most frequent task - this minimizes idle time. I track cooling tasks separately and add them back when available."

**For meeting rooms:**
"I sort by start time and use a min-heap of end times. For each meeting, if the earliest ending room is free, I reuse it. Otherwise, I need a new room."

**Complexity discussion:**
"Task Scheduler is O(n) with math optimization or O(n log 26) with heap. Meeting Rooms is O(n log n) due to sorting."

</details>

**Company Focus:**

| Company | Frequency | Common Problems |
|---------|-----------|-----------------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | All three |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Task Scheduler |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Meeting Rooms |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Meeting Rooms |

---

## ‚è±Ô∏è Time Estimates

| Problem | Time to Solve | Difficulty |
|---------|--------------|------------|
| Task Scheduler | 25-30 min | Medium |
| Meeting Rooms II | 20-25 min | Medium |
| Reorganize String | 20-25 min | Medium |

---

## üí° Key Insight

> **Scheduling problems are often greedy + heap.** The greedy choice (most frequent task, earliest ending room) is efficiently found using a heap. Track constraints (cooldowns, end times) separately and update the heap as resources become available.

---

## üîó Related

- **Next:** [Task Scheduler (LC 621)](./7.2-Task-Scheduler-LC621.md)
- **Patterns:** [Top K](../04-Top-K-Pattern/4.1-Top-K-Overview.md) | [Priority Queue Apps](../03-Priority-Queue/3.3-PQ-Applications.md)
