# When to Use Hash Map vs Hash Set vs Other

> **Choosing the right data structure is half the battle. Here's how to decide between hash-based structures and alternatives.**

This guide helps you quickly identify which data structure fits your problem, focusing on hash maps, hash sets, and when other options are better.

---

## ğŸ¯ Quick Decision Framework

<details>
<summary><strong>Decision Tree</strong></summary>

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    WHAT DO YOU NEED?                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                                       â”‚
   Need to store               Just checking existence
   key-value pairs?            or uniqueness?
        â”‚                                       â”‚
        â–¼                                       â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ HASH MAPâ”‚                            â”‚ HASH SETâ”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                                       â”‚
   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                            â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
   â”‚         â”‚                            â”‚         â”‚
Need sorted  No order                 Need sorted  No order
  keys?      needed                     values?    needed
   â”‚            â”‚                        â”‚            â”‚
   â–¼            â–¼                        â–¼            â–¼
 TreeMap    HashMap                   TreeSet     HashSet
```

</details>

---

## âœ… Hash Map - Use When

| Scenario | Example | Why Hash Map |
|----------|---------|--------------|
| **Key â†’ Value mapping** | Count characters | Need value per key |
| **Counting occurrences** | Word frequency | Key=item, Value=count |
| **Finding complements** | Two Sum | Store numâ†’index |
| **Grouping** | Group anagrams | Key=property, Value=list |
| **Caching/Memoization** | Fibonacci | Key=input, Value=result |
| **Last seen index** | Contains Duplicate II | Track positions |

**Code signals:**
```python
# You need a hash map if you're doing:
count[item] = count.get(item, 0) + 1   # Counting
seen[num] = index                       # Storing position
groups[key].append(item)                # Grouping
cache[args] = result                    # Memoization
mapping[a] = b                          # Transformation
```

---

## âœ… Hash Set - Use When

| Scenario | Example | Why Hash Set |
|----------|---------|--------------|
| **Membership testing** | Is X in collection? | O(1) contains |
| **Remove duplicates** | Unique elements | Sets auto-dedupe |
| **Tracking visited** | Graph BFS/DFS | Been here before? |
| **Finding intersection** | Common elements | Set operations |
| **Cycle detection** | Linked list cycle | Seen this node? |
| **Quick existence check** | Valid word in dict | O(1) lookup |

**Code signals:**
```python
# You need a hash set if you're doing:
if item in seen:              # Checking membership
seen.add(item)                # Recording existence
unique = set(items)           # Deduplication
a & b                         # Set intersection
if node in visited:           # Cycle/visited check
```

---

## âŒ DON'T Use Hash - Use These Instead

### When You Need Sorted Access

| Problem | Bad Choice | Good Choice | Why |
|---------|------------|-------------|-----|
| Kth smallest | Hash Map | Min-Heap, BST | Hash unsorted |
| Range queries | Hash Map | Segment Tree | Need [a,b] |
| Sorted iteration | Hash Set | TreeSet | Ordered access |
| Median stream | Hash Map | Two Heaps | Sorted halves |

### When Space is Critical

| Problem | Bad Choice | Good Choice | Why |
|---------|------------|-------------|-----|
| Single missing | Hash Set | XOR, Math | O(1) space |
| In-place dedup | Hash Set | Two pointers | O(1) space |
| Find duplicate | Hash Set | Cycle detection | Floyd's algo |

### When Array Index Works

| Problem | Bad Choice | Good Choice | Why |
|---------|------------|-------------|-----|
| Count chars (a-z) | Hash Map | Array[26] | Faster, less memory |
| Bitmap/flags | Hash Set | Bit array | 32x less memory |
| Known small range | Hash Map | Array | Direct indexing |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Learning Path</strong></summary>

**Before this, master:**
- [Hash Map Operations](./2.1-Hash-Map-Operations.md) - Core CRUD operations
- [Hash Set Operations](./2.2-Hash-Set-Operations.md) - Membership operations
- Basic complexity analysis (O(1) vs O(n) vs O(log n))

**After mastering this:**
- [Two Sum Pattern](../04-Two-Sum-Pattern/4.1-Two-Sum-Overview.md) - Classic hash application
- [Frequency Pattern](../03-Frequency-Pattern/3.1-Frequency-Overview.md) - Counting with hash
- [Grouping Pattern](../06-Grouping-Pattern/6.1-Grouping-Overview.md) - Categorizing data

**Connects to other structures:**
- Arrays â†’ Use when key range is small and bounded
- Trees (BST) â†’ Use when need sorted access
- Heaps â†’ Use for top-k or min/max tracking

</details>

---

## ğŸ”— Comparison Table

| Feature | Hash Map | Hash Set | Array | BST/TreeMap |
|---------|----------|----------|-------|-------------|
| Insert | O(1)* | O(1)* | O(1) amortized | O(log n) |
| Lookup | O(1)* | O(1)* | O(1) by index | O(log n) |
| Delete | O(1)* | O(1)* | O(n) | O(log n) |
| Ordered | âŒ | âŒ | âœ… by index | âœ… by key |
| Space | O(n) | O(n) | O(n) | O(n) |
| Memory | Higher | Higher | Lower | Higher |
| Range query | âŒ | âŒ | âŒ | âœ… |
| Min/Max | O(n) | O(n) | O(n) | O(log n) |

*Average case - worst is O(n)

---

## ğŸ“ Problem Type â†’ Data Structure

### Counting Problems

```
"Count occurrences of X"
"Find most frequent"
"Check if anagram"
        â”‚
        â–¼
    HASH MAP
    key=element, value=count
    
Alternative: Array if key range is small (e.g., 26 letters)
```

### Two Sum Style

```
"Find pair with sum X"
"Find complement"
"Match A with B"
        â”‚
        â–¼
    HASH MAP
    key=element, value=index (or element itself)
```

### Duplicates/Uniqueness

```
"Contains duplicate"
"Find unique element"
"Remove duplicates"
        â”‚
        â–¼
    HASH SET
    just track existence
    
Alternative: Sort + compare adjacent
Alternative: Bit manipulation (XOR)
```

### Grouping

```
"Group by property"
"Find all anagrams"
"Categorize elements"
        â”‚
        â–¼
    HASH MAP
    key=property, value=list of items
```

### Subarray Sum

```
"Subarray with sum K"
"Count subarrays with property"
        â”‚
        â–¼
    PREFIX SUM + HASH MAP
    key=prefix_sum, value=count or index
```

### Sliding Window + Uniqueness

```
"Longest substring without repeating"
"Window with K distinct"
        â”‚
        â–¼
    HASH MAP (for counts) or HASH SET (for presence)
```

### Sorted/Ordered Access

```
"Kth smallest/largest"
"Range of values"
"Ordered traversal"
        â”‚
        â–¼
    NOT HASH!
    Use: Heap, BST, Sorted Array
```

---

## ğŸ’» Code Examples: Choosing the Right Structure

### Example 1: Character Counting

```python
# Hash Map approach (general)
def is_anagram_hashmap(s, t):
    if len(s) != len(t):
        return False
    count = {}
    for c in s:
        count[c] = count.get(c, 0) + 1
    for c in t:
        if c not in count or count[c] == 0:
            return False
        count[c] -= 1
    return True

# Array approach (better for known alphabet)
def is_anagram_array(s, t):
    if len(s) != len(t):
        return False
    count = [0] * 26
    for c in s:
        count[ord(c) - ord('a')] += 1
    for c in t:
        count[ord(c) - ord('a')] -= 1
    return all(c == 0 for c in count)

# âœ… Use array when: characters are lowercase letters only
# âœ… Use hash map when: any Unicode characters possible
```

### Example 2: Find Missing Number

```python
# Hash Set approach - O(n) space
def missing_number_set(nums):
    n = len(nums)
    full_set = set(range(n + 1))
    return (full_set - set(nums)).pop()

# Math approach - O(1) space âœ… Better!
def missing_number_math(nums):
    n = len(nums)
    expected = n * (n + 1) // 2
    actual = sum(nums)
    return expected - actual

# XOR approach - O(1) space, avoids overflow
def missing_number_xor(nums):
    xor = len(nums)
    for i, num in enumerate(nums):
        xor ^= i ^ num
    return xor
```

### Example 3: Find Kth Largest

```python
import heapq

# âŒ Hash approach - doesn't help with ordering
def kth_largest_bad(nums, k):
    # Hash map/set doesn't help here!
    pass

# âœ… Heap approach - O(n log k)
def kth_largest_heap(nums, k):
    return heapq.nlargest(k, nums)[-1]

# âœ… QuickSelect approach - O(n) average
def kth_largest_quickselect(nums, k):
    k = len(nums) - k  # Convert to kth smallest
    
    def quickselect(l, r):
        pivot, p = nums[r], l
        for i in range(l, r):
            if nums[i] <= pivot:
                nums[p], nums[i] = nums[i], nums[p]
                p += 1
        nums[p], nums[r] = nums[r], nums[p]
        
        if p < k: return quickselect(p + 1, r)
        elif p > k: return quickselect(l, p - 1)
        else: return nums[p]
    
    return quickselect(0, len(nums) - 1)
```

### Example 4: When to Use Set vs Map

```python
# Set: Just need existence
def contains_duplicate(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    return False

# Map: Need additional info (index)
def contains_nearby_duplicate(nums, k):
    last_index = {}  # Need to store WHERE we saw it
    for i, num in enumerate(nums):
        if num in last_index and i - last_index[num] <= k:
            return True
        last_index[num] = i  # Store index, not just existence
    return False
```

---

## âš¡ Performance Comparison

| Operation | Hash | Array | Sorted Array | Heap | BST |
|-----------|------|-------|--------------|------|-----|
| Insert | O(1)* | O(1)â€  | O(n) | O(log n) | O(log n) |
| Search | O(1)* | O(n) | O(log n) | O(n) | O(log n) |
| Delete | O(1)* | O(n) | O(n) | O(log n) | O(log n) |
| Min/Max | O(n) | O(n) | O(1) | O(1)/O(n)â€¡ | O(log n) |
| kth element | O(n) | O(n) | O(1) | O(k log n) | O(log n) |
| Range query | O(n) | O(n) | O(log n + k) | N/A | O(log n + k) |

*Average, â€ Amortized at end, â€¡Min-heap O(1) for min, O(n) for max

---

## âš ï¸ Common Decision Mistakes

### 1. Using Hash When Array Works

```python
# âŒ Overkill: Hash for small fixed range
char_count = {}
for c in s:
    char_count[c] = char_count.get(c, 0) + 1

# âœ… Better: Array for 26 letters
char_count = [0] * 26
for c in s:
    char_count[ord(c) - ord('a')] += 1
```

### 2. Using Map When Set Suffices

```python
# âŒ Unnecessary: Storing dummy values
seen = {}
for num in nums:
    seen[num] = True  # Value never used!

# âœ… Better: Just use set
seen = set()
for num in nums:
    seen.add(num)
```

### 3. Using Hash for Ordered Data

```python
# âŒ Wrong tool: Hash can't give kth smallest
def kth_smallest(nums, k):
    s = set(nums)
    # Now what? Can't efficiently get kth element!

# âœ… Right tool: Use heap or sorting
import heapq
def kth_smallest(nums, k):
    return heapq.nsmallest(k, nums)[-1]
```

### 4. Not Considering Space Constraints

```python
# âŒ Space heavy: O(n) extra space
def find_duplicate(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)

# âœ… O(1) space: Floyd's cycle detection
def find_duplicate(nums):
    slow = fast = nums[0]
    while True:
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast:
            break
    slow = nums[0]
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]
    return slow
```

---

## ğŸ“ Practice Problems by Structure

### Hash Map Problems

| Problem | Pattern | Link |
|---------|---------|------|
| Two Sum | Complement lookup | [LC 1](https://leetcode.com/problems/two-sum/) |
| Group Anagrams | Grouping | [LC 49](https://leetcode.com/problems/group-anagrams/) |
| Subarray Sum K | Prefix + hash | [LC 560](https://leetcode.com/problems/subarray-sum-equals-k/) |
| LRU Cache | Map + ordering | [LC 146](https://leetcode.com/problems/lru-cache/) |

### Hash Set Problems

| Problem | Pattern | Link |
|---------|---------|------|
| Contains Duplicate | Existence check | [LC 217](https://leetcode.com/problems/contains-duplicate/) |
| Happy Number | Cycle detection | [LC 202](https://leetcode.com/problems/happy-number/) |
| Longest Consecutive | O(1) lookup | [LC 128](https://leetcode.com/problems/longest-consecutive-sequence/) |
| Intersection of Arrays | Set operation | [LC 349](https://leetcode.com/problems/intersection-of-two-arrays/) |

### Not Hash Problems

| Problem | Better Structure | Link |
|---------|------------------|------|
| Kth Largest | Heap | [LC 215](https://leetcode.com/problems/kth-largest-element-in-an-array/) |
| Median from Stream | Two Heaps | [LC 295](https://leetcode.com/problems/find-median-from-data-stream/) |
| Missing Number | Math/XOR | [LC 268](https://leetcode.com/problems/missing-number/) |
| Find Duplicate | Cycle detection | [LC 287](https://leetcode.com/problems/find-the-duplicate-number/) |

---

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

**For mastering data structure selection:**
- **Day 1:** Review decision tree, solve 2 easy problems with explicit structure choice
- **Day 3:** Without looking, draw decision tree from memory
- **Day 7:** Solve 3 medium problems, justify each structure choice out loud
- **Day 14:** Practice switching between hash/array/tree solutions for same problem
- **Day 30:** Quickly identify optimal structure for 10 random problems (< 30 seconds each)

**Key questions to ask yourself:**
1. Do I need key-value pairs or just existence?
2. Do I need sorted access or iteration order?
3. Is the key range bounded (can use array)?
4. What's my space budget?

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>Discussing Data Structure Choice</strong></summary>

**Verbalize your thinking:**
> "I need to track which elements I've seen, so I'll use a hash set for O(1) lookup."

> "I need to count occurrences, so I'll use a hash map with element as key and count as value."

> "The input is lowercase letters only, so instead of a hash map, I can use a 26-element array for better performance."

**When asked "can you do better?":**
- Check if you can use array instead of hash (if key range is small)
- Check if you can eliminate hash entirely (math, XOR, two pointers)
- Check if hash is even needed (maybe sorting works)

</details>

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Learn decision framework | 15 min |
| Practice choosing structures | 30 min |
| Solve 5 problems with explicit choice | 2 hours |

---

> **ğŸ’¡ Key Insight:** The best data structure depends on what questions you need to answer. Hash is great for "does X exist?" and "what's the value of X?", but wrong for "what's the kth smallest?" or "what's in range [a,b]?"

> **ğŸ”— Related:** [Hash Map Operations](./2.1-Hash-Map-Operations.md) | [Hash Set Operations](./2.2-Hash-Set-Operations.md) | [Heaps Overview](../../08-Heaps-Priority-Queues/01-Heap-Fundamentals/1.1-What-Is-Heap.md)
