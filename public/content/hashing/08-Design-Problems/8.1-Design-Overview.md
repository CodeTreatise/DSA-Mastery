# Hash-Based Design Problems Overview

> **Master designing data structures that leverage hashing for O(1) operations - a critical interview skill.**

Design problems test your ability to combine multiple data structures to achieve specific time/space complexities. Hash-based designs are among the most frequently asked in interviews.

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>How to Identify Design Problems</strong></summary>

**Problem signals:**
- "Design a data structure that..."
- "Implement X with O(1) operations"
- "Support insert, delete, getRandom"
- "Build a cache with..."
- "Create a class with methods..."

**Common requirements:**
```
O(1) lookup â†’ Need hash map
O(1) insert/delete â†’ Hash map/set
O(1) random access â†’ Array
O(1) order tracking â†’ Linked list / OrderedDict
Time-based â†’ Sorted structure or buckets
```

</details>

---

## âœ… When to Use Hash-Based Design

- Need O(1) average time operations
- Key-value storage with fast access
- Combining multiple access patterns
- Caching and memoization
- Tracking state efficiently

## âŒ When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need sorted order | Hash is unordered | TreeMap / BST |
| Range queries | No ordering support | Segment tree |
| Space critical | Hash has overhead | Arrays |
| Worst-case O(1) needed | Hash is amortized | Perfect hashing |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, master:**
- [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
- [Hash Set Operations](../02-Hash-Map-Set/2.2-Hash-Set-Operations.md)
- [Hash Fundamentals](../01-Hash-Fundamentals/1.1-What-Is-Hashing.md)

**Key design problems:**
- [Design HashMap (LC 706)](./8.2-Design-HashMap-LC706.md)
- [Design HashSet (LC 705)](./8.3-Design-HashSet-LC705.md)
- [LRU Cache (LC 146)](./8.4-LRU-Cache-LC146.md)
- [RandomizedSet (LC 380)](./8.5-RandomizedSet-LC380.md)

</details>

---

## ğŸ“ Design Problem Framework

### Step 1: Understand Requirements

```markdown
Questions to ask:
1. What operations are needed?
2. What are the time complexity requirements?
3. What are the space constraints?
4. What's the expected data scale?
5. Are there any ordering requirements?
```

### Step 2: Choose Data Structures

| Requirement | Primary Structure | Secondary Structure |
|-------------|------------------|-------------------|
| O(1) lookup | Hash Map | - |
| O(1) insert + delete | Hash Map/Set | - |
| O(1) random access | Array | Hash Map for indices |
| O(1) min/max | Heap | Hash for fast lookup |
| Maintain insertion order | OrderedDict | LinkedList + Hash |
| Time-based expiry | Hash Map | Doubly Linked List |

### Step 3: Handle Edge Cases

```python
# Common edge cases in design problems:
# 1. Empty structure operations
# 2. Duplicate keys/values
# 3. Capacity limits
# 4. Concurrent access (if mentioned)
# 5. Invalid inputs
```

---

## ğŸ’» Common Design Patterns

### Pattern 1: Hash Map + Doubly Linked List (LRU/LFU Cache)

```python
class Node:
    """Doubly linked list node with key-value."""
    def __init__(self, key=0, val=0):
        self.key = key
        self.val = val
        self.prev = None
        self.next = None

class DoublyLinkedList:
    """Doubly linked list with O(1) add/remove."""
    def __init__(self):
        self.head = Node()  # Dummy head
        self.tail = Node()  # Dummy tail
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def add_to_front(self, node):
        """Add node right after head."""
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def remove(self, node):
        """Remove node from list."""
        node.prev.next = node.next
        node.next.prev = node.prev
    
    def remove_last(self):
        """Remove and return node before tail."""
        if self.tail.prev == self.head:
            return None
        last = self.tail.prev
        self.remove(last)
        return last


# Usage: Hash Map stores key â†’ Node
# Linked List maintains access order
# O(1) for all operations!
```

### Pattern 2: Hash Map + Array (RandomizedSet)

```python
class RandomizedSet:
    """
    O(1) insert, delete, and getRandom.
    
    Key insight:
    - Array enables O(1) random access
    - Hash Map enables O(1) lookup by value
    - Swap-to-end trick enables O(1) deletion
    """
    def __init__(self):
        self.val_to_idx = {}  # value â†’ index in array
        self.values = []      # actual values
    
    def insert(self, val):
        if val in self.val_to_idx:
            return False
        self.val_to_idx[val] = len(self.values)
        self.values.append(val)
        return True
    
    def remove(self, val):
        if val not in self.val_to_idx:
            return False
        # Swap with last element
        idx = self.val_to_idx[val]
        last = self.values[-1]
        self.values[idx] = last
        self.val_to_idx[last] = idx
        # Remove last element
        self.values.pop()
        del self.val_to_idx[val]
        return True
    
    def getRandom(self):
        import random
        return random.choice(self.values)
```

### Pattern 3: Chaining/Open Addressing (Design HashMap)

```python
class MyHashMap:
    """
    Hash map using chaining (linked list buckets).
    """
    def __init__(self):
        self.size = 1000
        self.buckets = [[] for _ in range(self.size)]
    
    def _hash(self, key):
        return key % self.size
    
    def put(self, key, value):
        idx = self._hash(key)
        for i, (k, v) in enumerate(self.buckets[idx]):
            if k == key:
                self.buckets[idx][i] = (key, value)
                return
        self.buckets[idx].append((key, value))
    
    def get(self, key):
        idx = self._hash(key)
        for k, v in self.buckets[idx]:
            if k == key:
                return v
        return -1
    
    def remove(self, key):
        idx = self._hash(key)
        for i, (k, v) in enumerate(self.buckets[idx]):
            if k == key:
                self.buckets[idx].pop(i)
                return
```

### Pattern 4: Multiple Hash Maps (Complex Relationships)

```python
class BiMap:
    """
    Bidirectional mapping (like for Isomorphic Strings design).
    """
    def __init__(self):
        self.key_to_val = {}
        self.val_to_key = {}
    
    def put(self, key, val):
        # Remove old mappings if they exist
        if key in self.key_to_val:
            old_val = self.key_to_val[key]
            del self.val_to_key[old_val]
        if val in self.val_to_key:
            old_key = self.val_to_key[val]
            del self.key_to_val[old_key]
        
        # Add new mappings
        self.key_to_val[key] = val
        self.val_to_key[val] = key
```

---

## ğŸ”„ Classic Design Problems

| Problem | Data Structures | Key Insight |
|---------|----------------|-------------|
| HashMap | Array + Chaining | Collision handling |
| HashSet | Array + Chaining | Simplified HashMap |
| LRU Cache | HashMap + DLL | Order by recency |
| LFU Cache | HashMap + Frequency buckets | Order by frequency |
| RandomizedSet | HashMap + Array | Swap-to-end deletion |
| TimeMap | HashMap + Binary Search | Sorted timestamps |
| All O(1) DS | HashMap + DLL | Multiple constraints |

---

## âš¡ Complexity Requirements

| Operation | Typical Target | How to Achieve |
|-----------|---------------|----------------|
| get/put | O(1) average | Hash Map |
| insert/delete | O(1) | Hash Map/Set |
| getRandom | O(1) | Array |
| getMin/getMax | O(1) | Track separately or heap |
| Order tracking | O(1) move | Doubly Linked List |

---

## âš ï¸ Common Design Mistakes

### 1. Not Handling Edge Cases

```python
# âŒ WRONG: No duplicate handling
def insert(self, val):
    self.values.append(val)
    return True  # Always returns True

# âœ… CORRECT: Check for duplicates
def insert(self, val):
    if val in self.val_to_idx:
        return False  # Already exists
    self.val_to_idx[val] = len(self.values)
    self.values.append(val)
    return True
```

### 2. Incorrect Deletion from Array

```python
# âŒ WRONG: O(n) deletion from middle
def remove(self, val):
    idx = self.val_to_idx[val]
    self.values.pop(idx)  # O(n) - shifts all elements!

# âœ… CORRECT: Swap with last, then pop
def remove(self, val):
    idx = self.val_to_idx[val]
    last = self.values[-1]
    # Swap
    self.values[idx] = last
    self.val_to_idx[last] = idx
    # Pop last (O(1))
    self.values.pop()
    del self.val_to_idx[val]
```

### 3. Forgetting to Update All Data Structures

```python
# âŒ WRONG: Only updating one structure
class LRUCache:
    def put(self, key, value):
        self.cache[key] = value
        # Forgot to update linked list order!

# âœ… CORRECT: Update all structures
class LRUCache:
    def put(self, key, value):
        if key in self.cache:
            # Update value AND move to front
            node = self.cache[key]
            node.val = value
            self._move_to_front(node)
        else:
            # Add new node to hash AND list
            node = Node(key, value)
            self.cache[key] = node
            self._add_to_front(node)
            # Handle capacity...
```

### 4. Capacity Boundary Issues

```python
# âŒ WRONG: Check capacity after adding
def put(self, key, value):
    self.cache[key] = Node(key, value)
    if len(self.cache) > self.capacity:
        self._evict()  # May evict the just-added item!

# âœ… CORRECT: Check capacity before adding new items
def put(self, key, value):
    if key in self.cache:
        # Update existing - no capacity change
        self._update(key, value)
    else:
        if len(self.cache) >= self.capacity:
            self._evict()  # Make room first
        self._add_new(key, value)
```

---

## ğŸ“ Practice Problems (Progressive)

| Problem | Difficulty | Key Structures | Link |
|---------|------------|----------------|------|
| Design HashSet | ğŸŸ¢ Easy | Array + Chaining | [LC 705](https://leetcode.com/problems/design-hashset/) |
| Design HashMap | ğŸŸ¢ Easy | Array + Chaining | [LC 706](https://leetcode.com/problems/design-hashmap/) |
| LRU Cache | ğŸŸ¡ Medium | HashMap + DLL | [LC 146](https://leetcode.com/problems/lru-cache/) |
| Insert Delete GetRandom | ğŸŸ¡ Medium | HashMap + Array | [LC 380](https://leetcode.com/problems/insert-delete-getrandom-o1/) |
| LFU Cache | ğŸ”´ Hard | HashMap + Freq buckets | [LC 460](https://leetcode.com/problems/lfu-cache/) |
| All O(1) Data Structure | ğŸ”´ Hard | HashMap + DLL | [LC 432](https://leetcode.com/problems/all-oone-data-structure/) |
| Time Based Key-Value | ğŸŸ¡ Medium | HashMap + Binary Search | [LC 981](https://leetcode.com/problems/time-based-key-value-store/) |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Design HashMap and HashSet
- **Day 3:** LRU Cache (master the DLL pattern)
- **Day 7:** RandomizedSet (swap-to-end trick)
- **Day 14:** LFU Cache (combine patterns)
- **Day 30:** Mix of problems, < 20 min each

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Approach Design Problems</strong></summary>

**1. Clarify Requirements (2 min):**
> "What operations do I need to support? What are the time complexity requirements? Any space constraints?"

**2. Propose High-Level Design (2 min):**
> "For O(1) get and put, I'll use a hash map. For maintaining access order in LRU, I'll use a doubly linked list alongside the map."

**3. Discuss Trade-offs:**
> "Using a doubly linked list adds O(n) space but enables O(1) order updates. Alternatively, I could use OrderedDict in Python which combines both."

**4. Implement Core Operations:**
> Write code for main operations, explaining each step.

**5. Handle Edge Cases:**
> "I need to handle: empty cache, duplicate keys, capacity limits..."

</details>

**Company Frequency:**

| Company | Frequency | Common Problems |
|---------|-----------|-----------------|
| Amazon | â­â­â­â­â­ | LRU Cache, RandomizedSet |
| Meta | â­â­â­â­â­ | LRU, LFU, Design problems |
| Google | â­â­â­â­â­ | Complex designs |
| Microsoft | â­â­â­â­ | LRU Cache |
| Netflix | â­â­â­â­â­ | Cache designs |

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Clarify requirements | 2 min |
| High-level design | 3 min |
| Implement | 15-20 min |
| Test edge cases | 5 min |
| **Total** | **25-30 min** |

---

> **ğŸ’¡ Key Insight:** Design problems test your ability to combine data structures. Hash maps provide O(1) lookup, but often need auxiliary structures (arrays, linked lists) to support additional requirements like random access or order tracking.

> **ğŸ”— Related:** [Design HashMap](./8.2-Design-HashMap-LC706.md) | [LRU Cache](./8.4-LRU-Cache-LC146.md) | [RandomizedSet](./8.5-RandomizedSet-LC380.md)
