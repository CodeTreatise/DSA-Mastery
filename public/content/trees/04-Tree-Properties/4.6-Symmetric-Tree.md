# 4.6 - Symmetric Tree (LC 101)

> **Grokking Pattern:** #11 Tree DFS (Mirror Comparison)
>
> **Difficulty:** Easy | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very Common

---

## Problem Statement

Given the `root` of a binary tree, check whether it is a **mirror of itself** (i.e., symmetric around its center).

```
Input: root = [1,2,2,3,4,4,3]
        1
       / \
      2   2
     / \ / \
    3  4 4  3

Output: true (left side mirrors right side)
```

```
Input: root = [1,2,2,null,3,null,3]
        1
       / \
      2   2
       \   \
        3   3

Output: false (3s are on same side, not mirrored)
```

[LeetCode 101 - Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Symmetric" or "mirror image"
- Compare left subtree with right subtree
- Mirrored comparison (left-right vs right-left)

**Key insight:**
A tree is symmetric if its left subtree is a mirror of its right subtree.

**Mirror comparison:**
- Compare `left.left` with `right.right` (outer)
- Compare `left.right` with `right.left` (inner)

This is similar to [Same Tree](./4.5-Same-Tree.md) but with mirrored comparison.

</details>

---

## ‚úÖ When to Use

- Checking tree symmetry
- Mirror image comparison
- Palindrome-like tree structures

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Check if two trees identical | Not mirrored | Same Tree |
| Check if tree balanced | Different property | Balanced Tree |
| Find specific node | Not comparison | Tree search |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Same Tree](./4.5-Same-Tree.md) - Similar comparison pattern
- [DFS Concept](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)

**After mastering this:**
- [Invert Binary Tree](./4.7-Invert-Binary-Tree.md)
- Mirror construction problems

**Related:**
- Same Tree with swapped comparison directions

</details>

---

## üìê How It Works

### Mirror Property

```
For a symmetric tree:
       1
      / \
     2   2
    / \ / \
   3  4 4  3

Left subtree:      Right subtree (mirrored):
    2                   2
   / \                 / \
  3   4               4   3

To compare:
- left.val must equal right.val
- left.left must mirror right.right (outer pair)
- left.right must mirror right.left (inner pair)
```

### Same Tree vs Symmetric Tree

```
Same Tree:
isSame(left, right):
    return left.left == right.left AND left.right == right.right

Symmetric Tree:
isMirror(left, right):
    return left.left == right.right AND left.right == right.left
    
Just swap the comparison directions!
```

### Visualization

```
        1
       / \
      2   2
     / \ / \
    3  4 4  3

Check mirror(node2_left, node2_right):
1. node2_left.val (2) == node2_right.val (2) ‚úì
2. mirror(3, 3) - outer pair ‚Üí 3.val == 3.val ‚úì
3. mirror(4, 4) - inner pair ‚Üí 4.val == 4.val ‚úì
4. All leaf children are null pairs ‚úì
```

---

## üíª Code Implementation

### Solution 1: Recursive DFS

**Python:**
```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def is_symmetric(root: Optional[TreeNode]) -> bool:
    """
    Check if tree is symmetric around its center.
    
    Time: O(n), Space: O(h)
    """
    if not root:
        return True
    
    def is_mirror(left, right):
        """Check if two subtrees are mirrors of each other."""
        # Both null ‚Üí symmetric
        if not left and not right:
            return True
        
        # One null ‚Üí not symmetric
        if not left or not right:
            return False
        
        # Values must match AND
        # Outer pair (left.left, right.right) must mirror AND
        # Inner pair (left.right, right.left) must mirror
        return (left.val == right.val and
                is_mirror(left.left, right.right) and   # Outer
                is_mirror(left.right, right.left))      # Inner
    
    return is_mirror(root.left, root.right)
```

**JavaScript:**
```javascript
function isSymmetric(root) {
    if (!root) return true;
    
    function isMirror(left, right) {
        if (!left && !right) return true;
        if (!left || !right) return false;
        
        return left.val === right.val &&
               isMirror(left.left, right.right) &&  // Outer
               isMirror(left.right, right.left);    // Inner
    }
    
    return isMirror(root.left, root.right);
}
```

### Solution 2: Iterative with Queue

**Python:**
```python
from collections import deque

def is_symmetric_iterative(root: Optional[TreeNode]) -> bool:
    """
    Iterative check using queue.
    
    Compare pairs level by level.
    Time: O(n), Space: O(w)
    """
    if not root:
        return True
    
    queue = deque([(root.left, root.right)])
    
    while queue:
        left, right = queue.popleft()
        
        # Both null ‚Üí continue
        if not left and not right:
            continue
        
        # One null or values differ
        if not left or not right or left.val != right.val:
            return False
        
        # Add mirrored pairs
        queue.append((left.left, right.right))   # Outer
        queue.append((left.right, right.left))   # Inner
    
    return True
```

**JavaScript:**
```javascript
function isSymmetricIterative(root) {
    if (!root) return true;
    
    const queue = [[root.left, root.right]];
    
    while (queue.length > 0) {
        const [left, right] = queue.shift();
        
        if (!left && !right) continue;
        if (!left || !right || left.val !== right.val) {
            return false;
        }
        
        queue.push([left.left, right.right]);
        queue.push([left.right, right.left]);
    }
    
    return true;
}
```

### Solution 3: Iterative with Stack

**Python:**
```python
def is_symmetric_stack(root: Optional[TreeNode]) -> bool:
    """
    Iterative with stack (DFS style).
    """
    if not root:
        return True
    
    stack = [(root.left, root.right)]
    
    while stack:
        left, right = stack.pop()
        
        if not left and not right:
            continue
        
        if not left or not right or left.val != right.val:
            return False
        
        stack.append((left.left, right.right))
        stack.append((left.right, right.left))
    
    return True
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Recursive |" O(n) "| O(h) | h = height |
| Queue |" O(n) "| O(w) | w = max width |
| Stack |" O(n) "| O(h) | Similar to recursive |

---

## üîÑ Variations

| Variation | Difference | Notes |
|-----------|------------|-------|
| Flip to make symmetric | Modify tree | Tree modification |
| Check if can become symmetric | Count differences | - |
| Symmetric with value condition | Additional constraints | - |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Comparison Pairs

```python
# ‚ùå WRONG: Same comparison as Same Tree
return (is_mirror(left.left, right.left) and    # Wrong!
        is_mirror(left.right, right.right))      # Wrong!

# ‚úÖ CORRECT: Mirror comparison
return (is_mirror(left.left, right.right) and   # Outer pair
        is_mirror(left.right, right.left))      # Inner pair
```

### 2. Forgetting to Compare Root's Children

```python
# ‚ùå WRONG: Comparing root with itself
def is_symmetric(root):
    return is_mirror(root, root)  # Always true!

# ‚úÖ CORRECT: Compare left and right subtrees
def is_symmetric(root):
    if not root:
        return True
    return is_mirror(root.left, root.right)
```

### 3. Not Handling Single Child

```python
# Tree:
#     1
#    / \
#   2   2
#  /     \
# 3       3   ‚Üê This IS symmetric!

# Tree:
#     1
#    / \
#   2   2
#  /   /
# 3   3       ‚Üê This is NOT symmetric!

# The null positions must also mirror
```

---

## üìù Practice Problems

### This Problem
- [ ] [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/) - LC 101

### Related Problems
- [ ] [Same Tree](https://leetcode.com/problems/same-tree/) - LC 100
- [ ] [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/) - LC 226
- [ ] [Flip Equivalent Binary Trees](https://leetcode.com/problems/flip-equivalent-binary-trees/) - LC 951

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Recursive solution - focus on mirror pairs
**Day 3:** Draw out the comparison diagram
**Day 7:** Iterative solution
**Day 14:** Solve without notes, explain to someone

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Explaining the insight:**
> "A symmetric tree is one where the left subtree is a mirror of the right subtree. I'll compare them recursively, but with mirrored indices: left's left with right's right, and left's right with right's left."

**Clarifying the comparison:**
> "This is like Same Tree, but instead of comparing left-left and right-right, I compare left-left with right-right and left-right with right-left - the mirror comparison."

**Follow-up - Iterative:**
> "For iterative, I can use a queue and add pairs to compare. Each iteration, I pop a pair, check if they match, and add the mirrored child pairs."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Often asked |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask iterative |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Classic interview |
| Apple | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Recursive solution | 5-7 min | Key: mirror comparison |
| Iterative solution | 7-10 min | If asked |
| Explain difference from Same Tree | 2 min | Important distinction |

---

> **üí° Key Insight:** Symmetric Tree is Same Tree with swapped comparisons. Instead of comparing `(left.left, right.left)`, compare `(left.left, right.right)`. This "mirror swap" pattern is useful whenever you need to check for reflection symmetry.

---

## üîó Related

- [Same Tree](./4.5-Same-Tree.md)
- [Invert Binary Tree](./4.7-Invert-Binary-Tree.md)
- [DFS Concept](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
