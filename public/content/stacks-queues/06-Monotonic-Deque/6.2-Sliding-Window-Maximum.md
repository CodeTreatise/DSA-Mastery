# 6.2 Sliding Window Maximum (LC 239)

> **Grokking Pattern:** #32 Monotonic Queue
>
> **Difficulty:** Hard | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Must-Know Problem

---

## Problem Statement

You are given an array of integers `nums`, and a sliding window of size `k` moving from left to right. Return the maximum value in each window.

```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]

Explanation:
Window [1,3,-1]    ‚Üí max = 3
Window [3,-1,-3]   ‚Üí max = 3
Window [-1,-3,5]   ‚Üí max = 5
Window [-3,5,3]    ‚Üí max = 5
Window [5,3,6]     ‚Üí max = 6
Window [3,6,7]     ‚Üí max = 7
```

[LeetCode 239 - Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Sliding window of size k"
- "Maximum/minimum in each window"
- Need O(1) per window (total O(n))

**Why Monotonic Deque?**
- Brute force: O(nk) - scan each window
- Heap: O(n log k) - but can't efficiently remove expired elements
- Monotonic Deque: O(n) - each element added/removed once

**Key insight:**
When the window slides, we need to:
1. Remove elements that exit the window (from front)
2. Add the new element (from back)
3. Query the maximum (front of deque)

</details>

---

## ‚úÖ When to Use This Approach

- Finding max/min in each sliding window
- O(n) time required
- Window size is fixed

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Variable window size | Different tracking needed | Different approach |
| Need median, not max | Deque tracks extrema only | Two heaps |
| Very small k | Brute force may be simpler |" O(nk) scan "|
| Random access to window | Deque is sequential | Segment Tree / RMQ |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Monotonic Deque Concept](./6.1-Monotonic-Deque-Concept.md)
- [Deque data structure](../05-Queue-Fundamentals/5.3-Deque.md)

**After mastering this:**
- [Jump Game VI](https://leetcode.com/problems/jump-game-vi/) - LC 1696
- [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/) - LC 1425
- [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/) - LC 862

**This combines:**
- Monotonic ordering (for max/min tracking)
- Sliding window (for range processing)

</details>

---

## üìê How It Works

### Strategy

Maintain a **decreasing deque** of indices:
1. Front of deque = index of current maximum
2. Back of deque = most recently added index
3. All values are in decreasing order

### Why Decreasing Order?

- The maximum is always at the front
- When we add a new element, smaller elements behind it can never be the max
- Remove them to maintain decreasing order

### Visual Walkthrough

```
nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3

Legend: deque stores INDICES, values shown in parentheses

i=0: val=1
     Deque: empty ‚Üí push 0
     Deque: [0(1)]
     Window incomplete

i=1: val=3
     3 > 1, pop 0
     Deque: [] ‚Üí push 1
     Deque: [1(3)]
     Window incomplete

i=2: val=-1
     -1 < 3, no pop
     Deque: [1(3)] ‚Üí push 2
     Deque: [1(3), 2(-1)]
     Window [0,2] complete!
     Result: [3]

i=3: val=-3
     -3 < -1, no pop
     Deque: [1(3), 2(-1)] ‚Üí push 3
     Deque: [1(3), 2(-1), 3(-3)]
     Check expiration: 1 >= 3-3+1=1 ‚úì still valid
     Result: [3, 3]

i=4: val=5
     5 > -3, pop 3
     5 > -1, pop 2
     5 > 3, pop 1
     Deque: [] ‚Üí push 4
     Deque: [4(5)]
     Check expiration: 4 >= 4-3+1=2 ‚úì
     Result: [3, 3, 5]

i=5: val=3
     3 < 5, no pop
     Deque: [4(5)] ‚Üí push 5
     Deque: [4(5), 5(3)]
     Check expiration: 4 >= 5-3+1=3 ‚úì
     Result: [3, 3, 5, 5]

i=6: val=6
     6 > 3, pop 5
     6 > 5, pop 4
     Deque: [] ‚Üí push 6
     Deque: [6(6)]
     Result: [3, 3, 5, 5, 6]

i=7: val=7
     7 > 6, pop 6
     Deque: [] ‚Üí push 7
     Deque: [7(7)]
     Check expiration: 7 >= 7-3+1=5 ‚úì
     Result: [3, 3, 5, 5, 6, 7]
```

---

## üíª Code Implementation

### Solution: Monotonic Deque

**Python:**
```python
from collections import deque
from typing import List

def max_sliding_window(nums: List[int], k: int) -> List[int]:
    """
    Find maximum in each sliding window of size k.
    
    Pattern: Monotonic Deque (decreasing)
    Time: O(n), Space: O(k)
    
    Invariant: deque stores indices with decreasing values
    Front = index of current maximum
    """
    result = []
    dq = deque()  # stores indices
    
    for i in range(len(nums)):
        # Step 1: Remove expired element from front
        # Left boundary of window is i - k + 1
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Step 2: Remove smaller elements from back
        # They can never be the maximum while current exists
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        # Step 3: Add current index
        dq.append(i)
        
        # Step 4: Record maximum when window is complete
        # Window is complete starting at index k-1
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result


def max_sliding_window_verbose(nums: List[int], k: int) -> List[int]:
    """
    More explicit version showing each step.
    """
    if not nums or k == 0:
        return []
    
    n = len(nums)
    result = []
    dq = deque()
    
    # Process first k elements (initial window)
    for i in range(k):
        # Remove smaller elements from back
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        dq.append(i)
    
    # First window's maximum
    result.append(nums[dq[0]])
    
    # Process remaining elements
    for i in range(k, n):
        # Remove expired front
        if dq[0] <= i - k:
            dq.popleft()
        
        # Remove smaller elements
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        dq.append(i)
        result.append(nums[dq[0]])
    
    return result
```

**JavaScript:**
```javascript
/**
 * Sliding window maximum using monotonic deque.
 * Pattern: Monotonic Deque (decreasing)
 * Time: O(n), Space: O(k)
 */
function maxSlidingWindow(nums, k) {
    const result = [];
    const deque = []; // stores indices
    
    for (let i = 0; i < nums.length; i++) {
        // Remove expired element from front
        if (deque.length > 0 && deque[0] < i - k + 1) {
            deque.shift();
        }
        
        // Remove smaller elements from back
        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop();
        }
        
        // Add current index
        deque.push(i);
        
        // Record maximum when window complete
        if (i >= k - 1) {
            result.push(nums[deque[0]]);
        }
    }
    
    return result;
}

// Using optimized deque (avoid shift() which is O(k))
function maxSlidingWindowOptimized(nums, k) {
    const result = [];
    const deque = [];
    let front = 0; // front pointer to avoid shift()
    
    for (let i = 0; i < nums.length; i++) {
        // Remove expired element from front
        if (front < deque.length && deque[front] < i - k + 1) {
            front++;
        }
        
        // Remove smaller elements from back
        while (front < deque.length && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop();
        }
        
        deque.push(i);
        
        if (i >= k - 1) {
            result.push(nums[deque[front]]);
        }
    }
    
    return result;
}
```

### Alternative: Using Max Heap (O(n log k))

**Python:**
```python
import heapq
from typing import List

def max_sliding_window_heap(nums: List[int], k: int) -> List[int]:
    """
    Alternative approach using max heap.
    Time: O(n log n) worst case, O(n log k) average
    Space: O(n)
    
    Note: Less efficient than monotonic deque
    """
    result = []
    # Max heap: store (-value, index) for max extraction
    heap = []
    
    for i in range(len(nums)):
        # Add current element (negate for max heap)
        heapq.heappush(heap, (-nums[i], i))
        
        # Remove elements outside window (lazy deletion)
        while heap[0][1] <= i - k:
            heapq.heappop(heap)
        
        # Record maximum when window complete
        if i >= k - 1:
            result.append(-heap[0][0])
    
    return result
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Monotonic Deque |" O(n) "| O(k) | Optimal |
| Max Heap |" O(n log n) "| O(n) | Lazy deletion |
| Brute Force |" O(nk) "| O(1) | Scan each window |

**Why Monotonic Deque is O(n)?**
- Each element is added to deque exactly once
- Each element is removed from deque at most once
- Operations on deque front/back are O(1)
- Total: 2n operations ‚Üí O(n)

**Why O(k) space?**
- At any time, deque contains at most k elements (window size)
- Elements expire as window moves

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| Minimum instead of Max | Use increasing deque | Sliding Window Minimum |
| Both Min and Max | Two deques | Range Min-Max Query |
| Variable k | Different expiration check | Jump Game VI |
| With additional constraint | Add condition to deque | Constrained Subsequence Sum |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Checking Expiration After Adding

```python
# ‚ùå WRONG: Check expiration after adding
dq.append(i)
if dq[0] < i - k + 1:
    dq.popleft()

# ‚úÖ CORRECT: Check expiration before processing
if dq and dq[0] < i - k + 1:
    dq.popleft()
# ... then add
```

### 2. Using Values Instead of Indices

```python
# ‚ùå WRONG: Can't track expiration
dq.append(nums[i])

# ‚úÖ CORRECT: Store indices
dq.append(i)
# Use nums[dq[0]] to get the value
```

### 3. Returning Result Too Early

```python
# ‚ùå WRONG: Return before window is complete
for i in range(len(nums)):
    # ...
    result.append(nums[dq[0]])  # Wrong! First k-1 windows incomplete

# ‚úÖ CORRECT: Start returning after first window
if i >= k - 1:
    result.append(nums[dq[0]])
```

### 4. Wrong Expiration Check

```python
# ‚ùå WRONG: Off by one
if dq[0] < i - k:  # Too strict

# ‚úÖ CORRECT: Left boundary is i - k + 1
if dq[0] < i - k + 1:
    dq.popleft()
```

---

## üìù Practice Problems (Progressive)

### This Problem
- [ ] [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) - LC 239 ‚≠ê

### Related Problems
- [ ] [Jump Game VI](https://leetcode.com/problems/jump-game-vi/) - LC 1696 (DP + Deque)
- [ ] [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/) - LC 1425
- [ ] [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/) - LC 862
- [ ] [Max Value of Equation](https://leetcode.com/problems/max-value-of-equation/) - LC 1499

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement and trace through examples
**Day 3:** Code from memory, handle edge cases
**Day 7:** Solve without looking at notes
**Day 14:** Solve Jump Game VI (applies same pattern)
**Day 21:** Tackle Shortest Subarray with Sum ‚â• K

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Start with brute force:**
> "The naive approach scans each window for the maximum, giving O(nk). Can we do better?"

**Introduce optimization:**
> "I notice that as the window slides, most elements remain the same. I can use a data structure to track the maximum efficiently."

**Explain deque choice:**
> "A monotonic decreasing deque works here. The front is always the maximum. When I add a new element, I remove smaller elements from the back since they can never be the max while a larger element exists. I also remove expired elements from the front."

**Trace through example:**
> "Let me walk through with [1,3,-1,-3,5,3], k=3..."

**Discuss complexity:**
> "Each element is added once and removed at most once, so total time is O(n). Space is O(k) for the deque."

**Handle follow-up: "What about minimum?"**
> "For minimum, I'd just change the comparison to maintain an increasing deque instead of decreasing."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common, must know |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Frequently asked |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Tests data structure choice |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask variations |
| Bloomberg | ‚≠ê‚≠ê‚≠ê | Finance-related follow-ups |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Read examples carefully |
| Discuss approaches | 3-5 min | Brute force ‚Üí Heap ‚Üí Deque |
| Implement | 12-15 min | Include edge cases |
| Test & debug | 5-7 min | Walk through example |
| Interview target | 25-30 min | Including explanation |

---

> **üí° Key Insight:** The monotonic deque acts like a "self-cleaning priority queue." As new elements arrive, elements that can never be the answer automatically get removed. The front is always the current maximum because larger elements push out smaller ones, and expired elements are removed as the window slides.

---

## üîó Related

- [Monotonic Deque Concept](./6.1-Monotonic-Deque-Concept.md) - Pattern overview
- [Monotonic Stack Concept](../03-Monotonic-Stack/3.1-Monotonic-Stack-Concept.md) - Related pattern
- [Sliding Window Technique](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/02-Sliding-Window.md) - Foundation
