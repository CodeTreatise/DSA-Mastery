# What Is Hashing?

> **Hashing transforms data into fixed-size values for ultra-fast O(1) lookups.**

Hashing is one of the most powerful techniques in computer science, enabling constant-time operations for searching, inserting, and deleting data. Understanding hashing deeply will help you recognize when and how to apply it in interview problems.

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Think About Hashing</strong></summary>

**Problem signals:**
- "Find if exists in O(1)"
- "Count occurrences"
- "Check for duplicates"
- "Find complement/pair"
- "Group similar elements"
- "Remove duplicates"
- Need fast lookup/membership testing

**Hashing is the go-to when:**
- You need O(1) average-case lookup
- You're trading space for time
- Order doesn't matter

</details>

---

## ‚úÖ When to Use Hashing

- Fast lookup needed (O(1) average)
- Counting/frequency problems
- Finding duplicates
- Two Sum style problems (finding complements)
- Grouping elements by property
- Caching/memoization
- Set operations (union, intersection)

## ‚ùå When NOT to Use Hashing

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need sorted order | Hash tables unordered | BST, sorted array |
| Need range queries | Can't do [a,b] efficiently | Segment tree, BST |
| Worst-case O(1) guarantee | Hash has O(n) worst | Perfect hashing, arrays |
| Memory-constrained | Uses extra space | In-place algorithms |
| Keys not hashable | Can't compute hash | Custom comparison |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- Basic array operations
- Time/space complexity basics
- [Big O notation](../../00-Prerequisites.md#complexity)

**After this, learn:**
- [Hash Functions](./1.2-Hash-Functions.md)
- [Collision Handling](./1.3-Collision-Handling.md)
- [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
- [Hash Set Operations](../02-Hash-Map-Set/2.2-Hash-Set-Operations.md)

**Patterns using hashing:**
- [Two Sum Pattern](../04-Two-Sum-Pattern/4.1-Two-Sum-Overview.md)
- [Frequency Pattern](../03-Frequency-Pattern/3.1-Frequency-Overview.md)
- [Grouping Pattern](../06-Grouping-Pattern/6.1-Grouping-Overview.md)

</details>

---

## üìê How It Works

### The Core Idea

Hashing transforms any data into an integer (hash code) that serves as an index into an array.

```
Data ‚Üí Hash Function ‚Üí Hash Code ‚Üí Array Index ‚Üí Stored Value

"apple" ‚Üí hash("apple") ‚Üí 97342158 ‚Üí 97342158 % 100 ‚Üí 58 ‚Üí bucket[58]
```

### Why Hashing is Fast

Without hashing (unsorted array):
```
Finding "apple" in ["banana", "cherry", "apple", "date"]
‚Üí Check each element: O(n)
```

With hashing:
```
hash("apple") ‚Üí 58
array[58] ‚Üí "apple"  
‚Üí Direct access: O(1)
```

### Visual Representation

```
Hash Table with 10 buckets:

Keys: "cat", "dog", "ant", "bat"

Hash Function: sum of ASCII values % 10

"cat" ‚Üí (99+97+116) % 10 = 312 % 10 = 2
"dog" ‚Üí (100+111+103) % 10 = 314 % 10 = 4
"ant" ‚Üí (97+110+116) % 10 = 323 % 10 = 3
"bat" ‚Üí (98+97+116) % 10 = 311 % 10 = 1

Index:  0    1      2      3      4      5    6    7    8    9
       [ ] [bat]  [cat]  [ant]  [dog]  [ ]  [ ]  [ ]  [ ]  [ ]

Looking up "dog":
1. Hash "dog" ‚Üí 4
2. Access array[4] ‚Üí "dog"
3. Done in O(1)!
```

### Hash Table Components

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      HASH TABLE                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                              ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ   ‚îÇ   Key    ‚îÇ ‚Üí‚Üí‚Üí ‚îÇ Hash        ‚îÇ ‚Üí‚Üí‚Üí ‚îÇ  Bucket Array   ‚îÇ  ‚îÇ
‚îÇ   ‚îÇ "hello"  ‚îÇ     ‚îÇ Function    ‚îÇ     ‚îÇ  [0][1][2]...   ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ   Hash Function:                                             ‚îÇ
‚îÇ   - Takes any key (string, int, object)                     ‚îÇ
‚îÇ   - Returns an integer (hash code)                          ‚îÇ
‚îÇ   - hash_code % array_size = bucket index                   ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ   Bucket Array:                                              ‚îÇ
‚îÇ   - Fixed-size array of "buckets"                           ‚îÇ
‚îÇ   - Each bucket stores (key, value) pairs                   ‚îÇ
‚îÇ   - Collisions handled by chaining or probing               ‚îÇ
‚îÇ                                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üíª Code Implementation

### Python - Simple Hash Table Concept

```python
class SimpleHashTable:
    """
    A basic hash table implementation for learning.
    Uses chaining for collision resolution.
    """
    
    def __init__(self, size: int = 10):
        self.size = size
        # Each bucket is a list to handle collisions
        self.buckets = [[] for _ in range(size)]
    
    def _hash(self, key: str) -> int:
        """Simple hash function using built-in hash."""
        return hash(key) % self.size
    
    def put(self, key: str, value) -> None:
        """Insert or update a key-value pair."""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        # Check if key exists (update)
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        
        # Key not found (insert)
        bucket.append((key, value))
    
    def get(self, key: str):
        """Retrieve value by key. Returns None if not found."""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        for k, v in bucket:
            if k == key:
                return v
        
        return None
    
    def remove(self, key: str) -> bool:
        """Remove key-value pair. Returns True if removed."""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                return True
        
        return False


# Usage
ht = SimpleHashTable()
ht.put("apple", 5)
ht.put("banana", 3)
print(ht.get("apple"))   # 5
print(ht.get("orange"))  # None
```

### Python - Using Built-in dict

```python
# Python's dict is a highly optimized hash table
from collections import defaultdict, Counter

# Basic dictionary
d = {}
d["apple"] = 5
d["banana"] = 3
print(d.get("apple", 0))  # 5
print(d.get("orange", 0))  # 0 (default)

# defaultdict - auto-initializes missing keys
counts = defaultdict(int)
counts["apple"] += 1  # No KeyError!

# Counter - specialized for counting
words = ["apple", "banana", "apple"]
freq = Counter(words)
print(freq["apple"])  # 2
print(freq.most_common(1))  # [('apple', 2)]
```

### JavaScript - Hash Table Concepts

```javascript
class SimpleHashTable {
    constructor(size = 10) {
        this.size = size;
        this.buckets = Array.from({ length: size }, () => []);
    }
    
    _hash(key) {
        // Simple hash: sum of char codes mod size
        let hash = 0;
        for (const char of String(key)) {
            hash += char.charCodeAt(0);
        }
        return hash % this.size;
    }
    
    put(key, value) {
        const index = this._hash(key);
        const bucket = this.buckets[index];
        
        // Check if key exists
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                bucket[i][1] = value;
                return;
            }
        }
        
        bucket.push([key, value]);
    }
    
    get(key) {
        const index = this._hash(key);
        const bucket = this.buckets[index];
        
        for (const [k, v] of bucket) {
            if (k === key) return v;
        }
        
        return undefined;
    }
}

// Usage
const ht = new SimpleHashTable();
ht.put("apple", 5);
console.log(ht.get("apple")); // 5
```

### JavaScript - Using Built-in Map and Object

```javascript
// Object (limited to string keys)
const obj = {};
obj["apple"] = 5;
obj.banana = 3;
console.log(obj["apple"]);  // 5

// Map (any type as key, maintains insertion order)
const map = new Map();
map.set("apple", 5);
map.set([1, 2], "array key");  // Objects as keys!
console.log(map.get("apple"));  // 5
console.log(map.has("banana")); // false

// Set (for unique values)
const set = new Set([1, 2, 2, 3]);
console.log(set.size);  // 3 (duplicates removed)
console.log(set.has(2)); // true
```

---

## ‚ö° Complexity Analysis

| Operation | Average | Worst Case | Notes |
|-----------|---------|------------|-------|
| Insert | O(1) | O(n) | Worst: all keys collide |
| Lookup | O(1) | O(n) | Worst: all keys collide |
| Delete | O(1) | O(n) | Worst: all keys collide |
| Space | O(n) | O(n) | Stores n key-value pairs |

**Why O(1) average?**
- Good hash function distributes keys evenly
- With load factor < 1, most buckets have 0-1 items
- Direct array access is O(1)

**Why O(n) worst case?**
- Pathological input where all keys hash to same bucket
- Becomes a linked list search
- Rare with good hash functions

---

## üîÑ Hash Table Variants

| Type | Description | Use Case |
|------|-------------|----------|
| Hash Map | Key-value pairs | Dictionaries, caches |
| Hash Set | Keys only (no values) | Uniqueness, membership |
| Hash Multiset | Keys with counts | Frequency counting |
| Ordered Map | Maintains insertion order | LRU cache |
| Bloom Filter | Probabilistic membership | Large-scale dedup |

---

## ‚ö†Ô∏è Common Misconceptions

### 1. "Hashing is Always O(1)"

```python
# ‚ùå MISCONCEPTION: Always O(1)
# ‚úÖ REALITY: O(1) average, O(n) worst case

# Pathological case: all keys hash to same bucket
class BadHash:
    def __hash__(self):
        return 1  # Everything collides!
```

### 2. "Order is Preserved"

```python
# ‚ùå MISCONCEPTION: Hash tables maintain order
# ‚úÖ REALITY: Only Python 3.7+ dict maintains insertion order

# Use OrderedDict or check Python version
from collections import OrderedDict
```

### 3. "Any Object Can Be a Key"

```python
# ‚ùå MISCONCEPTION: Any object works as key
# ‚úÖ REALITY: Keys must be hashable (immutable)

# Valid keys
d = {
    "string": 1,      # ‚úì
    123: 2,           # ‚úì
    (1, 2): 3,        # ‚úì tuple (immutable)
}

# Invalid keys
# d[[1, 2]] = 4       # ‚úó list (mutable)
# d[{1: 2}] = 5       # ‚úó dict (mutable)
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Focus | Link |
|---------|------------|-------|------|
| Two Sum | üü¢ Easy | Basic lookup | [LC 1](https://leetcode.com/problems/two-sum/) |
| Contains Duplicate | üü¢ Easy | Set usage | [LC 217](https://leetcode.com/problems/contains-duplicate/) |
| Valid Anagram | üü¢ Easy | Frequency counting | [LC 242](https://leetcode.com/problems/valid-anagram/) |
| Design HashMap | üü¢ Easy | Implementation | [LC 706](https://leetcode.com/problems/design-hashmap/) |
| Group Anagrams | üü° Medium | Hash as key | [LC 49](https://leetcode.com/problems/group-anagrams/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Read this overview, understand hash table structure
- **Day 3:** Implement simple hash table from scratch
- **Day 7:** Solve LC 706 (Design HashMap)
- **Day 14:** Explain hashing to someone else
- **Day 30:** Review and solve 3 hash problems

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Hashing in Technical Interviews</strong></summary>

**When to propose hashing:**
> "I notice we need fast lookups here. I'll use a hash map for O(1) access."

**Trade-off discussion:**
> "This gives us O(n) space complexity, but improves time from O(n¬≤) to O(n). Is that acceptable?"

**Follow-up questions you might get:**
- "How does a hash table work internally?"
- "What happens when there's a collision?"
- "What's the worst-case complexity?"
- "Can you implement without using built-in hash map?"

**Red flags to avoid:**
- ‚ùå Not considering space trade-off
- ‚ùå Forgetting hash tables are unordered
- ‚ùå Using hash when array indices work
- ‚úÖ Explaining why O(1) average, not guaranteed

</details>

**Company Focus:**

| Company | Hashing Questions | Notes |
|---------|------------------|-------|
| All | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Fundamental skill |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Expected knowledge |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | System design too |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand hashing concept | 30 min |
| Learn hash table operations | 20 min |
| Implement simple hash table | 30-45 min |
| Master for interviews | 3-5 problems |

---

> **üí° Key Insight:** Hashing trades space for time, converting O(n) lookups to O(1) by using a smart indexing scheme. It's one of the most important techniques to master for coding interviews.

> **üîó Related:** [Hash Functions](./1.2-Hash-Functions.md) | [Collision Handling](./1.3-Collision-Handling.md) | [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
