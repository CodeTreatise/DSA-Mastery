# Longest Increasing Subsequence (LC 300)

> **The canonical LIS problem.** This is where you learn both the classic O(nÂ²) DP and the clever O(n log n) binary search optimization. Both approaches are worth knowingâ€”the DP for its clarity, the binary search for its elegance.

---

## ğŸ“‹ Problem Statement

**LeetCode:** [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)

Given an integer array `nums`, return the length of the longest strictly increasing subsequence.

A **subsequence** is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.

**Examples:**
```
Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]
Output: 4
Explanation: The LIS is [2, 3, 7, 101] (or [2, 5, 7, 101])

Input: nums = [0, 1, 0, 3, 2, 3]
Output: 4

Input: nums = [7, 7, 7, 7, 7, 7, 7]
Output: 1
```

**Constraints:**
- 1 â‰¤ nums.length â‰¤ 2500
- -10â´ â‰¤ nums[i] â‰¤ 10â´

**Follow up:** Can you solve it in O(n log n) time?

---

## ğŸ¯ Pattern Recognition

**This is LIS because:**
- Single sequence (not comparing two sequences like LCS)
- "Strictly increasing" ordering constraint
- Subsequence (elements can be skipped)
- Finding maximum length

---

## ğŸ“ Two Approaches

### Approach 1: O(nÂ²) DP

```
dp[i] = length of LIS ending at index i

For each i, check all j < i:
  if nums[j] < nums[i]: dp[i] = max(dp[i], dp[j] + 1)
  
Answer: max(dp)
```

### Approach 2: O(n log n) Binary Search

Maintain a "tails" array:
- `tails[len]` = smallest ending value for an LIS of length `len + 1`
- This array is always sorted!
- Use binary search to find where each element belongs

---

## ğŸ’» Solutions

### Solution 1: O(nÂ²) DP

```python
def length_of_lis(nums: list[int]) -> int:
    """
    Classic DP approach.
    dp[i] = LIS length ending at index i
    Time: O(nÂ²), Space: O(n)
    """
    n = len(nums)
    # Every element is an LIS of length 1
    dp = [1] * n
    
    for i in range(1, n):
        for j in range(i):
            # Can we extend the LIS ending at j?
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)
```

```javascript
function lengthOfLIS(nums) {
    const n = nums.length;
    const dp = new Array(n).fill(1);
    
    for (let i = 1; i < n; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    
    return Math.max(...dp);
}
```

### Solution 2: O(n log n) Binary Search

```python
import bisect

def length_of_lis_optimal(nums: list[int]) -> int:
    """
    Binary search approach.
    tails[i] = smallest ending value for LIS of length i+1
    Time: O(n log n), Space: O(n)
    """
    tails = []
    
    for num in nums:
        # Find position: where should num go?
        pos = bisect.bisect_left(tails, num)
        
        if pos == len(tails):
            # num is larger than all - extend LIS
            tails.append(num)
        else:
            # Replace to maintain smallest ending
            tails[pos] = num
    
    return len(tails)
```

```javascript
function lengthOfLISOptimal(nums) {
    const tails = [];
    
    for (const num of nums) {
        // Binary search for leftmost position >= num
        let left = 0, right = tails.length;
        
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (tails[mid] < num) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        if (left === tails.length) {
            tails.push(num);
        } else {
            tails[left] = num;
        }
    }
    
    return tails.length;
}
```

### Solution 3: O(nÂ²) with Parent Tracking (Get Actual LIS)

```python
def get_actual_lis(nums: list[int]) -> list[int]:
    """
    Return the actual LIS, not just length.
    """
    n = len(nums)
    dp = [1] * n
    parent = [-1] * n  # Track previous element
    
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i] and dp[j] + 1 > dp[i]:
                dp[i] = dp[j] + 1
                parent[i] = j
    
    # Find where LIS ends
    max_len = max(dp)
    end_idx = dp.index(max_len)
    
    # Backtrack to build LIS
    lis = []
    while end_idx != -1:
        lis.append(nums[end_idx])
        end_idx = parent[end_idx]
    
    return lis[::-1]  # Reverse to get correct order
```

### Solution 4: O(n log n) with Actual LIS

```python
import bisect

def get_actual_lis_optimal(nums: list[int]) -> list[int]:
    """
    Get actual LIS with O(n log n) complexity.
    Need to track indices, not just values.
    """
    n = len(nums)
    tails = []  # tails[i] = index of smallest ending for length i+1
    parent = [-1] * n
    
    for i, num in enumerate(nums):
        pos = bisect.bisect_left([nums[t] for t in tails], num)
        
        if pos == len(tails):
            if tails:
                parent[i] = tails[-1]
            tails.append(i)
        else:
            if pos > 0:
                parent[i] = tails[pos - 1]
            tails[pos] = i
    
    # Backtrack from last position
    lis = []
    idx = tails[-1]
    while idx != -1:
        lis.append(nums[idx])
        idx = parent[idx]
    
    return lis[::-1]
```

---

## âš¡ Complexity Analysis

| Approach | Time | Space |
|----------|------|-------|
| O(nÂ²) DP | O(nÂ²) | O(n) |
| Binary Search | O(n log n) | O(n) |

---

## ğŸ“Š Trace Through Example

### O(nÂ²) DP Trace

```
nums = [10, 9, 2, 5, 3, 7, 101, 18]

Initial: dp = [1, 1, 1, 1, 1, 1, 1, 1]

i=1 (9):  No j < i has nums[j] < 9 except... wait, 10 > 9 âŒ
          dp = [1, 1, 1, 1, 1, 1, 1, 1]

i=2 (2):  No j has nums[j] < 2
          dp = [1, 1, 1, 1, 1, 1, 1, 1]

i=3 (5):  j=2: nums[2]=2 < 5 âœ“ â†’ dp[3] = dp[2]+1 = 2
          dp = [1, 1, 1, 2, 1, 1, 1, 1]

i=4 (3):  j=2: nums[2]=2 < 3 âœ“ â†’ dp[4] = dp[2]+1 = 2
          dp = [1, 1, 1, 2, 2, 1, 1, 1]

i=5 (7):  j=2: 2 < 7 â†’ dp[5] = max(1, 1+1) = 2
          j=3: 5 < 7 â†’ dp[5] = max(2, 2+1) = 3
          j=4: 3 < 7 â†’ dp[5] = max(3, 2+1) = 3
          dp = [1, 1, 1, 2, 2, 3, 1, 1]

i=6 (101): Best extends from 7 â†’ dp[6] = 4
           dp = [1, 1, 1, 2, 2, 3, 4, 1]

i=7 (18):  Best extends from 7 â†’ dp[7] = 4
           dp = [1, 1, 1, 2, 2, 3, 4, 4]

Answer: max(dp) = 4
```

### O(n log n) Binary Search Trace

```
nums = [10, 9, 2, 5, 3, 7, 101, 18]

  10: tails = [10]           len=1
   9: tails = [9]            9 replaces 10
   2: tails = [2]            2 replaces 9
   5: tails = [2, 5]         5 extends
   3: tails = [2, 3]         3 replaces 5
   7: tails = [2, 3, 7]      7 extends
 101: tails = [2, 3, 7, 101] 101 extends
  18: tails = [2, 3, 7, 18]  18 replaces 101

Answer: len(tails) = 4

Note: tails = [2,3,7,18] is NOT necessarily the LIS!
      Actual LIS: [2,5,7,101] or [2,3,7,101] or [2,3,7,18]
```

---

## âš ï¸ Common Mistakes

### 1. Using <= Instead of <

**âŒ Wrong:**
```python
if nums[j] <= nums[i]:  # Allows equal elements!
    dp[i] = max(dp[i], dp[j] + 1)
```

**âœ… Correct:**
```python
if nums[j] < nums[i]:  # STRICTLY increasing
    dp[i] = max(dp[i], dp[j] + 1)
```

### 2. Wrong Initialization

**âŒ Wrong:**
```python
dp = [0] * n  # 0 means "no LIS"?
```

**âœ… Correct:**
```python
dp = [1] * n  # Every single element is an LIS of length 1
```

### 3. Returning dp[n-1] Instead of max(dp)

**âŒ Wrong:**
```python
return dp[n-1]  # LIS might not end at last element!
```

**âœ… Correct:**
```python
return max(dp)  # LIS can end anywhere
```

### 4. Thinking tails[] IS the LIS

**âŒ Wrong:**
```python
return tails  # These values change during processing!
```

**âœ… Correct:**
```python
return len(tails)  # Only the LENGTH is guaranteed correct
```

---

## ğŸ”„ Variations

### Non-Decreasing (Allow Equals)

```python
import bisect

def longest_non_decreasing(nums: list[int]) -> int:
    """Use bisect_right for <="""
    tails = []
    for num in nums:
        pos = bisect.bisect_right(tails, num)  # RIGHT for <=
        if pos == len(tails):
            tails.append(num)
        else:
            tails[pos] = num
    return len(tails)
```

### Longest Decreasing Subsequence

```python
def longest_decreasing(nums: list[int]) -> int:
    """Negate values, then LIS."""
    return length_of_lis_optimal([-x for x in nums])
```

### Count Number of LIS (LC 673)

```python
def find_number_of_lis(nums: list[int]) -> int:
    """Track count along with length."""
    n = len(nums)
    length = [1] * n
    count = [1] * n
    
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                if length[j] + 1 > length[i]:
                    length[i] = length[j] + 1
                    count[i] = count[j]
                elif length[j] + 1 == length[i]:
                    count[i] += count[j]
    
    max_len = max(length)
    return sum(c for l, c in zip(length, count) if l == max_len)
```

---

## ğŸ“ Related Problems

| Problem | Difficulty | Note |
|---------|------------|------|
| [673. Number of LIS](https://leetcode.com/problems/number-of-longest-increasing-subsequence/) | Medium | Count all LIS |
| [354. Russian Doll Envelopes](https://leetcode.com/problems/russian-doll-envelopes/) | Hard | 2D LIS |
| [646. Maximum Length of Pair Chain](https://leetcode.com/problems/maximum-length-of-pair-chain/) | Medium | Interval LIS |
| [1048. Longest String Chain](https://leetcode.com/problems/longest-string-chain/) | Medium | String LIS |
| [334. Increasing Triplet Subsequence](https://leetcode.com/problems/increasing-triplet-subsequence/) | Medium | Fixed length 3 |

---

## ğŸ¤ Interview Tips

**Time to solve:**
- O(nÂ²): 10-15 minutes
- O(n log n): 15-20 minutes

**When to use which:**
- Always start with O(nÂ²) to show understanding
- Mention O(n log n) optimization exists
- Implement O(n log n) if asked or if time permits

**Communication template (O(nÂ²)):**
> "I'll use dp[i] to represent the longest increasing subsequence ending at index i. For each position, I check all previous elementsâ€”if any is smaller, I can extend that LIS. The final answer is the maximum value in dp."

**Communication template (O(n log n)):**
> "I'll maintain a 'tails' array where tails[len-1] stores the smallest ending value for an LIS of that length. Since this array is always sorted, I can binary search to find where each new element belongs. If it's larger than all, I extend; otherwise, I replace to keep the smallest possible ending value."

**Company frequency:**
| Company | Frequency |
|---------|-----------|
| Google | â­â­â­â­â­ |
| Amazon | â­â­â­â­ |
| Microsoft | â­â­â­â­ |
| Meta | â­â­â­ |
| Apple | â­â­â­ |

---

> **ğŸ’¡ Key Insight:** The O(n log n) approach works because maintaining "smallest ending for each length" is monotonicâ€”smaller endings never hurt us, they only give more options. The tails array represents "what's possible" not "what we've chosen."

> **ğŸ”— Related:** [LIS Pattern Fundamentals](../7.1-LIS-Fundamentals.md) | [Russian Doll Envelopes](https://leetcode.com/problems/russian-doll-envelopes/) | [Number of LIS](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)
