# 2.5 Classic Backtracking Problems

> **N-Queens, Sudoku, and Other Constraint Satisfaction Problems**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - Top-tier interview problems  
> **Prerequisites:** [2.2 Backtracking Template](./2.2-Backtracking-Template.md)

---

## Overview

**Classic backtracking problems** are constraint satisfaction problems (CSP) where you must place elements satisfying specific rules:
- **N-Queens:** Place N queens on N*N board with no attacks
- **Sudoku:** Fill 9*9 grid with digits following rules
- **Valid Parentheses:** Generate balanced bracket sequences

These problems showcase backtracking's power for systematically exploring solution spaces with heavy pruning.

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Constraint Backtracking</strong></summary>

**Look for these signals:**
- "Place elements following **rules**"
- "Solve the puzzle"
- Multiple **constraints** must be satisfied simultaneously
- Need to **undo** placements when stuck

**Keywords in problem statement:**
- "valid placement", "satisfy constraints"
- "no conflicts", "valid solution"
- "solve", "fill", "place"

**Problem characteristics:**
- Multiple constraints to check
- Placement decisions affect future choices
- Need to backtrack when no valid choices remain

</details>

---

## ‚úÖ When to Use

- **Puzzle solving** (Sudoku, crossword, N-Queens)
- **Constraint satisfaction** (scheduling, coloring)
- **Configuration problems** (placing elements with rules)
- **All valid configurations** (not just one)

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Need ONE solution fast | Constraint propagation | More efficient |
| Optimization problem | DP, greedy | Better suited |
| Simple enumeration | Loops | Less overhead |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Backtracking Template](./2.2-Backtracking-Template.md)
- [Grid Backtracking](./2.4-Grid-Backtracking.md)

**After mastering this:**
- Advanced constraint propagation
- SAT solvers
- Optimization algorithms

</details>

---

## üìê Problem 1: N-Queens

### Problem Statement
Place N queens on an N*N chessboard so that no two queens attack each other.

Queens attack horizontally, vertically, and diagonally.

```
N = 4:
. Q . .
. . . Q
Q . . .
. . Q .
```

### How It Works

```
Place queens row by row:

Row 0: Try col 0, 1, 2, 3
  - Place Q at (0,0)
  
Row 1: Can't use col 0 (same col), can't use col 1 (diagonal)
  - Place Q at (0,1) originally ‚Üí Try (1,0)? No (diagonal from 0,0)
  - Try (1,2)? Valid!
  
Row 2: Check all constraints...
  - Continue until solution or backtrack

Key insight: Only need to place one queen per row!
```

### üíª Code

```python
def solve_n_queens(n: int) -> list[list[str]]:
    """
    Solve N-Queens problem.
    
    Time: O(N!), Space: O(N)
    """
    result = []
    
    # Track columns and diagonals under attack
    cols = set()
    diag1 = set()  # row - col (positive diagonal)
    diag2 = set()  # row + col (negative diagonal)
    
    def backtrack(row: int, queens: list):
        # Base case: placed all queens
        if row == n:
            # Build board representation
            board = []
            for r in range(n):
                row_str = '.' * queens[r] + 'Q' + '.' * (n - queens[r] - 1)
                board.append(row_str)
            result.append(board)
            return
        
        # Try each column in current row
        for col in range(n):
            # Check if position is under attack
            if col in cols or (row - col) in diag1 or (row + col) in diag2:
                continue
            
            # CHOOSE
            cols.add(col)
            diag1.add(row - col)
            diag2.add(row + col)
            queens.append(col)
            
            # EXPLORE
            backtrack(row + 1, queens)
            
            # UNCHOOSE
            cols.remove(col)
            diag1.remove(row - col)
            diag2.remove(row + col)
            queens.pop()
    
    backtrack(0, [])
    return result


def count_n_queens(n: int) -> int:
    """Just count solutions, don't store them."""
    cols = set()
    diag1 = set()
    diag2 = set()
    count = 0
    
    def backtrack(row: int):
        nonlocal count
        
        if row == n:
            count += 1
            return
        
        for col in range(n):
            if col in cols or (row - col) in diag1 or (row + col) in diag2:
                continue
            
            cols.add(col)
            diag1.add(row - col)
            diag2.add(row + col)
            
            backtrack(row + 1)
            
            cols.remove(col)
            diag1.remove(row - col)
            diag2.remove(row + col)
    
    backtrack(0)
    return count


# Example
solutions = solve_n_queens(4)
for sol in solutions:
    for row in sol:
        print(row)
    print()
```

```javascript
function solveNQueens(n) {
    const result = [];
    const cols = new Set();
    const diag1 = new Set();  // row - col
    const diag2 = new Set();  // row + col
    
    function backtrack(row, queens) {
        if (row === n) {
            const board = queens.map(col => 
                '.'.repeat(col) + 'Q' + '.'.repeat(n - col - 1)
            );
            result.push(board);
            return;
        }
        
        for (let col = 0; col < n; col++) {
            if (cols.has(col) || diag1.has(row - col) || diag2.has(row + col)) {
                continue;
            }
            
            cols.add(col);
            diag1.add(row - col);
            diag2.add(row + col);
            queens.push(col);
            
            backtrack(row + 1, queens);
            
            cols.delete(col);
            diag1.delete(row - col);
            diag2.delete(row + col);
            queens.pop();
        }
    }
    
    backtrack(0, []);
    return result;
}
```

### Diagonal Indexing Explained

```
Positive diagonal (row - col):
  0  -1  -2  -3
  1   0  -1  -2
  2   1   0  -1
  3   2   1   0

Negative diagonal (row + col):
  0   1   2   3
  1   2   3   4
  2   3   4   5
  3   4   5   6

Same value = same diagonal!
```

---

## üìê Problem 2: Sudoku Solver

### Problem Statement
Fill a 9*9 grid with digits 1-9 so that:
- Each row contains 1-9 exactly once
- Each column contains 1-9 exactly once
- Each 3*3 box contains 1-9 exactly once

### üíª Code

```python
def solve_sudoku(board: list[list[str]]) -> bool:
    """
    Solve Sudoku puzzle in-place.
    
    Time: O(9^(empty cells)), Space: O(81) for recursion
    """
    def is_valid(row: int, col: int, num: str) -> bool:
        # Check row
        if num in board[row]:
            return False
        
        # Check column
        for r in range(9):
            if board[r][col] == num:
                return False
        
        # Check 3x3 box
        box_row, box_col = 3 * (row // 3), 3 * (col // 3)
        for r in range(box_row, box_row + 3):
            for c in range(box_col, box_col + 3):
                if board[r][c] == num:
                    return False
        
        return True
    
    def solve() -> bool:
        # Find next empty cell
        for row in range(9):
            for col in range(9):
                if board[row][col] == '.':
                    # Try digits 1-9
                    for num in '123456789':
                        if is_valid(row, col, num):
                            # CHOOSE
                            board[row][col] = num
                            
                            # EXPLORE
                            if solve():
                                return True
                            
                            # UNCHOOSE
                            board[row][col] = '.'
                    
                    # No valid digit found - backtrack
                    return False
        
        # All cells filled
        return True
    
    solve()


# Optimized version with sets for O(1) validity check
def solve_sudoku_optimized(board: list[list[str]]) -> bool:
    """Optimized with precomputed constraints."""
    rows = [set() for _ in range(9)]
    cols = [set() for _ in range(9)]
    boxes = [set() for _ in range(9)]
    
    # Initialize sets with existing numbers
    empty = []
    for r in range(9):
        for c in range(9):
            if board[r][c] != '.':
                num = board[r][c]
                rows[r].add(num)
                cols[c].add(num)
                boxes[(r // 3) * 3 + c // 3].add(num)
            else:
                empty.append((r, c))
    
    def backtrack(idx: int) -> bool:
        if idx == len(empty):
            return True
        
        r, c = empty[idx]
        box_idx = (r // 3) * 3 + c // 3
        
        for num in '123456789':
            if num not in rows[r] and num not in cols[c] and num not in boxes[box_idx]:
                # CHOOSE
                board[r][c] = num
                rows[r].add(num)
                cols[c].add(num)
                boxes[box_idx].add(num)
                
                # EXPLORE
                if backtrack(idx + 1):
                    return True
                
                # UNCHOOSE
                board[r][c] = '.'
                rows[r].remove(num)
                cols[c].remove(num)
                boxes[box_idx].remove(num)
        
        return False
    
    backtrack(0)
```

```javascript
function solveSudoku(board) {
    function isValid(row, col, num) {
        // Check row
        if (board[row].includes(num)) return false;
        
        // Check column
        for (let r = 0; r < 9; r++) {
            if (board[r][col] === num) return false;
        }
        
        // Check 3x3 box
        const boxRow = Math.floor(row / 3) * 3;
        const boxCol = Math.floor(col / 3) * 3;
        for (let r = boxRow; r < boxRow + 3; r++) {
            for (let c = boxCol; c < boxCol + 3; c++) {
                if (board[r][c] === num) return false;
            }
        }
        
        return true;
    }
    
    function solve() {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (board[row][col] === '.') {
                    for (let num = 1; num <= 9; num++) {
                        const numStr = num.toString();
                        if (isValid(row, col, numStr)) {
                            board[row][col] = numStr;
                            
                            if (solve()) return true;
                            
                            board[row][col] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
    
    solve();
}
```

---

## üìê Problem 3: Valid Parentheses Generation

### Problem Statement
Generate all valid combinations of n pairs of parentheses.

(Covered in detail in [String Backtracking](./2.3-Core-Patterns/04-String-Backtracking.md))

```python
def generate_parenthesis(n: int) -> list[str]:
    """
    Generate valid parentheses using constraint tracking.
    
    Constraints:
    - Can add '(' if open < n
    - Can add ')' if close < open
    """
    result = []
    
    def backtrack(current: list, open_count: int, close_count: int):
        if len(current) == 2 * n:
            result.append(''.join(current))
            return
        
        if open_count < n:
            current.append('(')
            backtrack(current, open_count + 1, close_count)
            current.pop()
        
        if close_count < open_count:
            current.append(')')
            backtrack(current, open_count, close_count + 1)
            current.pop()
    
    backtrack([], 0, 0)
    return result
```

---

## ‚ö° Complexity Analysis

| Problem | Time | Space | Notes |
|---------|------|-------|-------|
| N-Queens |" O(N!) "| O(N) | N choices, N-1, N-2... |
| Sudoku |" O(9^M) "| O(M) | M = empty cells |
| Parentheses |" O(4‚Åø/‚àön) "| O(n) | Catalan number |

**N-Queens complexity:**
```
Row 0: N choices
Row 1: ~N-2 choices (after pruning)
Row 2: ~N-4 choices
...
Total: roughly N! / exponential factor = O(N!)
```

---

## üîÑ Variations

| Problem | Variation | LeetCode |
|---------|-----------|----------|
| N-Queens | Find all solutions | LC 51 |
| N-Queens II | Count solutions | LC 52 |
| Sudoku Solver | Fill board | LC 37 |
| Valid Sudoku | Check validity | LC 36 |
| Letter Tiles | Count distinct sequences | LC 1079 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Diagonal Formula

‚ùå **Wrong:**
```python
diag1 = row + col  # Both diagonals same formula
diag2 = row + col
```

‚úÖ **Correct:**
```python
diag1 = row - col  # Positive diagonal: ‚Üó
diag2 = row + col  # Negative diagonal: ‚Üò
```

### 2. Not Restoring State in Sudoku

‚ùå **Wrong:**
```python
board[row][col] = num
if solve():
    return True
# Forgot to restore!
return False
```

‚úÖ **Correct:**
```python
board[row][col] = num
if solve():
    return True
board[row][col] = '.'  # MUST restore
return False
```

### 3. Wrong Box Index in Sudoku

‚ùå **Wrong:**
```python
box_idx = (row // 3) + (col // 3)  # Wrong formula
```

‚úÖ **Correct:**
```python
box_idx = (row // 3) * 3 + (col // 3)  # Correct: 0-8
```

---

## üìù Practice Problems

### Medium (Learn the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| N-Queens II | Count solutions | [LC 52](https://leetcode.com/problems/n-queens-ii/) |
| Generate Parentheses | Constraint tracking | [LC 22](https://leetcode.com/problems/generate-parentheses/) |
| Letter Tile Possibilities | Distinct sequences | [LC 1079](https://leetcode.com/problems/letter-tile-possibilities/) |

### Hard (Master the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| N-Queens | Build all boards | [LC 51](https://leetcode.com/problems/n-queens/) |
| Sudoku Solver | Multiple constraints | [LC 37](https://leetcode.com/problems/sudoku-solver/) |
| Word Search II | Trie + backtracking | [LC 212](https://leetcode.com/problems/word-search-ii/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: N-Queens II (counting)
- Day 3: N-Queens (full solution)
- Day 5: Trace through 4-Queens example

**Week 2:**
- Day 8: Sudoku validity check (LC 36)
- Day 10: Sudoku Solver (LC 37)
- Day 12: Optimize with sets
- Day 14: Review both problems

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**For N-Queens:**
> "I'll place one queen per row. For each row, I try each column, checking if it's under attack using sets to track columns and diagonals. I use backtracking when no valid position exists."

**Diagonal explanation:**
> "I track diagonals using row-col and row+col. Cells on the same positive diagonal have the same row-col value."

**For Sudoku:**
> "I'll find empty cells and try digits 1-9, checking row, column, and box constraints. If no valid digit exists, I backtrack."

**Optimization discussion:**
> "I can optimize by precomputing which digits are already used in each row, column, and box using sets. This makes validity checking O(1) instead of O(9)."

**Company Focus:**

| Company | Classic Problems |
|---------|-----------------|
| Google | N-Queens, Sudoku |
| Amazon | Sudoku variants |
| Meta | Constraint problems |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand N-Queens | 20-30 min | With visualization |
| Implement N-Queens | 30-40 min | With constraints |
| Understand Sudoku | 20-30 min | Three constraint types |
| Implement Sudoku | 40-60 min | Full solution |
| Optimize Sudoku | 20-30 min | Set-based |

---

## üí° Key Insight

> **Classic backtracking = constraint satisfaction + pruning**
>
> The power of these problems lies in efficient pruning:
> - **N-Queens:** Track attacked positions with sets ‚Üí O(1) validity check
> - **Sudoku:** Precompute row/col/box constraints ‚Üí faster pruning
>
> Without pruning, these problems are intractable. With good pruning, they become solvable in reasonable time.

---

## üîó Related

- [Backtracking Template](./2.2-Backtracking-Template.md) - Foundation
- [Grid Backtracking](./2.4-Grid-Backtracking.md) - Word Search
- [String Backtracking](./2.3-Core-Patterns/04-String-Backtracking.md) - Parentheses, etc.
- [Core Patterns](./2.3-Core-Patterns/) - Subsets, Permutations
