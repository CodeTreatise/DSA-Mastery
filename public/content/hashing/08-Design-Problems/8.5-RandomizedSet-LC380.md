# Insert Delete GetRandom O(1) (LeetCode 380)

> **Medium** | Design a data structure that supports insert, delete, and getRandom in O(1) time.

This problem demonstrates the elegant combination of Hash Map + Array to achieve O(1) for operations that typically have trade-offs.

---

## üéØ Pattern Recognition

<details>
<summary><strong>Problem Signals</strong></summary>

**Keywords indicating this pattern:**
- "Insert, delete, getRandom in O(1)"
- "Random element with equal probability"
- "Design data structure"
- "O(1) average time for all operations"

**Problem classification:**
```
Category: Design Problem
Data Structures: Hash Map + Array
Key Insight: Array for O(1) random, Hash for O(1) lookup
Trick: Swap-to-end for O(1) deletion
```

</details>

---

## üìã Problem Statement

**LeetCode 380:** [Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/)

```
Implement the RandomizedSet class:
- RandomizedSet() Initializes the object
- bool insert(int val) - Insert if not present, return true if inserted
- bool remove(int val) - Remove if present, return true if removed  
- int getRandom() - Return random element with equal probability

You must implement in O(1) average time for each function.

Example:
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1);   // true, set = [1]
randomizedSet.remove(2);   // false, 2 not in set
randomizedSet.insert(2);   // true, set = [1, 2]
randomizedSet.getRandom(); // 1 or 2 randomly
randomizedSet.remove(1);   // true, set = [2]
randomizedSet.insert(2);   // false, 2 already present
randomizedSet.getRandom(); // 2 (only element)

Constraints:
- -2^31 <= val <= 2^31 - 1
- At most 2 * 10^5 calls to insert, remove, getRandom
- At least one element when getRandom is called
```

---

## ‚úÖ When to Use This Design

- Need O(1) insertion and deletion
- Need O(1) random access with uniform distribution
- Can't afford O(n) for any operation

---

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need weighted random | Uniform only | Weighted random with prefix sum |
| Need ordered iteration | No order maintained | TreeSet + array |
| Duplicates allowed | This is a set (unique) | RandomizedCollection (LC 381) |
| Range random needed | Only supports single random | Skip list or BST |
| No random needed | Overkill | Plain HashSet |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, understand:**
- [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
- [Hash Set Operations](../02-Hash-Map-Set/2.2-Hash-Set-Operations.md)
- Array swap-to-end deletion trick

**After mastering this:**
- [RandomizedCollection (LC 381)](https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/) - With duplicates
- [Random Pick with Weight (LC 528)](https://leetcode.com/problems/random-pick-with-weight/)
- [Shuffle an Array (LC 384)](https://leetcode.com/problems/shuffle-an-array/)

**Key insight:**
- Array for O(1) random access by index
- HashMap for O(1) lookup of index by value
- Swap-to-end for O(1) array deletion

</details>

---

## üìê Solution Design

### Why Hash Map + Array?

| Data Structure | Insert | Delete | Random | Problem |
|---------------|--------|--------|--------|---------|
| Array only | O(1) | O(n) | O(1) | Delete is O(n) |
| Hash Set only | O(1) | O(1) | O(n) | Random needs list |
| Hash Map + Array | O(1) | O(1) | O(1) | ‚úÖ All O(1) |

**The Challenge:** 
- Array gives O(1) random access but O(n) deletion (shifting)
- Hash Set gives O(1) delete but no random access

**The Solution:**
- Array stores values for O(1) random
- Hash Map stores value ‚Üí index for O(1) lookup
- **Swap-to-end trick** for O(1) deletion

### The Swap-to-End Trick

```
Delete from middle of array:

NAIVE: Shift all elements ‚Üí O(n)
[1, 2, 3, 4, 5] ‚Üí delete 2 ‚Üí [1, 3, 4, 5] (shifted 3 elements)

SMART: Swap with last, pop last ‚Üí O(1)
[1, 2, 3, 4, 5] ‚Üí delete 2:
  1. Swap 2 and 5: [1, 5, 3, 4, 2]
  2. Pop last: [1, 5, 3, 4]
  3. Update index of 5 in hash map
```

### Visualization

```
Insert 1, 2, 3:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Array: [1, 2, 3]                                 ‚îÇ
‚îÇ                                                  ‚îÇ
‚îÇ Hash Map: {1: 0, 2: 1, 3: 2}                     ‚îÇ
‚îÇ           value ‚Üí index                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Delete 2 (at index 1):
Step 1: Get index of 2 ‚Üí 1
Step 2: Swap 2 with last element (3)
        Array: [1, 3, 2]
Step 3: Update hash map for swapped element (3)
        Hash: {1: 0, 3: 1, 2: 2}
Step 4: Pop last element (2)
        Array: [1, 3]
Step 5: Remove 2 from hash map
        Hash: {1: 0, 3: 1}

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Array: [1, 3]                                    ‚îÇ
‚îÇ                                                  ‚îÇ
‚îÇ Hash Map: {1: 0, 3: 1}                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

getRandom(): Pick random index in [0, 1] ‚Üí return array[idx]
```

---

## üíª Code Implementation

### Python - Clean Implementation

```python
import random

class RandomizedSet:
    """
    RandomizedSet using Hash Map + Array.
    
    Hash Map: value ‚Üí index (O(1) lookup)
    Array: stores values (O(1) random access)
    Swap-to-end: O(1) deletion
    
    Time: O(1) average for all operations
    Space: O(n) for storing n elements
    """
    
    def __init__(self):
        self.val_to_idx = {}  # value ‚Üí index in array
        self.values = []      # list of values
    
    def insert(self, val: int) -> bool:
        """
        Insert value if not present.
        Returns True if inserted, False if already exists.
        """
        if val in self.val_to_idx:
            return False
        
        # Add to end of array
        self.val_to_idx[val] = len(self.values)
        self.values.append(val)
        return True
    
    def remove(self, val: int) -> bool:
        """
        Remove value if present.
        Returns True if removed, False if not found.
        Uses swap-to-end trick for O(1).
        """
        if val not in self.val_to_idx:
            return False
        
        # Get index of element to remove
        idx = self.val_to_idx[val]
        last_val = self.values[-1]
        
        # Swap with last element
        self.values[idx] = last_val
        self.val_to_idx[last_val] = idx
        
        # Remove last element
        self.values.pop()
        del self.val_to_idx[val]
        
        return True
    
    def getRandom(self) -> int:
        """
        Return random element with equal probability.
        """
        return random.choice(self.values)


# Example trace:
# rs = RandomizedSet()
#
# insert(1):
#   values = [1]
#   val_to_idx = {1: 0}
#   return True
#
# insert(2):
#   values = [1, 2]
#   val_to_idx = {1: 0, 2: 1}
#   return True
#
# insert(3):
#   values = [1, 2, 3]
#   val_to_idx = {1: 0, 2: 1, 3: 2}
#   return True
#
# remove(2):
#   idx = 1, last_val = 3
#   Swap: values[1] = 3 ‚Üí values = [1, 3, 3]
#   Update: val_to_idx[3] = 1
#   Pop: values = [1, 3]
#   Delete: del val_to_idx[2]
#   Result: values = [1, 3], val_to_idx = {1: 0, 3: 1}
#   return True
#
# getRandom():
#   random.choice([1, 3]) ‚Üí 1 or 3 with 50% each
```

### Python - With Edge Case Handling

```python
import random

class RandomizedSet:
    """
    Enhanced version with explicit edge case handling.
    """
    
    def __init__(self):
        self.val_to_idx = {}
        self.values = []
    
    def insert(self, val: int) -> bool:
        if val in self.val_to_idx:
            return False
        
        self.val_to_idx[val] = len(self.values)
        self.values.append(val)
        return True
    
    def remove(self, val: int) -> bool:
        if val not in self.val_to_idx:
            return False
        
        idx = self.val_to_idx[val]
        last_idx = len(self.values) - 1
        last_val = self.values[last_idx]
        
        # Special case: removing last element
        if idx != last_idx:
            # Swap with last
            self.values[idx] = last_val
            self.val_to_idx[last_val] = idx
        
        # Remove last
        self.values.pop()
        del self.val_to_idx[val]
        
        return True
    
    def getRandom(self) -> int:
        # Guaranteed at least one element per problem
        return random.choice(self.values)
```

### JavaScript - Clean Implementation

```javascript
class RandomizedSet {
    constructor() {
        this.valToIdx = new Map();  // value ‚Üí index
        this.values = [];           // list of values
    }
    
    /**
     * Insert value if not present.
     * @param {number} val
     * @return {boolean}
     */
    insert(val) {
        if (this.valToIdx.has(val)) {
            return false;
        }
        
        this.valToIdx.set(val, this.values.length);
        this.values.push(val);
        return true;
    }
    
    /**
     * Remove value if present.
     * @param {number} val
     * @return {boolean}
     */
    remove(val) {
        if (!this.valToIdx.has(val)) {
            return false;
        }
        
        const idx = this.valToIdx.get(val);
        const lastVal = this.values[this.values.length - 1];
        
        // Swap with last
        this.values[idx] = lastVal;
        this.valToIdx.set(lastVal, idx);
        
        // Remove last
        this.values.pop();
        this.valToIdx.delete(val);
        
        return true;
    }
    
    /**
     * Get random element.
     * @return {number}
     */
    getRandom() {
        const randomIdx = Math.floor(Math.random() * this.values.length);
        return this.values[randomIdx];
    }
}
```

### JavaScript - With Duplicates (LC 381 Variant)

```javascript
class RandomizedCollection {
    /**
     * Allows duplicates.
     * Uses Map with Set of indices.
     */
    constructor() {
        this.valToIndices = new Map();  // value ‚Üí Set of indices
        this.values = [];
    }
    
    insert(val) {
        if (!this.valToIndices.has(val)) {
            this.valToIndices.set(val, new Set());
        }
        
        this.valToIndices.get(val).add(this.values.length);
        this.values.push(val);
        
        // Returns true if val was not present before
        return this.valToIndices.get(val).size === 1;
    }
    
    remove(val) {
        if (!this.valToIndices.has(val) || this.valToIndices.get(val).size === 0) {
            return false;
        }
        
        // Get one index to remove
        const idxSet = this.valToIndices.get(val);
        const idx = idxSet.values().next().value;
        idxSet.delete(idx);
        
        const lastIdx = this.values.length - 1;
        const lastVal = this.values[lastIdx];
        
        if (idx !== lastIdx) {
            // Swap with last
            this.values[idx] = lastVal;
            this.valToIndices.get(lastVal).delete(lastIdx);
            this.valToIndices.get(lastVal).add(idx);
        }
        
        // Remove last
        this.values.pop();
        
        return true;
    }
    
    getRandom() {
        return this.values[Math.floor(Math.random() * this.values.length)];
    }
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| insert | O(1) average | O(1) |
| remove | O(1) average | O(1) |
| getRandom | O(1) | O(1) |
| Overall Space | - | O(n) |

**Why O(1)?**
- Insert: Hash map set + array append = O(1)
- Remove: Hash lookup + swap + pop = O(1)
- Random: Array random index access = O(1)

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Allow duplicates | Set ‚Üí List of indices | LC 381 |
| Weighted random | Weighted probability | Custom |
| With frequency | Track counts | Custom |
| Thread-safe | Synchronization | Custom |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Update Swapped Element's Index

```python
# ‚ùå WRONG: Not updating hash map
def remove(self, val):
    idx = self.val_to_idx[val]
    last_val = self.values[-1]
    
    self.values[idx] = last_val
    # Forgot to update: self.val_to_idx[last_val] = idx
    
    self.values.pop()
    del self.val_to_idx[val]

# ‚úÖ CORRECT: Update hash map for swapped element
def remove(self, val):
    idx = self.val_to_idx[val]
    last_val = self.values[-1]
    
    self.values[idx] = last_val
    self.val_to_idx[last_val] = idx  # Critical!
    
    self.values.pop()
    del self.val_to_idx[val]
```

### 2. Self-Swap Bug When Removing Last Element

```python
# ‚ùå PROBLEMATIC: Self-swap issue
def remove(self, val):
    idx = self.val_to_idx[val]
    last_val = self.values[-1]
    
    self.values[idx] = last_val
    self.val_to_idx[last_val] = idx
    
    self.values.pop()
    del self.val_to_idx[val]
    # If val == last_val, we just deleted the index we updated!

# ‚úÖ SAFER: Handle edge case
def remove(self, val):
    idx = self.val_to_idx[val]
    last_idx = len(self.values) - 1
    last_val = self.values[last_idx]
    
    if idx != last_idx:  # Only swap if not already last
        self.values[idx] = last_val
        self.val_to_idx[last_val] = idx
    
    self.values.pop()
    del self.val_to_idx[val]
```

### 3. Wrong Return Value Logic

```python
# ‚ùå WRONG: Always returning True
def insert(self, val):
    self.val_to_idx[val] = len(self.values)
    self.values.append(val)
    return True  # Wrong if val already existed!

# ‚úÖ CORRECT: Check existence first
def insert(self, val):
    if val in self.val_to_idx:
        return False
    self.val_to_idx[val] = len(self.values)
    self.values.append(val)
    return True
```

### 4. Non-Uniform Random Distribution

```python
# ‚ùå WRONG: Using hash map for random (non-uniform)
def getRandom(self):
    # This doesn't give uniform distribution!
    import random
    return random.choice(list(self.val_to_idx.keys()))
    # Also O(n) to convert to list!

# ‚úÖ CORRECT: Use array for uniform O(1) random
def getRandom(self):
    return random.choice(self.values)  # O(1), uniform
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Key Difference |
|---------|------------|----------------|
| RandomizedSet | üü° Medium | This problem |
| RandomizedCollection | üî¥ Hard | Allows duplicates |
| Shuffle an Array | üü° Medium | Fisher-Yates shuffle |
| Random Pick with Weight | üü° Medium | Weighted probability |

**Related LeetCode:**
- [381. Insert Delete GetRandom O(1) - Duplicates allowed](https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)
- [384. Shuffle an Array](https://leetcode.com/problems/shuffle-an-array/)
- [528. Random Pick with Weight](https://leetcode.com/problems/random-pick-with-weight/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand the swap-to-end trick
- **Day 3:** Implement from scratch
- **Day 7:** Solve LC 381 (with duplicates)
- **Day 14:** Explain why both structures are needed
- **Day 30:** < 10 min implementation

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Communication Template</strong></summary>

**1. Identify the challenge:**
> "Array gives O(1) random but O(n) delete. Hash set gives O(1) delete but O(n) random. I need both."

**2. Propose solution:**
> "I'll use both: array for O(1) random access, hash map for O(1) value lookup. The trick is swap-to-end deletion."

**3. Explain the trick:**
> "For O(1) deletion from array, I swap the element with the last element, then pop. No shifting needed."

**4. Implementation details:**
> "Hash map stores value ‚Üí index. When removing, I update the swapped element's index in the hash map."

**5. Follow-up (duplicates):**
> "For duplicates, I'd change hash map to store value ‚Üí set of indices."

</details>

**Company Frequency:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Design focus |
| LinkedIn | ‚≠ê‚≠ê‚≠ê‚≠ê | Frequent |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask variants |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand problem | 2 min |
| Design approach | 3 min |
| Implement | 10-12 min |
| Test edge cases | 3 min |
| **Total** | **18-20 min** |

---

> **üí° Key Insight:** The swap-to-end trick is the key to O(1) array deletion. Instead of shifting elements, swap with the last element and pop. The hash map tracks indices so we can find elements in O(1) to perform the swap.

> **üîó Related:** [Design Overview](./8.1-Design-Overview.md) | [LRU Cache](./8.4-LRU-Cache-LC146.md) | [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
