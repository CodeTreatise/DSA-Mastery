# 6.4 Smallest Range Covering Elements from K Lists (LC 632)

## Problem Statement

You have `k` lists of sorted integers in **non-decreasing order**. Find the **smallest range [a, b]** that includes at least one number from each of the `k` lists.

The range [a, b] is smaller than [c, d] if b - a < d - c or a < c if b - a == d - c.

```
Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]
Output: [20,24]

Explanation:
- List 0: 24 is in range [20,24]
- List 1: 20 is in range [20,24]
- List 2: 22 is in range [20,24]
Range width = 24 - 20 = 4 (smallest possible)
```

**LeetCode:** [632. Smallest Range Covering Elements from K Lists](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/)

---

## ðŸŽ¯ Pattern Recognition

<details>
<summary><strong>Pattern: K-Way Merge with Range Tracking</strong></summary>

**Key signals:**
- "K sorted lists"
- "Smallest range covering all lists"
- Need one element from each list

**Pattern insight:**
```
At any point, we have k pointers (one per list).
The range is [min of k values, max of k values].

To minimize range:
  - Track current min and max
  - Advance the minimum pointer (can't shrink by advancing max)
  - If any list exhausted, can't improve further
```

**Why min-heap:**
```
Need to quickly:
1. Find current minimum among k pointers
2. Find which list has the minimum
3. Advance that list's pointer

Min-heap gives O(log k) for finding and updating minimum.
Track maximum separately (just update on each push).
```

</details>

---

## âœ… When to Use This Pattern

| Scenario | Approach |
|----------|----------|
| Smallest range from k lists | K-Way merge + range tracking |
| All lists must contribute | Keep one element from each |
| Sorted lists | Heap for efficient merge |

## âŒ When NOT to Use

| Scenario | Better Alternative |
|----------|---------------------|
| Unsorted lists | Sort first or different approach |
| Range with count â‰¥ k | Sliding window |
| Just merge lists | Simple K-way merge |

---

## ðŸ“ Solution Approach

### K-Way Merge with Range Tracking

```
Data Structures:
- min_heap: (value, list_idx, elem_idx) - current pointers
- current_max: maximum value among current pointers

Algorithm:
1. Initialize heap with first element from each list
2. Track initial max among first elements
3. While all lists still have elements:
   a. Pop minimum from heap
   b. Current range = [min, current_max]
   c. Update best range if this is smaller
   d. Push next element from same list (if exists)
   e. Update current_max
   f. If any list exhausted, stop
4. Return best range
```

### Walkthrough Example

```
Lists: [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]

Initial:
  heap = [(0,1,0), (4,0,0), (5,2,0)]
  current_max = 5
  range = [0, 5], width = 5

Pop (0,1,0), push (9,1,1):
  heap = [(4,0,0), (5,2,0), (9,1,1)]
  current_max = 9
  range = [4, 9], width = 5

Pop (4,0,0), push (10,0,1):
  heap = [(5,2,0), (9,1,1), (10,0,1)]
  current_max = 10
  range = [5, 10], width = 5

Pop (5,2,0), push (18,2,1):
  heap = [(9,1,1), (10,0,1), (18,2,1)]
  current_max = 18
  range = [9, 18], width = 9

Pop (9,1,1), push (12,1,2):
  heap = [(10,0,1), (12,1,2), (18,2,1)]
  current_max = 18
  range = [10, 18], width = 8

...continue...

Eventually find [20, 24] with width 4 (best)
```

---

## ðŸ’» Code Implementation

### Python Solution

**Python:**
```python
import heapq

def smallestRange(nums: list[list[int]]) -> list[int]:
    """
    LC 632: Smallest Range Covering Elements from K Lists
    
    K-Way Merge with range tracking.
    
    Min-heap tracks current minimum across k lists.
    Separately track current maximum.
    Advance minimum pointer and update range.
    
    Time: O(n log k) where n = total elements, k = number of lists
    Space: O(k) for heap
    """
    k = len(nums)
    
    # Min-heap: (value, list_idx, element_idx)
    min_heap = []
    current_max = float('-inf')
    
    # Initialize with first element from each list
    for i in range(k):
        if nums[i]:  # Non-empty list
            heapq.heappush(min_heap, (nums[i][0], i, 0))
            current_max = max(current_max, nums[i][0])
    
    # Track best range
    best_range = [float('-inf'), float('inf')]
    
    while len(min_heap) == k:  # Must have element from each list
        current_min, list_idx, elem_idx = heapq.heappop(min_heap)
        
        # Check if this range is better
        if current_max - current_min < best_range[1] - best_range[0]:
            best_range = [current_min, current_max]
        
        # Move to next element in this list
        if elem_idx + 1 < len(nums[list_idx]):
            next_val = nums[list_idx][elem_idx + 1]
            heapq.heappush(min_heap, (next_val, list_idx, elem_idx + 1))
            current_max = max(current_max, next_val)
        # If list exhausted, loop ends (len(heap) < k)
    
    return best_range


# Example
nums = [[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]]
print(smallestRange(nums))  # [20, 24]
```

### Alternative: With Cleaner Structure

**Python:**
```python
import heapq
from typing import List

def smallestRange_v2(nums: List[List[int]]) -> List[int]:
    """
    Cleaner version with explicit tracking.
    """
    k = len(nums)
    
    # (value, list_index, element_index)
    pq = [(lst[0], i, 0) for i, lst in enumerate(nums)]
    heapq.heapify(pq)
    
    right = max(lst[0] for lst in nums)
    result = [pq[0][0], right]
    
    while True:
        left, i, j = heapq.heappop(pq)
        
        # Update result if better
        if right - left < result[1] - result[0]:
            result = [left, right]
        
        # If list i is exhausted, we can't continue
        if j + 1 == len(nums[i]):
            break
        
        # Push next element from list i
        next_val = nums[i][j + 1]
        heapq.heappush(pq, (next_val, i, j + 1))
        right = max(right, next_val)
    
    return result
```

### JavaScript Solution

**JavaScript:**
```javascript
function smallestRange(nums) {
    const k = nums.length;
    
    // Min-heap: [value, listIdx, elemIdx]
    const heap = [];
    let currentMax = -Infinity;
    
    // Helper functions for heap
    const push = (item) => {
        heap.push(item);
        let i = heap.length - 1;
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (heap[parent][0] <= heap[i][0]) break;
            [heap[parent], heap[i]] = [heap[i], heap[parent]];
            i = parent;
        }
    };
    
    const pop = () => {
        const min = heap[0];
        const last = heap.pop();
        if (heap.length > 0) {
            heap[0] = last;
            let i = 0;
            while (true) {
                let smallest = i;
                const left = 2 * i + 1;
                const right = 2 * i + 2;
                if (left < heap.length && heap[left][0] < heap[smallest][0]) smallest = left;
                if (right < heap.length && heap[right][0] < heap[smallest][0]) smallest = right;
                if (smallest === i) break;
                [heap[i], heap[smallest]] = [heap[smallest], heap[i]];
                i = smallest;
            }
        }
        return min;
    };
    
    // Initialize heap
    for (let i = 0; i < k; i++) {
        push([nums[i][0], i, 0]);
        currentMax = Math.max(currentMax, nums[i][0]);
    }
    
    let bestRange = [-Infinity, Infinity];
    
    while (heap.length === k) {
        const [currentMin, listIdx, elemIdx] = pop();
        
        // Check if better range
        if (currentMax - currentMin < bestRange[1] - bestRange[0]) {
            bestRange = [currentMin, currentMax];
        }
        
        // Advance pointer in this list
        if (elemIdx + 1 < nums[listIdx].length) {
            const nextVal = nums[listIdx][elemIdx + 1];
            push([nextVal, listIdx, elemIdx + 1]);
            currentMax = Math.max(currentMax, nextVal);
        }
        // If list exhausted, loop ends
    }
    
    return bestRange;
}

// Example
console.log(smallestRange([[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]));
// [20, 24]
```

---

## âš¡ Complexity Analysis

| Aspect | Complexity | Explanation |
|--------|------------|-------------|
| Time |" O(n log k) "| n total elements, log k per heap op |
| Space |" O(k) "| Heap stores one element per list |

**Detailed analysis:**
```
n = total number of elements across all lists
k = number of lists

Each element is:
  - Pushed once: O(log k)
  - Popped once: O(log k)

Total: O(n log k)

Space: Heap has exactly k elements at any time
```

---

## ðŸ”„ Variations

| Variation | Difference | Approach |
|-----------|------------|----------|
| Unsorted lists | Not sorted | Sort each list first |
| At least k/2 lists | Relaxed constraint | Sliding window on merged |
| Maximize range | Opposite goal | Different strategy |
| Infinite lists | Generators | Same heap approach |

---

## âš ï¸ Common Mistakes

### 1. Not Tracking Maximum Correctly

```python
# âŒ Wrong: Not updating max when pushing new element
next_val = nums[list_idx][elem_idx + 1]
heapq.heappush(min_heap, (next_val, list_idx, elem_idx + 1))
# Forgot to update current_max!

# âœ… Correct: Update max on each push
heapq.heappush(min_heap, (next_val, list_idx, elem_idx + 1))
current_max = max(current_max, next_val)
```

### 2. Not Checking Heap Size

```python
# âŒ Wrong: Continuing when a list is exhausted
while min_heap:  # Wrong condition!
    current_min, list_idx, elem_idx = heapq.heappop(min_heap)
    # Range now doesn't cover all lists!

# âœ… Correct: Stop when any list is exhausted
while len(min_heap) == k:
    current_min, list_idx, elem_idx = heapq.heappop(min_heap)
    ...
```

### 3. Comparing Ranges Wrong

```python
# âŒ Wrong: Only comparing width
if current_max - current_min < best_width:
    best_range = [current_min, current_max]
    best_width = current_max - current_min

# This misses the tie-breaker: prefer smaller left endpoint

# âœ… Correct: Compare width, then left endpoint
current_width = current_max - current_min
best_width = best_range[1] - best_range[0]
if current_width < best_width:
    best_range = [current_min, current_max]
elif current_width == best_width and current_min < best_range[0]:
    best_range = [current_min, current_max]
```

### 4. Empty List Handling

```python
# âŒ Wrong: Assuming all lists non-empty
for i in range(k):
    heapq.heappush(min_heap, (nums[i][0], i, 0))

# âœ… Correct: Check for empty lists
for i in range(k):
    if nums[i]:
        heapq.heappush(min_heap, (nums[i][0], i, 0))
# Also handle case where result is impossible
```

---

## ðŸ“ Related Practice Problems

### K-Way Merge Pattern
- [ ] [Merge K Sorted Lists (LC 23)](https://leetcode.com/problems/merge-k-sorted-lists/)
- [ ] [Kth Smallest Element in Sorted Matrix (LC 378)](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)
- [ ] [Find K Pairs with Smallest Sums (LC 373)](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/)

### Range/Window Problems
- [ ] [Minimum Window Substring (LC 76)](https://leetcode.com/problems/minimum-window-substring/)
- [ ] [Sliding Window Maximum (LC 239)](https://leetcode.com/problems/sliding-window-maximum/)

<details>
<summary><strong>ðŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand the approach, trace example
- **Day 3:** Implement from scratch
- **Day 7:** Solve Merge K Sorted Lists first
- **Day 14:** Revisit and optimize
- **Day 30:** Teach the pattern

</details>

---

## ðŸŽ¤ Interview Context

<details>
<summary><strong>How to Communicate This Solution</strong></summary>

**Opening:**
"This is a K-Way Merge problem where we need to track the current range. I'll maintain a min-heap with one pointer per list. At any time, my range is [heap minimum, current maximum]."

**Key insight:**
"To minimize the range, I can only advance the minimum pointer. Advancing any other pointer would make the range wider. So I repeatedly pop the minimum, update the range if it's smaller, and push the next element from that list."

**Termination:**
"When any list is exhausted, I can't have a valid range anymore - I need at least one element from each list. So I stop when the heap size drops below k."

**Complexity:**
"Each of the n total elements is pushed and popped once, at O(log k) each. Total time is O(n log k). Space is O(k) for the heap."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Google | â­â­â­â­â­ | Hard favorite |
| Amazon | â­â­â­â­ | Merge pattern |
| Meta | â­â­â­ | K-way merge |
| Apple | â­â­â­ | Range problems |

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 5-7 min | Tricky constraints |
| Design solution | 10-12 min | K-way merge insight |
| Implement | 15-18 min | Track min and max |
| Test | 5-7 min | Trace through |

**Interview target:** 35-40 minutes (hard problem)

---

## ðŸ’¡ Key Insight

> **To minimize a range covering k lists, only advance the minimum pointer.** Use a min-heap to track the current minimum across k pointers and separately track the maximum. The range is [heap.min, current_max]. When the minimum advances, check if the new range is smaller. Stop when any list is exhausted.

---

## ðŸ”— Related

- **Previous:** [Kth Smallest in Matrix (LC 378)](./6.3-Kth-Smallest-Matrix-LC378.md)
- **Pattern:** [K-Way Merge Overview](./6.1-K-Way-Merge-Overview.md)
- **Foundational:** [Merge K Sorted Lists (LC 23)](./6.2-Merge-K-Lists-LC23.md)
