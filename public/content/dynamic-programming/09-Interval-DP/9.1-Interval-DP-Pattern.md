# Interval DP Pattern

> **Think in ranges, not positions.** Interval DP solves problems where optimal solutions for larger ranges depend on optimal solutions for smaller ranges within them. It's the pattern behind matrix chain multiplication, burst balloons, and many string/array optimization problems.

---

## üìã Overview

**Interval DP** (also called Range DP) is a pattern where:
- State is defined over a range `[i, j]`
- We consider all possible ways to split/merge that range
- Optimal for subranges combines to give optimal for larger range

**Key Characteristic:** We fill the DP table by increasing interval length.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Interval DP</strong></summary>

**Look for these signals:**
- Problem involves a sequence/array that you process from two ends
- Decision involves "merging" or "splitting" at some point
- Optimal substructure: optimal for [i,j] depends on optimal for [i,k] and [k,j]
- Often involves parenthesization or grouping

**Keywords in problem statement:**
- "minimum cost to merge"
- "split the array/string"
- "remove elements from both ends"
- "matrix chain multiplication"
- "burst all balloons"

**Classic problems:**
- Matrix Chain Multiplication
- Burst Balloons
- Minimum Cost to Merge Stones
- Optimal BST Construction
- Palindrome-related problems

</details>

---

## ‚úÖ When to Use Interval DP

| Scenario | Example |
|----------|---------|
| Merge adjacent elements optimally | Merge Stones, Matrix Chain |
| Process sequence from two ends | Stone Game, Burst Balloons |
| Parenthesization problems | Evaluate Expression |
| Substring/subarray optimization | Palindrome DP, Optimal BST |

## ‚ùå When NOT to Use

| Scenario | Use Instead |
|----------|-------------|
| Single-direction processing | Linear DP |
| Two sequences comparison | LCS Pattern |
| Subsequence (not substring) | LCS or LIS |
| Grid traversal | Grid DP |

---

## üìê The Interval DP Template

### Standard Template

```python
def interval_dp(arr: list) -> int:
    """
    Template for interval DP problems.
    """
    n = len(arr)
    
    # dp[i][j] = optimal value for interval [i, j]
    dp = [[0] * n for _ in range(n)]
    
    # Base case: intervals of length 1
    for i in range(n):
        dp[i][i] = base_case_value(arr[i])
    
    # Fill by increasing interval length
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            dp[i][j] = worst_value  # Initialize (inf or -inf)
            
            # Try all split points
            for k in range(i, j):  # or range(i, j + 1) depending on problem
                # Combine solutions from [i, k] and [k+1, j]
                candidate = combine(dp[i][k], dp[k+1][j], cost(i, j, k))
                dp[i][j] = optimize(dp[i][j], candidate)
    
    return dp[0][n-1]
```

### Key Components

1. **State:** `dp[i][j]` = answer for range `[i, j]`
2. **Order:** Fill by increasing length (so subranges are ready)
3. **Transition:** Try all split points k in `[i, j-1]`
4. **Combine:** Merge results from left and right subranges

---

## üíª Core Problem Examples

### Problem 1: Matrix Chain Multiplication

**Minimize multiplications to compute A‚ÇÅ √ó A‚ÇÇ √ó ... √ó A‚Çô**

```python
def matrix_chain_order(dimensions: list[int]) -> int:
    """
    dimensions[i-1] √ó dimensions[i] = dimension of matrix i
    Time: O(n¬≥), Space: O(n¬≤)
    """
    n = len(dimensions) - 1  # Number of matrices
    
    # dp[i][j] = min operations to multiply matrices i to j
    dp = [[0] * n for _ in range(n)]
    
    # Length 1: single matrix, no multiplication
    # (already 0 from initialization)
    
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = float('inf')
            
            # Try all split points
            for k in range(i, j):
                # Cost = left chain + right chain + combining cost
                cost = (dp[i][k] + dp[k+1][j] + 
                       dimensions[i] * dimensions[k+1] * dimensions[j+1])
                dp[i][j] = min(dp[i][j], cost)
    
    return dp[0][n-1]
```

### Problem 2: Burst Balloons (LC 312)

```python
def max_coins(nums: list[int]) -> int:
    """
    Maximize coins from bursting all balloons.
    Key insight: Think of which balloon to burst LAST in range.
    """
    # Add boundary balloons
    nums = [1] + nums + [1]
    n = len(nums)
    
    # dp[i][j] = max coins for bursting all balloons in (i, j) exclusive
    dp = [[0] * n for _ in range(n)]
    
    for length in range(2, n):  # Length of gap
        for i in range(n - length):
            j = i + length
            
            # Try each balloon k as the LAST to burst
            for k in range(i + 1, j):
                # Coins from bursting k last
                coins = nums[i] * nums[k] * nums[j]
                # Plus optimal for left and right
                total = dp[i][k] + dp[k][j] + coins
                dp[i][j] = max(dp[i][j], total)
    
    return dp[0][n-1]
```

### Problem 3: Minimum Cost to Merge Stones (LC 1000)

```python
def merge_stones(stones: list[int], k: int) -> int:
    """
    Merge k consecutive piles at a time.
    Cost = sum of merged piles.
    """
    n = len(stones)
    
    # Check if merging is possible
    if (n - 1) % (k - 1) != 0:
        return -1
    
    # Prefix sums for range sum
    prefix = [0]
    for s in stones:
        prefix.append(prefix[-1] + s)
    
    def range_sum(i, j):
        return prefix[j + 1] - prefix[i]
    
    # dp[i][j] = min cost to reduce [i, j] as much as possible
    dp = [[0] * n for _ in range(n)]
    
    for length in range(k, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = float('inf')
            
            # Split into two parts where left can be merged to 1 pile
            for mid in range(i, j, k - 1):
                dp[i][j] = min(dp[i][j], dp[i][mid] + dp[mid + 1][j])
            
            # If this range can be merged into 1 pile
            if (length - 1) % (k - 1) == 0:
                dp[i][j] += range_sum(i, j)
    
    return dp[0][n - 1]
```

---

## ‚ö° Complexity Analysis

**For standard interval DP:**
- **Time:** O(n¬≥) - n¬≤ states, O(n) transitions each
- **Space:** O(n¬≤)

**Optimization possibilities:**
- Knuth's optimization ‚Üí O(n¬≤) for certain problems
- Divide and conquer optimization
- Monotonic structures

---

## üîÑ Interval DP Variations

### Type 1: Split at a Point

```python
# Matrix chain, optimal BST
for k in range(i, j):
    dp[i][j] = optimize(dp[i][k] + dp[k+1][j] + cost)
```

### Type 2: Choose Last/First Element

```python
# Burst balloons - what if k is LAST?
for k in range(i + 1, j):
    dp[i][j] = optimize(dp[i][k] + dp[k][j] + value(k))
```

### Type 3: Expand from Ends

```python
# Palindrome, remove from ends
if arr[i] == arr[j]:
    dp[i][j] = dp[i+1][j-1] + 2
else:
    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Fill Order

**‚ùå Wrong:**
```python
for i in range(n):
    for j in range(i, n):
        # dp[i+1][j] or dp[i][j-1] might not be ready!
```

**‚úÖ Correct:**
```python
for length in range(1, n + 1):  # Increasing length
    for i in range(n - length + 1):
        j = i + length - 1
        # Now all smaller ranges are computed
```

### 2. Off-by-One in Split Points

**‚ùå Wrong:**
```python
for k in range(i, j + 1):  # k can equal j?
    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])
    # dp[k][j] when k=j is just 0 anyway, but logic is confusing
```

**‚úÖ Correct:**
```python
for k in range(i, j):  # k is split point: [i,k] and [k+1,j]
    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + cost)
```

### 3. Forgetting Base Case

```python
# Don't forget: single element intervals
for i in range(n):
    dp[i][i] = 0  # or specific value
```

### 4. Burst Balloons: Thinking About First vs Last

In Burst Balloons, we think about which balloon to burst **LAST**, not first.

```python
# LAST balloon in (i, j) to pop is k
# When k pops, neighbors are nums[i] and nums[j] (the boundaries)
coins = nums[i] * nums[k] * nums[j]
```

---

## üìä Visualization: Fill Order

```
Matrix of size 5x5 (n=5)

Fill order by length:
Length 1: [0,0], [1,1], [2,2], [3,3], [4,4]
Length 2: [0,1], [1,2], [2,3], [3,4]
Length 3: [0,2], [1,3], [2,4]
Length 4: [0,3], [1,4]
Length 5: [0,4]

     0    1    2    3    4
0  [L1] [L2] [L3] [L4] [L5]
1       [L1] [L2] [L3] [L4]
2            [L1] [L2] [L3]
3                 [L1] [L2]
4                      [L1]

Final answer: dp[0][4]
```

---

## üìù Practice Problems (Progressive)

### Medium
- [ ] [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/) - Classic interval DP
- [ ] [1039. Minimum Score Triangulation of Polygon](https://leetcode.com/problems/minimum-score-triangulation-of-polygon/) - Triangulation
- [ ] [96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/) - Catalan numbers

### Hard
- [ ] [312. Burst Balloons](https://leetcode.com/problems/burst-balloons/) - Think in reverse
- [ ] [1000. Minimum Cost to Merge Stones](https://leetcode.com/problems/minimum-cost-to-merge-stones/) - K-way merge
- [ ] [1246. Palindrome Removal](https://leetcode.com/problems/palindrome-removal/) - Remove palindromes

### Classic (Not on LeetCode)
- [ ] Matrix Chain Multiplication
- [ ] Optimal Binary Search Tree

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: Longest Palindromic Subsequence
- Day 3: Matrix Chain Multiplication (concept)
- Day 5: Burst Balloons
- Day 7: Review template

**Week 2:**
- Day 8: Minimum Score Triangulation
- Day 10: Minimum Cost to Merge Stones
- Day 12: Revisit Burst Balloons
- Day 14: Pattern mastery test

</details>

---

## üé§ Interview Tips

**Recognize the pattern:**
> "This looks like interval DP because the optimal solution for a range depends on optimal solutions for subranges. I'll define dp[i][j] as the answer for the range [i, j] and fill by increasing length."

**Key template to communicate:**
1. Define state: `dp[i][j]` = ?
2. Base case: length 1 (or 0)
3. Transition: try all split points k
4. Order: fill by increasing length
5. Answer: `dp[0][n-1]`

**Common insight for Burst Balloons:**
> "The key insight is to think about which balloon to burst LAST in a range, not first. When we burst balloon k last, its neighbors are the range boundaries, not the original neighbors."

**Company frequency:**
| Company | Frequency | Focus |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | All variations |
| Amazon | ‚≠ê‚≠ê‚≠ê | Burst Balloons |
| Meta | ‚≠ê‚≠ê‚≠ê | Merge problems |
| Microsoft | ‚≠ê‚≠ê | Basic problems |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Learn pattern | 45-60 min |
| Solve basic interval DP | 25-30 min |
| Solve Burst Balloons | 30-40 min |
| Master pattern | 6-8 problems |

---

> **üí° Key Insight:** Interval DP's power comes from the fill order. By processing small ranges before large ones, we guarantee that when we compute `dp[i][j]`, all subranges `dp[i][k]` and `dp[k+1][j]` are already optimal. This bottom-up structure is what makes O(n¬≥) achievable.

> **üîó Related:** [Palindrome DP](../08-Palindrome-DP/) | [Matrix Chain](./9.2-Interval-Practice/02-Burst-Balloons-LC312.md) | [LCS Pattern](../06-LCS-Pattern/)
