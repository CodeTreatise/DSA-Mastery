# 7.2 - Lowest Common Ancestor of Deepest Leaves (LC 1123)

> **Grokking Pattern:** #11 Tree DFS (LCA + Depth Pattern)
>
> **Difficulty:** Medium | **Frequency:** ‚≠ê‚≠ê Less Common

---

## Problem Statement

Given the `root` of a binary tree, return the **lowest common ancestor** of its **deepest leaves**.

Recall that:
- A **leaf** is a node with no children
- The **depth** of a node is the number of edges to the root
- The **lowest common ancestor** of a set of nodes is the deepest node that has all of them as descendants

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4]

        3           ‚Üê depth 0
       / \
      5   1         ‚Üê depth 1
     / \ / \
    6  2 0  8       ‚Üê depth 2
      / \
     7   4          ‚Üê depth 3 (deepest leaves)

Output: 2
Explanation: Deepest leaves are 7 and 4. Their LCA is 2.
```

```
Input: root = [1]
Output: 1
Explanation: The root is the deepest leaf and its own LCA.
```

```
Input: root = [0,1,3,null,2]
        0
       / \
      1   3         
       \           
        2          ‚Üê depth 2 (only deepest leaf)

Output: 2
Explanation: Only one deepest leaf, so it's its own LCA.
```

[LeetCode 1123 - Lowest Common Ancestor of Deepest Leaves](https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Deepest leaves" mentioned
- LCA of multiple nodes
- Need to find depth AND LCA together

**Key insight:**
Combine two patterns:
1. Find maximum depth (like Maximum Depth problem)
2. Find LCA (like regular LCA problem)

The LCA of deepest leaves is the node where **both subtrees have the same maximum depth**.

</details>

---

## ‚úÖ When to Use

- LCA of all deepest nodes
- Depth-based ancestor finding
- Combining depth and LCA logic

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| LCA of specific nodes | Known targets | Regular LCA (LC 236) |
| Just finding depth | Don't need LCA | Maximum Depth |
| BST properties matter | Value comparisons | BST-specific LCA |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Maximum Depth](../04-Tree-Properties/4.1-Maximum-Depth.md) - Depth calculation
- [LCA of Binary Tree](./7.1-LCA-Binary-Tree.md) - LCA concept

**After mastering this:**
- Complex tree ancestor problems
- Multi-criteria tree traversals

</details>

---

## üìê How It Works

### The Key Insight

At each node, compare the depth of left and right subtrees:
- If `left_depth > right_depth`: LCA is in left subtree
- If `right_depth > left_depth`: LCA is in right subtree
- If `left_depth == right_depth`: Current node is the LCA

### Why This Works

```
        3           left_depth=3, right_depth=2 ‚Üí LCA in left
       / \
      5   1         left_depth=2, right_depth=2 ‚Üí Would be LCA here
     / \ / \        but we continue checking...
    6  2 0  8
      / \           left_depth=3, right_depth=3 ‚Üí This is LCA!
     7   4          

Node 2: left has depth 3, right has depth 3
        ‚Üí Both sides reach the deepest level
        ‚Üí Node 2 is the LCA of deepest leaves
```

### Return Value

Return a tuple: `(node, depth)`
- `node`: The LCA of deepest leaves in this subtree
- `depth`: The maximum depth in this subtree

---

## üíª Code Implementation

### Solution 1: Return (LCA, Depth) Tuple

**Python:**
```python
from typing import Optional, Tuple

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def lca_deepest_leaves(root: Optional[TreeNode]) -> Optional[TreeNode]:
    """
    Find LCA of deepest leaves.
    
    Returns the node where both subtrees have equal maximum depth.
    
    Time: O(n), Space: O(h)
    """
    def dfs(node) -> Tuple[Optional[TreeNode], int]:
        """Returns (lca_of_deepest, max_depth_in_subtree)"""
        if not node:
            return (None, 0)
        
        left_lca, left_depth = dfs(node.left)
        right_lca, right_depth = dfs(node.right)
        
        if left_depth > right_depth:
            # Deepest leaves are in left subtree
            return (left_lca, left_depth + 1)
        elif right_depth > left_depth:
            # Deepest leaves are in right subtree
            return (right_lca, right_depth + 1)
        else:
            # Equal depth: current node is LCA of deepest
            return (node, left_depth + 1)
    
    lca, _ = dfs(root)
    return lca
```

**JavaScript:**
```javascript
function lcaDeepestLeaves(root) {
    function dfs(node) {
        // Returns [lca, depth]
        if (!node) return [null, 0];
        
        const [leftLCA, leftDepth] = dfs(node.left);
        const [rightLCA, rightDepth] = dfs(node.right);
        
        if (leftDepth > rightDepth) {
            return [leftLCA, leftDepth + 1];
        } else if (rightDepth > leftDepth) {
            return [rightLCA, rightDepth + 1];
        } else {
            return [node, leftDepth + 1];
        }
    }
    
    return dfs(root)[0];
}
```

### Solution 2: Two-Pass Approach (Clearer Logic)

**Python:**
```python
def lca_deepest_leaves_two_pass(root: Optional[TreeNode]) -> Optional[TreeNode]:
    """
    Two-pass approach:
    1. Find maximum depth
    2. Find LCA of all nodes at that depth
    """
    # Pass 1: Find max depth
    def max_depth(node):
        if not node:
            return 0
        return 1 + max(max_depth(node.left), max_depth(node.right))
    
    target_depth = max_depth(root)
    
    # Pass 2: Find LCA of deepest leaves
    def find_lca(node, depth):
        if not node:
            return None
        if depth == target_depth:
            return node  # This is a deepest leaf
        
        left = find_lca(node.left, depth + 1)
        right = find_lca(node.right, depth + 1)
        
        if left and right:
            return node  # Both sides have deepest leaves
        return left or right
    
    return find_lca(root, 1)
```

### Solution 3: BFS + Bottom-Up LCA

**Python:**
```python
from collections import deque

def lca_deepest_leaves_bfs(root: Optional[TreeNode]) -> Optional[TreeNode]:
    """
    BFS to find deepest level, then bottom-up to find LCA.
    """
    if not root:
        return None
    
    parent = {root: None}
    queue = deque([root])
    deepest_leaves = []
    
    # BFS to find all leaves at deepest level
    while queue:
        level_size = len(queue)
        deepest_leaves = list(queue)  # Current level could be deepest
        
        for _ in range(level_size):
            node = queue.popleft()
            if node.left:
                parent[node.left] = node
                queue.append(node.left)
            if node.right:
                parent[node.right] = node
                queue.append(node.right)
    
    # Now find LCA of all deepest leaves
    # Start with all deepest leaves, move up until one node remains
    current_set = set(deepest_leaves)
    
    while len(current_set) > 1:
        current_set = {parent[node] for node in current_set if parent[node]}
    
    return current_set.pop()
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Single DFS (Tuple) |" O(n) "| O(h) | Most efficient |
| Two Pass |" O(n) "| O(h) | Clearer logic |
| BFS + Bottom-up |" O(n) "| O(n) | More space |

**Recommendation:** Single DFS with tuple return is best.

---

## üîÑ Variations

| Variation | Difference | LeetCode |
|-----------|------------|----------|
| LCA of two nodes | Specific targets | LC 236 |
| LCA in BST | Use value comparison | LC 235 |
| Smallest subtree with deepest nodes | Same problem! | LC 865 |

**Note:** LC 865 and LC 1123 are the **same problem** with different wording!

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Return Depth

```python
# ‚ùå WRONG: Only returning LCA
def dfs(node):
    if not node:
        return None
    left = dfs(node.left)
    right = dfs(node.right)
    # How do we know which subtree is deeper?

# ‚úÖ CORRECT: Return (lca, depth) tuple
def dfs(node):
    if not node:
        return (None, 0)
    left_lca, left_depth = dfs(node.left)
    right_lca, right_depth = dfs(node.right)
    # Now we can compare depths!
```

### 2. Wrong Comparison Logic

```python
# ‚ùå WRONG: Using >= instead of >
if left_depth >= right_depth:
    return (left_lca, left_depth + 1)
# When equal, should return CURRENT node, not left_lca!

# ‚úÖ CORRECT: Three-way comparison
if left_depth > right_depth:
    return (left_lca, left_depth + 1)
elif right_depth > left_depth:
    return (right_lca, right_depth + 1)
else:  # Equal
    return (node, left_depth + 1)
```

### 3. Not Handling Single Node

```python
# Single node tree: that node is both the deepest leaf AND its own LCA
# The algorithm handles this correctly:
#   - dfs returns (node, 1) for a leaf
#   - left_depth == right_depth == 0 at a leaf, so return (node, 1)
```

---

## üìù Practice Problems

### This Problem
- [ ] [LCA of Deepest Leaves](https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/) - LC 1123
- [ ] [Smallest Subtree with all Deepest Nodes](https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/) - LC 865 (Same!)

### Prerequisites
- [ ] [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) - LC 104
- [ ] [LCA of Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) - LC 236

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Understand depth comparison logic
**Day 3:** Implement from scratch
**Day 7:** Solve regular LCA first, then this
**Day 14:** Explain why equal depth means current is LCA

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Explaining approach:**
> "I'll do a DFS that returns both the LCA of deepest leaves AND the maximum depth in each subtree. At each node, I compare depths: if one side is deeper, the LCA must be in that subtree. If equal, this node is the LCA since both sides reach the same maximum depth."

**Why tuple return:**
> "I need two pieces of information: which node is the LCA and how deep that subtree goes. The depth lets me make the comparison at each parent node."

**Key insight:**
> "The LCA of deepest leaves is where the deepest level is 'split' - the first node where both children have paths to the deepest level."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê | Asked occasionally |
| Meta | ‚≠ê‚≠ê | Less common |
| Amazon | ‚≠ê‚≠ê | Sometimes appears |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 3-5 min | LCA + depth combo |
| Implement single-pass | 12-15 min | Tuple return |
| Implement two-pass | 10-12 min | Clearer but slower |

---

> **üí° Key Insight:** This problem elegantly combines depth-finding with LCA logic. The key is recognizing that the LCA of deepest leaves is simply the first node where both subtrees have the same maximum depth - that's where the deepest level "splits."

---

## üîó Related

- [LCA of Binary Tree](./7.1-LCA-Binary-Tree.md) - Foundation
- [Maximum Depth](../04-Tree-Properties/4.1-Maximum-Depth.md) - Depth calculation
- [Minimum Depth](../04-Tree-Properties/4.2-Minimum-Depth.md) - Similar depth logic
