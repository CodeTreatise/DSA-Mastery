# 4.1 Fast & Slow Pointer (Tortoise and Hare)

> **Grokking Pattern #2** - Two pointers moving at different speeds to detect cycles and find positions
>
> ‚è±Ô∏è Estimated Learning Time: 45-60 minutes

---

## Overview

The **Fast & Slow Pointer** technique (also called the **Tortoise and Hare** algorithm) uses two pointers that traverse a linked list at different speeds. The slow pointer moves one step at a time, while the fast pointer moves two steps. This simple yet powerful approach solves many linked list problems in O(n) time with O(1) space.

**Core Insight:** If there's a cycle, the fast pointer will eventually catch up to the slow pointer. If there's no cycle, the fast pointer will reach the end.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- Problem mentions "cycle" or "loop" in a linked list
- Need to find the "middle" of a linked list
- Checking if a sequence eventually repeats
- Finding a duplicate in a constrained space (like finding duplicate in array with O(1) space)
- Problems involving "meeting point" of two entities

**Keywords in problem statement:**
- "detect cycle", "find loop", "circular"
- "find middle", "split in half"
- "happy number", "repeating sequence"
- "constant space" + cycle-related problem

**Problem patterns:**
| Pattern | Example Problem |
|---------|-----------------|
| Cycle detection | Linked List Cycle (LC 141) |
| Find cycle start | Linked List Cycle II (LC 142) |
| Find middle | Middle of Linked List (LC 876) |
| Number sequence | Happy Number (LC 202) |
| Array as linked list | Find Duplicate Number (LC 287) |

</details>

---

## ‚úÖ When to Use

- **Cycle detection** in linked lists or implicit graphs
- **Finding the middle** of a linked list in one pass
- **Detecting patterns** in number sequences (like Happy Number)
- **Finding duplicates** when array indices represent next pointers
- When you need **O(1) space** for cycle-related problems
- **Splitting a linked list** into two halves
- Checking if a linked list is a **palindrome**

---

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need to access specific index | No random access in LL | Array indexing |
| Tree structures | Multiple children, not linear | BFS/DFS traversal |
| Need to store visited nodes |" Already using O(1) space approach "| HashSet for O(n) space |
| Doubly linked list operations | Can traverse backward already | Standard traversal |
| Finding all cycles | Only finds one cycle | DFS with coloring |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Linked List Basics](../01-Singly-LL/1.1-Basics.md) - Node structure, traversal
- [Pointer manipulation](../01-Singly-LL/1.2-Operations.md) - Moving pointers
- [Two Pointers concept](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md) - General two-pointer pattern

**After mastering this:**
- [In-Place Reversal](../05-In-Place-Reversal/5.1-Reversal-Technique.md) - Combines with F&S for palindrome
- [Cycle Problems](./4.2-Cycle-Problems/01-Cycle-Detection.md) - Specific applications
- [Find Middle Problems](../07-Two-Pointer-Problems/7.1-Find-Middle.md) - Practical applications

**Combines with:**
- **In-Place Reversal** for palindrome linked list
- **Merge technique** for merge sort on linked list
- **Binary Search** for optimized search in sorted list

</details>

---

## üìê How It Works

### The Core Mechanism

Two pointers start at the same position (usually head):
1. **Slow pointer** moves **1 step** per iteration
2. **Fast pointer** moves **2 steps** per iteration

### Why It Works for Cycle Detection

```
If there's a cycle:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                      ‚îÇ
‚îÇ  Non-cycle part     Cycle part       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ 1 ‚îÇ 2 ‚îÇ 3 ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ 4 ‚îÇ 5 ‚îÇ 6 ‚îÇ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚ñ≤‚îÄ‚îò  ‚îÇ  ‚îÇ
‚îÇ                             ‚îÇ    ‚îÇ  ‚îÇ
‚îÇ                             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Step-by-step (slow=S, fast=F):
  Start: S=1, F=1
  Step 1: S=2, F=3
  Step 2: S=3, F=5
  Step 3: S=4, F=4 ‚Üê They meet! Cycle detected.
```

**Mathematical proof:** In a cycle of length `k`, the fast pointer gains 1 step on the slow pointer each iteration. After at most `k` iterations, they will meet.

### Why It Works for Finding Middle

```
List: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí null
           S       F        (after 2 steps)
               S       F‚Üínull (fast reaches end)
               ‚Üë
             Middle!

When fast reaches end, slow is at middle:
- Fast travels 2x the distance of slow
- When fast = end, slow = middle
```

---

## üíª Code Implementation

### Basic Fast & Slow Template

**Python:**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def fast_slow_template(head: ListNode) -> bool:
    """
    Template for Fast & Slow Pointer pattern.
    
    Pattern: Grokking #2 - Fast & Slow Pointers
    Time: O(n), Space: O(1)
    """
    if not head or not head.next:
        return False  # No cycle possible with 0 or 1 node
    
    slow = head
    fast = head
    
    while fast and fast.next:
        slow = slow.next         # Move 1 step
        fast = fast.next.next    # Move 2 steps
        
        if slow == fast:
            return True  # Cycle detected (or other condition)
    
    return False  # Fast reached end, no cycle
```

**JavaScript:**
```javascript
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

function fastSlowTemplate(head) {
    // Template for Fast & Slow Pointer pattern
    // Time: O(n), Space: O(1)
    
    if (!head || !head.next) {
        return false; // No cycle possible
    }
    
    let slow = head;
    let fast = head;
    
    while (fast && fast.next) {
        slow = slow.next;       // Move 1 step
        fast = fast.next.next;  // Move 2 steps
        
        if (slow === fast) {
            return true; // Cycle detected
        }
    }
    
    return false; // Fast reached end
}
```

### Find Middle Implementation

**Python:**
```python
def find_middle(head: ListNode) -> ListNode:
    """
    Find the middle node of a linked list.
    For even length, returns the second middle node.
    
    Time: O(n), Space: O(1)
    """
    if not head:
        return None
    
    slow = head
    fast = head
    
    # When fast reaches end, slow is at middle
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow


def find_middle_first(head: ListNode) -> ListNode:
    """
    For even length, returns the FIRST middle node.
    Useful for splitting list into two equal halves.
    """
    if not head:
        return None
    
    slow = head
    fast = head
    
    # Stop when fast.next.next is None (before the usual stopping point)
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow
```

**JavaScript:**
```javascript
function findMiddle(head) {
    // Returns second middle for even length lists
    if (!head) return null;
    
    let slow = head;
    let fast = head;
    
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    return slow;
}

function findMiddleFirst(head) {
    // Returns first middle for even length lists
    if (!head) return null;
    
    let slow = head;
    let fast = head;
    
    while (fast.next && fast.next.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    return slow;
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Cycle Detection |" O(n) "| O(1) | At most 2n iterations |
| Find Middle |" O(n) "| O(1) | n/2 iterations |
| Find Cycle Start |" O(n) "| O(1) |" Two phases, each O(n) "|
| Find Cycle Length |" O(n) "| O(1) | One extra traversal of cycle |

**Why O(n) Time:**
- Slow pointer visits each node at most once: O(n)
- Fast pointer visits each node at most once: O(n)
- In cycle: fast gains 1 on slow each step, meets within cycle length

**Why O(1) Space:**
- Only two pointer variables regardless of list size
- No additional data structures needed

---

## üîÑ Variations

| Variation | Speed Ratio | Use Case | Example |
|-----------|-------------|----------|---------|
| Standard (1:2) | slow=1, fast=2 | Cycle detection, middle | LC 141, 876 |
| Find 1/3 position | slow=1, fast=3 | Divide into thirds | Custom problems |
| Same speed, offset | Both 1, start apart | Intersection, Nth from end | LC 160, 19 |
| Multiple pointers | 3+ pointers | Complex patterns | Rare |

### Same Speed, Different Start (Gap Technique)

```python
def find_nth_from_end(head: ListNode, n: int) -> ListNode:
    """
    Find Nth node from end using gap technique.
    First pointer starts n steps ahead.
    """
    fast = head
    slow = head
    
    # Move fast n steps ahead
    for _ in range(n):
        if not fast:
            return None  # List shorter than n
        fast = fast.next
    
    # Move both until fast reaches end
    while fast:
        slow = slow.next
        fast = fast.next
    
    return slow  # Slow is at Nth from end
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Checking for Null Before Accessing `.next`

```python
# ‚ùå Wrong - may crash on empty list or odd-length list
while fast.next:
    fast = fast.next.next  # Crash if fast is None

# ‚úÖ Correct - check both conditions
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
```

### 2. Wrong Starting Position

```python
# ‚ùå Wrong for some problems - starting at different positions
slow = head
fast = head.next  # This changes the meeting point!

# ‚úÖ Correct - both start at head for standard cycle detection
slow = head
fast = head
```

### 3. Off-by-One in Middle Finding

```python
# For list [1, 2, 3, 4]:
# Standard: returns 3 (second middle)
# Modified: returns 2 (first middle)

# Know which one your problem needs!
```

### 4. Forgetting Edge Cases

```python
# ‚ùå Missing edge case checks
def has_cycle(head):
    slow = head.next      # Crash if head is None!
    fast = head.next.next
    
# ‚úÖ Handle edge cases first
def has_cycle(head):
    if not head or not head.next:
        return False
    slow = head
    fast = head
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)
- [ ] [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) - LC 141 - Basic cycle detection
- [ ] [Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) - LC 876 - Find middle node
- [ ] [Happy Number](https://leetcode.com/problems/happy-number/) - LC 202 - Implicit cycle in number sequence

### Medium (Apply variations)
- [ ] [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) - LC 142 - Find cycle start
- [ ] [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/) - LC 234 - Combine with reversal
- [ ] [Reorder List](https://leetcode.com/problems/reorder-list/) - LC 143 - Find middle + reverse + merge
- [ ] [Remove Nth Node From End](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) - LC 19 - Gap technique

### Hard (Master edge cases)
- [ ] [Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/) - LC 287 - Array as linked list

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**After solving each problem:**
- **Day 1:** Redo without looking at solution
- **Day 3:** Explain the two-pointer approach out loud
- **Day 7:** Solve a variation (middle ‚Üí cycle ‚Üí palindrome)
- **Day 14:** Teach the pattern to someone else
- **Day 30:** Revisit Find the Duplicate Number (hardest application)

**Pattern mastery checklist:**
- [ ] Can detect cycle with eyes closed
- [ ] Know both middle variations (first vs second)
- [ ] Understand the math behind cycle start finding
- [ ] Can apply to non-linked-list problems (Happy Number, Find Duplicate)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**The 4-Step Communication Template:**

1. **Clarify** (1-2 min):
   - "So we have a linked list and need to detect if there's a cycle..."
   - "What should we return? Boolean or the node where cycle starts?"
   - "Are there any space constraints?"

2. **Plan** (2-3 min):
   - "I'll use the Fast & Slow pointer technique"
   - "Slow moves 1 step, fast moves 2 steps"
   - "If they meet, there's a cycle. If fast reaches null, no cycle"
   - "This gives us O(n) time and O(1) space"

3. **Code** (10-15 min):
   - Write the while loop condition carefully
   - Explain null checks as you write them

4. **Verify** (2-3 min):
   - Trace through: empty list, single node, no cycle, cycle at head, cycle in middle

**What interviewers evaluate:**
- Do you know this fundamental pattern?
- Can you explain WHY it works?
- Do you handle edge cases?
- Can you extend to harder versions (find cycle start)?

</details>

**Company Focus:**

| Company | Frequency | Typical Problems |
|---------|-----------|------------------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Cycle detection, find middle |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Palindrome check, reorder list |
| Google | ‚≠ê‚≠ê‚≠ê | Find duplicate number (tricky) |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard cycle problems |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn concept | 30-45 min | Understand why it works |
| Cycle Detection (Easy) | 10-15 min | Should be quick |
| Find Middle (Easy) | 5-10 min | Very straightforward |
| Cycle II (Medium) | 20-25 min | Need to understand math |
| Master pattern | 8-10 problems | Until it's automatic |

---

> **üí° Key Insight:** The fast pointer moves at 2x speed, so when it completes the list, the slow pointer is exactly at the middle. In a cycle, the fast pointer gains 1 step per iteration, so they MUST meet within one cycle length.

---

## üîó Related

- [Cycle Detection Problem](./4.2-Cycle-Problems/01-Cycle-Detection.md)
- [Find Cycle Start](./4.2-Cycle-Problems/02-Find-Cycle-Start.md)
- [Happy Number](./4.2-Cycle-Problems/03-Happy-Number.md)
- [In-Place Reversal](../05-In-Place-Reversal/5.1-Reversal-Technique.md)
- [Two Pointers (Arrays)](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md)
