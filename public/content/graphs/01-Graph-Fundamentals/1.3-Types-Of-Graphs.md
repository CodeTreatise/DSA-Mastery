# 1.3 Types of Graphs

> **Classification of graphs for algorithm selection**
>
> â±ï¸ **Time:** 30-40 min | ğŸ“Š **Difficulty:** Beginner | ğŸ¯ **Interview Frequency:** Foundation

---

## Overview

Graphs are classified by their structural properties. Understanding these classifications helps you:
1. Choose the right representation
2. Select appropriate algorithms
3. Analyze time/space complexity
4. Identify problem patterns quickly

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>Identifying Graph Types from Problems</strong></summary>

| Problem Keywords | Graph Type |
|-----------------|------------|
| "one-way", "direction", "from A to B" | Directed |
| "bidirectional", "connected", "neighbors" | Undirected |
| "cost", "distance", "weight", "time" | Weighted |
| "dependencies", "prerequisites", "order" | DAG |
| "two groups", "bipartite", "two sides" | Bipartite |
| "sparse connections", "few edges" | Sparse |
| "fully connected", "complete" | Dense/Complete |
| "no cycles", "tree structure" | Acyclic |

</details>

---

## âœ… When to Use Each Type

| Graph Type | Best For |
|------------|----------|
| Directed | Dependencies, workflows, state machines |
| Undirected | Social networks, roads (two-way), friendships |
| Weighted | Shortest path, minimum cost, network flow |
| DAG | Task scheduling, build systems, topological sort |
| Bipartite | Matching problems, two-sided relationships |
| Sparse | Most real-world graphs, adjacency list preferred |
| Dense | Complete connectivity, adjacency matrix preferred |

---

## âŒ When NOT to Use

| If You Assume... | But Graph Is... | Problem |
|------------------|-----------------|---------|
| Undirected | Directed | Missing edges in reverse |
| Unweighted | Weighted | Wrong shortest path |
| Connected | Disconnected | Missing components |
| Acyclic | Cyclic | Infinite loops |
| Sparse | Dense | O(V+E) â‰ˆ O(VÂ²) anyway |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Graph?](./1.1-What-Is-Graph.md)
- [Graph Terminology](./1.2-Graph-Terminology.md)

**After mastering this:**
- [Graph Representation](../02-Graph-Representation/2.1-Adjacency-Matrix.md)
- [BFS Fundamentals](../03-BFS-Pattern/3.1-BFS-Fundamentals.md)
- [DFS Fundamentals](../04-DFS-Pattern/4.1-DFS-Fundamentals.md)

**Type affects algorithm choice:**
- Directed â†’ Topological Sort possible
- Weighted â†’ Dijkstra/Bellman-Ford needed
- Bipartite â†’ 2-coloring works
- DAG â†’ No cycle detection needed

</details>

---

## ğŸ“ How It Works

### 1. Directed vs Undirected

```
    UNDIRECTED                    DIRECTED (Digraph)
    
    [A] â”€â”€â”€ [B]                   [A] â”€â”€â†’ [B]
     â”‚       â”‚                     â”‚       â†“
    [D] â”€â”€â”€ [C]                   [D] â†â”€â”€ [C]
    
    Edge (A,B) = Edge (B,A)       Edge Aâ†’B â‰  Edge Bâ†’A
    Symmetric relationship        One-way relationship
```

| Property | Undirected | Directed |
|----------|------------|----------|
| Edge meaning | Aâ†”B same as Bâ†”A | Aâ†’B different from Bâ†’A |
| Degree | Single degree per vertex | In-degree + Out-degree |
| Cycle detection | Simpler | Need 3-color DFS |
| Examples | Roads, friendships | Twitter follows, dependencies |

---

### 2. Weighted vs Unweighted

```
    UNWEIGHTED                    WEIGHTED
    
    [A] â”€â”€â”€ [B]                   [A] â”€â”€5â”€â”€ [B]
     â”‚       â”‚                     â”‚         â”‚
    [D] â”€â”€â”€ [C]                   2         3
                                   â”‚         â”‚
    All edges = 1                 [D] â”€â”€4â”€â”€ [C]
    
    Shortest path by BFS          Need Dijkstra/Bellman-Ford
```

| Property | Unweighted | Weighted |
|----------|------------|----------|
| Edge cost | All equal (1) | Variable per edge |
| Shortest path | BFS | Dijkstra (positive) / Bellman-Ford (negative) |
| Storage | Simple adjacency | (neighbor, weight) pairs |
| Examples | Social connections | Road distances, flight costs |

---

### 3. Cyclic vs Acyclic

```
    CYCLIC                        ACYCLIC
    
    [A] â”€â”€â†’ [B]                   [A] â”€â”€â†’ [B]
     â†‘       â†“                     â”‚       â”‚
    [D] â†â”€â”€ [C]                    â†“       â†“
                                  [C]     [D]
    Cycle: Aâ†’Bâ†’Câ†’Dâ†’A
    Can loop forever              No way to return to start
```

| Property | Cyclic | Acyclic |
|----------|--------|---------|
| Loops | Can revisit vertices | Cannot revisit |
| Topological sort | Impossible | Always possible (DAG) |
| Traversal | Must track visited | Simpler termination |
| Examples | Circular dependencies | Task dependencies |

---

### 4. DAG (Directed Acyclic Graph)

```
    DAG Example: Course Prerequisites
    
    [Math 101] â”€â”€â†’ [Math 201] â”€â”€â†’ [Math 301]
         â”‚              â”‚
         â†“              â†“
    [CS 101] â”€â”€â”€â†’ [CS 201] â”€â”€â”€â†’ [CS 301]
    
    No cycles â†’ Can compute valid course order
    Topological order: Math101 â†’ CS101 â†’ Math201 â†’ CS201 â†’ Math301 â†’ CS301
```

**DAG Properties:**
- Directed + No cycles
- Has at least one source (in-degree 0)
- Has at least one sink (out-degree 0)
- Topological ordering always exists
- Used for: Task scheduling, build systems, dependency resolution

---

### 5. Connected vs Disconnected

```
    CONNECTED                     DISCONNECTED
    
    [A] â”€â”€â”€ [B]                   [A] â”€â”€â”€ [B]     [E]
     â”‚       â”‚                     â”‚       â”‚       â”‚
    [D] â”€â”€â”€ [C]                   [D] â”€â”€â”€ [C]     [F]
    
    1 component                   2 components
    All vertices reachable        Some vertices unreachable
```

| Property | Connected | Disconnected |
|----------|-----------|--------------|
| Reachability | All pairs | Only within components |
| BFS/DFS | Single call traverses all | Multiple calls needed |
| Components | 1 | 2 or more |

---

### 6. Sparse vs Dense

```
    SPARSE                        DENSE (Complete shown)
    
    [A] â”€â”€â”€ [B]                   [A] â”€â”€â”€ [B]
     â”‚                             â”‚ â•²   â•± â”‚
    [D]     [C]                    â”‚  â•² â•±  â”‚
                                   â”‚  â•± â•²  â”‚
    E << VÂ²                       [D] â”€â”€â”€ [C]
    (few edges)                   E = V(V-1)/2 (max for undirected)
```

| Property | Sparse | Dense |
|----------|--------|-------|
| Edge count | E << VÂ² | E â‰ˆ VÂ² |
| Best representation | Adjacency List | Adjacency Matrix |
| Space | O(V + E) | O(VÂ²) |
| Edge check | O(degree) | O(1) |
| Real-world | Most graphs | Complete/near-complete |

**Threshold:** A graph is typically considered dense if E > VÂ²/4

---

### 7. Bipartite Graph

```
    BIPARTITE                     NOT BIPARTITE
    
    Set 1: [A] [B]                   [A]
            â”‚â•² â”‚                    â•±   â•²
            â”‚ â•²â”‚                   â”‚     â”‚
    Set 2: [C] [D]                 [B] â”€ [C]
    
    Vertices split into           Triangle = odd cycle
    two disjoint sets             Cannot 2-color
    No edges within sets
```

**Bipartite Properties:**
- Vertices can be split into two sets
- All edges go between sets (never within)
- No odd-length cycles
- Can be 2-colored
- Used for: Matching, scheduling, assignment problems

---

### 8. Complete Graph (Kâ‚™)

```
    Kâ‚ƒ                Kâ‚„                Kâ‚…
    
     [A]             [A]â”€â”€â”€â”€â”€[B]       (all 5 vertices
    â•±   â•²             â”‚â•²   â•±â”‚          connected to
  [B]â”€â”€â”€[C]           â”‚ â•² â•± â”‚          each other)
                      â”‚ â•± â•² â”‚
  3 edges            [D]â”€â”€â”€â”€â”€[C]
  V(V-1)/2 = 3        6 edges          10 edges
```

**Complete Graph Kâ‚™:**
- Every vertex connected to every other
- E = V(V-1)/2 edges (undirected)
- E = V(V-1) edges (directed)

---

## ğŸ’» Code Implementation

**Python - Graph Type Detection:**
```python
from collections import defaultdict, deque

class GraphTypeAnalyzer:
    """Analyze and classify graph types."""
    
    def __init__(self, directed=False, weighted=False):
        self.directed = directed
        self.weighted = weighted
        
        if weighted:
            self.graph = defaultdict(list)  # [(neighbor, weight), ...]
        else:
            self.graph = defaultdict(list)  # [neighbor, ...]
        
        self.vertices = set()
    
    def add_edge(self, u, v, weight=1):
        """Add an edge to the graph."""
        self.vertices.add(u)
        self.vertices.add(v)
        
        if self.weighted:
            self.graph[u].append((v, weight))
            if not self.directed:
                self.graph[v].append((u, weight))
        else:
            self.graph[u].append(v)
            if not self.directed:
                self.graph[v].append(u)
    
    def is_connected(self):
        """Check if undirected graph is connected."""
        if not self.vertices:
            return True
        
        start = next(iter(self.vertices))
        visited = set()
        queue = deque([start])
        visited.add(start)
        
        while queue:
            node = queue.popleft()
            neighbors = self.graph[node]
            
            for neighbor in neighbors:
                # Handle weighted graphs
                n = neighbor[0] if self.weighted else neighbor
                if n not in visited:
                    visited.add(n)
                    queue.append(n)
        
        return len(visited) == len(self.vertices)
    
    def has_cycle_undirected(self):
        """Detect cycle in undirected graph using DFS."""
        visited = set()
        
        def dfs(node, parent):
            visited.add(node)
            neighbors = self.graph[node]
            
            for neighbor in neighbors:
                n = neighbor[0] if self.weighted else neighbor
                if n not in visited:
                    if dfs(n, node):
                        return True
                elif n != parent:
                    return True  # Found cycle
            return False
        
        for vertex in self.vertices:
            if vertex not in visited:
                if dfs(vertex, None):
                    return True
        return False
    
    def has_cycle_directed(self):
        """Detect cycle in directed graph using 3-color DFS."""
        WHITE, GRAY, BLACK = 0, 1, 2
        color = {v: WHITE for v in self.vertices}
        
        def dfs(node):
            color[node] = GRAY  # Currently exploring
            neighbors = self.graph[node]
            
            for neighbor in neighbors:
                n = neighbor[0] if self.weighted else neighbor
                if color.get(n, WHITE) == GRAY:
                    return True  # Back edge - cycle!
                if color.get(n, WHITE) == WHITE:
                    if dfs(n):
                        return True
            
            color[node] = BLACK  # Finished exploring
            return False
        
        for vertex in self.vertices:
            if color[vertex] == WHITE:
                if dfs(vertex):
                    return True
        return False
    
    def is_bipartite(self):
        """Check if graph is bipartite using BFS 2-coloring."""
        color = {}
        
        for start in self.vertices:
            if start in color:
                continue
            
            queue = deque([start])
            color[start] = 0
            
            while queue:
                node = queue.popleft()
                neighbors = self.graph[node]
                
                for neighbor in neighbors:
                    n = neighbor[0] if self.weighted else neighbor
                    if n not in color:
                        color[n] = 1 - color[node]  # Alternate color
                        queue.append(n)
                    elif color[n] == color[node]:
                        return False  # Same color - not bipartite
        
        return True
    
    def is_sparse(self):
        """Heuristic: Graph is sparse if E < VÂ²/4."""
        v = len(self.vertices)
        e = sum(len(neighbors) for neighbors in self.graph.values())
        if not self.directed:
            e //= 2  # Each edge counted twice in undirected
        
        threshold = (v * v) / 4
        return e < threshold
    
    def classify(self):
        """Return a classification of the graph."""
        props = {
            'directed': self.directed,
            'weighted': self.weighted,
            'connected': self.is_connected(),
            'sparse': self.is_sparse(),
            'bipartite': self.is_bipartite(),
        }
        
        if self.directed:
            props['has_cycle'] = self.has_cycle_directed()
            props['is_dag'] = not props['has_cycle']
        else:
            props['has_cycle'] = self.has_cycle_undirected()
        
        return props


# Example usage
g = GraphTypeAnalyzer(directed=True, weighted=False)
g.add_edge('A', 'B')
g.add_edge('B', 'C')
g.add_edge('C', 'D')
# No cycle back to A - this is a DAG

classification = g.classify()
print(f"Classification: {classification}")
# {'directed': True, 'weighted': False, 'connected': True, 
#  'sparse': True, 'bipartite': True, 'has_cycle': False, 'is_dag': True}
```

**JavaScript:**
```javascript
class GraphTypeAnalyzer {
    constructor(directed = false, weighted = false) {
        this.directed = directed;
        this.weighted = weighted;
        this.graph = new Map();
        this.vertices = new Set();
    }
    
    addEdge(u, v, weight = 1) {
        this.vertices.add(u);
        this.vertices.add(v);
        
        if (!this.graph.has(u)) this.graph.set(u, []);
        if (!this.graph.has(v)) this.graph.set(v, []);
        
        if (this.weighted) {
            this.graph.get(u).push([v, weight]);
            if (!this.directed) {
                this.graph.get(v).push([u, weight]);
            }
        } else {
            this.graph.get(u).push(v);
            if (!this.directed) {
                this.graph.get(v).push(u);
            }
        }
    }
    
    isConnected() {
        if (this.vertices.size === 0) return true;
        
        const start = this.vertices.values().next().value;
        const visited = new Set([start]);
        const queue = [start];
        
        while (queue.length > 0) {
            const node = queue.shift();
            const neighbors = this.graph.get(node) || [];
            
            for (const neighbor of neighbors) {
                const n = this.weighted ? neighbor[0] : neighbor;
                if (!visited.has(n)) {
                    visited.add(n);
                    queue.push(n);
                }
            }
        }
        
        return visited.size === this.vertices.size;
    }
    
    hasCycleDirected() {
        const WHITE = 0, GRAY = 1, BLACK = 2;
        const color = new Map();
        
        for (const v of this.vertices) {
            color.set(v, WHITE);
        }
        
        const dfs = (node) => {
            color.set(node, GRAY);
            const neighbors = this.graph.get(node) || [];
            
            for (const neighbor of neighbors) {
                const n = this.weighted ? neighbor[0] : neighbor;
                if (color.get(n) === GRAY) return true;
                if (color.get(n) === WHITE && dfs(n)) return true;
            }
            
            color.set(node, BLACK);
            return false;
        };
        
        for (const vertex of this.vertices) {
            if (color.get(vertex) === WHITE) {
                if (dfs(vertex)) return true;
            }
        }
        return false;
    }
    
    isBipartite() {
        const color = new Map();
        
        for (const start of this.vertices) {
            if (color.has(start)) continue;
            
            const queue = [start];
            color.set(start, 0);
            
            while (queue.length > 0) {
                const node = queue.shift();
                const neighbors = this.graph.get(node) || [];
                
                for (const neighbor of neighbors) {
                    const n = this.weighted ? neighbor[0] : neighbor;
                    if (!color.has(n)) {
                        color.set(n, 1 - color.get(node));
                        queue.push(n);
                    } else if (color.get(n) === color.get(node)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    
    classify() {
        const props = {
            directed: this.directed,
            weighted: this.weighted,
            connected: this.isConnected(),
            bipartite: this.isBipartite()
        };
        
        if (this.directed) {
            props.hasCycle = this.hasCycleDirected();
            props.isDAG = !props.hasCycle;
        }
        
        return props;
    }
}

// Example
const g = new GraphTypeAnalyzer(true, false);
g.addEdge('A', 'B');
g.addEdge('B', 'C');
g.addEdge('C', 'D');

console.log(g.classify());
// {directed: true, weighted: false, connected: true, bipartite: true, hasCycle: false, isDAG: true}
```

---

## âš¡ Complexity Analysis

| Analysis | Time | Space |
|----------|------|-------|
| Check connected | O(V + E) | O(V) |
| Cycle detection (undirected) | O(V + E) | O(V) |
| Cycle detection (directed) | O(V + E) | O(V) |
| Bipartite check | O(V + E) | O(V) |
| Sparse/dense classification | O(V + E) | O(1) |

---

## ğŸ”„ Variations

### Summary Table of Graph Types

| Type | Key Property | Algorithm Impact |
|------|--------------|------------------|
| Directed | One-way edges | Need in/out degree |
| Undirected | Two-way edges | Simpler traversal |
| Weighted | Edge costs | Dijkstra/Bellman-Ford |
| Unweighted | Equal edges | BFS shortest path |
| Cyclic | Has loops | Must track visited |
| Acyclic | No loops | Topological sort works |
| DAG | Directed + Acyclic | DP on graphs |
| Connected | Single component | One traversal |
| Disconnected | Multiple components | Multiple traversals |
| Bipartite | 2-colorable | Matching algorithms |
| Sparse | Few edges | Adjacency list |
| Dense | Many edges | Adjacency matrix |
| Complete | All edges | Special formulas |

---

## âš ï¸ Common Mistakes

### 1. Assuming Connectivity

```python
# âŒ Wrong: Starting BFS/DFS from one node and assuming done
def count_nodes(graph, start):
    visited = bfs(start)
    return len(visited)  # Misses disconnected components!

# âœ… Correct: Iterate through all vertices
def count_all_nodes(graph, all_vertices):
    visited = set()
    for v in all_vertices:
        if v not in visited:
            bfs_from(v, visited)
    return len(visited)
```

### 2. Wrong Cycle Detection for Directed Graphs

```python
# âŒ Wrong: Using parent-based cycle detection for directed graphs
def has_cycle_wrong(node, parent, visited):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            if has_cycle_wrong(neighbor, node, visited):
                return True
        elif neighbor != parent:  # This doesn't work for directed!
            return True
    return False

# âœ… Correct: Use 3-color (white/gray/black) for directed graphs
```

### 3. Ignoring Edge Direction in Shortest Path

```python
# âŒ Wrong: Using undirected shortest path logic on directed graph
# Edge Aâ†’B exists, but Bâ†’A doesn't

# âœ… Correct: Only traverse in edge direction
for neighbor in graph[node]:  # Only outgoing edges
    if neighbor not in visited:
        process(neighbor)
```

---

## ğŸ“ Practice Problems

### By Graph Type
| Problem | Type Focus | Difficulty |
|---------|------------|------------|
| [Number of Islands](https://leetcode.com/problems/number-of-islands/) | Undirected, Grid | ğŸŸ¡ Medium |
| [Course Schedule](https://leetcode.com/problems/course-schedule/) | Directed, DAG | ğŸŸ¡ Medium |
| [Is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/) | Bipartite | ğŸŸ¡ Medium |
| [Network Delay Time](https://leetcode.com/problems/network-delay-time/) | Weighted, Directed | ğŸŸ¡ Medium |
| [Graph Valid Tree](https://leetcode.com/problems/graph-valid-tree/) | Connected, Acyclic | ğŸŸ¡ Medium |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Memorize all graph type definitions
- **Day 3:** Draw examples of each type
- **Day 7:** Implement type-checking functions
- **Day 14:** Classify 10 random problems by graph type
- **Day 30:** Quick recall - identify type from problem in <30 seconds

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>Clarification Questions to Ask</strong></summary>

**Always ask before coding:**

1. "Is this graph directed or undirected?"
2. "Are the edges weighted?"
3. "Can we assume the graph is connected?"
4. "Can there be cycles?"
5. "How sparse or dense is the graph? (affects representation choice)"

**Why this matters:**
| If Wrong About... | You Might... |
|-------------------|--------------|
| Direction | Traverse wrong way |
| Weights | Use wrong algorithm (BFS vs Dijkstra) |
| Connectivity | Miss components |
| Cycles | Loop infinitely |
| Density | Choose inefficient representation |

</details>

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Learn all graph types | 25-30 min |
| Implement type checkers | 30-40 min |
| Practice classification | 15-20 min |
| **Total to master** | **70-90 min** |

---

> **ğŸ’¡ Key Insight:** The type of graph determines which algorithms work and how efficient they are. Always classify the graph before choosing an approach.

> **ğŸ”— Related:** [Graph Terminology](./1.2-Graph-Terminology.md) | [Adjacency Matrix](../02-Graph-Representation/2.1-Adjacency-Matrix.md) | [Adjacency List](../02-Graph-Representation/2.2-Adjacency-List.md)

---

**Previous:** [â† 1.2 Graph Terminology](./1.2-Graph-Terminology.md)  
**Next:** [2.1 Adjacency Matrix â†’](../02-Graph-Representation/2.1-Adjacency-Matrix.md)
