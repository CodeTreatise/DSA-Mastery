# 1.5 Recursion on Arrays

> **Recursive Techniques for Array Processing**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê - Foundation for divide-and-conquer sorting  
> **Prerequisites:** [1.1-1.3 Recursion Fundamentals](./1.1-Recursion-Basics.md)

---

## Overview

Arrays provide excellent practice for recursive thinking. Common operations include:
- **Aggregation:** Sum, product, min, max
- **Transformation:** Reverse, filter, map
- **Search:** Find element, check condition
- **Divide and Conquer:** Merge sort, quick sort

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Recursion on Arrays</strong></summary>

**Good candidates for recursion:**
- Problem can process first element + "rest of array"
- Divide-and-conquer (split into halves)
- Need to generate all subsets/combinations

**May not need recursion:**
- Simple left-to-right traversal
- Single pass through array
- In-place modifications (often cleaner with loops)

</details>

---

## ‚úÖ When to Use

- **Learning recursion:** Great practice problems
- **Divide and conquer:** Merge sort, quick select
- **Tree-like structure:** Binary search on sorted arrays
- **Generating combinations:** Subsets, permutations

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Simple iteration | for loop | Simpler, clearer |
| Large arrays (>10K) | Iteration | Stack overflow risk |
| In-place modification | Iterative | Avoid array slicing overhead |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Recursion Basics](./1.1-Recursion-Basics.md)
- [Recursion Patterns](./1.2-Recursion-Patterns.md)

**After mastering this:**
- [Recursion on Strings](./1.6-Recursion-On-Strings.md)
- [Divide and Conquer](../03-Divide-Conquer/3.1-DC-Basics.md)

</details>

---

## üìê Approach 1: First Element + Rest

Process the first element, then recurse on the rest.

### Sum of Array

```python
def array_sum(arr: list[int]) -> int:
    """
    Sum array elements recursively.
    
    Pattern: first + sum(rest)
    Time: O(n), Space: O(n)
    """
    # Base case
    if not arr:
        return 0
    
    # Recursive case
    return arr[0] + array_sum(arr[1:])


# More efficient: use index instead of slicing
def array_sum_efficient(arr: list[int], index: int = 0) -> int:
    """Avoid creating new arrays with slicing."""
    if index == len(arr):
        return 0
    return arr[index] + array_sum_efficient(arr, index + 1)
```

```javascript
function arraySum(arr) {
    if (arr.length === 0) return 0;
    return arr[0] + arraySum(arr.slice(1));
}

// Efficient version
function arraySumEfficient(arr, index = 0) {
    if (index === arr.length) return 0;
    return arr[index] + arraySumEfficient(arr, index + 1);
}
```

### Find Maximum

```python
def find_max(arr: list[int]) -> int:
    """
    Find maximum element recursively.
    
    Time: O(n), Space: O(n)
    """
    # Base case
    if len(arr) == 1:
        return arr[0]
    
    # Recursive case
    max_of_rest = find_max(arr[1:])
    return arr[0] if arr[0] > max_of_rest else max_of_rest


# With index
def find_max_efficient(arr: list[int], index: int = 0) -> int:
    if index == len(arr) - 1:
        return arr[index]
    
    max_of_rest = find_max_efficient(arr, index + 1)
    return max(arr[index], max_of_rest)
```

```javascript
function findMax(arr) {
    if (arr.length === 1) return arr[0];
    const maxOfRest = findMax(arr.slice(1));
    return Math.max(arr[0], maxOfRest);
}
```

### Reverse Array

```python
def reverse_array(arr: list) -> list:
    """
    Reverse array recursively.
    
    Pattern: reverse(rest) + first
    Time: O(n¬≤) due to slicing, Space: O(n)
    """
    # Base case
    if len(arr) <= 1:
        return arr
    
    # Recursive case
    return reverse_array(arr[1:]) + [arr[0]]


# In-place reversal using recursion
def reverse_in_place(arr: list, left: int = 0, right: int = None):
    """Reverse array in-place using recursion."""
    if right is None:
        right = len(arr) - 1
    
    if left >= right:
        return
    
    # Swap
    arr[left], arr[right] = arr[right], arr[left]
    
    # Recurse on inner portion
    reverse_in_place(arr, left + 1, right - 1)
```

```javascript
function reverseArray(arr) {
    if (arr.length <= 1) return arr;
    return [...reverseArray(arr.slice(1)), arr[0]];
}

function reverseInPlace(arr, left = 0, right = arr.length - 1) {
    if (left >= right) return;
    [arr[left], arr[right]] = [arr[right], arr[left]];
    reverseInPlace(arr, left + 1, right - 1);
}
```

---

## üìê Approach 2: Divide and Conquer

Split array in half, process each half, combine results.

### Merge Sort

```python
def merge_sort(arr: list) -> list:
    """
    Sort array using merge sort.
    
    Pattern: Divide into halves, sort each, merge
    Time: O(n log n), Space: O(n)
    """
    # Base case
    if len(arr) <= 1:
        return arr
    
    # Divide
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    # Conquer (merge)
    return merge(left, right)


def merge(left: list, right: list) -> list:
    """Merge two sorted arrays."""
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

```javascript
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result.push(left[i++]);
        } else {
            result.push(right[j++]);
        }
    }
    
    return [...result, ...left.slice(i), ...right.slice(j)];
}
```

### Sum Using Divide and Conquer

```python
def sum_divide_conquer(arr: list[int]) -> int:
    """
    Sum using divide and conquer.
    
    Less efficient than linear, but demonstrates pattern.
    Time: O(n), Space: O(log n) - better stack depth
    """
    if not arr:
        return 0
    if len(arr) == 1:
        return arr[0]
    
    mid = len(arr) // 2
    left_sum = sum_divide_conquer(arr[:mid])
    right_sum = sum_divide_conquer(arr[mid:])
    
    return left_sum + right_sum
```

---

## üìê Approach 3: Check Conditions

Check if all/any elements satisfy a condition.

```python
def all_positive(arr: list[int], index: int = 0) -> bool:
    """Check if all elements are positive."""
    if index == len(arr):
        return True  # Empty or all checked
    
    if arr[index] <= 0:
        return False  # Found non-positive
    
    return all_positive(arr, index + 1)


def any_even(arr: list[int], index: int = 0) -> bool:
    """Check if any element is even."""
    if index == len(arr):
        return False  # None found
    
    if arr[index] % 2 == 0:
        return True  # Found one
    
    return any_even(arr, index + 1)


def contains(arr: list, target, index: int = 0) -> bool:
    """Check if array contains target."""
    if index == len(arr):
        return False
    
    if arr[index] == target:
        return True
    
    return contains(arr, target, index + 1)
```

```javascript
function allPositive(arr, index = 0) {
    if (index === arr.length) return true;
    if (arr[index] <= 0) return false;
    return allPositive(arr, index + 1);
}

function anyEven(arr, index = 0) {
    if (index === arr.length) return false;
    if (arr[index] % 2 === 0) return true;
    return anyEven(arr, index + 1);
}

function contains(arr, target, index = 0) {
    if (index === arr.length) return false;
    if (arr[index] === target) return true;
    return contains(arr, target, index + 1);
}
```

---

## üíª Code: Practical Examples

### Filter Array

```python
def filter_positive(arr: list[int]) -> list[int]:
    """Return only positive numbers."""
    if not arr:
        return []
    
    rest = filter_positive(arr[1:])
    
    if arr[0] > 0:
        return [arr[0]] + rest
    else:
        return rest


# Generic filter
def filter_recursive(arr: list, predicate) -> list:
    """Generic recursive filter."""
    if not arr:
        return []
    
    rest = filter_recursive(arr[1:], predicate)
    
    if predicate(arr[0]):
        return [arr[0]] + rest
    else:
        return rest


# Usage
evens = filter_recursive([1, 2, 3, 4, 5], lambda x: x % 2 == 0)
# [2, 4]
```

### Map Array

```python
def map_recursive(arr: list, transform) -> list:
    """Apply function to each element."""
    if not arr:
        return []
    
    return [transform(arr[0])] + map_recursive(arr[1:], transform)


# Usage
doubled = map_recursive([1, 2, 3], lambda x: x * 2)
# [2, 4, 6]
```

```javascript
function filterRecursive(arr, predicate) {
    if (arr.length === 0) return [];
    
    const rest = filterRecursive(arr.slice(1), predicate);
    
    if (predicate(arr[0])) {
        return [arr[0], ...rest];
    }
    return rest;
}

function mapRecursive(arr, transform) {
    if (arr.length === 0) return [];
    return [transform(arr[0]), ...mapRecursive(arr.slice(1), transform)];
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Sum (linear) |" O(n) "| O(n) | Stack depth n |
| Sum (index) |" O(n) "| O(n) | Better constant |
| Reverse (slice) |" O(n¬≤) "| O(n) |" Slicing is O(n) "|
| Reverse (in-place) |" O(n) "| O(n) | Better |
| Merge Sort |" O(n log n) "| O(n) | Stack depth log n |
| Binary Search |" O(log n) "| O(log n) | Divide and conquer |

**Why avoid slicing?**
```python
arr[1:]  # Creates new array, O(n) time and space
```
Use indices instead for O(1) access.

---

## üîÑ Variations

| Pattern | Description | Example |
|---------|-------------|---------|
| **Head + Tail** | Process first, recurse on rest | Sum, max |
| **Divide & Conquer** | Split in half, combine | Merge sort |
| **Two-pointer** | Converge from ends | Reverse, palindrome |
| **Generate all** | Include/exclude | Subsets |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Slicing When Index Works

‚ùå **Wrong:** O(n) slicing at each step
```python
def sum(arr):
    if not arr: return 0
    return arr[0] + sum(arr[1:])  # Creates new array!
```

‚úÖ **Correct:** O(1) index access
```python
def sum(arr, i=0):
    if i == len(arr): return 0
    return arr[i] + sum(arr, i+1)
```

### 2. Wrong Base Case for Empty Array

‚ùå **Wrong:**
```python
def find_max(arr):
    if len(arr) == 1: return arr[0]  # Crashes on empty!
    ...
```

‚úÖ **Correct:**
```python
def find_max(arr):
    if not arr: return float('-inf')  # Or raise error
    if len(arr) == 1: return arr[0]
    ...
```

### 3. Stack Overflow on Large Arrays

‚ùå **Wrong:** Recursion on 100K elements
```python
sum([1] * 100000)  # RecursionError!
```

‚úÖ **Correct:** Use iteration or increase limit carefully
```python
sum(arr)  # Built-in
# Or
import sys
sys.setrecursionlimit(200000)  # Use with caution
```

---

## üìù Practice Problems

### Easy (Learn the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Reverse String | Two-pointer recursion | [LC 344](https://leetcode.com/problems/reverse-string/) |
| Fibonacci Number | Basic recursion | [LC 509](https://leetcode.com/problems/fibonacci-number/) |

### Medium (Apply pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Sort an Array | Merge sort | [LC 912](https://leetcode.com/problems/sort-an-array/) |
| Maximum Subarray | Divide and conquer | [LC 53](https://leetcode.com/problems/maximum-subarray/) |
| Merge k Sorted Lists | Divide and conquer | [LC 23](https://leetcode.com/problems/merge-k-sorted-lists/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: Sum, max, min (index version)
- Day 2: Reverse (in-place)
- Day 3: Filter, map
- Day 5: Merge sort

**Week 2:**
- Solve LC 344, 912
- Implement quick sort
- Practice tracing through calls

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**When explaining recursive array solutions:**
> "I'll process the first element, then recursively handle the rest. My base case is an empty array."

**When asked about efficiency:**
> "I'm using indices instead of slicing to avoid creating new arrays at each step."

**For divide and conquer:**
> "I'll split the array in half, solve each half recursively, then merge the results."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand patterns | 20-30 min | Three approaches |
| Implement sum, max | 15-20 min | Basic practice |
| Implement merge sort | 30-45 min | More complex |
| Solve 3 problems | 45-60 min | Application |

---

## üí° Key Insight

> **Use indices, not slicing:**
> - `arr[1:]` creates a new array: O(n) time/space per call
> - `arr[index + 1]` is just pointer arithmetic: O(1)
>
> For competitive programming and interviews, always pass indices to avoid unnecessary memory allocation.

---

## üîó Related

- [Recursion Basics](./1.1-Recursion-Basics.md) - Foundation
- [Recursion on Strings](./1.6-Recursion-On-Strings.md) - Similar techniques
- [Divide and Conquer](../03-Divide-Conquer/3.1-DC-Basics.md) - Advanced patterns
