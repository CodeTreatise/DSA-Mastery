# 3.2 Recover Binary Search Tree (LC 99)

## Problem Statement

[LeetCode 99 - Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)

You are given the root of a BST where **exactly two nodes** were swapped by mistake. Recover the tree without changing its structure.

```
Input: root = [3,1,4,null,null,2]
        3
       / \
      1   4
         /
        2

Output: [2,1,4,null,null,3]
        2
       / \
      1   4
         /
        3

Explanation: 3 and 2 were swapped. Swap them back.
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is an Inorder Violation Detection problem:**
- Inorder of valid BST is sorted
- Swapped nodes create violations where current < previous
- Find the two swapped nodes and swap them back

**Keywords:**
- "two nodes swapped", "recover BST"
- "fix", "repair" BST
- "exactly two nodes exchanged"

**Key Insight:**
- If we swap 2 elements in sorted array, we get at most 2 violations
- First violation: larger swapped node is "previous"
- Second violation: smaller swapped node is "current"

</details>

---

## ‚úÖ When to Use

- BST repair problems
- Finding anomalies in sorted sequences
- Detecting swapped elements

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| More than 2 swaps | Won't work | Rebuild BST |
| Need to validate only | Overkill | LC 98 Validate BST |
| Unknown number of errors | Different approach | Full reconstruction |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Validate BST (LC 98)](./3.1-Validate-BST-LC98.md) - Detection logic
- [Inorder Traversal](../../06-Trees/03-Tree-Traversals/3.1-DFS-Traversals/)
- [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md) - Inorder = sorted

**After mastering this:**
- [Morris Traversal](../../06-Trees/03-Tree-Traversals/) - O(1) space inorder
- More complex tree repairs

**Combines with:**
- Inorder traversal
- Finding violations in sorted sequence

</details>

---

## üìê How It Works

### The Key Insight

```
Valid BST inorder: [1, 2, 3, 4, 5, 6, 7]

Swap nodes 2 and 6:  [1, 6, 3, 4, 5, 2, 7]
                        ‚Üë           ‚Üë
                     6 > 3       5 > 2
                   violation    violation

First violation: 6 > 3 ‚Üí first = 6 (previous), second = 3
Second violation: 5 > 2 ‚Üí update second = 2

Swap 6 and 2 to recover.
```

### Two Cases

#### Case 1: Adjacent Nodes Swapped
```
[1, 2, 3, 4, 5] ‚Üí swap 3,4 ‚Üí [1, 2, 4, 3, 5]
                                   ‚Üë ‚Üë
                              Only ONE violation: 4 > 3

first = 4 (previous at violation)
second = 3 (current at violation)
```

#### Case 2: Non-Adjacent Nodes Swapped
```
[1, 2, 3, 4, 5] ‚Üí swap 2,5 ‚Üí [1, 5, 3, 4, 2]
                                ‚Üë        ‚Üë
                           5 > 3     4 > 2
                           
First violation: first = 5, second = 3
Second violation: update second = 2
```

### Visualization on Tree

```
Original invalid BST:
        3
       / \
      1   4
         /
        2

Inorder: [1, 3, 2, 4]
                ‚Üë ‚Üë
            3 > 2 (violation!)

first = 3 (previous when violation occurred)
second = 2 (current when violation occurred)

Swap 3 and 2 to fix.
```

---

## üíª Code Implementation

### Approach 1: O(n) Space - Store Inorder

**Python:**
```python
def recoverTree(self, root: Optional[TreeNode]) -> None:
    """
    Recover BST by finding two swapped nodes.
    
    Time: O(n) - traverse all nodes
    Space: O(n) - store inorder traversal
    
    Approach: Store inorder, find violations, swap values.
    """
    # Step 1: Get inorder traversal (list of nodes, not values)
    nodes = []
    def inorder(node):
        if node:
            inorder(node.left)
            nodes.append(node)
            inorder(node.right)
    inorder(root)
    
    # Step 2: Find the two swapped nodes
    first = second = None
    for i in range(len(nodes) - 1):
        if nodes[i].val > nodes[i + 1].val:
            if first is None:
                first = nodes[i]
                second = nodes[i + 1]  # Might be adjacent
            else:
                second = nodes[i + 1]  # Non-adjacent, update second
                break
    
    # Step 3: Swap values
    first.val, second.val = second.val, first.val
```

**JavaScript:**
```javascript
var recoverTree = function(root) {
    // Store inorder traversal
    const nodes = [];
    
    function inorder(node) {
        if (node) {
            inorder(node.left);
            nodes.push(node);
            inorder(node.right);
        }
    }
    inorder(root);
    
    // Find swapped nodes
    let first = null, second = null;
    for (let i = 0; i < nodes.length - 1; i++) {
        if (nodes[i].val > nodes[i + 1].val) {
            if (first === null) {
                first = nodes[i];
                second = nodes[i + 1];
            } else {
                second = nodes[i + 1];
                break;
            }
        }
    }
    
    // Swap values
    [first.val, second.val] = [second.val, first.val];
};
```

### Approach 2: O(h) Space - Track Previous

**Python:**
```python
def recoverTree(self, root: Optional[TreeNode]) -> None:
    """
    Recover BST with O(h) space by tracking previous node.
    
    Time: O(n)
    Space: O(h) - recursion stack only
    """
    self.first = self.second = self.prev = None
    
    def inorder(node):
        if not node:
            return
        
        inorder(node.left)
        
        # Check for violation
        if self.prev and self.prev.val > node.val:
            if self.first is None:
                self.first = self.prev
            self.second = node  # Always update second
        
        self.prev = node
        
        inorder(node.right)
    
    inorder(root)
    
    # Swap values
    self.first.val, self.second.val = self.second.val, self.first.val
```

**JavaScript:**
```javascript
var recoverTree = function(root) {
    let first = null, second = null, prev = null;
    
    function inorder(node) {
        if (!node) return;
        
        inorder(node.left);
        
        // Check for violation
        if (prev && prev.val > node.val) {
            if (first === null) {
                first = prev;
            }
            second = node;  // Always update
        }
        prev = node;
        
        inorder(node.right);
    }
    
    inorder(root);
    
    // Swap values
    [first.val, second.val] = [second.val, first.val];
};
```

### Approach 3: O(1) Space - Morris Traversal

**Python:**
```python
def recoverTree(self, root: Optional[TreeNode]) -> None:
    """
    Recover BST with O(1) space using Morris traversal.
    
    Morris traversal modifies tree temporarily to traverse
    without a stack, then restores it.
    
    Time: O(n), Space: O(1)
    """
    first = second = prev = None
    current = root
    
    while current:
        if current.left is None:
            # Visit current
            if prev and prev.val > current.val:
                if first is None:
                    first = prev
                second = current
            prev = current
            current = current.right
        else:
            # Find inorder predecessor
            predecessor = current.left
            while predecessor.right and predecessor.right != current:
                predecessor = predecessor.right
            
            if predecessor.right is None:
                # Make current the right child of predecessor
                predecessor.right = current
                current = current.left
            else:
                # Revert the changes
                predecessor.right = None
                # Visit current
                if prev and prev.val > current.val:
                    if first is None:
                        first = prev
                    second = current
                prev = current
                current = current.right
    
    # Swap values
    first.val, second.val = second.val, first.val
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Store inorder |" O(n) "| O(n) | Simple but uses array |
| Track previous |" O(n) "| O(h) | Recursion stack only |
| Morris traversal |" O(n) "| O(1) | Optimal space |

**Why O(n) time:**
- Must traverse all nodes to find violations
- Cannot stop early since second violation might be at end

---

## üîÑ Variations

| Variation | Modification | Difficulty |
|-----------|--------------|------------|
| **Find without fixing** | Just return swapped nodes | Easier |
| **Multiple swaps** | More complex detection | Harder |
| **Return new root** | If root is swapped | Same approach |
| **Iterative inorder** | Stack-based traversal | Same complexity |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Handling Adjacent Swap Case

```python
# ‚ùå Wrong: Only looking for two separate violations
for i in range(len(nodes) - 1):
    if nodes[i].val > nodes[i + 1].val:
        violations.append((nodes[i], nodes[i + 1]))
# If adjacent, there's only 1 violation!

# ‚úÖ Correct: Set second at first violation, update at second
if first is None:
    first = prev
    second = current  # Initial second (might be final)
else:
    second = current  # Update second for non-adjacent case
```

### 2. Forgetting to Update Previous

```python
# ‚ùå Wrong: prev never gets updated
def inorder(node):
    if node:
        inorder(node.left)
        if self.prev.val > node.val:  # Uses stale prev
            ...
        inorder(node.right)

# ‚úÖ Correct: Update prev after visiting
def inorder(node):
    if node:
        inorder(node.left)
        if self.prev and self.prev.val > node.val:
            ...
        self.prev = node  # Update!
        inorder(node.right)
```

### 3. Swapping Nodes Instead of Values

```python
# ‚ùå Wrong: Trying to swap nodes (complex pointer manipulation)
def swap_nodes(a, b):
    # Would need to update parent pointers, children, etc.
    ...

# ‚úÖ Correct: Just swap values (simple and sufficient)
first.val, second.val = second.val, first.val
```

---

## üìù Practice Problems (Progressive)

### Easy (Build up)
- [ ] [Validate BST (LC 98)](https://leetcode.com/problems/validate-binary-search-tree/) - Find violations

### Medium (Apply pattern)
- [ ] [Recover BST (LC 99)](https://leetcode.com/problems/recover-binary-search-tree/) - This problem
- [ ] [Kth Smallest (LC 230)](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) - Inorder tracking
- [ ] [BST Iterator (LC 173)](https://leetcode.com/problems/binary-search-tree-iterator/) - Controlled inorder

### Hard (Master)
- [ ] Implement Morris Traversal from scratch

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand adjacent vs non-adjacent cases
- **Day 3:** Implement O(h) space solution
- **Day 7:** Trace through example by hand
- **Day 14:** Implement Morris traversal version
- **Day 30:** Explain the algorithm without code

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"Since inorder traversal of a valid BST is sorted, swapping two nodes creates violations where current < previous. I'll traverse inorder, track the previous node, and identify violations. The first violation gives me the larger swapped node, and the last violation gives me the smaller one."

**Key points:**
1. "There are two cases: adjacent swap (1 violation) and non-adjacent swap (2 violations)"
2. "I always set first at the first violation, and keep updating second"
3. "Finally, I just swap the values, not the node pointers"

**Follow-up: O(1) space?**
"I can use Morris traversal, which creates temporary links to traverse without a stack."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê | Medium-hard BST |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Tests BST understanding |
| Google | ‚≠ê‚≠ê |" May ask for O(1) space "|
| Meta | ‚≠ê‚≠ê | Less common |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 5-7 min | Two cases to grasp |
|" Code O(h) solution "| 12-15 min | Track prev carefully |
|" Code O(1) Morris "| 20-25 min | If asked |
| Discuss complexity | 3-4 min | Space trade-offs |
| Total interview time | 25-35 min | Hard problem |

---

## üí° Key Insight

> **Two swapped elements in a sorted array create at most two "inversions" (where a[i] > a[i+1]).** The first inversion's left element and the last inversion's right element are the swapped pair. This array insight translates directly to BST inorder traversal.

---

## üîó Related

- **Previous:** [Validate BST (LC 98)](./3.1-Validate-BST-LC98.md)
- **Next:** [Trim BST (LC 669)](./3.3-Trim-BST-LC669.md)
- **Uses:** [Inorder Traversal](../../06-Trees/03-Tree-Traversals/3.1-DFS-Traversals/)
- **Advanced:** Morris Traversal for O(1) space
