# 6.2 DFS Approach to Topological Sort

> **Post-order DFS traversal with reversal - elegant recursive solution**
>
> ðŸŽ¯ **Best For:** Concise code, natural recursion | **Trade-off:** Cycle detection needs careful state

---

## Overview

The DFS approach to topological sort leverages a key insight: in DFS, a node is finished (added to result) only after all its descendants are finished. This is **post-order** traversal.

```
If A â†’ B â†’ C (A depends on B, B depends on C)

DFS post-order:  C, B, A
Reversed:        A, B, C  â† Correct topological order!
```

---

## ðŸ“ How It Works

### The Algorithm

```
1. For each unvisited node, run DFS
2. Mark node as "in progress" (GRAY)
3. Recursively visit all neighbors
4. After all neighbors done, mark node as "done" (BLACK)
5. Add node to result stack
6. Reverse the stack for final answer

Why reverse?
- DFS adds nodes in POST-order (leaves first)
- We want PRE-order (roots first)
- Reverse gives us what we need
```

### Three-Color Marking

```
WHITE (0): Not visited yet
GRAY (1):  Currently in DFS path (being processed)
BLACK (2): Completely processed

GRAY â†’ GRAY edge = BACK EDGE = CYCLE!
```

**Visualization:**
```
Graph: A â†’ B â†’ C
       A â†’ D

DFS from A:
  A becomes GRAY
    B becomes GRAY
      C becomes GRAY
      C has no neighbors â†’ C becomes BLACK, add C
    B has no more neighbors â†’ B becomes BLACK, add B
  D becomes GRAY
  D has no neighbors â†’ D becomes BLACK, add D
  A has no more neighbors â†’ A becomes BLACK, add A

Stack: [C, B, D, A]
Reversed: [A, D, B, C] â† Valid topological order
```

---

## ðŸ’» Implementation

**Python:**
```python
from collections import defaultdict
from typing import List, Optional

def topological_sort_dfs(num_nodes: int, edges: List[List[int]]) -> List[int]:
    """
    DFS-based topological sort with cycle detection.
    
    Uses three-color marking:
    - WHITE (0): unvisited
    - GRAY (1): in current DFS path
    - BLACK (2): completely processed
    
    Time: O(V + E)
    Space: O(V + E)
    """
    # Build adjacency list
    graph = defaultdict(list)
    for src, dst in edges:
        graph[src].append(dst)
    
    WHITE, GRAY, BLACK = 0, 1, 2
    state = [WHITE] * num_nodes
    result = []
    has_cycle = [False]  # Use list to allow modification in nested function
    
    def dfs(node: int) -> None:
        if has_cycle[0]:
            return
        
        state[node] = GRAY
        
        for neighbor in graph[node]:
            if state[neighbor] == GRAY:
                # Back edge: neighbor is ancestor in current path
                has_cycle[0] = True
                return
            if state[neighbor] == WHITE:
                dfs(neighbor)
                if has_cycle[0]:
                    return
        
        state[node] = BLACK
        result.append(node)  # POST-order: add after processing children
    
    # Process all nodes (handles disconnected graph)
    for node in range(num_nodes):
        if state[node] == WHITE:
            dfs(node)
            if has_cycle[0]:
                return []
    
    # Reverse for topological order
    return result[::-1]


# Alternative: Using stack instead of recursion (for large graphs)
def topological_sort_iterative(num_nodes: int, edges: List[List[int]]) -> List[int]:
    """Iterative DFS to avoid stack overflow on large graphs."""
    graph = defaultdict(list)
    for src, dst in edges:
        graph[src].append(dst)
    
    WHITE, GRAY, BLACK = 0, 1, 2
    state = [WHITE] * num_nodes
    result = []
    
    for start in range(num_nodes):
        if state[start] != WHITE:
            continue
        
        stack = [(start, False)]  # (node, is_processed)
        
        while stack:
            node, processed = stack.pop()
            
            if processed:
                # Second visit: all children done, add to result
                result.append(node)
                continue
            
            if state[node] == BLACK:
                continue
            
            if state[node] == GRAY:
                # Cycle detected
                return []
            
            state[node] = GRAY
            stack.append((node, True))  # Schedule post-processing
            
            for neighbor in graph[node]:
                if state[neighbor] == WHITE:
                    stack.append((neighbor, False))
                elif state[neighbor] == GRAY:
                    return []  # Cycle
        
        # Mark all processed nodes as BLACK
        for i in range(num_nodes):
            if state[i] == GRAY:
                state[i] = BLACK
    
    return result[::-1]


# Test
edges = [[5,0], [5,2], [4,0], [4,1], [2,3], [3,1]]
print(topological_sort_dfs(6, edges))
# Output: [5, 4, 2, 3, 1, 0] or similar valid order
```

**JavaScript:**
```javascript
function topologicalSortDFS(numNodes, edges) {
    // Build adjacency list
    const graph = new Map();
    for (let i = 0; i < numNodes; i++) {
        graph.set(i, []);
    }
    for (const [src, dst] of edges) {
        graph.get(src).push(dst);
    }
    
    const WHITE = 0, GRAY = 1, BLACK = 2;
    const state = new Array(numNodes).fill(WHITE);
    const result = [];
    let hasCycle = false;
    
    function dfs(node) {
        if (hasCycle) return;
        
        state[node] = GRAY;
        
        for (const neighbor of graph.get(node)) {
            if (state[neighbor] === GRAY) {
                hasCycle = true;
                return;
            }
            if (state[neighbor] === WHITE) {
                dfs(neighbor);
                if (hasCycle) return;
            }
        }
        
        state[node] = BLACK;
        result.push(node);
    }
    
    for (let node = 0; node < numNodes; node++) {
        if (state[node] === WHITE) {
            dfs(node);
            if (hasCycle) return [];
        }
    }
    
    return result.reverse();
}
```

---

## ðŸ”„ Step-by-Step Trace

```
Graph:
0 â† 5 â†’ 2 â†’ 3 â†’ 1 â† 4 â†’ 0
        
Edges: [[5,0], [5,2], [4,0], [4,1], [2,3], [3,1]]

DFS Execution:
Node 0: No outgoing edges
  state[0] = GRAY â†’ BLACK
  result = [0]

Node 1: No outgoing edges  
  state[1] = GRAY â†’ BLACK
  result = [0, 1]

Node 2: Goes to 3
  state[2] = GRAY
    Node 3: Goes to 1 (already BLACK, skip)
    state[3] = GRAY â†’ BLACK
    result = [0, 1, 3]
  state[2] = BLACK
  result = [0, 1, 3, 2]

Node 3: Already BLACK

Node 4: Goes to 0 (BLACK), 1 (BLACK)
  state[4] = GRAY â†’ BLACK
  result = [0, 1, 3, 2, 4]

Node 5: Goes to 0 (BLACK), 2 (BLACK)
  state[5] = GRAY â†’ BLACK
  result = [0, 1, 3, 2, 4, 5]

Final (reversed): [5, 4, 2, 3, 1, 0] âœ“
```

---

## âš ï¸ Common Mistakes

### 1. Using Only Two States

```python
# âŒ Wrong: Can't detect back edges properly
visited = set()
def dfs(node):
    if node in visited:
        return  # Is this a cycle? Or already processed?

# âœ… Correct: Three states distinguish cycle from completed
if state[neighbor] == GRAY:  # In current path = cycle
    has_cycle = True
elif state[neighbor] == WHITE:  # Unvisited = explore
    dfs(neighbor)
# BLACK = completed, skip
```

### 2. Forgetting to Reverse

```python
# âŒ Wrong: Returns post-order (leaves first)
return result

# âœ… Correct: Reverse for topological order
return result[::-1]
```

### 3. Not Handling Disconnected Graphs

```python
# âŒ Wrong: Only start from node 0
dfs(0)
return result[::-1]

# âœ… Correct: Start from all unvisited nodes
for node in range(num_nodes):
    if state[node] == WHITE:
        dfs(node)
```

---

## âš¡ Complexity Analysis

| Aspect | Complexity | Explanation |
|--------|------------|-------------|
| **Time** | O(V + E) | Each vertex and edge visited once |
| **Space** | O(V + E) | Adjacency list + recursion stack |

---

## ðŸ†š DFS vs Kahn's

| Aspect | DFS Approach | Kahn's (BFS) |
|--------|--------------|--------------|
| Code length | Shorter | Longer |
| Intuition | Post-order magic | Obvious (remove nodes) |
| Cycle detection | Need 3 states | Easy (count nodes) |
| Stack overflow risk | Yes (deep recursion) | No |
| Parallelizable | No | Yes |

---

> **ðŸ’¡ Key Insight:** DFS post-order naturally puts dependencies after their dependents. Reversing this gives us the correct order. The three-color marking elegantly detects cycles by identifying back edges (GRAY â†’ GRAY).

---

**Next:** [Kahn's Algorithm (BFS) â†’](./6.3-Kahns-BFS.md)
