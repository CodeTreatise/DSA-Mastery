# 10.1 Bipartite Graphs

> **Two-colorable graphs - divide vertices into two disjoint sets**
>
> ‚è±Ô∏è **Study Time:** 30 min | üìä **Priority:** Medium | üéØ **Pattern:** Graph Coloring / BFS

---

## Overview

A **bipartite graph** is a graph whose vertices can be divided into two disjoint sets such that **every edge connects a vertex from one set to a vertex in the other set**. No edges exist within the same set.

```
Bipartite:              NOT Bipartite:
Set A: {1, 3}           Triangle (odd cycle):
Set B: {2, 4}           
                        1 ‚îÄ‚îÄ‚îÄ 2
1 ‚îÄ‚îÄ‚îÄ 2                  \   /
‚îÇ     ‚îÇ                   \ /
3 ‚îÄ‚îÄ‚îÄ 4                    3

Each edge crosses       Edge 1-3 is within same "set"
between sets            Can't 2-color!
```

**Key Insight:** A graph is bipartite ‚ü∫ it has no odd-length cycles.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Bipartite Problems</strong></summary>

**Look for these signals:**
- "Can we divide into two groups?"
- "Two-coloring problem"
- "People who dislike each other in different groups"
- "Matching problems" (jobs to workers, etc.)

**Keywords in problem statement:**
- "bipartite", "two groups", "two sets"
- "enemy", "dislike", "conflict"
- "matching", "assignment"
- "alternating colors"

</details>

---

## ‚úÖ When to Use

- Checking if graph can be 2-colored
- Matching problems (jobs, assignments)
- Conflict resolution (enemies in different groups)
- Detecting odd cycles

## ‚ùå When NOT to Use

| Instead of... | Use... | When... |
|--------------|--------|---------|
| Bipartite check | General coloring | Need more than 2 colors |
| BFS coloring | Union-Find | Just checking connectivity |
| Full check | Quick odd cycle | Only need cycle detection |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BFS Pattern](../03-BFS-Traversal/3.1-BFS-Fundamentals.md)
- [DFS Pattern](../04-DFS-Traversal/4.1-DFS-Fundamentals.md)

**After mastering this:**
- [Graph Coloring](./10.2-Graph-Coloring.md)
- Maximum Bipartite Matching (Hungarian Algorithm)
- Network Flow (Max-Flow Min-Cut)

**Combines with:**
- BFS/DFS traversal
- Cycle detection (odd cycles = not bipartite)

</details>

---

## üìê How It Works

### Two-Coloring Approach

```
Algorithm:
1. Start from any uncolored node, color it 0
2. Color all neighbors with opposite color (1)
3. For each neighbor, color their neighbors with 0
4. If we ever try to color a node that already has the same color ‚Üí NOT bipartite!

Example:
    1 ‚îÄ‚îÄ‚îÄ 2 ‚îÄ‚îÄ‚îÄ 3
    ‚îÇ           ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Step 1: Color 1 with 0
Step 2: Color neighbors (2) with 1
Step 3: Color 2's neighbors (1, 3) 
        - 1 already has color 0, need 0... OK!
        - 3 gets color 0
Step 4: Color 3's neighbors (2, 1)
        - 2 already has color 1, need 1... OK!
        - 1 already has color 0, need 0... OK!

Result: Bipartite! Colors: {0: [1,3], 1: [2]}
```

### Odd Cycle Detection

```
    1 ‚îÄ‚îÄ‚îÄ 2
     \   /
      \ /
       3

Coloring attempt:
1 ‚Üí color 0
2 ‚Üí color 1 (neighbor of 0)
3 ‚Üí color 0 (neighbor of 1)
Check: 1-3 edge, both color 0 ‚Üí CONFLICT!

This is a triangle (cycle of length 3 = odd)
```

---

## üíª Code Implementation

**Python - BFS Approach:**
```python
from collections import deque, defaultdict
from typing import List

def isBipartite(graph: List[List[int]]) -> bool:
    """
    Check if graph is bipartite using BFS coloring.
    graph[i] = list of neighbors of node i
    
    Time: O(V + E)
    Space: O(V)
    """
    n = len(graph)
    color = [-1] * n  # -1 = uncolored
    
    for start in range(n):
        if color[start] != -1:
            continue  # Already colored
        
        # BFS from this node
        queue = deque([start])
        color[start] = 0
        
        while queue:
            node = queue.popleft()
            
            for neighbor in graph[node]:
                if color[neighbor] == -1:
                    # Color with opposite color
                    color[neighbor] = 1 - color[node]
                    queue.append(neighbor)
                elif color[neighbor] == color[node]:
                    # Same color as current = NOT bipartite!
                    return False
    
    return True


def isBipartiteDFS(graph: List[List[int]]) -> bool:
    """
    Check if graph is bipartite using DFS coloring.
    """
    n = len(graph)
    color = [-1] * n
    
    def dfs(node: int, c: int) -> bool:
        color[node] = c
        
        for neighbor in graph[node]:
            if color[neighbor] == -1:
                if not dfs(neighbor, 1 - c):
                    return False
            elif color[neighbor] == c:
                return False
        
        return True
    
    for i in range(n):
        if color[i] == -1:
            if not dfs(i, 0):
                return False
    
    return True


def possibleBipartition(n: int, dislikes: List[List[int]]) -> bool:
    """
    LC 886: Possible Bipartition
    Can we split people into two groups where no two people who dislike
    each other are in the same group?
    """
    graph = defaultdict(list)
    for a, b in dislikes:
        graph[a].append(b)
        graph[b].append(a)
    
    color = {}
    
    def dfs(node, c):
        color[node] = c
        for neighbor in graph[node]:
            if neighbor in color:
                if color[neighbor] == c:
                    return False
            else:
                if not dfs(neighbor, 1 - c):
                    return False
        return True
    
    for i in range(1, n + 1):  # 1-indexed people
        if i not in color:
            if not dfs(i, 0):
                return False
    
    return True


# Test
print(isBipartite([[1,3],[0,2],[1,3],[0,2]]))  # True: 0-1, 2-3 groups
print(isBipartite([[1,2,3],[0,2],[0,1,3],[0,2]]))  # False: triangle 0-1-2
```

**JavaScript:**
```javascript
function isBipartite(graph) {
    const n = graph.length;
    const color = new Array(n).fill(-1);
    
    for (let start = 0; start < n; start++) {
        if (color[start] !== -1) continue;
        
        const queue = [start];
        color[start] = 0;
        
        while (queue.length > 0) {
            const node = queue.shift();
            
            for (const neighbor of graph[node]) {
                if (color[neighbor] === -1) {
                    color[neighbor] = 1 - color[node];
                    queue.push(neighbor);
                } else if (color[neighbor] === color[node]) {
                    return false;
                }
            }
        }
    }
    
    return true;
}

// DFS version
function isBipartiteDFS(graph) {
    const n = graph.length;
    const color = new Array(n).fill(-1);
    
    function dfs(node, c) {
        color[node] = c;
        
        for (const neighbor of graph[node]) {
            if (color[neighbor] === -1) {
                if (!dfs(neighbor, 1 - c)) return false;
            } else if (color[neighbor] === c) {
                return false;
            }
        }
        
        return true;
    }
    
    for (let i = 0; i < n; i++) {
        if (color[i] === -1 && !dfs(i, 0)) {
            return false;
        }
    }
    
    return true;
}
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| **BFS** | O(V + E) | O(V) | Level-order coloring |
| **DFS** | O(V + E) | O(V) | Recursion + color array |

---

## üîÑ Variations

### Union-Find Approach

Use union-find with "enemy" tracking:

```python
def isBipartiteUnionFind(graph):
    """
    Alternative: Union all enemies of a node together.
    If a node ends up in same set as its enemy, not bipartite.
    """
    n = len(graph)
    parent = list(range(n))
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        parent[find(x)] = find(y)
    
    for node in range(n):
        if not graph[node]:
            continue
        
        # All neighbors should be in same group (enemies of node)
        first_enemy = graph[node][0]
        
        for neighbor in graph[node]:
            # If node and neighbor in same group, fail!
            if find(node) == find(neighbor):
                return False
            # Put all neighbors together
            union(first_enemy, neighbor)
    
    return True
```

### Get Partition Sets

Return the actual two sets:

```python
def getBipartition(graph):
    """
    Return the two sets if bipartite, or None if not.
    """
    n = len(graph)
    color = [-1] * n
    
    for start in range(n):
        if color[start] != -1:
            continue
        
        queue = deque([start])
        color[start] = 0
        
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if color[neighbor] == -1:
                    color[neighbor] = 1 - color[node]
                    queue.append(neighbor)
                elif color[neighbor] == color[node]:
                    return None
    
    set0 = [i for i in range(n) if color[i] == 0]
    set1 = [i for i in range(n) if color[i] == 1]
    return set0, set1
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting Disconnected Components

```python
# ‚ùå WRONG: Only check from node 0
dfs(0, 0)

# ‚úÖ CORRECT: Check all unvisited nodes
for i in range(n):
    if color[i] == -1:
        if not dfs(i, 0):
            return False
```

### 2. Wrong Color Assignment

```python
# ‚ùå WRONG: Using same color for neighbors
color[neighbor] = color[node]  # Wrong!

# ‚úÖ CORRECT: Opposite color
color[neighbor] = 1 - color[node]
```

### 3. Confusing Edges and Neighbors

```python
# ‚ùå WRONG: Treating edges as graph
def isBipartite(edges):  # edges = [[0,1], [1,2]]
    # Need to build adjacency list first!

# ‚úÖ CORRECT: Build graph from edges
graph = defaultdict(list)
for u, v in edges:
    graph[u].append(v)
    graph[v].append(u)
```

---

## üìù Practice Problems (Progressive)

### Easy (Basic bipartite check)
- [ ] [Is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/) - Direct application

### Medium (Variations)
- [ ] [Possible Bipartition](https://leetcode.com/problems/possible-bipartition/) - Dislikes graph
- [ ] [Flower Planting With No Adjacent](https://leetcode.com/problems/flower-planting-with-no-adjacent/) - Graph coloring

### Hard (Advanced)
- [ ] [Maximum Bipartite Matching](https://leetcode.com/problems/maximum-number-of-accepted-invitations/) - Matching

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

| Day | Activity |
|-----|----------|
| 1 | Implement BFS bipartite check |
| 3 | Solve Is Graph Bipartite |
| 7 | Solve Possible Bipartition |
| 14 | Explain odd cycle connection |

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening:**
> "A bipartite graph can be 2-colored so no adjacent nodes have the same color. I'll use BFS/DFS to try coloring - if I find a conflict, it's not bipartite."

**Key insight to mention:**
> "This works because a graph is bipartite if and only if it has no odd-length cycles. The coloring process naturally detects odd cycles."

**Alternative approaches:**
> "I could also use Union-Find: put all neighbors of each node in the same set, and check if a node ever ends up with a neighbor."

</details>

**Company Focus:**
| Company | Frequency | Notes |
|---------|-----------|-------|
| **Amazon** | Medium | Possible Bipartition |
| **Meta** | Medium | Grouping problems |
| **Google** | Low | Usually as subproblem |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn concept | 20 min | With examples |
| Implement | 10 min | BFS or DFS |
| Solve basic problem | 15 min | Is Graph Bipartite |
| Solve medium | 20 min | Possible Bipartition |

---

> **üí° Key Insight:** Bipartite ‚ü∫ No odd cycles. The 2-coloring BFS/DFS naturally fails exactly when there's an odd cycle, because you'll try to give a node the same color twice.

---

> **üîó Related:** [Graph Coloring](./10.2-Graph-Coloring.md) | [BFS Pattern](../03-BFS-Traversal/3.1-BFS-Fundamentals.md) | [Cycle Detection](../09-Cycle-Detection/9.1-Undirected-Cycles.md)

---

**Next:** [Graph Coloring ‚Üí](./10.2-Graph-Coloring.md)
