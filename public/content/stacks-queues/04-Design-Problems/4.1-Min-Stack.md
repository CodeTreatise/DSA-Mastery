# 4.1 Min Stack (LC 155)

> **Grokking Pattern:** #7 Stacks - Design
>
> **Difficulty:** Medium | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Classic Design Problem

---

## Problem Statement

Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

Implement the `MinStack` class:
- `MinStack()` initializes the stack object
- `void push(int val)` pushes element val onto the stack
- `void pop()` removes the element on top of the stack
- `int top()` gets the top element of the stack
- `int getMin()` retrieves the minimum element in the stack

**All operations must be O(1) time complexity.**

```
Example:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   // Returns -3
minStack.pop();
minStack.top();      // Returns 0
minStack.getMin();   // Returns -2
```

[LeetCode 155 - Min Stack](https://leetcode.com/problems/min-stack/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Design a data structure"
- "O(1) time for all operations"
- Track additional state (min/max) alongside normal stack operations
- State changes with push/pop

**Key insight:**
The minimum can change when we push or pop. We need to track what the minimum was at each point in time.

**Two approaches:**
1. **Two stacks:** One for values, one for minimums
2. **Single stack with pairs:** Store (value, current_min) together

</details>

---

## ‚úÖ When to Use This Approach

- Need O(1) access to minimum/maximum in stack
- State tracking that changes with stack operations
- Design problems with auxiliary information

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Need median, not min | Requires sorted access | Two heaps |
| Queue instead of stack | Different order | Min Queue design |
| Need range min | Point query only | Segment Tree |
| Dynamic updates | Only track push/pop min | Different structure |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md)
- Basic stack operations

**After mastering this:**
- [Max Stack](https://leetcode.com/problems/max-stack/) - LC 716
- [Stack with Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/) - LC 1381
- [Dinner Plate Stacks](https://leetcode.com/problems/dinner-plate-stacks/) - LC 1172

**This combines:**
- Stack fundamentals
- Auxiliary data tracking
- Space-time tradeoffs

</details>

---

## üìê How It Works

### Approach 1: Two Stacks

Maintain two stacks:
- `main_stack`: stores all values
- `min_stack`: stores minimum at each level

```
Push(-2): main=[‚àí2]     min=[‚àí2]     (min is ‚àí2)
Push(0):  main=[‚àí2,0]   min=[‚àí2,‚àí2]  (min still ‚àí2)
Push(-3): main=[‚àí2,0,‚àí3] min=[‚àí2,‚àí2,‚àí3] (new min ‚àí3)
Pop():    main=[‚àí2,0]   min=[‚àí2,‚àí2]  (min back to ‚àí2)
```

### Approach 2: Single Stack with Pairs

Store (value, current_min) pairs:

```
Push(-2): stack=[(‚àí2,‚àí2)]
Push(0):  stack=[(‚àí2,‚àí2), (0,‚àí2)]
Push(-3): stack=[(‚àí2,‚àí2), (0,‚àí2), (‚àí3,‚àí3)]
Pop():    stack=[(‚àí2,‚àí2), (0,‚àí2)]
```

### Space Optimization

If many duplicates, min_stack can store (value, count):

```
Push(1): main=[1]     min=[(1,1)]
Push(1): main=[1,1]   min=[(1,2)]    ‚Üê increment count
Push(0): main=[1,1,0] min=[(1,2),(0,1)]
Pop():   main=[1,1]   min=[(1,2)]    ‚Üê decrement/remove
```

---

## üíª Code Implementation

### Solution 1: Two Stacks (Clean, Recommended)

**Python:**
```python
class MinStack:
    """
    Stack with O(1) minimum retrieval.
    
    Approach: Two parallel stacks
    - main_stack: stores all values
    - min_stack: stores running minimum
    
    Time: O(1) all operations
    Space: O(n) where n = number of elements
    """
    
    def __init__(self):
        self.main_stack = []
        self.min_stack = []
    
    def push(self, val: int) -> None:
        self.main_stack.append(val)
        
        # Push the new minimum (or same if val not smaller)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)
        else:
            self.min_stack.append(self.min_stack[-1])
    
    def pop(self) -> None:
        self.main_stack.pop()
        self.min_stack.pop()
    
    def top(self) -> int:
        return self.main_stack[-1]
    
    def getMin(self) -> int:
        return self.min_stack[-1]


class MinStackOptimized:
    """
    Space-optimized: only push to min_stack when new minimum.
    """
    
    def __init__(self):
        self.stack = []
        self.min_stack = []
    
    def push(self, val: int) -> None:
        self.stack.append(val)
        # Only push if new minimum or equal (for duplicates)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)
    
    def pop(self) -> None:
        val = self.stack.pop()
        # Only pop from min_stack if it was the minimum
        if val == self.min_stack[-1]:
            self.min_stack.pop()
    
    def top(self) -> int:
        return self.stack[-1]
    
    def getMin(self) -> int:
        return self.min_stack[-1]
```

**JavaScript:**
```javascript
/**
 * Min Stack - Two Stack Approach
 * Time: O(1) all operations
 * Space: O(n)
 */
class MinStack {
    constructor() {
        this.stack = [];
        this.minStack = [];
    }
    
    push(val) {
        this.stack.push(val);
        // Track minimum at each level
        if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1]) {
            this.minStack.push(val);
        } else {
            this.minStack.push(this.minStack[this.minStack.length - 1]);
        }
    }
    
    pop() {
        this.stack.pop();
        this.minStack.pop();
    }
    
    top() {
        return this.stack[this.stack.length - 1];
    }
    
    getMin() {
        return this.minStack[this.minStack.length - 1];
    }
}

/**
 * Space-optimized version
 */
class MinStackOptimized {
    constructor() {
        this.stack = [];
        this.minStack = [];
    }
    
    push(val) {
        this.stack.push(val);
        if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1]) {
            this.minStack.push(val);
        }
    }
    
    pop() {
        const val = this.stack.pop();
        if (val === this.minStack[this.minStack.length - 1]) {
            this.minStack.pop();
        }
    }
    
    top() {
        return this.stack[this.stack.length - 1];
    }
    
    getMin() {
        return this.minStack[this.minStack.length - 1];
    }
}
```

### Solution 2: Single Stack with Pairs

**Python:**
```python
class MinStackPairs:
    """
    Store (value, min_at_this_point) pairs.
    
    Slightly simpler logic, same time/space.
    """
    
    def __init__(self):
        self.stack = []  # stores (value, current_min)
    
    def push(self, val: int) -> None:
        if not self.stack:
            self.stack.append((val, val))
        else:
            current_min = min(val, self.stack[-1][1])
            self.stack.append((val, current_min))
    
    def pop(self) -> None:
        self.stack.pop()
    
    def top(self) -> int:
        return self.stack[-1][0]
    
    def getMin(self) -> int:
        return self.stack[-1][1]
```

### Solution 3: Single Variable (O(1) Space Extra, Tricky)

**Python:**
```python
class MinStackConstantSpace:
    """
    O(1) extra space using encoding trick.
    
    Key insight: When pushing value smaller than min,
    store encoded value and update min.
    
    Caution: Can overflow with large integers.
    """
    
    def __init__(self):
        self.stack = []
        self.min_val = float('inf')
    
    def push(self, val: int) -> None:
        if not self.stack:
            self.stack.append(val)
            self.min_val = val
        elif val >= self.min_val:
            self.stack.append(val)
        else:
            # Encode: push (2*val - min), update min
            self.stack.append(2 * val - self.min_val)
            self.min_val = val
    
    def pop(self) -> None:
        top = self.stack.pop()
        if top < self.min_val:
            # Was encoded, restore previous min
            self.min_val = 2 * self.min_val - top
    
    def top(self) -> int:
        top = self.stack[-1]
        if top < self.min_val:
            return self.min_val  # Encoded value, real value is min
        return top
    
    def getMin(self) -> int:
        return self.min_val
```

---

## ‚ö° Complexity Analysis

| Approach | Time (all ops) | Space | Notes |
|----------|----------------|-------|-------|
| Two Stacks |" O(1) "| O(n) | Clearest logic |
| Optimized Two Stacks |" O(1) "| O(n) best, O(n) worst | Better in practice |
| Single Stack + Pairs |" O(1) "| O(n) | Same complexity, different encoding |
| Constant Space Trick |" O(1) "| O(1) extra | Tricky, can overflow |

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Max Stack | Track maximum instead | LC 716 |
| Min/Max together | Two auxiliary stacks | Custom |
| With increment | Add delta to bottom k | LC 1381 |
| Popable at any position | More complex structure | Max Stack |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using `<` Instead of `<=` for Duplicates

```python
# ‚ùå WRONG: Misses duplicate minimums
if val < self.min_stack[-1]:
    self.min_stack.append(val)

# ‚úÖ CORRECT: Handle equal values
if val <= self.min_stack[-1]:
    self.min_stack.append(val)
```

**Why?** If we push [0, 0] and pop once, we need to know 0 is still the min.

### 2. Forgetting to Check Empty Stack

```python
# ‚ùå WRONG: Crashes on first push
if val <= self.min_stack[-1]:
    
# ‚úÖ CORRECT: Check empty first
if not self.min_stack or val <= self.min_stack[-1]:
```

### 3. Optimized Version: Wrong Pop Logic

```python
# ‚ùå WRONG: Comparing references instead of values
if self.stack[-1] is self.min_stack[-1]:
    
# ‚úÖ CORRECT: Compare actual values
if self.stack[-1] == self.min_stack[-1]:
```

---

## üìù Practice Problems (Progressive)

### This Problem
- [ ] [Min Stack](https://leetcode.com/problems/min-stack/) - LC 155 ‚≠ê

### Related Design Problems
- [ ] [Max Stack](https://leetcode.com/problems/max-stack/) - LC 716 (Premium)
- [ ] [Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/) - LC 1381
- [ ] [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) - LC 232
- [ ] [Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/) - LC 225

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement two-stack version
**Day 3:** Implement space-optimized version
**Day 7:** Implement without notes
**Day 14:** Solve Max Stack variant
**Day 21:** Review and compare all approaches

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Clarifying questions to ask:**
> "Can the stack contain duplicates?" (Yes - important for `<=` check)
> "What should getMin return on empty stack?" (Usually won't be called)
> "Integer range?" (Matters for constant space trick)

**Explain the key insight:**
> "The minimum can only change when we push or pop. If I track the minimum at each level of the stack, I can retrieve it in O(1) by just looking at the current level."

**Present two-stack solution first:**
> "I'll use two stacks: one for values, one for the minimum at each point. When I push, I also push the new minimum. When I pop, I pop from both."

**Optimization discussion:**
> "For space optimization, I only push to the min stack when the value is a new minimum. But I need to handle duplicates with `<=` not `<`."

**Handle follow-up about constant space:**
> "There's a clever encoding trick where I store `2*val - min` when pushing a new minimum, allowing me to recover the previous min on pop. But it has overflow risks."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common, often as warm-up |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Frequently asked |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask follow-ups |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Design focus |
| Bloomberg | ‚≠ê‚≠ê‚≠ê‚≠ê | Finance applications |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Read carefully |
| Discuss approach | 3-5 min | Explain two-stack idea |
| Implement | 8-10 min | Basic version |
| Test | 3-5 min | Walk through example |
| Optimization discussion | 5 min | If asked |
| Interview target | 20-25 min | Including explanation |

---

> **üí° Key Insight:** The minimum at any point in the stack only depends on the elements below it. By tracking the minimum at each level (either with a parallel stack or embedded in tuples), we achieve O(1) retrieval without recalculating the minimum on every call.

---

## üîó Related

- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md) - Foundation
- [Queue Using Stacks](./4.2-Queue-Using-Stacks.md) - Related design
- [Stack Using Queues](./4.3-Stack-Using-Queues.md) - Related design
