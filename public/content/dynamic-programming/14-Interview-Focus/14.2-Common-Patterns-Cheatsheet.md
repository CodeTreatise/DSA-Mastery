# DP Patterns Cheatsheet

> **Quick reference for all DP patterns with templates, signals, and key insights.**

---

## Pattern Overview Matrix

| # | Pattern | Time | Space | Key Signal |
|---|---------|------|-------|------------|
| 1 | Fibonacci/Linear | O(n) | O(1) | "previous elements", "steps" |
| 2 | Grid DP | O(mn) | O(n) | Matrix, path, "reach cell" |
| 3 | 0/1 Knapsack | O(nW) | O(W) | "use once", constraint |
| 4 | Unbounded Knapsack | O(nW) | O(W) | "unlimited", "minimum number" |
| 5 | LCS Family | O(mn) | O(n) | Two sequences, matching |
| 6 | LIS | O(n log n) | O(n) | Increasing/decreasing sequence |
| 7 | Palindrome DP | O(nÂ²) | O(n) | "palindrome", "subsequence" |
| 8 | Interval DP | O(nÂ³) | O(nÂ²) | Merge ranges, "first/last" |
| 9 | String DP | O(mn) | O(n) | Matching, transformation |
| 10 | Tree DP | O(n) | O(h) | Tree structure, paths |
| 11 | State Machine | O(nk) | O(k) | Multiple states, transitions |
| 12 | Bitmask DP | O(nÃ—2â¿) | O(2â¿) | Small n (â‰¤20), subsets |
| 13 | Digit DP | O(digitsÃ—states) | O(states) | Range queries, digit constraints |

---

## 1. Fibonacci/Linear DP

### Template
```python
def linear_dp(n):
    if n <= 1: return base_cases[n]
    prev2, prev1 = base_values
    for i in range(2, n + 1):
        curr = f(prev1, prev2)
        prev2, prev1 = prev1, curr
    return prev1
```

### Signals
- "number of ways to reach step n"
- "using previous 1, 2, ... elements"
- Clear recurrence from problem statement

### Classic Problems
| Problem | Recurrence |
|---------|------------|
| Climbing Stairs | dp[i] = dp[i-1] + dp[i-2] |
| House Robber | dp[i] = max(dp[i-1], dp[i-2] + nums[i]) |
| Decode Ways | dp[i] = dp[i-1] (if valid 1-digit) + dp[i-2] (if valid 2-digit) |

---

## 2. Grid DP

### Template
```python
def grid_dp(grid):
    m, n = len(grid), len(grid[0])
    dp = [initial_values] * n
    
    for i in range(m):
        new_dp = [0] * n
        for j in range(n):
            # From top and left
            new_dp[j] = f(dp[j], new_dp[j-1], grid[i][j])
        dp = new_dp
    
    return dp[n-1]
```

### Signals
- "reach bottom-right from top-left"
- "can only move right/down"
- "minimum/maximum path sum"

### Classic Problems
| Problem | Recurrence |
|---------|------------|
| Unique Paths | dp[i][j] = dp[i-1][j] + dp[i][j-1] |
| Min Path Sum | dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] |
| Triangle | dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + tri[i][j] |

---

## 3. 0/1 Knapsack

### Template
```python
def knapsack_01(items, W):
    dp = [0] * (W + 1)  # or [False], [-inf]
    
    for item in items:
        # RIGHT TO LEFT (use each item once)
        for w in range(W, item - 1, -1):
            dp[w] = max(dp[w], dp[w - item] + value)
    
    return dp[W]
```

### Signals
- "each item used at most once"
- "capacity/weight/budget constraint"
- "subset with target sum"

### Classic Problems
| Problem | State | Optimization Goal |
|---------|-------|-------------------|
| Subset Sum | dp[w] = can reach sum w | Reachability |
| Partition Equal | dp[sum/2] | Target = total/2 |
| Target Sum | dp[sum + offset] | Count ways |

> **âš ï¸ Key:** Iterate capacity **RIGHT TO LEFT** to avoid using same item twice!

---

## 4. Unbounded Knapsack

### Template
```python
def knapsack_unbounded(items, W):
    dp = [0] * (W + 1)  # or [inf], [False]
    
    for w in range(W + 1):
        # LEFT TO RIGHT (reuse items)
        for item in items:
            if w >= item:
                dp[w] = min(dp[w], dp[w - item] + 1)
    
    return dp[W]
```

### Signals
- "unlimited supply of items"
- "minimum number to reach target"
- Coin change variants

### Classic Problems
| Problem | State | Goal |
|---------|-------|------|
| Coin Change | dp[amount] = min coins | Minimize |
| Coin Change II | dp[amount] = count ways | Count |
| Perfect Squares | dp[n] = min squares | Minimize |

> **âš ï¸ Key:** Iterate capacity **LEFT TO RIGHT** to allow reuse!

---

## 5. LCS Family

### Template
```python
def lcs_family(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]
```

### Signals
- "two sequences/strings"
- "common subsequence/substring"
- "transform one to another"

### Variants
| Problem | Match | Mismatch |
|---------|-------|----------|
| LCS | dp[i-1][j-1] + 1 | max(dp[i-1][j], dp[i][j-1]) |
| Edit Distance | dp[i-1][j-1] | 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) |
| Longest Common Substring | dp[i-1][j-1] + 1 | 0 (reset) |

---

## 6. LIS (Longest Increasing Subsequence)

### O(nÂ²) Template
```python
def lis_quadratic(nums):
    n = len(nums)
    dp = [1] * n
    
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)
```

### O(n log n) Template
```python
def lis_binary_search(nums):
    tails = []  # Smallest tail for each length
    
    for num in nums:
        pos = bisect_left(tails, num)
        if pos == len(tails):
            tails.append(num)
        else:
            tails[pos] = num
    
    return len(tails)
```

### Signals
- "longest increasing/decreasing"
- "maximum number of elements in order"
- "chain of elements"

---

## 7. Palindrome DP

### Template
```python
def palindrome_dp(s):
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    
    # Base: single chars and pairs
    for i in range(n):
        dp[i][i] = True
        if i < n - 1:
            dp[i][i+1] = (s[i] == s[i+1])
    
    # Fill by length
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]
    
    return dp
```

### Key Insight: LPS via LCS
```python
# Longest Palindromic Subsequence = LCS(s, reverse(s))
def lps(s):
    return lcs(s, s[::-1])
```

### Signals
- "palindrome" in problem
- "subsequence/substring"
- "minimum cuts/insertions"

---

## 8. Interval DP

### Template
```python
def interval_dp(arr):
    n = len(arr)
    dp = [[0] * n for _ in range(n)]
    
    # Fill by length
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = float('inf')
            
            for k in range(i, j):  # Split point
                dp[i][j] = min(dp[i][j],
                    dp[i][k] + dp[k+1][j] + merge_cost(i, j, k))
    
    return dp[0][n-1]
```

### Signals
- "merge adjacent elements"
- "optimal way to combine ranges"
- "what to do FIRST or LAST"

### Key Insight
- Think about **LAST operation**, not first
- Burst Balloons: which balloon to pop LAST?
- Matrix Chain: where to split for LAST multiplication?

---

## 9. String DP

### Wildcard Matching Template
```python
def wildcard(s, p):
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    
    # Handle leading *
    for j in range(1, n + 1):
        if p[j-1] == '*':
            dp[0][j] = dp[0][j-1]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j-1] == '*':
                dp[i][j] = dp[i-1][j] or dp[i][j-1]  # Use * or skip *
            elif p[j-1] == '?' or s[i-1] == p[j-1]:
                dp[i][j] = dp[i-1][j-1]
    
    return dp[m][n]
```

### Signals
- "pattern matching with wildcards"
- "transform string A to B"
- "count distinct subsequences"

---

## 10. Tree DP

### Template
```python
def tree_dp(root):
    result = [float('-inf')]  # Global answer
    
    def dfs(node):
        if not node:
            return initial_value
        
        left = dfs(node.left)
        right = dfs(node.right)
        
        # Update global with complete solution at this node
        result[0] = max(result[0], f(left, right, node.val))
        
        # Return partial solution to extend upward
        return g(left, right, node.val)
    
    dfs(root)
    return result[0]
```

### Key Insight
- **Return value**: What can be extended by parent
- **Global update**: What completes at this node

### Signals
- Tree structure in input
- "path sum", "diameter"
- "rob houses on tree"

---

## 11. State Machine DP

### Stock Trading Template
```python
def stock_machine(prices):
    hold = float('-inf')  # Have stock
    sold = 0               # Just sold
    rest = 0               # Cooldown/waiting
    
    for price in prices:
        prev_hold, prev_sold = hold, sold
        
        hold = max(hold, rest - price)      # Buy
        sold = prev_hold + price             # Sell
        rest = max(rest, prev_sold)          # Wait
    
    return max(sold, rest)
```

### Signals
- Multiple states (hold/sold/rest)
- Transitions between states
- Stock problems with cooldown/fee/limit

### State Diagrams
```
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                   â†“
   REST â”€â”€buyâ”€â”€> HOLD â”€â”€sellâ”€â”€> SOLD
     â†‘            â”‚               â”‚
     â””â”€â”€â”€â”€waitâ”€â”€â”€â”€â”˜               â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€cooldownâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 12. Bitmask DP

### Template
```python
def bitmask_dp(n):
    dp = [initial] * (1 << n)  # 2^n states
    dp[0] = base_value
    
    for mask in range(1 << n):
        for i in range(n):
            if mask & (1 << i):  # i is in subset
                prev_mask = mask ^ (1 << i)  # Remove i
                dp[mask] = f(dp[mask], dp[prev_mask], contribution(i))
    
    return dp[(1 << n) - 1]
```

### Bit Operations
```python
# Check if i-th bit is set
if mask & (1 << i): ...

# Set i-th bit
mask | (1 << i)

# Clear i-th bit
mask ^ (1 << i)  # or mask & ~(1 << i)

# Count set bits
bin(mask).count('1')  # or bit_count() in Python 3.10+
```

### Signals
- Small n (â‰¤ 20, ideally â‰¤ 15)
- "all elements", "visit each once"
- "partition into k groups"

---

## 13. Digit DP

### Template
```python
from functools import lru_cache

def count_to(n):
    digits = list(map(int, str(n)))
    
    @lru_cache(maxsize=None)
    def dp(pos, tight, started, ...other_state...):
        if pos == len(digits):
            return 1 if started else 0
        
        limit = digits[pos] if tight else 9
        count = 0
        
        for d in range(0, limit + 1):
            new_tight = tight and (d == limit)
            new_started = started or (d > 0)
            count += dp(pos + 1, new_tight, new_started, ...)
        
        return count
    
    return dp(0, True, False)

def count_range(low, high):
    return count_to(high) - count_to(low - 1)
```

### Signals
- "count numbers in range [L, R]"
- "digit sum", "no repeated digits"
- "divisibility by k"

---

## Quick Decision Tree

```
                    Is it a DP problem?
                           â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼                â–¼                â–¼
      Sequence         Selection         Structure
         â”‚                â”‚                  â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â–¼         â–¼      â–¼         â–¼       â–¼         â–¼
  Linear    Two    Once?    Unlimited  Tree    Range
  (Fib)    Seqs    â”‚            â”‚       â”‚        â”‚
            â”‚      â–¼            â–¼       â–¼        â–¼
            â–¼    0/1 KS    Unbounded  Tree DP  Interval
          LCS              Knapsack

```

---

## Space Optimization Quick Reference

| Pattern | Original | Optimized | Technique |
|---------|----------|-----------|-----------|
| Fibonacci | O(n) | O(1) | Keep prev1, prev2 |
| Grid | O(mn) | O(n) | Single row + variable |
| Knapsack | O(nW) | O(W) | 1D array |
| LCS | O(mn) | O(n) | Two rows or single row |
| Interval | O(nÂ²) | O(nÂ²) | Cannot optimize |

---

> **ğŸ’¡ Remember:** The hardest part of DP is defining the state correctly. Once you have the state, the recurrence usually follows naturally.

> **ğŸ”— Related:** [DP Interview Strategy](14.1-DP-Interview-Strategy.md) | [Problem Recognition Guide](14.3-Problem-Recognition-Guide.md)
