# Trie Interview Quick Reference

> **One-page reference for Trie concepts during interview prep. Print this out or review before interviews.**

---

## ðŸŽ¯ When Trie = Correct Answer

| Signal | Why Trie? |
|--------|-----------|
| "Prefix" in problem | Trie is THE prefix data structure |
| "Search suggestions" / "Autocomplete" | Prefix matching + word collection |
| "Word dictionary" + multiple queries | O(m) per query vs O(nÃ—m) linear |
| "Wild card search" (.) | DFS through Trie |
| "Maximum XOR" | Bit Trie with greedy selection |

---

## ðŸ“ Standard Implementation (Memorize This)

```python
class TrieNode:
    def __init__(self):
        self.children = {}  # or [None] * 26
        self.is_end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def search(self, word: str) -> bool:
        node = self._traverse(word)
        return node is not None and node.is_end
    
    def startsWith(self, prefix: str) -> bool:
        return self._traverse(prefix) is not None
    
    def _traverse(self, s: str):
        node = self.root
        for char in s:
            if char not in node.children:
                return None
            node = node.children[char]
        return node
```

---

## âš¡ Complexity Cheat Sheet

| Operation | Time | Space |
|-----------|------|-------|
| Insert word | O(m) | O(m) new nodes |
| Search word | O(m) | O(1) |
| Prefix check | O(m) | O(1) |
| Build from n words | O(n Ã— avg_len) | O(total_chars) |
| Wildcard search | O(26^dots Ã— m) | O(m) recursion |

**Where m = word length**

---

## ðŸ”¥ Top 5 Interview Problems

| Problem | Pattern | Key Insight |
|---------|---------|-------------|
| **LC 208: Implement Trie** | Basic | Template memorization |
| **LC 211: Add & Search Words** | Wildcard | DFS when char is '.' |
| **LC 212: Word Search II** | Trie + Backtracking | Trie as search guide |
| **LC 421: Maximum XOR** | Bit Trie | Greedy opposite bit |
| **LC 1268: Search Suggestions** | Collect + Sort | Pre-sort for lex order |

---

## ðŸ’¡ Key Patterns

### Pattern 1: Wildcard Search (LC 211)

```python
def search_with_wildcard(self, node, word, idx):
    if idx == len(word):
        return node.is_end
    
    char = word[idx]
    
    if char == '.':
        # Try ALL children
        for child in node.children.values():
            if self.search_with_wildcard(child, word, idx + 1):
                return True
        return False
    else:
        if char not in node.children:
            return False
        return self.search_with_wildcard(node.children[char], word, idx + 1)
```

### Pattern 2: Word Search II (LC 212)

```python
# Store word at end node (not just is_end)
node.word = word

# During backtracking:
if node.word:
    result.append(node.word)
    node.word = None  # Mark as found (avoid duplicates)
```

### Pattern 3: Bit Trie for XOR (LC 421)

```python
def get_max_xor(self, num):
    node = self.root
    max_xor = 0
    
    for i in range(30, -1, -1):
        bit = (num >> i) & 1
        opposite = 1 - bit
        
        if node.children[opposite]:
            max_xor |= (1 << i)  # Add this bit to result
            node = node.children[opposite]
        else:
            node = node.children[bit]
    
    return max_xor
```

---

## âš ï¸ Common Mistakes to Avoid

| Mistake | Fix |
|---------|-----|
| Returning True for prefix (not word) | Check `node.is_end` in search |
| Using Array[26] for mixed case | Use HashMap or handle case |
| Bit Trie: LSB first | Process MSB first for max XOR |
| Word Search II: duplicate results | Set `node.word = None` after finding |
| Forgetting to create root | `self.root = TrieNode()` |

---

## ðŸŽ¤ Interview Communication

### Step 1: Recognize the Pattern
> "I see this involves prefix matching / word dictionary / XOR maximization, so I'll use a Trie."

### Step 2: Explain Your Approach
> "I'll build a Trie from the dictionary. Each node represents a character, and I'll mark word endings. This gives O(m) lookup per query."

### Step 3: Code Methodically
- Write TrieNode class first
- Write insert method
- Write the query method
- Test with examples

### Step 4: Analyze Complexity
> "Time is O(m) for each operation where m is word length. Space is O(total characters) for the Trie."

---

## ðŸ“Š Decision Tree

```
Problem involves strings + queries?
â”œâ”€â”€ Prefix-based queries â†’ TRIE
â”‚   â”œâ”€â”€ Exact word â†’ search()
â”‚   â”œâ”€â”€ Has prefix â†’ startsWith()
â”‚   â”œâ”€â”€ Wildcard (.) â†’ DFS
â”‚   â””â”€â”€ Collect words â†’ DFS from prefix node
â”œâ”€â”€ XOR optimization â†’ BIT TRIE
â”‚   â””â”€â”€ Maximum XOR â†’ Greedy opposite bit
â””â”€â”€ Not prefix-based â†’ Consider Hash Map
```

---

## ðŸ”— Related Structures

| When | Use Instead |
|------|-------------|
| Single word search | HashSet - O(1) |
| Substring (not prefix) | Suffix Tree/Array |
| Memory critical | Radix Tree (compressed) |
| Fuzzy matching | Trie + Edit Distance |

---

## ðŸ“ Pre-Interview Checklist

- [ ] Can implement basic Trie in 3 minutes
- [ ] Know HashMap vs Array[26] trade-off
- [ ] Can explain wildcard search with DFS
- [ ] Understand Bit Trie for XOR
- [ ] Know complexity for all operations
- [ ] Practiced top 5 problems

---

> **ðŸ’¡ Remember:** Trie = "Prefix Tree". If the problem involves prefixes, Trie is probably the answer.
