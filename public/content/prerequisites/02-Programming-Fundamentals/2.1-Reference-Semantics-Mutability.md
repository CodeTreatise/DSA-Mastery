# 2.1 Reference Semantics & Mutability

> **Why your backtracking solution returns empty lists, your string concatenation TLEs, and your "copy" modifies the original. These bugs cost more interview time than any algorithm.**
>
> â±ï¸ *Estimated reading: 20 minutes*

---

## ğŸ¯ Why This Matters for DSA

| Bug | Root Cause | Frequency |
|-----|-----------|-----------|
| Backtracking returns all empty or duplicate results | Appending reference instead of copy | ğŸ”´ Very Common |
| "I didn't touch that variable" but it changed | Shallow copy of nested structure | ğŸ”´ Very Common |
| String concatenation TLE | O(nÂ²) from immutable string rebuilding | ğŸŸ¡ Common |
| 2D grid rows all change together | `[[0]*n] * m` shares row references | ğŸ”´ Very Common |

---

## ğŸ“ Pass by Value vs Pass by Reference

### The Mental Model

Think of variables as **labels on boxes**:

```
Pass by Value:     You get a COPY of what's in the box
                   Changing your copy doesn't affect the original

Pass by Reference: You get the SAME box (another label on it)
                   Changing the contents affects everyone who has a label
```

### Python's Model: "Pass by Object Reference"

Python is neither strictly "by value" nor "by reference." It passes references to objects, but reassignment creates new references.

```python
# IMMUTABLE types (int, float, str, tuple, frozenset)
# Behave like "pass by value" â€” safe
def modify(x):
    x = x + 1    # Creates NEW int object, local x points to it
    return x

a = 5
modify(a)
print(a)          # 5 â€” unchanged âœ…

# MUTABLE types (list, dict, set)
# Behave like "pass by reference" â€” DANGEROUS
def modify(lst):
    lst.append(4)  # Modifies the SAME list object

a = [1, 2, 3]
modify(a)
print(a)           # [1, 2, 3, 4] â€” changed! âš ï¸
```

### JavaScript's Model: Same Rules

```javascript
// Primitives (number, string, boolean, null, undefined)
// Pass by value â€” safe
function modify(x) {
    x = x + 1;    // Local copy
}
let a = 5;
modify(a);
console.log(a);    // 5 â€” unchanged âœ…

// Objects (arrays, objects, maps, sets)
// Pass by reference â€” DANGEROUS
function modify(arr) {
    arr.push(4);   // Modifies same array
}
let b = [1, 2, 3];
modify(b);
console.log(b);    // [1, 2, 3, 4] â€” changed! âš ï¸
```

---

## ğŸ”´ The Backtracking Copy Bug

This is the **#1 most common bug** in backtracking problems.

### The Problem

```python
# LC 78: Subsets
def subsets(nums):
    result = []
    
    def backtrack(start, path):
        result.append(path)       # âŒ BUG! Appends REFERENCE
        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()            # This undoes the append...
            # ...but result still holds the REFERENCE to path
            # So result's entries get modified too!
    
    backtrack(0, [])
    return result
    # Returns [[], [], [], [], ...] â€” all empty!
    # Because every entry in result points to the SAME path
    # which is empty after all backtracking completes
```

### The Fix

```python
# âœ… CORRECT â€” append a COPY
def subsets(nums):
    result = []
    
    def backtrack(start, path):
        result.append(path[:])    # âœ… Shallow copy with [:]
        # Or: result.append(list(path))
        # Or: result.append(path.copy())
        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()
    
    backtrack(0, [])
    return result
```

```javascript
// JavaScript equivalent
function subsets(nums) {
    const result = [];
    
    function backtrack(start, path) {
        result.push([...path]);    // âœ… Spread creates copy
        // Or: result.push(path.slice());
        for (let i = start; i < nums.length; i++) {
            path.push(nums[i]);
            backtrack(i + 1, path);
            path.pop();
        }
    }
    
    backtrack(0, []);
    return result;
}
```

### Visual Trace

```
backtrack(0, [])
â”œâ”€â”€ result.append(path[:])     â†’ result = [[]]           â† copy of []
â”œâ”€â”€ path.append(1) â†’ path = [1]
â”‚   â”œâ”€â”€ result.append(path[:]) â†’ result = [[], [1]]      â† copy of [1]
â”‚   â”œâ”€â”€ path.append(2) â†’ path = [1,2]
â”‚   â”‚   â””â”€â”€ result.append(path[:]) â†’ result = [[], [1], [1,2]]
â”‚   â””â”€â”€ path.pop() â†’ path = [1]
â”‚   â”œâ”€â”€ path.append(3) â†’ path = [1,3]
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ path.pop() â†’ path = [1]
â””â”€â”€ path.pop() â†’ path = []    â† path is now empty, but copies in result are safe!
```

---

## ğŸ“ Shallow Copy vs Deep Copy

### When Shallow Copy Is Enough

For 1D arrays of primitives (numbers, strings):

```python
# âœ… Shallow copy works for flat lists
original = [1, 2, 3]
copy = original[:]        # or list(original) or original.copy()
copy[0] = 99
print(original)            # [1, 2, 3] â€” safe âœ…
```

```javascript
const original = [1, 2, 3];
const copy = [...original];   // or original.slice()
copy[0] = 99;
console.log(original);        // [1, 2, 3] â€” safe âœ…
```

### When You Need Deep Copy

For nested structures (2D arrays, objects containing arrays):

```python
# âŒ Shallow copy shares inner lists
original = [[1, 2], [3, 4]]
shallow = original[:]
shallow[0][0] = 99
print(original)   # [[99, 2], [3, 4]] â€” inner list was shared!

# âœ… Deep copy creates independent copy of everything
import copy
deep = copy.deepcopy(original)
deep[0][0] = 99
print(original)   # [[1, 2], [3, 4]] â€” safe âœ…
```

```javascript
// JavaScript â€” no built-in deep copy for nested arrays
const original = [[1, 2], [3, 4]];

// âœ… Method 1: JSON (works for JSON-safe data)
const deep = JSON.parse(JSON.stringify(original));

// âœ… Method 2: structuredClone (modern browsers/Node 17+)
const deep2 = structuredClone(original);

// âœ… Method 3: Manual for 2D arrays (most common in DSA)
const deep3 = original.map(row => [...row]);
```

### Quick Reference

| Scenario | Python | JavaScript |
|----------|--------|------------|
| Copy 1D array | `arr[:]` / `list(arr)` | `[...arr]` / `arr.slice()` |
| Copy 2D array | `copy.deepcopy(arr)` | `arr.map(r => [...r])` |
| Copy dict/object | `dict(d)` / `d.copy()` | `{...obj}` / `Object.assign({}, obj)` |
| Copy nested dict | `copy.deepcopy(d)` | `structuredClone(obj)` |

---

## ğŸ”´ The 2D Array Initialization Trap

### The Problem (Both Languages)

```python
# âŒ WRONG â€” all rows are the SAME list
grid = [[0] * 3] * 3
grid[0][0] = 1
print(grid)
# [[1, 0, 0], [1, 0, 0], [1, 0, 0]]  â† all rows changed!

# Why? [row] * 3 creates 3 REFERENCES to the same row object
```

```javascript
// âŒ WRONG â€” same trap
const grid = new Array(3).fill(new Array(3).fill(0));
grid[0][0] = 1;
console.log(grid);
// [[1,0,0], [1,0,0], [1,0,0]]  â† all rows changed!
```

### The Fix

```python
# âœ… CORRECT â€” each row is a NEW list
grid = [[0] * 3 for _ in range(3)]
grid[0][0] = 1
print(grid)
# [[1, 0, 0], [0, 0, 0], [0, 0, 0]]  â† only row 0 changed âœ…
```

```javascript
// âœ… CORRECT
const grid = Array.from({length: 3}, () => new Array(3).fill(0));
grid[0][0] = 1;
console.log(grid);
// [[1,0,0], [0,0,0], [0,0,0]]  â† only row 0 changed âœ…
```

---

## ğŸ”´ String Immutability & O(nÂ²) Concatenation

### The Problem

Strings are **immutable** in both Python and JavaScript. Every concatenation creates a **new string object**.

```python
# âŒ O(nÂ²) â€” each += creates a new string
result = ""
for char in some_list:      # n iterations
    result += char           # Each creates new string of growing length
# Total work: 1 + 2 + 3 + ... + n = O(nÂ²)
```

### The Fix

```python
# âœ… O(n) â€” collect in list, join once
parts = []
for char in some_list:
    parts.append(char)
result = ''.join(parts)

# Even better â€” list comprehension
result = ''.join(char for char in some_list)
```

```javascript
// âŒ O(nÂ²) in theory (V8 optimizes simple cases, but don't rely on it)
let result = '';
for (const char of someList) {
    result += char;
}

// âœ… O(n) â€” guaranteed
const parts = [];
for (const char of someList) {
    parts.push(char);
}
const result2 = parts.join('');
```

### Where This Matters in LeetCode

| Problem | Wrong Approach | Right Approach |
|---------|---------------|----------------|
| String building in backtracking | `result += char` in loop | Collect in array, join at end |
| Reverse string | `result = char + result` | `arr.reverse()` then join |
| Build result string | Repeated concatenation | `''.join(parts)` / `parts.join('')` |

---

## ğŸ“ Mutable Default Arguments (Python Only)

### The Problem

```python
# âŒ BUG â€” default list is shared across all calls!
def add_item(item, lst=[]):
    lst.append(item)
    return lst

add_item(1)    # [1]
add_item(2)    # [1, 2]   â† NOT [2]!
add_item(3)    # [1, 2, 3] â† NOT [3]!
```

### The Fix

```python
# âœ… Use None as default, create new list inside
def add_item(item, lst=None):
    if lst is None:
        lst = []
    lst.append(item)
    return lst

add_item(1)    # [1]
add_item(2)    # [2] âœ…
```

### In DSA Context

```python
# âŒ Common in tree/graph traversals
def dfs(node, path=[]):       # DON'T DO THIS
    path.append(node)
    # ...

# âœ… Correct
def dfs(node, path=None):
    if path is None:
        path = []
    path.append(node)
```

---

## âš ï¸ Common Mistakes Summary

| # | Mistake | Fix |
|---|---------|-----|
| 1 | Backtracking: `result.append(path)` | `result.append(path[:])` or `result.push([...path])` |
| 2 | 2D init: `[[0]*n]*m` | `[[0]*n for _ in range(m)]` |
| 3 | String concat in loop: `s += char` | `parts.append(char)` then `''.join(parts)` |
| 4 | Shallow copy of nested data | Use `copy.deepcopy()` or `structuredClone()` |
| 5 | Python mutable default args | Use `None` default, create inside function |
| 6 | Modifying list while iterating | Iterate over copy: `for x in lst[:]` |
| 7 | Assuming `=` copies an object | It copies the **reference**, not the object |

---

## ğŸ“ Practice Problems

These problems will expose you to reference bugs if you're not careful:

| Problem | Reference Trap | Difficulty |
|---------|---------------|------------|
| [Subsets (LC 78)](https://leetcode.com/problems/subsets/) | Must copy path before appending | Medium |
| [Permutations (LC 46)](https://leetcode.com/problems/permutations/) | Must copy path in backtracking | Medium |
| [Combination Sum (LC 39)](https://leetcode.com/problems/combination-sum/) | Same copy-path pattern | Medium |
| [Letter Combinations (LC 17)](https://leetcode.com/problems/letter-combinations-of-a-phone-number/) | String building approach matters | Medium |
| [Flood Fill (LC 733)](https://leetcode.com/problems/flood-fill/) | Don't create new grid unnecessarily | Easy |
| [Set Matrix Zeroes (LC 73)](https://leetcode.com/problems/set-matrix-zeroes/) | In-place modification of 2D array | Medium |

---

> **ğŸ’¡ Key Insight:** The most time-wasting bugs in interviews aren't algorithmic â€” they're reference bugs. Before you submit, ask yourself: "Am I storing a reference or a copy?" This one question prevents the #1 backtracking bug and the #1 2D array bug.

---

**Next:** [2.2 OOP Basics for DSA](./2.2-OOP-Basics-For-DSA.md) â†’
