{
  "version": "1.0.0",
  "generatedAt": "2026-02-08T18:02:08.875Z",
  "topics": {
    "prerequisites": {
      "id": "prerequisites",
      "folderName": "00-Prerequisites",
      "chapters": [
        {
          "type": "section",
          "name": "01-Complexity-Analysis",
          "title": "Complexity Analysis",
          "path": "01-Complexity-Analysis",
          "children": [
            {
              "type": "chapter",
              "name": "1.0-Why-Complexity-Matters.md",
              "title": "1.0 Why Complexity Analysis Matters",
              "description": "> The most important skill that separates junior from senior developers.",
              "path": "01-Complexity-Analysis/1.0-Why-Complexity-Matters.md",
              "size": 8291,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "1.1-What-Is-Big-O.md",
              "title": "1.1 What Is Big O Notation?",
              "description": "> A simple way to describe how fast (or slow) an algorithm becomes as input grows.",
              "path": "01-Complexity-Analysis/1.1-What-Is-Big-O.md",
              "size": 12420,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "1.2-Common-Complexities.md",
              "title": "1.2 Common Complexities",
              "description": "> The 7 complexity classes you'll encounter 99% of the time.",
              "path": "01-Complexity-Analysis/1.2-Common-Complexities.md",
              "size": 17301,
              "estimatedReadTime": 14
            },
            {
              "type": "chapter",
              "name": "1.3-Analyzing-Loops.md",
              "title": "1.3 Analyzing Loops",
              "description": "> The systematic approach to finding time complexity of any loop structure.",
              "path": "01-Complexity-Analysis/1.3-Analyzing-Loops.md",
              "size": 12561,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "1.4-Analyzing-Recursion.md",
              "title": "1.4 Analyzing Recursion",
              "description": "> How to find the complexity of recursive algorithms using trees and formulas.",
              "path": "01-Complexity-Analysis/1.4-Analyzing-Recursion.md",
              "size": 14206,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "1.5-Space-Complexity.md",
              "title": "1.5 Space Complexity",
              "description": "> How to analyze and optimize memory usage in your algorithms.",
              "path": "01-Complexity-Analysis/1.5-Space-Complexity.md",
              "size": 13730,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "1.6-Complexity-Cheatsheet.md",
              "title": "1.6 Complexity Cheatsheet",
              "description": "> Your quick reference for all things Big O. Print this, bookmark it, review it.",
              "path": "01-Complexity-Analysis/1.6-Complexity-Cheatsheet.md",
              "size": 12383,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "1.7-Practice-Problems.md",
              "title": "1.7 Practice Problems",
              "description": "> Test your understanding with these complexity analysis exercises.",
              "path": "01-Complexity-Analysis/1.7-Practice-Problems.md",
              "size": 13305,
              "estimatedReadTime": 11
            }
          ]
        }
      ],
      "stats": {
        "sections": 1,
        "chapters": 8
      }
    },
    "arrays-strings": {
      "id": "arrays-strings",
      "folderName": "01-Arrays-Strings",
      "chapters": [
        {
          "type": "section",
          "name": "01-Arrays",
          "title": "Arrays",
          "path": "01-Arrays",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-Array-Basics.md",
              "title": "1.1 Array Basics",
              "description": "> Foundation for all array-based algorithms",
              "path": "01-Arrays/1.1-Array-Basics.md",
              "size": 13726,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "1.2-Basic-Operations.md",
              "title": "1.2 Basic Array Operations",
              "description": "> Foundation for understanding time complexity trade-offs",
              "path": "01-Arrays/1.2-Basic-Operations.md",
              "size": 12629,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "1.3-Array-Traversal.md",
              "title": "1.3 Array Traversal",
              "description": "> Master iteration patterns before tackling algorithms",
              "path": "01-Arrays/1.3-Array-Traversal.md",
              "size": 13091,
              "estimatedReadTime": 10
            },
            {
              "type": "section",
              "name": "1.4-Common-Techniques",
              "title": "4 Common Techniques",
              "path": "01-Arrays/1.4-Common-Techniques",
              "children": [
                {
                  "type": "chapter",
                  "name": "00-Technique-Overview.md",
                  "title": "Array Techniques Overview",
                  "description": "> Master reference for choosing the right technique",
                  "path": "01-Arrays/1.4-Common-Techniques/00-Technique-Overview.md",
                  "size": 12767,
                  "estimatedReadTime": 10
                },
                {
                  "type": "chapter",
                  "name": "01-Two-Pointers.md",
                  "title": "Two Pointers Technique",
                  "description": "> Grokking Pattern #2 | ROI: ⭐⭐⭐⭐⭐ (~25% of interview problems)",
                  "path": "01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md",
                  "size": 17305,
                  "estimatedReadTime": 14
                },
                {
                  "type": "chapter",
                  "name": "02-Sliding-Window.md",
                  "title": "Sliding Window Technique",
                  "description": "> Grokking Pattern #3 | ROI: ⭐⭐⭐⭐⭐ (~15% of interview problems)",
                  "path": "01-Arrays/1.4-Common-Techniques/02-Sliding-Window.md",
                  "size": 19625,
                  "estimatedReadTime": 15
                },
                {
                  "type": "chapter",
                  "name": "03-Prefix-Sum.md",
                  "title": "Prefix Sum Technique",
                  "description": "> Grokking Pattern #27 | ROI: ⭐⭐⭐⭐ (Common in range query problems)",
                  "path": "01-Arrays/1.4-Common-Techniques/03-Prefix-Sum.md",
                  "size": 17981,
                  "estimatedReadTime": 14
                },
                {
                  "type": "chapter",
                  "name": "04-Kadanes-Algorithm.md",
                  "title": "Kadane's Algorithm",
                  "description": "> Classic DP Pattern | ROI: ⭐⭐⭐⭐ (Frequently asked, easy to master)",
                  "path": "01-Arrays/1.4-Common-Techniques/04-Kadanes-Algorithm.md",
                  "size": 19090,
                  "estimatedReadTime": 14
                },
                {
                  "type": "chapter",
                  "name": "05-Hash-Map-Technique.md",
                  "title": "Hash Map Technique",
                  "description": "> Grokking Pattern #14 | ROI: ⭐⭐⭐⭐⭐ (Foundation for many patterns)",
                  "path": "01-Arrays/1.4-Common-Techniques/05-Hash-Map-Technique.md",
                  "size": 20577,
                  "estimatedReadTime": 16
                }
              ]
            },
            {
              "type": "chapter",
              "name": "1.5-Array-Problems-By-Pattern.md",
              "title": "1.5 - Array Problems by Pattern",
              "description": "> Reference: LeetCode problems organized by algorithmic pattern",
              "path": "01-Arrays/1.5-Array-Problems-By-Pattern.md",
              "size": 9242,
              "estimatedReadTime": 6
            },
            {
              "type": "chapter",
              "name": "1.6-2D-Arrays.md",
              "title": "1.6 - 2D Arrays (Matrices)",
              "description": "> Foundation: Multi-dimensional array operations essential for grid/matrix problems",
              "path": "01-Arrays/1.6-2D-Arrays.md",
              "size": 18033,
              "estimatedReadTime": 14
            }
          ]
        },
        {
          "type": "section",
          "name": "02-Strings",
          "title": "Strings",
          "path": "02-Strings",
          "children": [
            {
              "type": "chapter",
              "name": "2.1-String-Basics.md",
              "title": "2.1 String Basics",
              "description": "> Strings are character arrays with special properties",
              "path": "02-Strings/2.1-String-Basics.md",
              "size": 16053,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "2.2-String-Operations.md",
              "title": "2.2 - String Operations",
              "description": "> Foundation: Core string manipulation operations in Python and JavaScript",
              "path": "02-Strings/2.2-String-Operations.md",
              "size": 11910,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "2.3-String-Methods.md",
              "title": "2.3 - Common String Methods",
              "description": "> Reference: Built-in string methods for Python and JavaScript",
              "path": "02-Strings/2.3-String-Methods.md",
              "size": 13494,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "2.4-String-Techniques.md",
              "title": "2.4 String Techniques",
              "description": "> Apply array patterns to strings with character-specific optimizations",
              "path": "02-Strings/2.4-String-Techniques.md",
              "size": 17438,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "2.5-Pattern-Matching.md",
              "title": "2.5 String Pattern Matching",
              "description": "> Advanced algorithms for finding patterns in text",
              "path": "02-Strings/2.5-Pattern-Matching.md",
              "size": 17273,
              "estimatedReadTime": 14
            },
            {
              "type": "chapter",
              "name": "2.6-String-Problems.md",
              "title": "2.6 - String Problems by Category",
              "description": "> Reference: LeetCode string problems organized by difficulty and technique",
              "path": "02-Strings/2.6-String-Problems.md",
              "size": 10264,
              "estimatedReadTime": 7
            }
          ]
        },
        {
          "type": "section",
          "name": "03-Hashing",
          "title": "Hashing",
          "path": "03-Hashing",
          "children": [
            {
              "type": "chapter",
              "name": "3.1-Hash-Maps.md",
              "title": "3.1 Hash Maps (Hash Tables)",
              "description": "> The O(1) Lookup Superpower",
              "path": "03-Hashing/3.1-Hash-Maps.md",
              "size": 18461,
              "estimatedReadTime": 14
            }
          ]
        }
      ],
      "stats": {
        "sections": 4,
        "chapters": 18
      }
    },
    "recursion-backtracking": {
      "id": "recursion-backtracking",
      "folderName": "02-Recursion-Backtracking",
      "chapters": [
        {
          "type": "section",
          "name": "01-Recursion",
          "title": "Recursion",
          "path": "01-Recursion",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-Recursion-Basics.md",
              "title": "1.1 Recursion Basics",
              "description": "> Foundation: Understanding How Recursion Works",
              "path": "01-Recursion/1.1-Recursion-Basics.md",
              "size": 12126,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "1.2-Recursion-Patterns.md",
              "title": "1.2 Recursion Patterns",
              "description": "> Common Patterns in Recursive Problem Solving",
              "path": "01-Recursion/1.2-Recursion-Patterns.md",
              "size": 16278,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "1.3-Thinking-Process.md",
              "title": "1.3 Thinking Recursively",
              "description": "> Mental Model for Recursive Problem Solving",
              "path": "01-Recursion/1.3-Thinking-Process.md",
              "size": 12743,
              "estimatedReadTime": 10
            },
            {
              "type": "section",
              "name": "1.4-Basic-Problems",
              "title": "4 Basic Problems",
              "path": "01-Recursion/1.4-Basic-Problems",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Factorial-Fibonacci.md",
                  "title": "01 Factorial and Fibonacci",
                  "description": "> Classic Introductory Recursion Problems",
                  "path": "01-Recursion/1.4-Basic-Problems/01-Factorial-Fibonacci.md",
                  "size": 11780,
                  "estimatedReadTime": 9
                },
                {
                  "type": "chapter",
                  "name": "02-Power-Binary-Search.md",
                  "title": "02 Power and Binary Search",
                  "description": "> Efficient Recursion: Divide-and-Conquer Foundation",
                  "path": "01-Recursion/1.4-Basic-Problems/02-Power-Binary-Search.md",
                  "size": 12721,
                  "estimatedReadTime": 11
                }
              ]
            },
            {
              "type": "chapter",
              "name": "1.5-Recursion-On-Arrays.md",
              "title": "1.5 Recursion on Arrays",
              "description": "> Recursive Techniques for Array Processing",
              "path": "01-Recursion/1.5-Recursion-On-Arrays.md",
              "size": 13629,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "1.6-Recursion-On-Strings.md",
              "title": "1.6 Recursion on Strings",
              "description": "> Recursive Techniques for String Processing",
              "path": "01-Recursion/1.6-Recursion-On-Strings.md",
              "size": 15060,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "02-Backtracking",
          "title": "Backtracking",
          "path": "02-Backtracking",
          "children": [
            {
              "type": "chapter",
              "name": "2.1-Backtracking-Basics.md",
              "title": "2.1 Backtracking Basics",
              "description": "> Introduction to Backtracking: Exploring All Possibilities",
              "path": "02-Backtracking/2.1-Backtracking-Basics.md",
              "size": 12320,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "2.2-Backtracking-Template.md",
              "title": "2.2 The Backtracking Template",
              "description": "> The Universal Framework for Exploring All Possibilities",
              "path": "02-Backtracking/2.2-Backtracking-Template.md",
              "size": 17595,
              "estimatedReadTime": 12
            },
            {
              "type": "section",
              "name": "2.3-Core-Patterns",
              "title": "3 Core Patterns",
              "path": "02-Backtracking/2.3-Core-Patterns",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Subsets-Pattern.md",
                  "title": "01 Subsets Pattern",
                  "description": "> The Foundation of Backtracking: Include or Exclude",
                  "path": "02-Backtracking/2.3-Core-Patterns/01-Subsets-Pattern.md",
                  "size": 16288,
                  "estimatedReadTime": 12
                },
                {
                  "type": "chapter",
                  "name": "02-Permutations-Pattern.md",
                  "title": "02 Permutations Pattern",
                  "description": "> Generating All Possible Arrangements",
                  "path": "02-Backtracking/2.3-Core-Patterns/02-Permutations-Pattern.md",
                  "size": 16437,
                  "estimatedReadTime": 12
                },
                {
                  "type": "chapter",
                  "name": "03-Combinations-Pattern.md",
                  "title": "03 Combinations Pattern",
                  "description": "> Selecting k Elements from n - Order Doesn't Matter",
                  "path": "02-Backtracking/2.3-Core-Patterns/03-Combinations-Pattern.md",
                  "size": 16587,
                  "estimatedReadTime": 12
                },
                {
                  "type": "chapter",
                  "name": "04-String-Backtracking.md",
                  "title": "04 String Backtracking",
                  "description": "> Classic String Generation Problems Using Backtracking",
                  "path": "02-Backtracking/2.3-Core-Patterns/04-String-Backtracking.md",
                  "size": 19490,
                  "estimatedReadTime": 13
                }
              ]
            },
            {
              "type": "chapter",
              "name": "2.4-Grid-Backtracking.md",
              "title": "2.4 Grid Backtracking",
              "description": "> Backtracking on 2D Grids: Word Search, Path Finding, Islands",
              "path": "02-Backtracking/2.4-Grid-Backtracking.md",
              "size": 16577,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "2.5-Classic-Problems.md",
              "title": "2.5 Classic Backtracking Problems",
              "description": "> N-Queens, Sudoku, and Other Constraint Satisfaction Problems",
              "path": "02-Backtracking/2.5-Classic-Problems.md",
              "size": 16561,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "03-Divide-Conquer",
          "title": "Divide Conquer",
          "path": "03-Divide-Conquer",
          "children": [
            {
              "type": "chapter",
              "name": "3.1-DC-Basics.md",
              "title": "3.1 Divide and Conquer Basics",
              "description": "> Breaking Problems Into Subproblems",
              "path": "03-Divide-Conquer/3.1-DC-Basics.md",
              "size": 12042,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "3.2-Classic-DC-Problems.md",
              "title": "3.2 Classic Divide and Conquer Problems",
              "description": "> Applying D&C to Real Interview Problems",
              "path": "03-Divide-Conquer/3.2-Classic-DC-Problems.md",
              "size": 17673,
              "estimatedReadTime": 13
            }
          ]
        },
        {
          "type": "section",
          "name": "04-Optimization",
          "title": "Optimization",
          "path": "04-Optimization",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-Memoization.md",
              "title": "4.1 Memoization",
              "description": "> The Bridge from Recursion to Dynamic Programming",
              "path": "04-Optimization/4.1-Memoization.md",
              "size": 16625,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "4.2-Tail-Recursion.md",
              "title": "4.2 Tail Recursion",
              "description": "> Stack-Safe Recursion Through Tail Call Optimization",
              "path": "04-Optimization/4.2-Tail-Recursion.md",
              "size": 15336,
              "estimatedReadTime": 12
            }
          ]
        }
      ],
      "stats": {
        "sections": 6,
        "chapters": 19
      }
    },
    "sorting-searching": {
      "id": "sorting-searching",
      "folderName": "03-Sorting-Searching",
      "chapters": [
        {
          "type": "section",
          "name": "01-Sorting",
          "title": "Sorting",
          "path": "01-Sorting",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-Sorting-Basics.md",
              "title": "1.1 - Sorting Basics",
              "description": "> Foundation for All Sorting Algorithms",
              "path": "01-Sorting/1.1-Sorting-Basics.md",
              "size": 11856,
              "estimatedReadTime": 10
            },
            {
              "type": "section",
              "name": "1.2-Basic-Sorting",
              "title": "2 Basic Sorting",
              "path": "01-Sorting/1.2-Basic-Sorting",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Bubble-Selection-Insertion.md",
                  "title": "01 - Bubble, Selection, and Insertion Sort",
                  "description": "> The O(n²) Sorting Algorithms",
                  "path": "01-Sorting/1.2-Basic-Sorting/01-Bubble-Selection-Insertion.md",
                  "size": 12729,
                  "estimatedReadTime": 11
                }
              ]
            },
            {
              "type": "chapter",
              "name": "1.3-Merge-Sort.md",
              "title": "1.3 - Merge Sort",
              "description": "> Divide and Conquer Sorting",
              "path": "01-Sorting/1.3-Merge-Sort.md",
              "size": 15144,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "1.4-Quick-Sort.md",
              "title": "1.4 - Quick Sort",
              "description": "> The Fast In-Place Sort",
              "path": "01-Sorting/1.4-Quick-Sort.md",
              "size": 15982,
              "estimatedReadTime": 13
            },
            {
              "type": "chapter",
              "name": "1.5-Heap-Sort.md",
              "title": "1.5 - Heap Sort",
              "description": "> The Guaranteed O(n log n) In-Place Sort",
              "path": "01-Sorting/1.5-Heap-Sort.md",
              "size": 14669,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "1.6-Linear-Time-Sorting.md",
              "title": "1.6 - Linear Time Sorting",
              "description": "> Breaking the O(n log n) Barrier",
              "path": "01-Sorting/1.6-Linear-Time-Sorting.md",
              "size": 15474,
              "estimatedReadTime": 13
            },
            {
              "type": "chapter",
              "name": "1.7-Sorting-Problems.md",
              "title": "1.7 - Sorting Problems",
              "description": "> Classic Interview Problems Using Sorting",
              "path": "01-Sorting/1.7-Sorting-Problems.md",
              "size": 16765,
              "estimatedReadTime": 13
            }
          ]
        },
        {
          "type": "section",
          "name": "02-Searching",
          "title": "Searching",
          "path": "02-Searching",
          "children": [
            {
              "type": "chapter",
              "name": "2.1-Binary-Search-Basics.md",
              "title": "2.1 Binary Search Basics",
              "description": "> The Most Important Search Algorithm",
              "path": "02-Searching/2.1-Binary-Search-Basics.md",
              "size": 14917,
              "estimatedReadTime": 11
            },
            {
              "type": "section",
              "name": "2.2-Binary-Search-Patterns",
              "title": "2 Binary Search Patterns",
              "path": "02-Searching/2.2-Binary-Search-Patterns",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Exact-Match.md",
                  "title": "01 - Exact Match Binary Search",
                  "description": "> Finding an Exact Target Value",
                  "path": "02-Searching/2.2-Binary-Search-Patterns/01-Exact-Match.md",
                  "size": 11128,
                  "estimatedReadTime": 9
                },
                {
                  "type": "chapter",
                  "name": "02-Boundary-Search.md",
                  "title": "02 - Boundary Search (First/Last Occurrence)",
                  "description": "> Finding Lower and Upper Bounds",
                  "path": "02-Searching/2.2-Binary-Search-Patterns/02-Boundary-Search.md",
                  "size": 12818,
                  "estimatedReadTime": 11
                },
                {
                  "type": "chapter",
                  "name": "03-Rotated-Arrays.md",
                  "title": "03 - Rotated Sorted Arrays",
                  "description": "> Binary Search on Rotated Arrays",
                  "path": "02-Searching/2.2-Binary-Search-Patterns/03-Rotated-Arrays.md",
                  "size": 13605,
                  "estimatedReadTime": 11
                },
                {
                  "type": "chapter",
                  "name": "04-Search-On-Answer.md",
                  "title": "04 - Binary Search on Answer",
                  "description": "> Optimization Problems with Binary Search",
                  "path": "02-Searching/2.2-Binary-Search-Patterns/04-Search-On-Answer.md",
                  "size": 15855,
                  "estimatedReadTime": 13
                },
                {
                  "type": "chapter",
                  "name": "05-2D-Matrix-Search.md",
                  "title": "05 - 2D Matrix Search",
                  "description": "> Binary Search on 2D Matrices",
                  "path": "02-Searching/2.2-Binary-Search-Patterns/05-2D-Matrix-Search.md",
                  "size": 12034,
                  "estimatedReadTime": 10
                }
              ]
            },
            {
              "type": "chapter",
              "name": "2.3-Advanced-Binary-Search.md",
              "title": "2.3 - Advanced Binary Search",
              "description": "> Hard Binary Search Problems",
              "path": "02-Searching/2.3-Advanced-Binary-Search.md",
              "size": 14118,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "03-Cyclic-Sort",
          "title": "Cyclic Sort",
          "path": "03-Cyclic-Sort",
          "children": [
            {
              "type": "chapter",
              "name": "3.1-Cyclic-Sort-Pattern.md",
              "title": "3.1 - Cyclic Sort Pattern",
              "description": "> The Grokking Pattern for Missing/Duplicate Numbers",
              "path": "03-Cyclic-Sort/3.1-Cyclic-Sort-Pattern.md",
              "size": 13983,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "3.2-Missing-Duplicate-Problems.md",
              "title": "3.2 - Missing and Duplicate Number Problems",
              "description": "> Complete Guide to the Most Common Interview Problems",
              "path": "03-Cyclic-Sort/3.2-Missing-Duplicate-Problems.md",
              "size": 19079,
              "estimatedReadTime": 16
            }
          ]
        }
      ],
      "stats": {
        "sections": 5,
        "chapters": 16
      }
    },
    "linked-lists": {
      "id": "linked-lists",
      "folderName": "04-Linked-Lists",
      "chapters": [
        {
          "type": "section",
          "name": "01-Singly-LL",
          "title": "Singly LL",
          "path": "01-Singly-LL",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-Basics.md",
              "title": "1.1 Singly Linked List Basics",
              "description": "> Foundation: Core data structure for dynamic collections",
              "path": "01-Singly-LL/1.1-Basics.md",
              "size": 13052,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "1.2-Operations.md",
              "title": "1.2 Singly Linked List Operations",
              "description": "> Foundation: Core CRUD operations for linked lists",
              "path": "01-Singly-LL/1.2-Operations.md",
              "size": 19770,
              "estimatedReadTime": 14
            },
            {
              "type": "chapter",
              "name": "1.3-Basic-Problems.md",
              "title": "1.3 Basic Linked List Problems",
              "description": "> Foundation: Common interview problems using basic operations",
              "path": "01-Singly-LL/1.3-Basic-Problems.md",
              "size": 14034,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "02-Doubly-LL",
          "title": "Doubly LL",
          "path": "02-Doubly-LL",
          "children": [
            {
              "type": "chapter",
              "name": "2.1-Doubly-LL-Complete.md",
              "title": "2.1 Doubly Linked List - Complete Guide",
              "description": "> Grokking Pattern: Foundation for LRU Cache, Browser History, Deques",
              "path": "02-Doubly-LL/2.1-Doubly-LL-Complete.md",
              "size": 16590,
              "estimatedReadTime": 12
            }
          ]
        },
        {
          "type": "section",
          "name": "03-Circular-LL",
          "title": "Circular LL",
          "path": "03-Circular-LL",
          "children": [
            {
              "type": "chapter",
              "name": "3.1-Circular-LL-Complete.md",
              "title": "3.1 Circular Linked List - Complete Guide",
              "description": "> Variation: Last node points back to first, forming a cycle",
              "path": "03-Circular-LL/3.1-Circular-LL-Complete.md",
              "size": 16503,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "04-Fast-Slow-Pointer",
          "title": "Fast Slow Pointer",
          "path": "04-Fast-Slow-Pointer",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-Concept.md",
              "title": "4.1 Fast & Slow Pointer (Tortoise and Hare)",
              "description": "> Grokking Pattern #2 - Two pointers moving at different speeds to detect cycles and find positions",
              "path": "04-Fast-Slow-Pointer/4.1-Concept.md",
              "size": 14613,
              "estimatedReadTime": 12
            },
            {
              "type": "section",
              "name": "4.2-Cycle-Problems",
              "title": "2 Cycle Problems",
              "path": "04-Fast-Slow-Pointer/4.2-Cycle-Problems",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Cycle-Detection.md",
                  "title": "01 - Cycle Detection (LeetCode 141)",
                  "description": "> Pattern: Fast & Slow Pointer (Grokking #2)",
                  "path": "04-Fast-Slow-Pointer/4.2-Cycle-Problems/01-Cycle-Detection.md",
                  "size": 11699,
                  "estimatedReadTime": 10
                },
                {
                  "type": "chapter",
                  "name": "02-Find-Cycle-Start.md",
                  "title": "02 - Find Cycle Start (LeetCode 142)",
                  "description": "> Pattern: Fast & Slow Pointer + Floyd's Algorithm",
                  "path": "04-Fast-Slow-Pointer/4.2-Cycle-Problems/02-Find-Cycle-Start.md",
                  "size": 15638,
                  "estimatedReadTime": 13
                },
                {
                  "type": "chapter",
                  "name": "03-Happy-Number.md",
                  "title": "03 - Happy Number (LeetCode 202)",
                  "description": "> Pattern: Fast & Slow Pointer (Implicit Cycle Detection)",
                  "path": "04-Fast-Slow-Pointer/4.2-Cycle-Problems/03-Happy-Number.md",
                  "size": 13504,
                  "estimatedReadTime": 12
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "05-In-Place-Reversal",
          "title": "In Place Reversal",
          "path": "05-In-Place-Reversal",
          "children": [
            {
              "type": "chapter",
              "name": "5.1-Reversal-Technique.md",
              "title": "5.1 In-Place Reversal Technique",
              "description": "> Grokking Pattern #6 - Reverse a linked list or portion without extra space",
              "path": "05-In-Place-Reversal/5.1-Reversal-Technique.md",
              "size": 15613,
              "estimatedReadTime": 12
            },
            {
              "type": "section",
              "name": "5.2-Reversal-Problems",
              "title": "2 Reversal Problems",
              "path": "05-In-Place-Reversal/5.2-Reversal-Problems",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Reverse-Entire-List.md",
                  "title": "01 - Reverse Entire Linked List (LeetCode 206)",
                  "description": "> Pattern: In-Place Reversal (Grokking #6)",
                  "path": "05-In-Place-Reversal/5.2-Reversal-Problems/01-Reverse-Entire-List.md",
                  "size": 12819,
                  "estimatedReadTime": 10
                },
                {
                  "type": "chapter",
                  "name": "02-Reverse-Between.md",
                  "title": "02 - Reverse Linked List II (LeetCode 92)",
                  "description": "> Pattern: In-Place Reversal (Sub-list)",
                  "path": "05-In-Place-Reversal/5.2-Reversal-Problems/02-Reverse-Between.md",
                  "size": 13593,
                  "estimatedReadTime": 11
                },
                {
                  "type": "chapter",
                  "name": "03-Reverse-K-Group.md",
                  "title": "03 - Reverse Nodes in k-Group (LeetCode 25)",
                  "description": "> Pattern: In-Place Reversal (Group Reversal)",
                  "path": "05-In-Place-Reversal/5.2-Reversal-Problems/03-Reverse-K-Group.md",
                  "size": 15532,
                  "estimatedReadTime": 12
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "06-Merge-Problems",
          "title": "Merge Problems",
          "path": "06-Merge-Problems",
          "children": [
            {
              "type": "chapter",
              "name": "6.1-Merge-Two-Sorted.md",
              "title": "6.1 Merge Two Sorted Lists (LC 21)",
              "description": "> Grokking Pattern: Two Pointers on Linked Lists",
              "path": "06-Merge-Problems/6.1-Merge-Two-Sorted.md",
              "size": 10748,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "6.2-Merge-K-Sorted.md",
              "title": "6.2 Merge K Sorted Lists (LC 23)",
              "description": "> Grokking Pattern: K-way Merge using Heap",
              "path": "06-Merge-Problems/6.2-Merge-K-Sorted.md",
              "size": 12668,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "07-Two-Pointer-Problems",
          "title": "Two Pointer Problems",
          "path": "07-Two-Pointer-Problems",
          "children": [
            {
              "type": "chapter",
              "name": "7.1-Find-Middle.md",
              "title": "7.1 Find Middle of Linked List (LC 876)",
              "description": "> Grokking Pattern: Fast & Slow Pointers",
              "path": "07-Two-Pointer-Problems/7.1-Find-Middle.md",
              "size": 8535,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "7.2-Nth-From-End.md",
              "title": "7.2 Remove Nth Node From End of List (LC 19)",
              "description": "> Grokking Pattern: Two Pointers with Fixed Gap",
              "path": "07-Two-Pointer-Problems/7.2-Nth-From-End.md",
              "size": 9295,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "7.3-Intersection.md",
              "title": "7.3 Intersection of Two Linked Lists (LC 160)",
              "description": "> Grokking Pattern: Two Pointers with Length Equalization",
              "path": "07-Two-Pointer-Problems/7.3-Intersection.md",
              "size": 10488,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "7.4-Palindrome-Check.md",
              "title": "7.4 Palindrome Linked List (LC 234)",
              "description": "> Grokking Pattern: Fast & Slow + In-Place Reversal",
              "path": "07-Two-Pointer-Problems/7.4-Palindrome-Check.md",
              "size": 10466,
              "estimatedReadTime": 8
            }
          ]
        },
        {
          "type": "section",
          "name": "08-Advanced-Problems",
          "title": "Advanced Problems",
          "path": "08-Advanced-Problems",
          "children": [
            {
              "type": "chapter",
              "name": "8.1-LRU-Cache.md",
              "title": "8.1 LRU Cache (LC 146)",
              "description": "> Grokking Pattern: Hash Map + Doubly Linked List",
              "path": "08-Advanced-Problems/8.1-LRU-Cache.md",
              "size": 14510,
              "estimatedReadTime": 10
            }
          ]
        }
      ],
      "stats": {
        "sections": 10,
        "chapters": 20
      }
    },
    "stacks-queues": {
      "id": "stacks-queues",
      "folderName": "05-Stacks-Queues",
      "chapters": [
        {
          "type": "section",
          "name": "01-Stack-Fundamentals",
          "title": "Stack Fundamentals",
          "path": "01-Stack-Fundamentals",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-Stack-Basics.md",
              "title": "1.1 Stack Basics",
              "description": "> Grokking Pattern: #7 Stacks",
              "path": "01-Stack-Fundamentals/1.1-Stack-Basics.md",
              "size": 9960,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "1.2-Stack-Operations.md",
              "title": "1.2 Stack Operations",
              "description": "> Foundation Reference | All O(1) Operations Detailed",
              "path": "01-Stack-Fundamentals/1.2-Stack-Operations.md",
              "size": 9404,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "1.3-Stack-Implementation.md",
              "title": "1.3 Stack Implementation",
              "description": "> Foundation Reference | Low-Level Implementation Details",
              "path": "01-Stack-Fundamentals/1.3-Stack-Implementation.md",
              "size": 11827,
              "estimatedReadTime": 8
            }
          ]
        },
        {
          "type": "section",
          "name": "02-Basic-Stack-Problems",
          "title": "Basic Stack Problems",
          "path": "02-Basic-Stack-Problems",
          "children": [
            {
              "type": "chapter",
              "name": "2.1-Valid-Parentheses.md",
              "title": "2.1 Valid Parentheses (LC 20)",
              "description": "> Grokking Pattern: #7 Stacks - Matching Pairs",
              "path": "02-Basic-Stack-Problems/2.1-Valid-Parentheses.md",
              "size": 12021,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "2.2-Reverse-Operations.md",
              "title": "2.2 Stack Reverse Operations",
              "description": "> Grokking Pattern: #7 Stacks - Classic Applications",
              "path": "02-Basic-Stack-Problems/2.2-Reverse-Operations.md",
              "size": 10697,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "2.3-Expression-Evaluation.md",
              "title": "2.3 Expression Evaluation (LC 150)",
              "description": "> Grokking Pattern: #7 Stacks - Expression Parsing",
              "path": "02-Basic-Stack-Problems/2.3-Expression-Evaluation.md",
              "size": 12974,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "03-Monotonic-Stack",
          "title": "Monotonic Stack",
          "path": "03-Monotonic-Stack",
          "children": [
            {
              "type": "chapter",
              "name": "3.1-Monotonic-Stack-Concept.md",
              "title": "3.1 Monotonic Stack - Pattern Overview",
              "description": "> Grokking Pattern: #8 Monotonic Stack",
              "path": "03-Monotonic-Stack/3.1-Monotonic-Stack-Concept.md",
              "size": 18015,
              "estimatedReadTime": 13
            },
            {
              "type": "section",
              "name": "3.2-Next-Greater-Problems",
              "title": "2 Next Greater Problems",
              "path": "03-Monotonic-Stack/3.2-Next-Greater-Problems",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Next-Greater-Element-I.md",
                  "title": "01 - Next Greater Element I (LC 496)",
                  "description": "> Grokking Pattern: Monotonic Stack",
                  "path": "03-Monotonic-Stack/3.2-Next-Greater-Problems/01-Next-Greater-Element-I.md",
                  "size": 11995,
                  "estimatedReadTime": 10
                },
                {
                  "type": "chapter",
                  "name": "02-Next-Greater-Element-II.md",
                  "title": "02 - Next Greater Element II (LC 503)",
                  "description": "> Grokking Pattern: Monotonic Stack (Circular Array)",
                  "path": "03-Monotonic-Stack/3.2-Next-Greater-Problems/02-Next-Greater-Element-II.md",
                  "size": 11731,
                  "estimatedReadTime": 9
                },
                {
                  "type": "chapter",
                  "name": "03-Daily-Temperatures.md",
                  "title": "03 - Daily Temperatures (LC 739)",
                  "description": "> Grokking Pattern: Monotonic Stack",
                  "path": "03-Monotonic-Stack/3.2-Next-Greater-Problems/03-Daily-Temperatures.md",
                  "size": 12307,
                  "estimatedReadTime": 10
                },
                {
                  "type": "chapter",
                  "name": "04-Stock-Span.md",
                  "title": "04 - Online Stock Span (LC 901)",
                  "description": "> Grokking Pattern: Monotonic Stack (Previous Greater)",
                  "path": "03-Monotonic-Stack/3.2-Next-Greater-Problems/04-Stock-Span.md",
                  "size": 12875,
                  "estimatedReadTime": 10
                }
              ]
            },
            {
              "type": "section",
              "name": "3.3-Histogram-Problems",
              "title": "3 Histogram Problems",
              "path": "03-Monotonic-Stack/3.3-Histogram-Problems",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Largest-Rectangle.md",
                  "title": "01 - Largest Rectangle in Histogram (LC 84)",
                  "description": "> Grokking Pattern: Monotonic Stack (Advanced)",
                  "path": "03-Monotonic-Stack/3.3-Histogram-Problems/01-Largest-Rectangle.md",
                  "size": 13645,
                  "estimatedReadTime": 11
                },
                {
                  "type": "chapter",
                  "name": "02-Trapping-Rain-Water.md",
                  "title": "02 - Trapping Rain Water (LC 42)",
                  "description": "> Grokking Pattern: Monotonic Stack / Two Pointers / Dynamic Programming",
                  "path": "03-Monotonic-Stack/3.3-Histogram-Problems/02-Trapping-Rain-Water.md",
                  "size": 14017,
                  "estimatedReadTime": 11
                }
              ]
            },
            {
              "type": "chapter",
              "name": "3.4-Remove-K-Digits.md",
              "title": "3.4 Remove K Digits (LC 402)",
              "description": "> Grokking Pattern: Monotonic Stack + Greedy",
              "path": "03-Monotonic-Stack/3.4-Remove-K-Digits.md",
              "size": 11896,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "04-Design-Problems",
          "title": "Design Problems",
          "path": "04-Design-Problems",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-Min-Stack.md",
              "title": "4.1 Min Stack (LC 155)",
              "description": "> Grokking Pattern: #7 Stacks - Design",
              "path": "04-Design-Problems/4.1-Min-Stack.md",
              "size": 13277,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "4.2-Queue-Using-Stacks.md",
              "title": "4.2 Queue Using Stacks (LC 232)",
              "description": "> Grokking Pattern: #7 Stacks - Design",
              "path": "04-Design-Problems/4.2-Queue-Using-Stacks.md",
              "size": 12712,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "4.3-Stack-Using-Queues.md",
              "title": "4.3 Stack Using Queues (LC 225)",
              "description": "> Grokking Pattern: #7 Stacks - Design",
              "path": "04-Design-Problems/4.3-Stack-Using-Queues.md",
              "size": 13409,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "05-Queue-Fundamentals",
          "title": "Queue Fundamentals",
          "path": "05-Queue-Fundamentals",
          "children": [
            {
              "type": "chapter",
              "name": "5.1-Queue-Basics.md",
              "title": "5.1 Queue Basics",
              "description": "> Grokking Pattern: Related to BFS (#5, #6)",
              "path": "05-Queue-Fundamentals/5.1-Queue-Basics.md",
              "size": 10744,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "5.2-Circular-Queue.md",
              "title": "5.2 Circular Queue (LC 622)",
              "description": "> Grokking Pattern: Queue Design",
              "path": "05-Queue-Fundamentals/5.2-Circular-Queue.md",
              "size": 11980,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "5.3-Deque.md",
              "title": "5.3 Deque (Double-Ended Queue)",
              "description": "> Foundation Concept | Essential for Sliding Window & Monotonic Problems",
              "path": "05-Queue-Fundamentals/5.3-Deque.md",
              "size": 13090,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "06-Monotonic-Deque",
          "title": "Monotonic Deque",
          "path": "06-Monotonic-Deque",
          "children": [
            {
              "type": "chapter",
              "name": "6.1-Monotonic-Deque-Concept.md",
              "title": "6.1 Monotonic Deque Concept",
              "description": "> Grokking Pattern: #32 Monotonic Queue",
              "path": "06-Monotonic-Deque/6.1-Monotonic-Deque-Concept.md",
              "size": 13414,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "6.2-Sliding-Window-Maximum.md",
              "title": "6.2 Sliding Window Maximum (LC 239)",
              "description": "> Grokking Pattern: #32 Monotonic Queue",
              "path": "06-Monotonic-Deque/6.2-Sliding-Window-Maximum.md",
              "size": 13673,
              "estimatedReadTime": 11
            }
          ]
        }
      ],
      "stats": {
        "sections": 8,
        "chapters": 22
      }
    },
    "trees": {
      "id": "trees",
      "folderName": "06-Trees",
      "chapters": [
        {
          "type": "section",
          "name": "01-Tree-Fundamentals",
          "title": "Tree Fundamentals",
          "path": "01-Tree-Fundamentals",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-Tree-Terminology.md",
              "title": "1.1 - Tree Terminology",
              "description": "> Foundation: Essential vocabulary for understanding trees",
              "path": "01-Tree-Fundamentals/1.1-Tree-Terminology.md",
              "size": 9976,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "1.2-TreeNode-Class.md",
              "title": "1.2 - TreeNode Class",
              "description": "> Foundation: The building block for all tree problems",
              "path": "01-Tree-Fundamentals/1.2-TreeNode-Class.md",
              "size": 11619,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "1.3-Traversal-Overview.md",
              "title": "1.3 - Tree Traversal Overview",
              "description": "> Foundation: Understanding all traversal methods before diving into specifics",
              "path": "01-Tree-Fundamentals/1.3-Traversal-Overview.md",
              "size": 11049,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "1.4-Recursion-Trees.md",
              "title": "1.4 - Recursion on Trees",
              "description": "> Foundation: Understanding why recursion is the natural fit for trees",
              "path": "01-Tree-Fundamentals/1.4-Recursion-Trees.md",
              "size": 11738,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "1.5-Common-Patterns.md",
              "title": "1.5 - Common Tree Patterns",
              "description": "> Foundation: Recognizing patterns that appear across tree problems",
              "path": "01-Tree-Fundamentals/1.5-Common-Patterns.md",
              "size": 9010,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "1.6-Complexity-Analysis.md",
              "title": "1.6 - Complexity Analysis for Trees",
              "description": "> Foundation: Understanding time and space complexity for tree operations",
              "path": "01-Tree-Fundamentals/1.6-Complexity-Analysis.md",
              "size": 10170,
              "estimatedReadTime": 8
            }
          ]
        },
        {
          "type": "section",
          "name": "03-Tree-Traversals",
          "title": "Tree Traversals",
          "path": "03-Tree-Traversals",
          "children": [
            {
              "type": "section",
              "name": "3.1-DFS-Traversals",
              "title": "1 DFS Traversals",
              "path": "03-Tree-Traversals/3.1-DFS-Traversals",
              "children": [
                {
                  "type": "chapter",
                  "name": "00-DFS-Concept.md",
                  "title": "Tree DFS - Pattern Overview",
                  "description": "> Grokking Pattern: #11 Tree DFS",
                  "path": "03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md",
                  "size": 12725,
                  "estimatedReadTime": 9
                },
                {
                  "type": "chapter",
                  "name": "01-Inorder-Traversal.md",
                  "title": "01 - Inorder Traversal (LC 94)",
                  "description": "> Grokking Pattern: #11 Tree DFS",
                  "path": "03-Tree-Traversals/3.1-DFS-Traversals/01-Inorder-Traversal.md",
                  "size": 10279,
                  "estimatedReadTime": 7
                },
                {
                  "type": "chapter",
                  "name": "02-Preorder-Traversal.md",
                  "title": "02 - Preorder Traversal (LC 144)",
                  "description": "> Grokking Pattern: #11 Tree DFS",
                  "path": "03-Tree-Traversals/3.1-DFS-Traversals/02-Preorder-Traversal.md",
                  "size": 9137,
                  "estimatedReadTime": 6
                },
                {
                  "type": "chapter",
                  "name": "03-Postorder-Traversal.md",
                  "title": "03 - Postorder Traversal (LC 145)",
                  "description": "> Grokking Pattern: #11 Tree DFS",
                  "path": "03-Tree-Traversals/3.1-DFS-Traversals/03-Postorder-Traversal.md",
                  "size": 10874,
                  "estimatedReadTime": 8
                }
              ]
            },
            {
              "type": "section",
              "name": "3.2-BFS-Traversals",
              "title": "2 BFS Traversals",
              "path": "03-Tree-Traversals/3.2-BFS-Traversals",
              "children": [
                {
                  "type": "chapter",
                  "name": "00-BFS-Concept.md",
                  "title": "BFS Concept - Tree Level Order Traversal",
                  "description": "> Grokking Pattern: #10 Tree BFS",
                  "path": "03-Tree-Traversals/3.2-BFS-Traversals/00-BFS-Concept.md",
                  "size": 10202,
                  "estimatedReadTime": 7
                },
                {
                  "type": "chapter",
                  "name": "01-Level-Order.md",
                  "title": "01 - Level Order Traversal (LC 102)",
                  "description": "> Grokking Pattern: #10 Tree BFS",
                  "path": "03-Tree-Traversals/3.2-BFS-Traversals/01-Level-Order.md",
                  "size": 10189,
                  "estimatedReadTime": 7
                },
                {
                  "type": "chapter",
                  "name": "02-Zigzag-Level-Order.md",
                  "title": "02 - Zigzag Level Order Traversal (LC 103)",
                  "description": "> Grokking Pattern: #10 Tree BFS (Direction Alternation)",
                  "path": "03-Tree-Traversals/3.2-BFS-Traversals/02-Zigzag-Level-Order.md",
                  "size": 11062,
                  "estimatedReadTime": 8
                },
                {
                  "type": "chapter",
                  "name": "03-Level-Averages.md",
                  "title": "03 - Average of Levels in Binary Tree (LC 637)",
                  "description": "> Grokking Pattern: #10 Tree BFS (Level Aggregation)",
                  "path": "03-Tree-Traversals/3.2-BFS-Traversals/03-Level-Averages.md",
                  "size": 9369,
                  "estimatedReadTime": 7
                },
                {
                  "type": "chapter",
                  "name": "04-Right-Side-View.md",
                  "title": "04 - Binary Tree Right Side View (LC 199)",
                  "description": "> Grokking Pattern: #10 Tree BFS (Level Extremes)",
                  "path": "03-Tree-Traversals/3.2-BFS-Traversals/04-Right-Side-View.md",
                  "size": 10339,
                  "estimatedReadTime": 8
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "04-Tree-Properties",
          "title": "Tree Properties",
          "path": "04-Tree-Properties",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-Maximum-Depth.md",
              "title": "4.1 - Maximum Depth of Binary Tree (LC 104)",
              "description": "> Grokking Pattern: #11 Tree DFS (Postorder Application)",
              "path": "04-Tree-Properties/4.1-Maximum-Depth.md",
              "size": 9226,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "4.2-Minimum-Depth.md",
              "title": "4.2 - Minimum Depth of Binary Tree (LC 111)",
              "description": "> Grokking Pattern: #11 Tree DFS | #10 Tree BFS",
              "path": "04-Tree-Properties/4.2-Minimum-Depth.md",
              "size": 9984,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "4.3-Diameter-of-Tree.md",
              "title": "4.3 - Diameter of Binary Tree (LC 543)",
              "description": "> Grokking Pattern: #11 Tree DFS (Global Variable Pattern)",
              "path": "04-Tree-Properties/4.3-Diameter-of-Tree.md",
              "size": 10463,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "4.4-Balanced-Tree.md",
              "title": "4.4 - Balanced Binary Tree (LC 110)",
              "description": "> Grokking Pattern: #11 Tree DFS (Postorder + Early Termination)",
              "path": "04-Tree-Properties/4.4-Balanced-Tree.md",
              "size": 10738,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "4.5-Same-Tree.md",
              "title": "4.5 - Same Tree (LC 100)",
              "description": "> Grokking Pattern: #11 Tree DFS (Comparison Pattern)",
              "path": "04-Tree-Properties/4.5-Same-Tree.md",
              "size": 9762,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "4.6-Symmetric-Tree.md",
              "title": "4.6 - Symmetric Tree (LC 101)",
              "description": "> Grokking Pattern: #11 Tree DFS (Mirror Comparison)",
              "path": "04-Tree-Properties/4.6-Symmetric-Tree.md",
              "size": 10436,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "4.7-Invert-Binary-Tree.md",
              "title": "4.7 - Invert Binary Tree (LC 226)",
              "description": "> Grokking Pattern: #11 Tree DFS (Tree Modification)",
              "path": "04-Tree-Properties/4.7-Invert-Binary-Tree.md",
              "size": 10081,
              "estimatedReadTime": 7
            }
          ]
        },
        {
          "type": "section",
          "name": "05-Path-Problems",
          "title": "Path Problems",
          "path": "05-Path-Problems",
          "children": [
            {
              "type": "chapter",
              "name": "5.1-Path-Sum.md",
              "title": "5.1 - Path Sum (LC 112)",
              "description": "> Grokking Pattern: #11 Tree DFS (Path Tracking)",
              "path": "05-Path-Problems/5.1-Path-Sum.md",
              "size": 9357,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "5.2-Path-Sum-II.md",
              "title": "5.2 - Path Sum II (LC 113)",
              "description": "> Grokking Pattern: #11 Tree DFS (Path Collection)",
              "path": "05-Path-Problems/5.2-Path-Sum-II.md",
              "size": 10728,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "5.3-Maximum-Path-Sum.md",
              "title": "5.3 - Binary Tree Maximum Path Sum (LC 124)",
              "description": "> Grokking Pattern: #11 Tree DFS (Global Variable Pattern - Advanced)",
              "path": "05-Path-Problems/5.3-Maximum-Path-Sum.md",
              "size": 11457,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "5.4-Sum-Root-to-Leaf.md",
              "title": "5.4 - Sum Root to Leaf Numbers (LC 129)",
              "description": "> Grokking Pattern: #11 Tree DFS (Path as Number Pattern)",
              "path": "05-Path-Problems/5.4-Sum-Root-to-Leaf.md",
              "size": 10092,
              "estimatedReadTime": 8
            }
          ]
        },
        {
          "type": "section",
          "name": "06-View-Problems",
          "title": "View Problems",
          "path": "06-View-Problems",
          "children": [
            {
              "type": "chapter",
              "name": "6.1-Vertical-Order.md",
              "title": "6.1 - Vertical Order Traversal (LC 987)",
              "description": "> Grokking Pattern: #10 Tree BFS + Sorting",
              "path": "06-View-Problems/6.1-Vertical-Order.md",
              "size": 12125,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "07-Ancestor-Problems",
          "title": "Ancestor Problems",
          "path": "07-Ancestor-Problems",
          "children": [
            {
              "type": "chapter",
              "name": "7.1-LCA-Binary-Tree.md",
              "title": "7.1 - Lowest Common Ancestor of Binary Tree (LC 236)",
              "description": "> Grokking Pattern: #11 Tree DFS (LCA Pattern)",
              "path": "07-Ancestor-Problems/7.1-LCA-Binary-Tree.md",
              "size": 12635,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "7.2-Deepest-Leaves-LCA.md",
              "title": "7.2 - Lowest Common Ancestor of Deepest Leaves (LC 1123)",
              "description": "> Grokking Pattern: #11 Tree DFS (LCA + Depth Pattern)",
              "path": "07-Ancestor-Problems/7.2-Deepest-Leaves-LCA.md",
              "size": 11564,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "08-Construction-Problems",
          "title": "Construction Problems",
          "path": "08-Construction-Problems",
          "children": [
            {
              "type": "chapter",
              "name": "8.1-Construct-Preorder-Inorder.md",
              "title": "8.1 - Construct Binary Tree from Preorder and Inorder Traversal (LC 105)",
              "description": "> Grokking Pattern: #11 Tree DFS (Construction Pattern)",
              "path": "08-Construction-Problems/8.1-Construct-Preorder-Inorder.md",
              "size": 12132,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "8.2-Construct-Inorder-Postorder.md",
              "title": "8.2 - Construct Binary Tree from Inorder and Postorder Traversal (LC 106)",
              "description": "> Grokking Pattern: #11 Tree DFS (Construction Pattern)",
              "path": "08-Construction-Problems/8.2-Construct-Inorder-Postorder.md",
              "size": 12214,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "8.3-Serialize-Deserialize.md",
              "title": "8.3 - Serialize and Deserialize Binary Tree (LC 297)",
              "description": "> Grokking Pattern: #11 Tree DFS + #10 Tree BFS (Serialization Pattern)",
              "path": "08-Construction-Problems/8.3-Serialize-Deserialize.md",
              "size": 15335,
              "estimatedReadTime": 10
            }
          ]
        }
      ],
      "stats": {
        "sections": 9,
        "chapters": 32
      }
    },
    "binary-search-trees": {
      "id": "binary-search-trees",
      "folderName": "07-Binary-Search-Trees",
      "chapters": [
        {
          "type": "section",
          "name": "01-BST-Fundamentals",
          "title": "BST Fundamentals",
          "path": "01-BST-Fundamentals",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-BST-Definition.md",
              "title": "1.1 Binary Search Tree Definition",
              "description": "A Binary Search Tree (BST) is a binary tree data structure where each node follows the BST Property: for every node, all values in its left subtree...",
              "path": "01-BST-Fundamentals/1.1-BST-Definition.md",
              "size": 12031,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "1.2-BST-Properties.md",
              "title": "1.2 BST Properties",
              "description": "Beyond the fundamental ordering property, BSTs have several important characteristics that directly influence algorithm design and interview problems.",
              "path": "01-BST-Fundamentals/1.2-BST-Properties.md",
              "size": 13354,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "1.3-BST-MinMax-Successor.md",
              "title": "1.3 BST Min/Max and Successor/Predecessor",
              "description": "Understanding how to navigate to minimum, maximum, successor, and predecessor in a BST is fundamental. These operations form the building blocks fo...",
              "path": "01-BST-Fundamentals/1.3-BST-MinMax-Successor.md",
              "size": 16496,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "1.4-BST-vs-Trees.md",
              "title": "1.4 BST vs Binary Tree Comparison",
              "description": "Understanding when to use BST-specific algorithms versus general tree algorithms is critical for interview success. This file clarifies the key dif...",
              "path": "01-BST-Fundamentals/1.4-BST-vs-Trees.md",
              "size": 12742,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "02-BST-Operations",
          "title": "BST Operations",
          "path": "02-BST-Operations",
          "children": [
            {
              "type": "chapter",
              "name": "2.1-BST-Search-LC700.md",
              "title": "2.1 Search in BST (LC 700)",
              "description": "[LeetCode 700 - Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/)",
              "path": "02-BST-Operations/2.1-BST-Search-LC700.md",
              "size": 10680,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "2.2-BST-Insert-LC701.md",
              "title": "2.2 Insert into BST (LC 701)",
              "description": "[LeetCode 701 - Insert into a Binary Search Tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/)",
              "path": "02-BST-Operations/2.2-BST-Insert-LC701.md",
              "size": 12227,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "2.3-BST-Delete-LC450.md",
              "title": "2.3 Delete Node in BST (LC 450)",
              "description": "[LeetCode 450 - Delete Node in a BST](https://leetcode.com/problems/delete-node-in-a-bst/)",
              "path": "02-BST-Operations/2.3-BST-Delete-LC450.md",
              "size": 14218,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "2.4-Inorder-Successor-LC285.md",
              "title": "2.4 Inorder Successor in BST (LC 285)",
              "description": "[LeetCode 285 - Inorder Successor in BST](https://leetcode.com/problems/inorder-successor-in-bst/) (Premium)",
              "path": "02-BST-Operations/2.4-Inorder-Successor-LC285.md",
              "size": 12526,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "03-BST-Validation",
          "title": "BST Validation",
          "path": "03-BST-Validation",
          "children": [
            {
              "type": "chapter",
              "name": "3.1-Validate-BST-LC98.md",
              "title": "3.1 Validate Binary Search Tree (LC 98)",
              "description": "[LeetCode 98 - Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)",
              "path": "03-BST-Validation/3.1-Validate-BST-LC98.md",
              "size": 12026,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "3.2-Recover-BST-LC99.md",
              "title": "3.2 Recover Binary Search Tree (LC 99)",
              "description": "[LeetCode 99 - Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)",
              "path": "03-BST-Validation/3.2-Recover-BST-LC99.md",
              "size": 13094,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "3.3-Trim-BST-LC669.md",
              "title": "3.3 Trim a Binary Search Tree (LC 669)",
              "description": "[LeetCode 669 - Trim a Binary Search Tree](https://leetcode.com/problems/trim-a-binary-search-tree/)",
              "path": "03-BST-Validation/3.3-Trim-BST-LC669.md",
              "size": 11378,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "04-Inorder-Property",
          "title": "Inorder Property",
          "path": "04-Inorder-Property",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-Kth-Smallest-LC230.md",
              "title": "4.1 Kth Smallest Element in BST (LC 230)",
              "description": "[LeetCode 230 - Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)",
              "path": "04-Inorder-Property/4.1-Kth-Smallest-LC230.md",
              "size": 11533,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "4.2-BST-Iterator-LC173.md",
              "title": "4.2 Binary Search Tree Iterator (LC 173)",
              "description": "[LeetCode 173 - Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)",
              "path": "04-Inorder-Property/4.2-BST-Iterator-LC173.md",
              "size": 11596,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "4.3-Greater-Sum-Tree-LC538.md",
              "title": "4.3 Convert BST to Greater Sum Tree (LC 538 / LC 1038)",
              "description": "[LeetCode 538 - Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree/)",
              "path": "04-Inorder-Property/4.3-Greater-Sum-Tree-LC538.md",
              "size": 12142,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "4.4-Two-Sum-BST-LC653.md",
              "title": "4.4 Two Sum IV - Input is a BST (LC 653)",
              "description": "[LeetCode 653 - Two Sum IV - Input is a BST](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/)",
              "path": "04-Inorder-Property/4.4-Two-Sum-BST-LC653.md",
              "size": 13224,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "05-BST-Range-Problems",
          "title": "BST Range Problems",
          "path": "05-BST-Range-Problems",
          "children": [
            {
              "type": "chapter",
              "name": "5.1-Range-Sum-Overview.md",
              "title": "5.1 Range Problems Overview",
              "description": "Range problems on BSTs leverage the ordered property to efficiently process nodes within a value range [low, high]. The BST structure allows us to ...",
              "path": "05-BST-Range-Problems/5.1-Range-Sum-Overview.md",
              "size": 7967,
              "estimatedReadTime": 6
            },
            {
              "type": "chapter",
              "name": "5.2-Range-Sum-BST-LC938.md",
              "title": "5.2 Range Sum of BST (LC 938)",
              "description": "[LeetCode 938 - Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/)",
              "path": "05-BST-Range-Problems/5.2-Range-Sum-BST-LC938.md",
              "size": 12285,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "06-BST-Construction",
          "title": "BST Construction",
          "path": "06-BST-Construction",
          "children": [
            {
              "type": "chapter",
              "name": "6.1-Sorted-Array-to-BST-LC108.md",
              "title": "6.1 Convert Sorted Array to BST (LC 108)",
              "description": "[LeetCode 108 - Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)",
              "path": "06-BST-Construction/6.1-Sorted-Array-to-BST-LC108.md",
              "size": 11301,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "6.2-Preorder-to-BST-LC1008.md",
              "title": "6.2 Construct BST from Preorder Traversal (LC 1008)",
              "description": "[LeetCode 1008 - Construct Binary Search Tree from Preorder Traversal](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-tra...",
              "path": "06-BST-Construction/6.2-Preorder-to-BST-LC1008.md",
              "size": 12841,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "07-LCA-in-BST",
          "title": "LCA in BST",
          "path": "07-LCA-in-BST",
          "children": [
            {
              "type": "chapter",
              "name": "7.1-LCA-BST-LC235.md",
              "title": "7.1 Lowest Common Ancestor of BST (LC 235)",
              "description": "[LeetCode 235 - Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)",
              "path": "07-LCA-in-BST/7.1-LCA-BST-LC235.md",
              "size": 11865,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "08-Advanced-BST",
          "title": "Advanced BST",
          "path": "08-Advanced-BST",
          "children": [
            {
              "type": "chapter",
              "name": "8.1-Unique-BSTs-LC96.md",
              "title": "8.1 Unique Binary Search Trees (LC 96)",
              "description": "[LeetCode 96 - Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)",
              "path": "08-Advanced-BST/8.1-Unique-BSTs-LC96.md",
              "size": 10741,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "8.2-Self-Balancing-Overview.md",
              "title": "8.2 Self-Balancing BST Overview",
              "description": "Standard BSTs can become unbalanced (skewed), degrading O(log n) operations to O(n). Self-balancing BSTs automatically maintain balance after inser...",
              "path": "08-Advanced-BST/8.2-Self-Balancing-Overview.md",
              "size": 11413,
              "estimatedReadTime": 9
            }
          ]
        }
      ],
      "stats": {
        "sections": 8,
        "chapters": 22
      }
    },
    "heaps-priority-queues": {
      "id": "heaps-priority-queues",
      "folderName": "08-Heaps-Priority-Queues",
      "chapters": [
        {
          "type": "section",
          "name": "01-Heap-Fundamentals",
          "title": "Heap Fundamentals",
          "path": "01-Heap-Fundamentals",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-What-Is-Heap.md",
              "title": "1.1 What Is a Heap?",
              "description": "A heap is a specialized complete binary tree that satisfies the heap property:",
              "path": "01-Heap-Fundamentals/1.1-What-Is-Heap.md",
              "size": 12928,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "1.2-Heap-Property.md",
              "title": "1.2 Heap Property Explained",
              "description": "The heap property is the ordering constraint that makes a heap useful:",
              "path": "01-Heap-Fundamentals/1.2-Heap-Property.md",
              "size": 11746,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "1.3-Complete-Binary-Tree.md",
              "title": "1.3 Complete Binary Tree",
              "description": "A Complete Binary Tree is a binary tree where:",
              "path": "01-Heap-Fundamentals/1.3-Complete-Binary-Tree.md",
              "size": 12443,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "1.4-Array-Representation.md",
              "title": "1.4 Array Representation of Heaps",
              "description": "A heap is stored as an array where the parent-child relationships are determined by index formulas:",
              "path": "01-Heap-Fundamentals/1.4-Array-Representation.md",
              "size": 14044,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "02-Heap-Operations",
          "title": "Heap Operations",
          "path": "02-Heap-Operations",
          "children": [
            {
              "type": "chapter",
              "name": "2.1-Insert.md",
              "title": "2.1 Insert (Push) Operation",
              "description": "",
              "path": "02-Heap-Operations/2.1-Insert.md",
              "size": 12401,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "2.2-Extract.md",
              "title": "2.2 Extract (Pop) Operation",
              "description": "",
              "path": "02-Heap-Operations/2.2-Extract.md",
              "size": 14091,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "2.3-Peek.md",
              "title": "2.3 Peek Operation",
              "description": "",
              "path": "02-Heap-Operations/2.3-Peek.md",
              "size": 8334,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "2.4-Heapify.md",
              "title": "2.4 Heapify (Build Heap)",
              "description": "",
              "path": "02-Heap-Operations/2.4-Heapify.md",
              "size": 12200,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "2.5-Replace.md",
              "title": "2.5 Replace Operations",
              "description": "",
              "path": "02-Heap-Operations/2.5-Replace.md",
              "size": 15924,
              "estimatedReadTime": 12
            }
          ]
        },
        {
          "type": "section",
          "name": "03-Priority-Queue",
          "title": "Priority Queue",
          "path": "03-Priority-Queue",
          "children": [
            {
              "type": "chapter",
              "name": "3.1-PQ-Basics.md",
              "title": "3.1 Priority Queue Basics",
              "description": "A Priority Queue is an abstract data type (ADT) where each element has an associated priority, and elements are served based on their priority rath...",
              "path": "03-Priority-Queue/3.1-PQ-Basics.md",
              "size": 14484,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "3.2-PQ-Implementation.md",
              "title": "3.2 Priority Queue Implementation",
              "description": "This section covers implementing a complete Priority Queue from scratch using a binary heap, including handling custom priorities and objects.",
              "path": "03-Priority-Queue/3.2-PQ-Implementation.md",
              "size": 18416,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "3.3-PQ-Applications.md",
              "title": "3.3 Priority Queue Applications",
              "description": "This section covers real-world applications of priority queues, demonstrating where this data structure provides optimal solutions across different...",
              "path": "03-Priority-Queue/3.3-PQ-Applications.md",
              "size": 16816,
              "estimatedReadTime": 12
            }
          ]
        },
        {
          "type": "section",
          "name": "04-Top-K-Pattern",
          "title": "Top K Pattern",
          "path": "04-Top-K-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-Top-K-Overview.md",
              "title": "4.1 Top K Elements Pattern Overview",
              "description": "The Top K Elements pattern is one of the highest-ROI patterns for coding interviews, covering approximately 8% of all interview problems. This patt...",
              "path": "04-Top-K-Pattern/4.1-Top-K-Overview.md",
              "size": 14468,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "4.2-Kth-Largest-LC215.md",
              "title": "4.2 Kth Largest Element in Array (LC 215)",
              "description": "[LeetCode 215 - Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)",
              "path": "04-Top-K-Pattern/4.2-Kth-Largest-LC215.md",
              "size": 13448,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "4.3-Kth-Largest-Stream-LC703.md",
              "title": "4.3 Kth Largest Element in a Stream (LC 703)",
              "description": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in sorted order, not the kth distinct element.",
              "path": "04-Top-K-Pattern/4.3-Kth-Largest-Stream-LC703.md",
              "size": 12697,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "4.4-Top-K-Frequent-LC347.md",
              "title": "4.4 Top K Frequent Elements (LC 347)",
              "description": "[LeetCode 347 - Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)",
              "path": "04-Top-K-Pattern/4.4-Top-K-Frequent-LC347.md",
              "size": 12264,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "4.5-K-Closest-Points-LC973.md",
              "title": "4.5 K Closest Points to Origin (LC 973)",
              "description": "[LeetCode 973 - K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/)",
              "path": "04-Top-K-Pattern/4.5-K-Closest-Points-LC973.md",
              "size": 12468,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "4.6-Top-K-Frequent-Words-LC692.md",
              "title": "4.6 Top K Frequent Words (LC 692)",
              "description": "Given an array of strings words and an integer k, return the k most frequent strings. Return the answer sorted by frequency from highest to lowest....",
              "path": "04-Top-K-Pattern/4.6-Top-K-Frequent-Words-LC692.md",
              "size": 14846,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "05-Two-Heaps-Pattern",
          "title": "Two Heaps Pattern",
          "path": "05-Two-Heaps-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "5.1-Two-Heaps-Overview.md",
              "title": "5.1 Two Heaps Pattern Overview",
              "description": "The Two Heaps pattern uses a max-heap and a min-heap together to efficiently track the median or maintain a balanced partition of elements.",
              "path": "05-Two-Heaps-Pattern/5.1-Two-Heaps-Overview.md",
              "size": 13314,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "5.2-Median-Stream-LC295.md",
              "title": "5.2 Find Median from Data Stream (LC 295)",
              "description": "[LeetCode 295 - Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)",
              "path": "05-Two-Heaps-Pattern/5.2-Median-Stream-LC295.md",
              "size": 16136,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "5.3-Sliding-Window-Median-LC480.md",
              "title": "5.3 Sliding Window Median (LC 480)",
              "description": "Given an array of integers nums and an integer k, find the median of each sliding window of size k. Return an array of medians.",
              "path": "05-Two-Heaps-Pattern/5.3-Sliding-Window-Median-LC480.md",
              "size": 15635,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "5.4-IPO-LC502.md",
              "title": "5.4 IPO (LC 502)",
              "description": "You are given n projects with profits profits[i] and minimum capital requirements capital[i]. You start with capital w. Complete at most k projects...",
              "path": "05-Two-Heaps-Pattern/5.4-IPO-LC502.md",
              "size": 12540,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "06-K-Way-Merge-Pattern",
          "title": "K Way Merge Pattern",
          "path": "06-K-Way-Merge-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "6.1-K-Way-Merge-Overview.md",
              "title": "6.1 K-Way Merge Pattern Overview",
              "description": "The K-Way Merge pattern uses a min-heap to efficiently merge K sorted lists/arrays into a single sorted sequence. It generalizes the \"merge two sor...",
              "path": "06-K-Way-Merge-Pattern/6.1-K-Way-Merge-Overview.md",
              "size": 15305,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "6.2-Merge-K-Lists-LC23.md",
              "title": "6.2 Merge K Sorted Lists (LC 23)",
              "description": "[LeetCode 23 - Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)",
              "path": "06-K-Way-Merge-Pattern/6.2-Merge-K-Lists-LC23.md",
              "size": 15151,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "6.3-Kth-Smallest-Matrix-LC378.md",
              "title": "6.3 Kth Smallest Element in a Sorted Matrix (LC 378)",
              "description": "Given an n x n matrix where each row and column is sorted in ascending order, find the kth smallest element.",
              "path": "06-K-Way-Merge-Pattern/6.3-Kth-Smallest-Matrix-LC378.md",
              "size": 13506,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "6.4-Smallest-Range-LC632.md",
              "title": "6.4 Smallest Range Covering Elements from K Lists (LC 632)",
              "description": "You have k lists of sorted integers in non-decreasing order. Find the smallest range [a, b] that includes at least one number from each of the k li...",
              "path": "06-K-Way-Merge-Pattern/6.4-Smallest-Range-LC632.md",
              "size": 13528,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "07-Scheduling-Problems",
          "title": "Scheduling Problems",
          "path": "07-Scheduling-Problems",
          "children": [
            {
              "type": "chapter",
              "name": "7.1-Task-Scheduler-Overview.md",
              "title": "7.1 Scheduling Problems Overview",
              "description": "",
              "path": "07-Scheduling-Problems/7.1-Task-Scheduler-Overview.md",
              "size": 14349,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "7.2-Task-Scheduler-LC621.md",
              "title": "7.2 Task Scheduler (LC 621)",
              "description": "Given a characters array tasks representing tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any orde...",
              "path": "07-Scheduling-Problems/7.2-Task-Scheduler-LC621.md",
              "size": 10111,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "7.3-Meeting-Rooms-II-LC253.md",
              "title": "7.3 Meeting Rooms II (LC 253)",
              "description": "Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.",
              "path": "07-Scheduling-Problems/7.3-Meeting-Rooms-II-LC253.md",
              "size": 10884,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "7.4-Reorganize-String-LC767.md",
              "title": "7.4 Reorganize String (LC 767)",
              "description": "Given a string s, rearrange the characters of s so that any two adjacent characters are not the same.",
              "path": "07-Scheduling-Problems/7.4-Reorganize-String-LC767.md",
              "size": 10640,
              "estimatedReadTime": 8
            }
          ]
        },
        {
          "type": "section",
          "name": "08-Heap-Sort",
          "title": "Heap Sort",
          "path": "08-Heap-Sort",
          "children": [
            {
              "type": "chapter",
              "name": "8.1-Heap-Sort-Algorithm.md",
              "title": "8.1 Heap Sort Algorithm",
              "description": "",
              "path": "08-Heap-Sort/8.1-Heap-Sort-Algorithm.md",
              "size": 10886,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "8.2-Heap-Sort-Analysis.md",
              "title": "8.2 Heap Sort Complexity Analysis",
              "description": "This document provides a deep dive into the complexity analysis of Heap Sort, including the non-obvious O(n) build heap proof and comparisons with ...",
              "path": "08-Heap-Sort/8.2-Heap-Sort-Analysis.md",
              "size": 9581,
              "estimatedReadTime": 8
            }
          ]
        }
      ],
      "stats": {
        "sections": 8,
        "chapters": 32
      }
    },
    "hashing": {
      "id": "hashing",
      "folderName": "09-Hashing",
      "chapters": [
        {
          "type": "section",
          "name": "01-Hash-Fundamentals",
          "title": "Hash Fundamentals",
          "path": "01-Hash-Fundamentals",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-What-Is-Hashing.md",
              "title": "What Is Hashing?",
              "description": "> Hashing transforms data into fixed-size values for ultra-fast O(1) lookups.",
              "path": "01-Hash-Fundamentals/1.1-What-Is-Hashing.md",
              "size": 13067,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "1.2-Hash-Functions.md",
              "title": "Hash Functions",
              "description": "> A hash function converts any input into a fixed-size integer, determining where data is stored in a hash table.",
              "path": "01-Hash-Fundamentals/1.2-Hash-Functions.md",
              "size": 13401,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "1.3-Collision-Handling.md",
              "title": "Collision Handling",
              "description": "> When two keys hash to the same bucket, we need strategies to resolve the conflict.",
              "path": "01-Hash-Fundamentals/1.3-Collision-Handling.md",
              "size": 19262,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "1.4-Load-Factor.md",
              "title": "Load Factor and Resizing",
              "description": "> Load factor measures hash table fullness and triggers resizing to maintain O(1) performance.",
              "path": "01-Hash-Fundamentals/1.4-Load-Factor.md",
              "size": 17714,
              "estimatedReadTime": 12
            }
          ]
        },
        {
          "type": "section",
          "name": "02-Hash-Map-Set",
          "title": "Hash Map Set",
          "path": "02-Hash-Map-Set",
          "children": [
            {
              "type": "chapter",
              "name": "2.1-Hash-Map-Operations.md",
              "title": "Hash Map Operations",
              "description": "> Hash maps store key-value pairs with O(1) average access time for insert, lookup, and delete.",
              "path": "02-Hash-Map-Set/2.1-Hash-Map-Operations.md",
              "size": 15901,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "2.2-Hash-Set-Operations.md",
              "title": "Hash Set Operations",
              "description": "> Hash sets store unique elements with O(1) membership testing - perfect for deduplication and existence checks.",
              "path": "02-Hash-Map-Set/2.2-Hash-Set-Operations.md",
              "size": 17830,
              "estimatedReadTime": 13
            },
            {
              "type": "chapter",
              "name": "2.3-When-To-Use.md",
              "title": "When to Use Hash Map vs Hash Set vs Other",
              "description": "> Choosing the right data structure is half the battle. Here's how to decide between hash-based structures and alternatives.",
              "path": "02-Hash-Map-Set/2.3-When-To-Use.md",
              "size": 15186,
              "estimatedReadTime": 12
            }
          ]
        },
        {
          "type": "section",
          "name": "03-Frequency-Pattern",
          "title": "Frequency Pattern",
          "path": "03-Frequency-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "3.1-Frequency-Overview.md",
              "title": "Frequency Counting Pattern",
              "description": "> The most common hash map usage: count occurrences in O(n) time.",
              "path": "03-Frequency-Pattern/3.1-Frequency-Overview.md",
              "size": 13216,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "3.2-Valid-Anagram-LC242.md",
              "title": "Valid Anagram (LeetCode 242)",
              "description": "> The classic frequency counting problem - compare character frequencies of two strings.",
              "path": "03-Frequency-Pattern/3.2-Valid-Anagram-LC242.md",
              "size": 10394,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "3.3-First-Unique-Char-LC387.md",
              "title": "First Unique Character in a String (LeetCode 387)",
              "description": "> Count then find - a two-pass frequency pattern for locating unique elements.",
              "path": "03-Frequency-Pattern/3.3-First-Unique-Char-LC387.md",
              "size": 10762,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "3.4-Top-K-Frequent-LC347.md",
              "title": "Top K Frequent Elements (LeetCode 347)",
              "description": "> Frequency counting meets sorting - find the k most common elements efficiently.",
              "path": "03-Frequency-Pattern/3.4-Top-K-Frequent-LC347.md",
              "size": 14340,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "04-Two-Sum-Pattern",
          "title": "Two Sum Pattern",
          "path": "04-Two-Sum-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-Two-Sum-Overview.md",
              "title": "Two Sum Pattern",
              "description": "> The foundational hash map pattern that transforms O(n²) brute force into O(n) elegance.",
              "path": "04-Two-Sum-Pattern/4.1-Two-Sum-Overview.md",
              "size": 12724,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "4.2-Two-Sum-LC1.md",
              "title": "Two Sum (LeetCode 1)",
              "description": "> The most famous coding interview problem. Master this and you understand hash maps.",
              "path": "04-Two-Sum-Pattern/4.2-Two-Sum-LC1.md",
              "size": 10437,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "4.3-Contains-Duplicate-II-LC219.md",
              "title": "Contains Duplicate II (LeetCode 219)",
              "description": "> Two Sum pattern with a distance constraint - combining hash map with sliding window logic.",
              "path": "04-Two-Sum-Pattern/4.3-Contains-Duplicate-II-LC219.md",
              "size": 11266,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "4.4-Longest-Consecutive-LC128.md",
              "title": "Longest Consecutive Sequence (LeetCode 128)",
              "description": "> The clever hash set pattern that achieves O(n) for what seems like a sorting problem.",
              "path": "04-Two-Sum-Pattern/4.4-Longest-Consecutive-LC128.md",
              "size": 13118,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "05-Prefix-Sum-Hash",
          "title": "Prefix Sum Hash",
          "path": "05-Prefix-Sum-Hash",
          "children": [
            {
              "type": "chapter",
              "name": "5.1-Prefix-Hash-Overview.md",
              "title": "Prefix Sum + Hash Map Pattern",
              "description": "> Turn O(n²) subarray problems into O(n) using prefix sums and hash maps.",
              "path": "05-Prefix-Sum-Hash/5.1-Prefix-Hash-Overview.md",
              "size": 11956,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "5.2-Subarray-Sum-K-LC560.md",
              "title": "Subarray Sum Equals K (LeetCode 560)",
              "description": "> Count subarrays with a target sum using prefix sums and hash maps.",
              "path": "05-Prefix-Sum-Hash/5.2-Subarray-Sum-K-LC560.md",
              "size": 12229,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "5.3-Continuous-Subarray-LC523.md",
              "title": "Continuous Subarray Sum (LeetCode 523)",
              "description": "> Find a subarray of length ≥2 whose sum is a multiple of k using prefix sums with modular arithmetic.",
              "path": "05-Prefix-Sum-Hash/5.3-Continuous-Subarray-LC523.md",
              "size": 13278,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "06-Grouping-Pattern",
          "title": "Grouping Pattern",
          "path": "06-Grouping-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "6.1-Grouping-Overview.md",
              "title": "Grouping Pattern Overview",
              "description": "> Group elements by a common property using hash maps - transform O(n²) comparisons into O(n) grouping.",
              "path": "06-Grouping-Pattern/6.1-Grouping-Overview.md",
              "size": 14655,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "6.2-Group-Anagrams-LC49.md",
              "title": "Group Anagrams (LeetCode 49)",
              "description": "> Medium | Given an array of strings, group anagrams together. Return the answer in any order.",
              "path": "06-Grouping-Pattern/6.2-Group-Anagrams-LC49.md",
              "size": 14448,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "6.3-Isomorphic-Strings-LC205.md",
              "title": "Isomorphic Strings (LeetCode 205)",
              "description": "> Easy | Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t.",
              "path": "06-Grouping-Pattern/6.3-Isomorphic-Strings-LC205.md",
              "size": 14571,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "6.4-Word-Pattern-LC290.md",
              "title": "Word Pattern (LeetCode 290)",
              "description": "> Easy | Given a pattern and a string s, find if s follows the same pattern. \"Follow\" means a full match: there's a bijection between a letter in p...",
              "path": "06-Grouping-Pattern/6.4-Word-Pattern-LC290.md",
              "size": 14221,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "07-Sliding-Window-Hash",
          "title": "Sliding Window Hash",
          "path": "07-Sliding-Window-Hash",
          "children": [
            {
              "type": "chapter",
              "name": "7.1-Sliding-Hash-Overview.md",
              "title": "Sliding Window + Hash Pattern Overview",
              "description": "> Combine sliding window traversal with hash-based state tracking for efficient substring/subarray problems.",
              "path": "07-Sliding-Window-Hash/7.1-Sliding-Hash-Overview.md",
              "size": 17576,
              "estimatedReadTime": 13
            },
            {
              "type": "chapter",
              "name": "7.2-Longest-Substring-LC3.md",
              "title": "Longest Substring Without Repeating Characters (LeetCode 3)",
              "description": "> Medium | Given a string s, find the length of the longest substring without repeating characters.",
              "path": "07-Sliding-Window-Hash/7.2-Longest-Substring-LC3.md",
              "size": 16076,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "7.3-Find-Anagrams-LC438.md",
              "title": "Find All Anagrams in a String (LeetCode 438)",
              "description": "> Medium | Given a string s and a pattern p, return all start indices of p's anagrams in s. An anagram is a permutation of a string.",
              "path": "07-Sliding-Window-Hash/7.3-Find-Anagrams-LC438.md",
              "size": 16216,
              "estimatedReadTime": 12
            }
          ]
        },
        {
          "type": "section",
          "name": "08-Design-Problems",
          "title": "Design Problems",
          "path": "08-Design-Problems",
          "children": [
            {
              "type": "chapter",
              "name": "8.1-Design-Overview.md",
              "title": "Hash-Based Design Problems Overview",
              "description": "> Master designing data structures that leverage hashing for O(1) operations - a critical interview skill.",
              "path": "08-Design-Problems/8.1-Design-Overview.md",
              "size": 12879,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "8.2-Design-HashMap-LC706.md",
              "title": "Design HashMap (LeetCode 706)",
              "description": "> Easy | Design a HashMap without using any built-in hash table libraries. Implement put, get, and remove operations.",
              "path": "08-Design-Problems/8.2-Design-HashMap-LC706.md",
              "size": 16004,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "8.3-Design-HashSet-LC705.md",
              "title": "Design HashSet (LeetCode 705)",
              "description": "> Easy | Design a HashSet without using any built-in hash table libraries. Implement add, remove, and contains operations.",
              "path": "08-Design-Problems/8.3-Design-HashSet-LC705.md",
              "size": 14081,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "8.4-LRU-Cache-LC146.md",
              "title": "LRU Cache (LeetCode 146)",
              "description": "> Medium | Design a data structure that follows LRU (Least Recently Used) cache constraints with O(1) get and put operations.",
              "path": "08-Design-Problems/8.4-LRU-Cache-LC146.md",
              "size": 18374,
              "estimatedReadTime": 13
            },
            {
              "type": "chapter",
              "name": "8.5-RandomizedSet-LC380.md",
              "title": "Insert Delete GetRandom O(1) (LeetCode 380)",
              "description": "> Medium | Design a data structure that supports insert, delete, and getRandom in O(1) time.",
              "path": "08-Design-Problems/8.5-RandomizedSet-LC380.md",
              "size": 16767,
              "estimatedReadTime": 12
            }
          ]
        },
        {
          "type": "section",
          "name": "09-String-Hashing",
          "title": "String Hashing",
          "path": "09-String-Hashing",
          "children": [
            {
              "type": "chapter",
              "name": "9.1-Rolling-Hash-Overview.md",
              "title": "Rolling Hash Overview",
              "description": "> A technique for computing hash values incrementally as a window slides over data, enabling O(n) string matching instead of O(nm).",
              "path": "09-String-Hashing/9.1-Rolling-Hash-Overview.md",
              "size": 15973,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "9.2-Rabin-Karp.md",
              "title": "Rabin-Karp Algorithm",
              "description": "> A string searching algorithm that uses rolling hash to find pattern occurrences in O(n+m) average time.",
              "path": "09-String-Hashing/9.2-Rabin-Karp.md",
              "size": 17399,
              "estimatedReadTime": 14
            }
          ]
        }
      ],
      "stats": {
        "sections": 9,
        "chapters": 32
      }
    },
    "graphs": {
      "id": "graphs",
      "folderName": "10-Graphs",
      "chapters": [
        {
          "type": "section",
          "name": "01-Graph-Fundamentals",
          "title": "Graph Fundamentals",
          "path": "01-Graph-Fundamentals",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-What-Is-Graph.md",
              "title": "1.1 What Is a Graph?",
              "description": "> Foundation concept for all graph algorithms",
              "path": "01-Graph-Fundamentals/1.1-What-Is-Graph.md",
              "size": 11152,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "1.2-Graph-Terminology.md",
              "title": "1.2 Graph Terminology",
              "description": "> Essential vocabulary for all graph algorithms",
              "path": "01-Graph-Fundamentals/1.2-Graph-Terminology.md",
              "size": 15884,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "1.3-Types-Of-Graphs.md",
              "title": "1.3 Types of Graphs",
              "description": "> Classification of graphs for algorithm selection",
              "path": "01-Graph-Fundamentals/1.3-Types-Of-Graphs.md",
              "size": 21805,
              "estimatedReadTime": 13
            }
          ]
        },
        {
          "type": "section",
          "name": "02-Graph-Representation",
          "title": "Graph Representation",
          "path": "02-Graph-Representation",
          "children": [
            {
              "type": "chapter",
              "name": "2.1-Adjacency-Matrix.md",
              "title": "2.1 Adjacency Matrix",
              "description": "> 2D array representation for dense graphs",
              "path": "02-Graph-Representation/2.1-Adjacency-Matrix.md",
              "size": 14961,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "2.2-Adjacency-List.md",
              "title": "2.2 Adjacency List",
              "description": "> The most common graph representation for interview problems",
              "path": "02-Graph-Representation/2.2-Adjacency-List.md",
              "size": 16896,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "2.3-Edge-List.md",
              "title": "2.3 Edge List",
              "description": "> Simple list of all edges - used for specific algorithms",
              "path": "02-Graph-Representation/2.3-Edge-List.md",
              "size": 15136,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "2.4-Representation-Comparison.md",
              "title": "2.4 Representation Comparison",
              "description": "> Choosing the right representation for your problem",
              "path": "02-Graph-Representation/2.4-Representation-Comparison.md",
              "size": 16729,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "03-BFS-Pattern",
          "title": "BFS Pattern",
          "path": "03-BFS-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "3.1-BFS-Fundamentals.md",
              "title": "3.1 BFS Fundamentals",
              "description": "> Level-by-level exploration - the foundation of shortest path in unweighted graphs",
              "path": "03-BFS-Pattern/3.1-BFS-Fundamentals.md",
              "size": 18184,
              "estimatedReadTime": 13
            },
            {
              "type": "chapter",
              "name": "3.2-BFS-Template.md",
              "title": "3.2 BFS Template",
              "description": "> The universal BFS template for any problem - memorize this pattern",
              "path": "03-BFS-Pattern/3.2-BFS-Template.md",
              "size": 18614,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "3.3-Multi-Source-BFS.md",
              "title": "3.3 Multi-Source BFS",
              "description": "> BFS from multiple starting points simultaneously - spreading in parallel",
              "path": "03-BFS-Pattern/3.3-Multi-Source-BFS.md",
              "size": 19094,
              "estimatedReadTime": 13
            },
            {
              "type": "section",
              "name": "3.4-BFS-Practice",
              "title": "4 BFS Practice",
              "path": "03-BFS-Pattern/3.4-BFS-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Rotting-Oranges-LC994.md",
                  "title": "LC 994: Rotting Oranges",
                  "description": "> The quintessential Multi-Source BFS problem",
                  "path": "03-BFS-Pattern/3.4-BFS-Practice/01-Rotting-Oranges-LC994.md",
                  "size": 12195,
                  "estimatedReadTime": 9
                },
                {
                  "type": "chapter",
                  "name": "02-Word-Ladder-LC127.md",
                  "title": "LC 127: Word Ladder",
                  "description": "> The classic BFS state transformation problem",
                  "path": "03-BFS-Pattern/3.4-BFS-Practice/02-Word-Ladder-LC127.md",
                  "size": 15418,
                  "estimatedReadTime": 11
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "04-DFS-Pattern",
          "title": "DFS Pattern",
          "path": "04-DFS-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-DFS-Fundamentals.md",
              "title": "4.1 DFS Fundamentals",
              "description": "> Deep exploration before backtracking - the foundation of graph traversal",
              "path": "04-DFS-Pattern/4.1-DFS-Fundamentals.md",
              "size": 18914,
              "estimatedReadTime": 13
            },
            {
              "type": "chapter",
              "name": "4.2-DFS-Template.md",
              "title": "4.2 DFS Template",
              "description": "> Universal DFS templates for any problem - memorize these patterns",
              "path": "04-DFS-Pattern/4.2-DFS-Template.md",
              "size": 18638,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "4.3-DFS-Applications.md",
              "title": "4.3 DFS Applications",
              "description": "> Practical applications of DFS - cycle detection, connectivity, and more",
              "path": "04-DFS-Pattern/4.3-DFS-Applications.md",
              "size": 18954,
              "estimatedReadTime": 13
            },
            {
              "type": "section",
              "name": "4.4-DFS-Practice",
              "title": "4 DFS Practice",
              "path": "04-DFS-Pattern/4.4-DFS-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Number-Of-Islands-LC200.md",
                  "title": "LC 200: Number of Islands",
                  "description": "> The quintessential DFS grid problem - count connected components",
                  "path": "04-DFS-Pattern/4.4-DFS-Practice/01-Number-Of-Islands-LC200.md",
                  "size": 8144,
                  "estimatedReadTime": 7
                },
                {
                  "type": "chapter",
                  "name": "02-Clone-Graph-LC133.md",
                  "title": "LC 133: Clone Graph",
                  "description": "> Deep copy a graph with cycle handling - classic DFS with memoization",
                  "path": "04-DFS-Pattern/4.4-DFS-Practice/02-Clone-Graph-LC133.md",
                  "size": 9157,
                  "estimatedReadTime": 7
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "05-Grid-Traversal",
          "title": "Grid Traversal",
          "path": "05-Grid-Traversal",
          "children": [
            {
              "type": "chapter",
              "name": "5.1-Grid-Introduction.md",
              "title": "5.1 Grid Traversal Introduction",
              "description": "> Grids are graphs in disguise - master the translation and patterns",
              "path": "05-Grid-Traversal/5.1-Grid-Introduction.md",
              "size": 8636,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "5.2-Island-Pattern.md",
              "title": "5.2 Island Pattern (Grokking Pattern #16)",
              "description": "> The \"Island Pattern\" - connected component traversal on grids",
              "path": "05-Grid-Traversal/5.2-Island-Pattern.md",
              "size": 13309,
              "estimatedReadTime": 10
            },
            {
              "type": "section",
              "name": "5.3-Grid-Practice",
              "title": "3 Grid Practice",
              "path": "05-Grid-Traversal/5.3-Grid-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Flood-Fill-LC733.md",
                  "title": "LC 733: Flood Fill",
                  "description": "> The simplest grid DFS problem - perfect for learning the pattern",
                  "path": "05-Grid-Traversal/5.3-Grid-Practice/01-Flood-Fill-LC733.md",
                  "size": 5973,
                  "estimatedReadTime": 5
                },
                {
                  "type": "chapter",
                  "name": "02-Shortest-Bridge-LC934.md",
                  "title": "LC 934: Shortest Bridge",
                  "description": "> A beautiful combination of DFS + BFS - find one island, then BFS to the other",
                  "path": "05-Grid-Traversal/5.3-Grid-Practice/02-Shortest-Bridge-LC934.md",
                  "size": 9287,
                  "estimatedReadTime": 8
                },
                {
                  "type": "chapter",
                  "name": "03-Pacific-Atlantic-LC417.md",
                  "title": "LC 417: Pacific Atlantic Water Flow",
                  "description": "> Reverse thinking - start from oceans and work inward",
                  "path": "05-Grid-Traversal/5.3-Grid-Practice/03-Pacific-Atlantic-LC417.md",
                  "size": 10009,
                  "estimatedReadTime": 8
                },
                {
                  "type": "chapter",
                  "name": "04-Surrounded-Regions-LC130.md",
                  "title": "LC 130: Surrounded Regions",
                  "description": "> Boundary DFS - save cells connected to boundary, capture the rest",
                  "path": "05-Grid-Traversal/5.3-Grid-Practice/04-Surrounded-Regions-LC130.md",
                  "size": 8322,
                  "estimatedReadTime": 7
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "06-Topological-Sort",
          "title": "Topological Sort",
          "path": "06-Topological-Sort",
          "children": [
            {
              "type": "chapter",
              "name": "6.1-Topo-Sort-Fundamentals.md",
              "title": "6.1 Topological Sort Fundamentals (Grokking Pattern #29)",
              "description": "> Order tasks with dependencies - essential for scheduling problems",
              "path": "06-Topological-Sort/6.1-Topo-Sort-Fundamentals.md",
              "size": 12387,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "6.2-DFS-Approach.md",
              "title": "6.2 DFS Approach to Topological Sort",
              "description": "> Post-order DFS traversal with reversal - elegant recursive solution",
              "path": "06-Topological-Sort/6.2-DFS-Approach.md",
              "size": 8352,
              "estimatedReadTime": 6
            },
            {
              "type": "chapter",
              "name": "6.3-Kahns-BFS.md",
              "title": "6.3 Kahn's Algorithm (BFS Approach)",
              "description": "> Iteratively remove nodes with no dependencies - intuitive and parallel-friendly",
              "path": "06-Topological-Sort/6.3-Kahns-BFS.md",
              "size": 11593,
              "estimatedReadTime": 8
            },
            {
              "type": "section",
              "name": "6.4-Topo-Practice",
              "title": "4 Topo Practice",
              "path": "06-Topological-Sort/6.4-Topo-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Course-Schedule-LC207.md",
                  "title": "LC 207: Course Schedule",
                  "description": "> The classic topological sort problem - can you finish all courses?",
                  "path": "06-Topological-Sort/6.4-Topo-Practice/01-Course-Schedule-LC207.md",
                  "size": 6868,
                  "estimatedReadTime": 5
                },
                {
                  "type": "chapter",
                  "name": "02-Course-Schedule-II-LC210.md",
                  "title": "LC 210: Course Schedule II",
                  "description": "> Return the actual course order - topological sort with result extraction",
                  "path": "06-Topological-Sort/6.4-Topo-Practice/02-Course-Schedule-II-LC210.md",
                  "size": 6347,
                  "estimatedReadTime": 5
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "07-Union-Find",
          "title": "Union Find",
          "path": "07-Union-Find",
          "children": [
            {
              "type": "chapter",
              "name": "7.1-Union-Find-Basics.md",
              "title": "7.1 Union-Find (Disjoint Set Union) Basics (Grokking Pattern #30)",
              "description": "> Track connected components dynamically - essential for connectivity problems",
              "path": "07-Union-Find/7.1-Union-Find-Basics.md",
              "size": 8031,
              "estimatedReadTime": 6
            },
            {
              "type": "chapter",
              "name": "7.2-Optimizations.md",
              "title": "7.2 Union-Find Optimizations",
              "description": "> Path Compression + Union by Rank = Nearly O(1) operations",
              "path": "07-Union-Find/7.2-Optimizations.md",
              "size": 9688,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "7.3-Applications.md",
              "title": "7.3 Union-Find Applications",
              "description": "> Real-world patterns: connectivity, cycles, MST, and more",
              "path": "07-Union-Find/7.3-Applications.md",
              "size": 10222,
              "estimatedReadTime": 7
            },
            {
              "type": "section",
              "name": "7.4-UF-Practice",
              "title": "4 UF Practice",
              "path": "07-Union-Find/7.4-UF-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Number-Of-Provinces-LC547.md",
                  "title": "LC 547: Number of Provinces",
                  "description": "> Count connected components in an adjacency matrix - classic Union-Find",
                  "path": "07-Union-Find/7.4-UF-Practice/01-Number-Of-Provinces-LC547.md",
                  "size": 5449,
                  "estimatedReadTime": 4
                },
                {
                  "type": "chapter",
                  "name": "02-Redundant-Connection-LC684.md",
                  "title": "LC 684: Redundant Connection",
                  "description": "> Find the edge that creates a cycle - classic Union-Find cycle detection",
                  "path": "07-Union-Find/7.4-UF-Practice/02-Redundant-Connection-LC684.md",
                  "size": 6904,
                  "estimatedReadTime": 6
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "08-Shortest-Path",
          "title": "Shortest Path",
          "path": "08-Shortest-Path",
          "children": [
            {
              "type": "chapter",
              "name": "8.1-Shortest-Path-Overview.md",
              "title": "8.1 Shortest Path Overview",
              "description": "> Finding optimal routes in weighted graphs - the foundation of navigation, routing, and optimization",
              "path": "08-Shortest-Path/8.1-Shortest-Path-Overview.md",
              "size": 12664,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "8.2-Dijkstra.md",
              "title": "8.2 Dijkstra's Algorithm",
              "description": "> The gold standard for shortest paths in non-negative weighted graphs",
              "path": "08-Shortest-Path/8.2-Dijkstra.md",
              "size": 16313,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "8.3-Bellman-Ford.md",
              "title": "8.3 Bellman-Ford Algorithm",
              "description": "> Handle negative edges and detect negative cycles",
              "path": "08-Shortest-Path/8.3-Bellman-Ford.md",
              "size": 14822,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "8.4-Floyd-Warshall.md",
              "title": "8.4 Floyd-Warshall Algorithm",
              "description": "> All-pairs shortest path in O(V³) - elegant DP solution",
              "path": "08-Shortest-Path/8.4-Floyd-Warshall.md",
              "size": 14499,
              "estimatedReadTime": 11
            },
            {
              "type": "section",
              "name": "8.5-SP-Practice",
              "title": "5 SP Practice",
              "path": "08-Shortest-Path/8.5-SP-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Network-Delay-Time-LC743.md",
                  "title": "LC 743: Network Delay Time",
                  "description": "> Classic Dijkstra implementation - find time for signal to reach all nodes",
                  "path": "08-Shortest-Path/8.5-SP-Practice/01-Network-Delay-Time-LC743.md",
                  "size": 5879,
                  "estimatedReadTime": 5
                },
                {
                  "type": "chapter",
                  "name": "02-Cheapest-Flights-LC787.md",
                  "title": "LC 787: Cheapest Flights Within K Stops",
                  "description": "> Bellman-Ford variant - shortest path with limited edges",
                  "path": "08-Shortest-Path/8.5-SP-Practice/02-Cheapest-Flights-LC787.md",
                  "size": 7924,
                  "estimatedReadTime": 7
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "09-Cycle-Detection",
          "title": "Cycle Detection",
          "path": "09-Cycle-Detection",
          "children": [
            {
              "type": "chapter",
              "name": "9.1-Undirected-Cycles.md",
              "title": "9.1 Cycle Detection in Undirected Graphs",
              "description": "> Detecting cycles with DFS parent tracking or Union-Find",
              "path": "09-Cycle-Detection/9.1-Undirected-Cycles.md",
              "size": 12673,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "9.2-Directed-Cycles.md",
              "title": "9.2 Cycle Detection in Directed Graphs",
              "description": "> Three-color DFS marking for detecting back edges",
              "path": "09-Cycle-Detection/9.2-Directed-Cycles.md",
              "size": 13347,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "10-Bipartite",
          "title": "Bipartite",
          "path": "10-Bipartite",
          "children": [
            {
              "type": "chapter",
              "name": "10.1-Bipartite-Basics.md",
              "title": "10.1 Bipartite Graphs",
              "description": "> Two-colorable graphs - divide vertices into two disjoint sets",
              "path": "10-Bipartite/10.1-Bipartite-Basics.md",
              "size": 12407,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "11-MST",
          "title": "MST",
          "path": "11-MST",
          "children": [
            {
              "type": "chapter",
              "name": "11.1-MST-Introduction.md",
              "title": "11.1 Minimum Spanning Tree Introduction",
              "description": "> Connect all nodes with minimum total edge weight",
              "path": "11-MST/11.1-MST-Introduction.md",
              "size": 10111,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "11.2-Prims-Algorithm.md",
              "title": "11.2 Prim's Algorithm",
              "description": "> Grow MST from a starting vertex - similar to Dijkstra",
              "path": "11-MST/11.2-Prims-Algorithm.md",
              "size": 10648,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "11.3-Kruskals-Algorithm.md",
              "title": "11.3 Kruskal's Algorithm",
              "description": "> Sort edges by weight, greedily add if no cycle - using Union-Find",
              "path": "11-MST/11.3-Kruskals-Algorithm.md",
              "size": 10267,
              "estimatedReadTime": 8
            }
          ]
        },
        {
          "type": "section",
          "name": "12-Advanced",
          "title": "Advanced",
          "path": "12-Advanced",
          "children": [
            {
              "type": "chapter",
              "name": "12.1-Advanced-Overview.md",
              "title": "12.1 Advanced Graph Topics Overview",
              "description": "> SCCs, Bridges, Articulation Points - Deeper graph analysis",
              "path": "12-Advanced/12.1-Advanced-Overview.md",
              "size": 11191,
              "estimatedReadTime": 8
            }
          ]
        }
      ],
      "stats": {
        "sections": 18,
        "chapters": 46
      }
    },
    "dynamic-programming": {
      "id": "dynamic-programming",
      "folderName": "11-Dynamic-Programming",
      "chapters": [
        {
          "type": "section",
          "name": "01-DP-Fundamentals",
          "title": "DP Fundamentals",
          "path": "01-DP-Fundamentals",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-What-Is-DP.md",
              "title": "1.1 What Is Dynamic Programming?",
              "description": "> Dynamic Programming (DP) is an algorithmic technique that solves complex problems by breaking them into simpler overlapping subproblems, solving ...",
              "path": "01-DP-Fundamentals/1.1-What-Is-DP.md",
              "size": 11829,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "1.2-When-To-Use-DP.md",
              "title": "1.2 When to Use Dynamic Programming",
              "description": "> Use DP when your problem has overlapping subproblems AND optimal substructure. This section provides a systematic approach to recognize DP opport...",
              "path": "01-DP-Fundamentals/1.2-When-To-Use-DP.md",
              "size": 14533,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "1.3-DP-vs-Other-Techniques.md",
              "title": "1.3 DP vs Other Techniques",
              "description": "> A quick reference for distinguishing Dynamic Programming from related algorithmic techniques. Knowing when NOT to use DP is as important as knowi...",
              "path": "01-DP-Fundamentals/1.3-DP-vs-Other-Techniques.md",
              "size": 10482,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "2.1-Top-Down-Memoization.md",
              "title": "2.1 Top-Down Memoization",
              "description": "> Memoization is a DP implementation where you start with the original problem, recursively break it into subproblems, and cache results to avoid r...",
              "path": "01-DP-Fundamentals/2.1-Top-Down-Memoization.md",
              "size": 12426,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "2.2-Bottom-Up-Tabulation.md",
              "title": "2.2 Bottom-Up Tabulation",
              "description": "> Tabulation is a DP implementation where you start from the smallest subproblems and iteratively build up to the final answer. It's called \"bottom...",
              "path": "01-DP-Fundamentals/2.2-Bottom-Up-Tabulation.md",
              "size": 15133,
              "estimatedReadTime": 12
            },
            {
              "type": "chapter",
              "name": "2.3-Space-Optimization.md",
              "title": "2.3 Space Optimization in DP",
              "description": "> Space optimization reduces memory usage by observing that most DP recurrences only depend on a limited number of previous states. Instead of stor...",
              "path": "01-DP-Fundamentals/2.3-Space-Optimization.md",
              "size": 14631,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "3.0-DP-Problem-Solving-Framework.md",
              "title": "3.0 DP Problem-Solving Framework",
              "description": "> The 5-Step DP Framework is a systematic approach to solve any dynamic programming problem. Master this framework and you can tackle any DP proble...",
              "path": "01-DP-Fundamentals/3.0-DP-Problem-Solving-Framework.md",
              "size": 14190,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "02-Fibonacci-Pattern",
          "title": "Fibonacci Pattern",
          "path": "02-Fibonacci-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-Fibonacci-Pattern-Overview.md",
              "title": "4.1 Fibonacci Pattern Overview",
              "description": "> The Fibonacci Pattern is the simplest and most common DP pattern. Any problem where the current state depends on a constant number of previous st...",
              "path": "02-Fibonacci-Pattern/4.1-Fibonacci-Pattern-Overview.md",
              "size": 11521,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "4.2-Linear-DP-Patterns.md",
              "title": "4.2 Linear DP Patterns",
              "description": "> Linear DP extends the Fibonacci pattern to handle more complex linear sequences. Instead of just 2 previous states, you might need to consider al...",
              "path": "02-Fibonacci-Pattern/4.2-Linear-DP-Patterns.md",
              "size": 12876,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "4.3-Jump-Game-Pattern.md",
              "title": "4.3 Jump Game Pattern",
              "description": "> Jump Game problems form a distinct sub-pattern of linear DP. They involve making jump decisions along an array, with variations including reachab...",
              "path": "02-Fibonacci-Pattern/4.3-Jump-Game-Pattern.md",
              "size": 12990,
              "estimatedReadTime": 11
            },
            {
              "type": "section",
              "name": "4.4-Fibonacci-Practice",
              "title": "4 Fibonacci Practice",
              "path": "02-Fibonacci-Pattern/4.4-Fibonacci-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Climbing-Stairs-LC70.md",
                  "title": "Climbing Stairs (LC 70)",
                  "description": "> The quintessential Fibonacci DP problem. If you can only solve one DP problem, make it this one. It's the foundation for understanding how DP works.",
                  "path": "02-Fibonacci-Pattern/4.4-Fibonacci-Practice/01-Climbing-Stairs-LC70.md",
                  "size": 6637,
                  "estimatedReadTime": 6
                },
                {
                  "type": "chapter",
                  "name": "02-House-Robber-LC198.md",
                  "title": "House Robber (LC 198)",
                  "description": "> The classic take-or-skip DP problem. Understanding House Robber unlocks a whole family of problems where you make binary decisions with constrain...",
                  "path": "02-Fibonacci-Pattern/4.4-Fibonacci-Practice/02-House-Robber-LC198.md",
                  "size": 8865,
                  "estimatedReadTime": 7
                },
                {
                  "type": "chapter",
                  "name": "03-Decode-Ways-LC91.md",
                  "title": "Decode Ways (LC 91)",
                  "description": "> Fibonacci with conditions. This problem extends the pattern by adding validity checks—not every step is valid, which makes the recurrence more nu...",
                  "path": "02-Fibonacci-Pattern/4.4-Fibonacci-Practice/03-Decode-Ways-LC91.md",
                  "size": 9363,
                  "estimatedReadTime": 8
                },
                {
                  "type": "chapter",
                  "name": "04-Maximum-Subarray-LC53.md",
                  "title": "Maximum Subarray - Kadane's Algorithm (LC 53)",
                  "description": "> The most famous 1D DP problem. Kadane's Algorithm is elegant, efficient, and appears constantly in interviews. It's also the foundation for many ...",
                  "path": "02-Fibonacci-Pattern/4.4-Fibonacci-Practice/04-Maximum-Subarray-LC53.md",
                  "size": 9923,
                  "estimatedReadTime": 8
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "03-Grid-DP",
          "title": "Grid DP",
          "path": "03-Grid-DP",
          "children": [
            {
              "type": "chapter",
              "name": "5.1-Grid-DP-Fundamentals.md",
              "title": "5.1 Grid DP Fundamentals",
              "description": "> Grid DP is the natural extension of linear DP to two dimensions. Any time you're moving through a 2D matrix, making optimal decisions along the w...",
              "path": "03-Grid-DP/5.1-Grid-DP-Fundamentals.md",
              "size": 10794,
              "estimatedReadTime": 9
            },
            {
              "type": "section",
              "name": "5.2-Grid-Practice",
              "title": "2 Grid Practice",
              "path": "03-Grid-DP/5.2-Grid-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Unique-Paths-LC62.md",
                  "title": "Unique Paths (LC 62)",
                  "description": "> The canonical Grid DP problem. This problem establishes the foundation for all 2D path counting and optimization problems. If you understand this...",
                  "path": "03-Grid-DP/5.2-Grid-Practice/01-Unique-Paths-LC62.md",
                  "size": 7549,
                  "estimatedReadTime": 7
                },
                {
                  "type": "chapter",
                  "name": "02-Min-Path-Sum-LC64.md",
                  "title": "Minimum Path Sum (LC 64)",
                  "description": "> The optimization variant of Grid DP. Instead of counting paths, find the path with minimum sum. This pattern extends to many real-world optimizat...",
                  "path": "03-Grid-DP/5.2-Grid-Practice/02-Min-Path-Sum-LC64.md",
                  "size": 9165,
                  "estimatedReadTime": 8
                },
                {
                  "type": "chapter",
                  "name": "03-Triangle-LC120.md",
                  "title": "Triangle (LC 120)",
                  "description": "> Bottom-up Grid DP with an irregular shape. This problem teaches you to think about direction—sometimes top-down isn't the best approach. Processi...",
                  "path": "03-Grid-DP/5.2-Grid-Practice/03-Triangle-LC120.md",
                  "size": 8365,
                  "estimatedReadTime": 7
                },
                {
                  "type": "chapter",
                  "name": "04-Maximal-Square-LC221.md",
                  "title": "Maximal Square (LC 221)",
                  "description": "> The classic DP grid problem that isn't about paths. Unlike path-sum problems, this requires thinking about \"what's the largest square ending here...",
                  "path": "03-Grid-DP/5.2-Grid-Practice/04-Maximal-Square-LC221.md",
                  "size": 9861,
                  "estimatedReadTime": 8
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "04-Knapsack-01",
          "title": "Knapsack 01",
          "path": "04-Knapsack-01",
          "children": [
            {
              "type": "chapter",
              "name": "6.1-Knapsack-01-Pattern.md",
              "title": "6.1 0/1 Knapsack Pattern",
              "description": "> The 0/1 Knapsack Pattern is the foundation for all bounded choice DP problems. \"0/1\" means you either take an item completely (1) or leave it (0)...",
              "path": "04-Knapsack-01/6.1-Knapsack-01-Pattern.md",
              "size": 11585,
              "estimatedReadTime": 10
            },
            {
              "type": "section",
              "name": "6.2-01-Knapsack-Practice",
              "title": "2 01 Knapsack Practice",
              "path": "04-Knapsack-01/6.2-01-Knapsack-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Partition-Equal-LC416.md",
                  "title": "Partition Equal Subset Sum (LC 416)",
                  "description": "> The classic 0/1 Knapsack reduction. This problem looks like a partition problem but reduces beautifully to \"can we find a subset summing to total...",
                  "path": "04-Knapsack-01/6.2-01-Knapsack-Practice/01-Partition-Equal-LC416.md",
                  "size": 9242,
                  "estimatedReadTime": 8
                },
                {
                  "type": "chapter",
                  "name": "02-Target-Sum-LC494.md",
                  "title": "Target Sum (LC 494)",
                  "description": "> Counting variant of 0/1 Knapsack with a mathematical transformation. This problem teaches you to think algebraically about DP—transforming the pr...",
                  "path": "04-Knapsack-01/6.2-01-Knapsack-Practice/02-Target-Sum-LC494.md",
                  "size": 8550,
                  "estimatedReadTime": 8
                },
                {
                  "type": "chapter",
                  "name": "03-Last-Stone-Weight-II-LC1049.md",
                  "title": "Last Stone Weight II (LC 1049)",
                  "description": "> The hidden knapsack problem. This problem looks like simulation but is actually a partition problem in disguise. We want to split stones into two...",
                  "path": "04-Knapsack-01/6.2-01-Knapsack-Practice/03-Last-Stone-Weight-II-LC1049.md",
                  "size": 9121,
                  "estimatedReadTime": 8
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "05-Knapsack-Unbounded",
          "title": "Knapsack Unbounded",
          "path": "05-Knapsack-Unbounded",
          "children": [
            {
              "type": "chapter",
              "name": "6.3-Unbounded-Knapsack-Pattern.md",
              "title": "6.3 Unbounded Knapsack Pattern",
              "description": "> Unbounded Knapsack is the \"items can be reused\" variant. While 0/1 Knapsack uses each item at most once, Unbounded allows unlimited copies. This ...",
              "path": "05-Knapsack-Unbounded/6.3-Unbounded-Knapsack-Pattern.md",
              "size": 10498,
              "estimatedReadTime": 9
            },
            {
              "type": "section",
              "name": "6.4-Unbounded-Practice",
              "title": "4 Unbounded Practice",
              "path": "05-Knapsack-Unbounded/6.4-Unbounded-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Coin-Change-LC322.md",
                  "title": "Coin Change (LC 322)",
                  "description": "> The definitive Unbounded Knapsack problem. If you understand Coin Change, you understand unbounded DP. This problem appears constantly in intervi...",
                  "path": "05-Knapsack-Unbounded/6.4-Unbounded-Practice/01-Coin-Change-LC322.md",
                  "size": 8969,
                  "estimatedReadTime": 8
                },
                {
                  "type": "chapter",
                  "name": "02-Coin-Change-II-LC518.md",
                  "title": "Coin Change II (LC 518)",
                  "description": "> Count COMBINATIONS to make an amount. This is Coin Change's cousin that asks \"how many ways\" instead of \"minimum coins.\" The key difference: loop...",
                  "path": "05-Knapsack-Unbounded/6.4-Unbounded-Practice/02-Coin-Change-II-LC518.md",
                  "size": 9482,
                  "estimatedReadTime": 8
                },
                {
                  "type": "chapter",
                  "name": "03-Perfect-Squares-LC279.md",
                  "title": "Perfect Squares (LC 279)",
                  "description": "> Unbounded Knapsack with squares as \"coins.\" This problem elegantly maps to Coin Change—the \"coins\" are 1², 2², 3²... and we minimize the count to...",
                  "path": "05-Knapsack-Unbounded/6.4-Unbounded-Practice/03-Perfect-Squares-LC279.md",
                  "size": 9049,
                  "estimatedReadTime": 8
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "06-LCS-Pattern",
          "title": "LCS Pattern",
          "path": "06-LCS-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "6.5-LCS-Fundamentals.md",
              "title": "LCS Pattern: Longest Common Subsequence Fundamentals",
              "description": "> The foundation of string/sequence DP. LCS teaches you how to think about comparing two sequences—a skill that extends to Edit Distance, Longest P...",
              "path": "06-LCS-Pattern/6.5-LCS-Fundamentals.md",
              "size": 13251,
              "estimatedReadTime": 10
            },
            {
              "type": "section",
              "name": "6.6-LCS-Practice",
              "title": "6 LCS Practice",
              "path": "06-LCS-Pattern/6.6-LCS-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-LCS-LC1143.md",
                  "title": "Longest Common Subsequence (LC 1143)",
                  "description": "> The canonical LCS problem. This is the foundation for understanding how to compare two sequences character by character. Every string DP problem ...",
                  "path": "06-LCS-Pattern/6.6-LCS-Practice/01-LCS-LC1143.md",
                  "size": 10718,
                  "estimatedReadTime": 8
                },
                {
                  "type": "chapter",
                  "name": "02-Edit-Distance-LC72.md",
                  "title": "Edit Distance (LC 72)",
                  "description": "> The quintessential interview DP problem. Edit Distance (Levenshtein Distance) is asked at every major tech company. It elegantly demonstrates how...",
                  "path": "06-LCS-Pattern/6.6-LCS-Practice/02-Edit-Distance-LC72.md",
                  "size": 12699,
                  "estimatedReadTime": 10
                },
                {
                  "type": "chapter",
                  "name": "03-Longest-Palindromic-Subseq-LC516.md",
                  "title": "Longest Palindromic Subsequence (LC 516)",
                  "description": "> A beautiful transformation: LPS = LCS(s, reverse(s)). This problem demonstrates the power of problem reduction. Instead of creating a new DP, we ...",
                  "path": "06-LCS-Pattern/6.6-LCS-Practice/03-Longest-Palindromic-Subseq-LC516.md",
                  "size": 11197,
                  "estimatedReadTime": 9
                },
                {
                  "type": "chapter",
                  "name": "04-Interleaving-String-LC97.md",
                  "title": "Interleaving String (LC 97)",
                  "description": "> Can two strings weave together to form a third? This problem is a beautiful application of 2D DP where we track progress through both source stri...",
                  "path": "06-LCS-Pattern/6.6-LCS-Practice/04-Interleaving-String-LC97.md",
                  "size": 11688,
                  "estimatedReadTime": 10
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "07-LIS-Pattern",
          "title": "LIS Pattern",
          "path": "07-LIS-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "7.1-LIS-Fundamentals.md",
              "title": "LIS Pattern: Longest Increasing Subsequence",
              "description": "> The foundation for sequence ordering problems. LIS teaches you how to find optimal orderings in sequences. The O(n log n) binary search solution ...",
              "path": "07-LIS-Pattern/7.1-LIS-Fundamentals.md",
              "size": 13072,
              "estimatedReadTime": 10
            },
            {
              "type": "section",
              "name": "7.2-LIS-Practice",
              "title": "2 LIS Practice",
              "path": "07-LIS-Pattern/7.2-LIS-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-LIS-LC300.md",
                  "title": "Longest Increasing Subsequence (LC 300)",
                  "description": "> The canonical LIS problem. This is where you learn both the classic O(n²) DP and the clever O(n log n) binary search optimization. Both approache...",
                  "path": "07-LIS-Pattern/7.2-LIS-Practice/01-LIS-LC300.md",
                  "size": 11205,
                  "estimatedReadTime": 9
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "08-Palindrome-DP",
          "title": "Palindrome DP",
          "path": "08-Palindrome-DP",
          "children": [
            {
              "type": "chapter",
              "name": "8.1-Palindrome-DP-Patterns.md",
              "title": "Palindrome DP Pattern",
              "description": "> Master the art of symmetry. Palindrome problems appear frequently in interviews and showcase elegant DP patterns—from the center-expansion techni...",
              "path": "08-Palindrome-DP/8.1-Palindrome-DP-Patterns.md",
              "size": 13044,
              "estimatedReadTime": 10
            },
            {
              "type": "section",
              "name": "8.2-Palindrome-Practice",
              "title": "2 Palindrome Practice",
              "path": "08-Palindrome-DP/8.2-Palindrome-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Longest-Palindromic-Substring-LC5.md",
                  "title": "Longest Palindromic Substring (LC 5)",
                  "description": "> The most common palindrome interview question. This problem teaches the elegant center expansion technique—O(n²) time with O(1) space. It's simpl...",
                  "path": "08-Palindrome-DP/8.2-Palindrome-Practice/01-Longest-Palindromic-Substring-LC5.md",
                  "size": 10923,
                  "estimatedReadTime": 9
                },
                {
                  "type": "chapter",
                  "name": "02-Palindrome-Partitioning-II-LC132.md",
                  "title": "Palindrome Partitioning II (LC 132)",
                  "description": "> A classic hard DP problem. This combines palindrome precomputation with linear DP to find minimum cuts. It's a beautiful example of how breaking ...",
                  "path": "08-Palindrome-DP/8.2-Palindrome-Practice/02-Palindrome-Partitioning-II-LC132.md",
                  "size": 11603,
                  "estimatedReadTime": 9
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "09-Interval-DP",
          "title": "Interval DP",
          "path": "09-Interval-DP",
          "children": [
            {
              "type": "chapter",
              "name": "9.1-Interval-DP-Pattern.md",
              "title": "Interval DP Pattern",
              "description": "> Think in ranges, not positions. Interval DP solves problems where optimal solutions for larger ranges depend on optimal solutions for smaller ran...",
              "path": "09-Interval-DP/9.1-Interval-DP-Pattern.md",
              "size": 11480,
              "estimatedReadTime": 9
            },
            {
              "type": "section",
              "name": "9.2-Interval-Practice",
              "title": "2 Interval Practice",
              "path": "09-Interval-DP/9.2-Interval-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Matrix-Chain-Multiplication.md",
                  "title": "Matrix Chain Multiplication",
                  "description": "> The canonical interval DP problem. This problem introduced the concept of \"optimal parenthesization\" and gave birth to interval DP. Understanding...",
                  "path": "09-Interval-DP/9.2-Interval-Practice/01-Matrix-Chain-Multiplication.md",
                  "size": 11522,
                  "estimatedReadTime": 9
                },
                {
                  "type": "chapter",
                  "name": "02-Burst-Balloons-LC312.md",
                  "title": "Burst Balloons (LC 312)",
                  "description": "> The ultimate interval DP problem. This problem seems impossible at first—how do you handle changing neighbors? The key insight is thinking BACKWA...",
                  "path": "09-Interval-DP/9.2-Interval-Practice/02-Burst-Balloons-LC312.md",
                  "size": 11652,
                  "estimatedReadTime": 10
                },
                {
                  "type": "chapter",
                  "name": "03-Min-Cost-Merge-Stones-LC1000.md",
                  "title": "Minimum Cost to Merge Stones (LC 1000)",
                  "description": "> Interval DP with a twist: K-way merging. Unlike simple merging where you combine 2 piles, this problem requires merging exactly K piles at a time...",
                  "path": "09-Interval-DP/9.2-Interval-Practice/03-Min-Cost-Merge-Stones-LC1000.md",
                  "size": 12380,
                  "estimatedReadTime": 11
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "10-String-DP",
          "title": "String DP",
          "path": "10-String-DP",
          "children": [
            {
              "type": "chapter",
              "name": "10.1-String-DP-Patterns.md",
              "title": "String DP Patterns",
              "description": "> String manipulation + Dynamic Programming = Powerful problem-solving. String DP problems involve building/matching/transforming strings optimally...",
              "path": "10-String-DP/10.1-String-DP-Patterns.md",
              "size": 11415,
              "estimatedReadTime": 9
            },
            {
              "type": "section",
              "name": "10.2-String-Practice",
              "title": "2 String Practice",
              "path": "10-String-DP/10.2-String-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Wildcard-Matching-LC44.md",
                  "title": "Wildcard Matching (LC 44)",
                  "description": "> Pattern matching with ? and . The wildcard  can match ANY sequence (including empty), making this simpler than regex but still requiring careful ...",
                  "path": "10-String-DP/10.2-String-Practice/01-Wildcard-Matching-LC44.md",
                  "size": 10259,
                  "estimatedReadTime": 9
                },
                {
                  "type": "chapter",
                  "name": "02-Distinct-Subsequences-LC115.md",
                  "title": "Distinct Subsequences (LC 115)",
                  "description": "> Counting, not just matching. How many ways can you form string t as a subsequence of string s? This is the counting variant of the subsequence ma...",
                  "path": "10-String-DP/10.2-String-Practice/02-Distinct-Subsequences-LC115.md",
                  "size": 10746,
                  "estimatedReadTime": 9
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "11-Tree-DP",
          "title": "Tree DP",
          "path": "11-Tree-DP",
          "children": [
            {
              "type": "chapter",
              "name": "11.1-Tree-DP-Patterns.md",
              "title": "Tree DP Patterns",
              "description": "> DP on trees: when recursion meets optimization. Tree DP combines the natural recursive structure of trees with dynamic programming to solve optim...",
              "path": "11-Tree-DP/11.1-Tree-DP-Patterns.md",
              "size": 11920,
              "estimatedReadTime": 9
            },
            {
              "type": "section",
              "name": "11.2-Tree-Practice",
              "title": "2 Tree Practice",
              "path": "11-Tree-DP/11.2-Tree-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-House-Robber-III-LC337.md",
                  "title": "House Robber III (LC 337)",
                  "description": "> The classic take-or-skip Tree DP problem. You can rob houses in a binary tree, but not two directly-linked houses. This perfectly demonstrates th...",
                  "path": "11-Tree-DP/11.2-Tree-Practice/01-House-Robber-III-LC337.md",
                  "size": 10577,
                  "estimatedReadTime": 9
                },
                {
                  "type": "chapter",
                  "name": "02-Max-Path-Sum-LC124.md",
                  "title": "Binary Tree Maximum Path Sum (LC 124)",
                  "description": "> The hardest Tree DP problem you'll face. This problem requires understanding the difference between paths that EXTEND to a parent versus paths th...",
                  "path": "11-Tree-DP/11.2-Tree-Practice/02-Max-Path-Sum-LC124.md",
                  "size": 11979,
                  "estimatedReadTime": 9
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "12-State-Machine-DP",
          "title": "State Machine DP",
          "path": "12-State-Machine-DP",
          "children": [
            {
              "type": "chapter",
              "name": "12.1-State-Machine-Patterns.md",
              "title": "State Machine DP Patterns",
              "description": "> When your problem has explicit states and transitions. State Machine DP models problems where you move between defined states, and the optimal so...",
              "path": "12-State-Machine-DP/12.1-State-Machine-Patterns.md",
              "size": 10594,
              "estimatedReadTime": 8
            },
            {
              "type": "section",
              "name": "12.2-State-Machine-Practice",
              "title": "2 State Machine Practice",
              "path": "12-State-Machine-DP/12.2-State-Machine-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Stock-Cooldown-LC309.md",
                  "title": "Best Time to Buy and Sell Stock with Cooldown (LC 309)",
                  "description": "> The quintessential State Machine DP problem. After selling a stock, you must wait one day before buying again. This \"cooldown\" naturally creates ...",
                  "path": "12-State-Machine-DP/12.2-State-Machine-Practice/01-Stock-Cooldown-LC309.md",
                  "size": 10612,
                  "estimatedReadTime": 9
                },
                {
                  "type": "chapter",
                  "name": "02-Stock-IV-LC188.md",
                  "title": "Best Time to Buy and Sell Stock IV (LC 188)",
                  "description": "> The generalized stock trading problem. At most K transactions allowed. This combines state machine thinking with the transaction count dimension,...",
                  "path": "12-State-Machine-DP/12.2-State-Machine-Practice/02-Stock-IV-LC188.md",
                  "size": 12263,
                  "estimatedReadTime": 10
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "13-Advanced-DP",
          "title": "Advanced DP",
          "path": "13-Advanced-DP",
          "children": [
            {
              "type": "chapter",
              "name": "13.1-Bitmask-DP.md",
              "title": "Bitmask DP Pattern",
              "description": "> When your state is a subset. Bitmask DP uses binary representation to track which elements have been selected. Perfect for problems with small se...",
              "path": "13-Advanced-DP/13.1-Bitmask-DP.md",
              "size": 11220,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "13.2-Digit-DP.md",
              "title": "Digit DP Pattern",
              "description": "> When counting numbers with specific digit properties. Digit DP systematically counts integers in a range that satisfy certain constraints on thei...",
              "path": "13-Advanced-DP/13.2-Digit-DP.md",
              "size": 12120,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "14-Interview-Focus",
          "title": "Interview Focus",
          "path": "14-Interview-Focus",
          "children": [
            {
              "type": "chapter",
              "name": "14.1-DP-Interview-Strategy.md",
              "title": "DP Interview Strategy",
              "description": "> How to recognize, approach, and communicate DP problems in interviews. This guide combines pattern recognition, systematic problem-solving, and c...",
              "path": "14-Interview-Focus/14.1-DP-Interview-Strategy.md",
              "size": 9792,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "14.2-Common-Patterns-Cheatsheet.md",
              "title": "DP Patterns Cheatsheet",
              "description": "> Quick reference for all DP patterns with templates, signals, and key insights.",
              "path": "14-Interview-Focus/14.2-Common-Patterns-Cheatsheet.md",
              "size": 12069,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "14.3-Problem-Recognition-Guide.md",
              "title": "DP Problem Recognition Guide",
              "description": "> Map problem signals to DP patterns instantly. This guide helps you recognize which DP pattern to apply based on problem keywords, structure, and ...",
              "path": "14-Interview-Focus/14.3-Problem-Recognition-Guide.md",
              "size": 12605,
              "estimatedReadTime": 9
            }
          ]
        }
      ],
      "stats": {
        "sections": 25,
        "chapters": 55
      }
    },
    "greedy-algorithms": {
      "id": "greedy-algorithms",
      "folderName": "12-Greedy-Algorithms",
      "chapters": [
        {
          "type": "section",
          "name": "01-Greedy-Fundamentals",
          "title": "Greedy Fundamentals",
          "path": "01-Greedy-Fundamentals",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-What-Is-Greedy.md",
              "title": "1.1 What Is Greedy?",
              "description": "> Definition: A greedy algorithm makes the locally optimal choice at each step, hoping that these local choices lead to a globally optimal solution.",
              "path": "01-Greedy-Fundamentals/1.1-What-Is-Greedy.md",
              "size": 11456,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "1.2-When-Greedy-Works.md",
              "title": "1.2 When Greedy Works",
              "description": "> Definition: Greedy algorithms work when the problem exhibits the Greedy Choice Property and Optimal Substructure—meaning local optimal choices le...",
              "path": "01-Greedy-Fundamentals/1.2-When-Greedy-Works.md",
              "size": 12488,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "1.3-Greedy-vs-DP.md",
              "title": "1.3 Greedy vs Dynamic Programming",
              "description": "> Definition: Greedy makes one choice per step and never reconsiders; DP explores all choices and combines optimal subproblem solutions. Use greedy...",
              "path": "01-Greedy-Fundamentals/1.3-Greedy-vs-DP.md",
              "size": 13261,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "2.1-Greedy-Stays-Ahead.md",
              "title": "2.1 Greedy Stays Ahead Proof",
              "description": "> Definition: The \"Greedy Stays Ahead\" proof technique shows that at every step, the greedy solution is at least as good as any other solution. If ...",
              "path": "01-Greedy-Fundamentals/2.1-Greedy-Stays-Ahead.md",
              "size": 11682,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "2.2-Exchange-Argument.md",
              "title": "2.2 Exchange Argument Proof",
              "description": "> Definition: The Exchange Argument proves greedy optimality by showing that any optimal solution differing from greedy can be transformed into gre...",
              "path": "01-Greedy-Fundamentals/2.2-Exchange-Argument.md",
              "size": 12956,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "3.0-Greedy-Problem-Solving-Framework.md",
              "title": "3.0 Greedy Problem-Solving Framework",
              "description": "> Definition: A systematic approach to solving greedy problems—from recognition to implementation to verification.",
              "path": "01-Greedy-Fundamentals/3.0-Greedy-Problem-Solving-Framework.md",
              "size": 11726,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "3.1-Greedy-Recognition-Guide.md",
              "title": "3.1 Greedy Recognition Guide",
              "description": "> Definition: A systematic method to identify whether a problem can be solved with a greedy approach, based on problem patterns, keywords, and stru...",
              "path": "01-Greedy-Fundamentals/3.1-Greedy-Recognition-Guide.md",
              "size": 14802,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "02-Interval-Pattern",
          "title": "Interval Pattern",
          "path": "02-Interval-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-Interval-Greedy-Overview.md",
              "title": "4.1 Interval Greedy Overview",
              "description": "> Definition: Interval problems involve collections of ranges [start, end] where we need to optimize some property—maximize non-overlapping, merge ...",
              "path": "02-Interval-Pattern/4.1-Interval-Greedy-Overview.md",
              "size": 11611,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "4.2-Sort-By-End-Pattern.md",
              "title": "4.2 Sort by End Time Pattern",
              "description": "> Definition: A greedy strategy for interval problems where sorting by ending time allows us to maximize the number of non-overlapping intervals se...",
              "path": "02-Interval-Pattern/4.2-Sort-By-End-Pattern.md",
              "size": 12983,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "4.3-Sort-By-Start-Pattern.md",
              "title": "4.3 Sort by Start Time Pattern",
              "description": "> Definition: A greedy strategy for interval problems where sorting by start time allows us to process intervals left-to-right, enabling merging an...",
              "path": "02-Interval-Pattern/4.3-Sort-By-Start-Pattern.md",
              "size": 14149,
              "estimatedReadTime": 10
            },
            {
              "type": "section",
              "name": "4.4-Interval-Practice",
              "title": "4 Interval Practice",
              "path": "02-Interval-Pattern/4.4-Interval-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "Meeting-Rooms-II.md",
                  "title": "Meeting Rooms II - Practice Problem",
                  "description": "> LeetCode 253: [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)",
                  "path": "02-Interval-Pattern/4.4-Interval-Practice/Meeting-Rooms-II.md",
                  "size": 9646,
                  "estimatedReadTime": 8
                },
                {
                  "type": "chapter",
                  "name": "Merge-Intervals.md",
                  "title": "Merge Intervals - Practice Problem",
                  "description": "> LeetCode 56: [Merge Intervals](https://leetcode.com/problems/merge-intervals/)",
                  "path": "02-Interval-Pattern/4.4-Interval-Practice/Merge-Intervals.md",
                  "size": 5233,
                  "estimatedReadTime": 4
                },
                {
                  "type": "chapter",
                  "name": "Min-Arrows.md",
                  "title": "Minimum Number of Arrows to Burst Balloons - Practice Problem",
                  "description": "> LeetCode 452: [Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)",
                  "path": "02-Interval-Pattern/4.4-Interval-Practice/Min-Arrows.md",
                  "size": 8142,
                  "estimatedReadTime": 7
                },
                {
                  "type": "chapter",
                  "name": "Non-Overlapping-Intervals.md",
                  "title": "Non-Overlapping Intervals - Practice Problem",
                  "description": "> LeetCode 435: [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)",
                  "path": "02-Interval-Pattern/4.4-Interval-Practice/Non-Overlapping-Intervals.md",
                  "size": 7385,
                  "estimatedReadTime": 6
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "03-Jump-Traversal-Pattern",
          "title": "Jump Traversal Pattern",
          "path": "03-Jump-Traversal-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "5.1-Jump-Greedy-Overview.md",
              "title": "5.1 Jump/Traversal Greedy Overview",
              "description": "> Definition: Jump and traversal problems involve moving through an array or graph where each position determines how far you can go next. Greedy a...",
              "path": "03-Jump-Traversal-Pattern/5.1-Jump-Greedy-Overview.md",
              "size": 10956,
              "estimatedReadTime": 9
            },
            {
              "type": "section",
              "name": "5.2-Jump-Practice",
              "title": "2 Jump Practice",
              "path": "03-Jump-Traversal-Pattern/5.2-Jump-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "Gas-Station.md",
                  "title": "Gas Station - Practice Problem",
                  "description": "> LeetCode 134: [Gas Station](https://leetcode.com/problems/gas-station/)",
                  "path": "03-Jump-Traversal-Pattern/5.2-Jump-Practice/Gas-Station.md",
                  "size": 10410,
                  "estimatedReadTime": 9
                },
                {
                  "type": "chapter",
                  "name": "Jump-Game-II.md",
                  "title": "Jump Game II - Practice Problem",
                  "description": "> LeetCode 45: [Jump Game II](https://leetcode.com/problems/jump-game-ii/)",
                  "path": "03-Jump-Traversal-Pattern/5.2-Jump-Practice/Jump-Game-II.md",
                  "size": 9197,
                  "estimatedReadTime": 8
                },
                {
                  "type": "chapter",
                  "name": "Jump-Game.md",
                  "title": "Jump Game - Practice Problem",
                  "description": "> LeetCode 55: [Jump Game](https://leetcode.com/problems/jump-game/)",
                  "path": "03-Jump-Traversal-Pattern/5.2-Jump-Practice/Jump-Game.md",
                  "size": 7650,
                  "estimatedReadTime": 7
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "04-Scheduling-Pattern",
          "title": "Scheduling Pattern",
          "path": "04-Scheduling-Pattern",
          "children": [
            {
              "type": "chapter",
              "name": "6.1-Scheduling-Greedy-Overview.md",
              "title": "6.1 Scheduling Greedy Overview",
              "description": "> Definition: Scheduling problems involve ordering jobs/tasks to optimize some objective—maximize profit, minimize delay, or complete the most jobs...",
              "path": "04-Scheduling-Pattern/6.1-Scheduling-Greedy-Overview.md",
              "size": 12640,
              "estimatedReadTime": 9
            },
            {
              "type": "section",
              "name": "6.2-Scheduling-Practice",
              "title": "2 Scheduling Practice",
              "path": "04-Scheduling-Pattern/6.2-Scheduling-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "Task-Scheduler.md",
                  "title": "Task Scheduler - Practice Problem",
                  "description": "> LeetCode 621: [Task Scheduler](https://leetcode.com/problems/task-scheduler/)",
                  "path": "04-Scheduling-Pattern/6.2-Scheduling-Practice/Task-Scheduler.md",
                  "size": 10256,
                  "estimatedReadTime": 9
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "05-Classic-Greedy",
          "title": "Classic Greedy",
          "path": "05-Classic-Greedy",
          "children": [
            {
              "type": "chapter",
              "name": "7.1-Classic-Problems-Overview.md",
              "title": "7.1 Classic Greedy Problems Overview",
              "description": "> Definition: Classic greedy problems are foundational algorithms that demonstrate core greedy principles—from Huffman coding to fractional knapsac...",
              "path": "05-Classic-Greedy/7.1-Classic-Problems-Overview.md",
              "size": 11739,
              "estimatedReadTime": 9
            },
            {
              "type": "section",
              "name": "7.2-Classic-Practice",
              "title": "2 Classic Practice",
              "path": "05-Classic-Greedy/7.2-Classic-Practice",
              "children": [
                {
                  "type": "chapter",
                  "name": "Assign-Cookies.md",
                  "title": "Assign Cookies (LeetCode 455)",
                  "description": "> Pattern: Sorting + Two Pointers Greedy",
                  "path": "05-Classic-Greedy/7.2-Classic-Practice/Assign-Cookies.md",
                  "size": 6453,
                  "estimatedReadTime": 6
                },
                {
                  "type": "chapter",
                  "name": "Candy.md",
                  "title": "Candy (LeetCode 135)",
                  "description": "> Pattern: Two-Pass Greedy",
                  "path": "05-Classic-Greedy/7.2-Classic-Practice/Candy.md",
                  "size": 8034,
                  "estimatedReadTime": 7
                },
                {
                  "type": "chapter",
                  "name": "Lemonade-Change.md",
                  "title": "Lemonade Change (LeetCode 860)",
                  "description": "> Pattern: Simulation Greedy",
                  "path": "05-Classic-Greedy/7.2-Classic-Practice/Lemonade-Change.md",
                  "size": 5817,
                  "estimatedReadTime": 5
                },
                {
                  "type": "chapter",
                  "name": "Two-City-Scheduling.md",
                  "title": "Two City Scheduling (LeetCode 1029)",
                  "description": "> Pattern: Difference Greedy (Cost Comparison)",
                  "path": "05-Classic-Greedy/7.2-Classic-Practice/Two-City-Scheduling.md",
                  "size": 7232,
                  "estimatedReadTime": 7
                }
              ]
            }
          ]
        },
        {
          "type": "section",
          "name": "06-Greedy-Techniques",
          "title": "Greedy Techniques",
          "path": "06-Greedy-Techniques",
          "children": [
            {
              "type": "chapter",
              "name": "8.1-Two-Pass-Greedy.md",
              "title": "8.1 Two-Pass Greedy Technique",
              "description": "> Definition: Two-pass greedy processes data in two opposite directions (left-to-right then right-to-left), combining results to satisfy constraint...",
              "path": "06-Greedy-Techniques/8.1-Two-Pass-Greedy.md",
              "size": 9566,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "8.2-Greedy-With-Heap.md",
              "title": "8.2 Greedy with Heap Technique",
              "description": "> Definition: Greedy with Heap combines greedy decision-making with a heap (priority queue) to efficiently access the best choice at each step.",
              "path": "06-Greedy-Techniques/8.2-Greedy-With-Heap.md",
              "size": 10193,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "8.3-Sorting-Tricks.md",
              "title": "8.3 Greedy Sorting Tricks",
              "description": "> Definition: Many greedy problems require specific sorting strategies to enable optimal choices. The sorting criterion is often the key insight th...",
              "path": "06-Greedy-Techniques/8.3-Sorting-Tricks.md",
              "size": 8992,
              "estimatedReadTime": 7
            }
          ]
        },
        {
          "type": "section",
          "name": "07-Additional-Practice",
          "title": "Additional Practice",
          "path": "07-Additional-Practice",
          "children": [
            {
              "type": "chapter",
              "name": "Boats-To-Save-People.md",
              "title": "Boats to Save People (LeetCode 881)",
              "description": "> Pattern: Two Pointers Greedy",
              "path": "07-Additional-Practice/Boats-To-Save-People.md",
              "size": 6379,
              "estimatedReadTime": 6
            },
            {
              "type": "chapter",
              "name": "Maximum-Subarray.md",
              "title": "Maximum Subarray (LeetCode 53) - Greedy View",
              "description": "> Pattern: Greedy Running Maximum (Kadane's Algorithm)",
              "path": "07-Additional-Practice/Maximum-Subarray.md",
              "size": 7977,
              "estimatedReadTime": 6
            },
            {
              "type": "chapter",
              "name": "Partition-Labels.md",
              "title": "Partition Labels (LeetCode 763)",
              "description": "> Pattern: Greedy with Last Occurrence",
              "path": "07-Additional-Practice/Partition-Labels.md",
              "size": 6933,
              "estimatedReadTime": 6
            }
          ]
        },
        {
          "type": "section",
          "name": "08-Interview-Focus",
          "title": "Interview Focus",
          "path": "08-Interview-Focus",
          "children": [
            {
              "type": "chapter",
              "name": "9.1-Interview-Prep-Guide.md",
              "title": "Greedy Interview Preparation Guide",
              "description": "> Your complete guide to greedy algorithm interviews",
              "path": "08-Interview-Focus/9.1-Interview-Prep-Guide.md",
              "size": 8466,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "9.2-Pattern-Cheat-Sheet.md",
              "title": "Greedy Patterns Cheat Sheet",
              "description": "> Quick reference for all greedy patterns in one place",
              "path": "08-Interview-Focus/9.2-Pattern-Cheat-Sheet.md",
              "size": 6259,
              "estimatedReadTime": 6
            },
            {
              "type": "chapter",
              "name": "9.3-Company-Specific-Focus.md",
              "title": "Company-Specific Greedy Focus",
              "description": "> What each major company emphasizes in greedy interviews",
              "path": "08-Interview-Focus/9.3-Company-Specific-Focus.md",
              "size": 6914,
              "estimatedReadTime": 6
            }
          ]
        }
      ],
      "stats": {
        "sections": 12,
        "chapters": 34
      }
    },
    "tries": {
      "id": "tries",
      "folderName": "13-Tries",
      "chapters": [
        {
          "type": "section",
          "name": "01-Trie-Fundamentals",
          "title": "Trie Fundamentals",
          "path": "01-Trie-Fundamentals",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-What-Is-Trie.md",
              "title": "What Is a Trie?",
              "description": "> A Trie (pronounced \"try\") is a tree-like data structure that stores strings character by character, enabling blazing-fast prefix operations.",
              "path": "01-Trie-Fundamentals/1.1-What-Is-Trie.md",
              "size": 10617,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "2.1-TrieNode-Structure.md",
              "title": "TrieNode Structure",
              "description": "> The TrieNode is the building block of every Trie - understanding its design is crucial for implementing efficient Trie operations.",
              "path": "01-Trie-Fundamentals/2.1-TrieNode-Structure.md",
              "size": 14209,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "2.2-Trie-Class-Design.md",
              "title": "Trie Class Design",
              "description": "> A complete Trie class combines the TrieNode structure with Insert, Search, StartsWith, and optionally Delete operations into a cohesive data stru...",
              "path": "01-Trie-Fundamentals/2.2-Trie-Class-Design.md",
              "size": 14507,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "02-Trie-Operations",
          "title": "Trie Operations",
          "path": "02-Trie-Operations",
          "children": [
            {
              "type": "chapter",
              "name": "3.1-Insert-Operation.md",
              "title": "Trie Insert Operation",
              "description": "> Insert adds words to the Trie character by character, creating new nodes as needed and marking word endings.",
              "path": "02-Trie-Operations/3.1-Insert-Operation.md",
              "size": 14050,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "3.2-Search-Operation.md",
              "title": "Trie Search Operation",
              "description": "> Search checks if an exact word exists in the Trie - it must traverse all characters AND verify the end marker is set.",
              "path": "02-Trie-Operations/3.2-Search-Operation.md",
              "size": 12831,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "3.3-StartsWith-Prefix.md",
              "title": "Trie StartsWith (Prefix) Operation",
              "description": "> StartsWith checks if ANY word in the Trie begins with a given prefix - this is Trie's killer feature that Hash Maps can't do efficiently.",
              "path": "02-Trie-Operations/3.3-StartsWith-Prefix.md",
              "size": 13902,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "3.4-Delete-Operation.md",
              "title": "Trie Delete Operation",
              "description": "> Delete removes a word from the Trie while preserving other words that share prefixes - the trickiest Trie operation requiring careful node cleanup.",
              "path": "02-Trie-Operations/3.4-Delete-Operation.md",
              "size": 14592,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "03-Trie-Patterns",
          "title": "Trie Patterns",
          "path": "03-Trie-Patterns",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-Wildcard-Search.md",
              "title": "Wildcard Search Pattern",
              "description": "> Wildcard search allows matching patterns with special characters like '.' that can match any single character - this requires DFS/backtracking on...",
              "path": "03-Trie-Patterns/4.1-Wildcard-Search.md",
              "size": 12704,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "4.2-Trie-Plus-Backtracking.md",
              "title": "Trie + Backtracking Pattern",
              "description": "> Trie + Backtracking is the killer combination for grid word search problems - use Trie to prune invalid paths early and backtracking to explore a...",
              "path": "03-Trie-Patterns/4.2-Trie-Plus-Backtracking.md",
              "size": 13622,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "4.3-Collect-All-Words.md",
              "title": "Collect All Words Pattern",
              "description": "> Use DFS on a Trie to enumerate all words matching a prefix - the foundation for autocomplete, suggestions, and word enumeration.",
              "path": "03-Trie-Patterns/4.3-Collect-All-Words.md",
              "size": 12670,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "4.4-Prefix-Matching.md",
              "title": "Prefix Matching Pattern",
              "description": "> Find the shortest/longest prefix in the dictionary that matches a word - used for word replacement, IP routing, and dictionary-based transformati...",
              "path": "03-Trie-Patterns/4.4-Prefix-Matching.md",
              "size": 12506,
              "estimatedReadTime": 8
            }
          ]
        },
        {
          "type": "section",
          "name": "04-Bit-Trie",
          "title": "Bit Trie",
          "path": "04-Bit-Trie",
          "children": [
            {
              "type": "chapter",
              "name": "5.1-Bit-Trie-Fundamentals.md",
              "title": "Bit Trie (Binary Trie) Fundamentals",
              "description": "> A specialized Trie where each edge represents a single bit (0 or 1). Essential for XOR-based problems and bit manipulation.",
              "path": "04-Bit-Trie/5.1-Bit-Trie-Fundamentals.md",
              "size": 12349,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "5.2-Maximum-XOR.md",
              "title": "LC 421: Maximum XOR of Two Numbers in an Array",
              "description": "> The definitive Bit Trie problem. Find the maximum XOR of any two numbers in an array using greedy bit selection.",
              "path": "04-Bit-Trie/5.2-Maximum-XOR.md",
              "size": 9883,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "5.3-Max-XOR-With-Element.md",
              "title": "LC 1707: Maximum XOR With an Element From Array",
              "description": "> Extension of Maximum XOR with an added constraint: the number must be ≤ a threshold. Combine Bit Trie with offline processing.",
              "path": "04-Bit-Trie/5.3-Max-XOR-With-Element.md",
              "size": 10189,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "5.4-Count-XOR-Pairs.md",
              "title": "LC 1803: Count Pairs With XOR in a Range",
              "description": "> Advanced Bit Trie problem: count pairs where XOR falls within [low, high]. Uses prefix count technique.",
              "path": "04-Bit-Trie/5.4-Count-XOR-Pairs.md",
              "size": 9273,
              "estimatedReadTime": 8
            }
          ]
        },
        {
          "type": "section",
          "name": "05-Trie-Variations",
          "title": "Trie Variations",
          "path": "05-Trie-Variations",
          "children": [
            {
              "type": "chapter",
              "name": "4.5-Trie-Variations.md",
              "title": "Trie Variations",
              "description": "> Beyond the basic character Trie: specialized structures for different use cases including Suffix Trie, Compressed Trie (Radix Tree), and Ternary ...",
              "path": "05-Trie-Variations/4.5-Trie-Variations.md",
              "size": 11580,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "4.6-Space-Time-Tradeoffs.md",
              "title": "Space vs Time Trade-offs in Trie Implementations",
              "description": "> Understanding when to use HashMap vs Array[26] and other memory optimization techniques.",
              "path": "05-Trie-Variations/4.6-Space-Time-Tradeoffs.md",
              "size": 9281,
              "estimatedReadTime": 7
            }
          ]
        },
        {
          "type": "section",
          "name": "06-Applications",
          "title": "Applications",
          "path": "06-Applications",
          "children": [
            {
              "type": "chapter",
              "name": "7.1-Autocomplete-System.md",
              "title": "Design Autocomplete System",
              "description": "> Real-world Trie application: Build a search autocomplete system that suggests top-k completions based on frequency.",
              "path": "06-Applications/7.1-Autocomplete-System.md",
              "size": 9983,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "7.2-Spell-Checker.md",
              "title": "Spell Checker with Trie",
              "description": "> Build a spell checker that suggests corrections for misspelled words using Trie + edit distance techniques.",
              "path": "06-Applications/7.2-Spell-Checker.md",
              "size": 14257,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "7.3-IP-Routing.md",
              "title": "IP Routing Table (Longest Prefix Match)",
              "description": "> Trie application in networking: Efficiently find the longest matching prefix for IP address routing using a Binary Trie.",
              "path": "06-Applications/7.3-IP-Routing.md",
              "size": 12521,
              "estimatedReadTime": 8
            }
          ]
        },
        {
          "type": "section",
          "name": "07-Practice-Problems",
          "title": "Practice Problems",
          "path": "07-Practice-Problems",
          "children": [
            {
              "type": "chapter",
              "name": "6.1-Implement-Trie.md",
              "title": "LC 208: Implement Trie (Prefix Tree)",
              "description": "> The foundational Trie problem - master this and you've mastered 50% of Trie interviews.",
              "path": "07-Practice-Problems/6.1-Implement-Trie.md",
              "size": 7721,
              "estimatedReadTime": 6
            },
            {
              "type": "chapter",
              "name": "6.2-Add-Search-Words.md",
              "title": "LC 211: Design Add and Search Words Data Structure",
              "description": "> The classic wildcard search problem - extends basic Trie with DFS for '.' pattern matching.",
              "path": "07-Practice-Problems/6.2-Add-Search-Words.md",
              "size": 9493,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "6.3-Word-Search-II.md",
              "title": "LC 212: Word Search II",
              "description": "> The ultimate Trie problem - combines Trie with grid backtracking. Master this and you've mastered Tries.",
              "path": "07-Practice-Problems/6.3-Word-Search-II.md",
              "size": 10832,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "6.4-Search-Suggestions.md",
              "title": "LC 1268: Search Suggestions System",
              "description": "> Real-world autocomplete implementation - use Trie to return top 3 lexicographically sorted suggestions for each prefix.",
              "path": "07-Practice-Problems/6.4-Search-Suggestions.md",
              "size": 11994,
              "estimatedReadTime": 8
            }
          ]
        },
        {
          "type": "section",
          "name": "08-Interview-Focus",
          "title": "Interview Focus",
          "path": "08-Interview-Focus",
          "children": [
            {
              "type": "chapter",
              "name": "8.1-Quick-Reference.md",
              "title": "Trie Interview Quick Reference",
              "description": "> One-page reference for Trie concepts during interview prep. Print this out or review before interviews.",
              "path": "08-Interview-Focus/8.1-Quick-Reference.md",
              "size": 5518,
              "estimatedReadTime": 5
            },
            {
              "type": "chapter",
              "name": "8.2-Common-Mistakes.md",
              "title": "Trie Common Mistakes & Edge Cases",
              "description": "> Compilation of frequent errors when implementing Tries and how to avoid them.",
              "path": "08-Interview-Focus/8.2-Common-Mistakes.md",
              "size": 7950,
              "estimatedReadTime": 6
            },
            {
              "type": "chapter",
              "name": "8.3-Practice-Roadmap.md",
              "title": "Trie Practice Roadmap",
              "description": "> Structured 2-week practice plan to master Tries for coding interviews.",
              "path": "08-Interview-Focus/8.3-Practice-Roadmap.md",
              "size": 7589,
              "estimatedReadTime": 7
            }
          ]
        }
      ],
      "stats": {
        "sections": 8,
        "chapters": 27
      }
    },
    "advanced-data-structures": {
      "id": "advanced-data-structures",
      "folderName": "14-Advanced-Data-Structures",
      "chapters": [
        {
          "type": "section",
          "name": "01-Union-Find",
          "title": "Union Find",
          "path": "01-Union-Find",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-Union-Find-Fundamentals.md",
              "title": "Union-Find (Disjoint Set Union) Fundamentals",
              "description": "> The go-to data structure for tracking connected components and grouping relationships.",
              "path": "01-Union-Find/1.1-Union-Find-Fundamentals.md",
              "size": 14021,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "1.2-Basic-Implementation.md",
              "title": "Basic Union-Find Implementation",
              "description": "> Start with the naive approach to understand the core ideas, then optimize.",
              "path": "01-Union-Find/1.2-Basic-Implementation.md",
              "size": 8316,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "1.3-Optimizations.md",
              "title": "Union-Find: Optimizations",
              "description": "> Path Compression + Union by Rank = Near O(1) for all operations",
              "path": "01-Union-Find/1.3-Optimizations.md",
              "size": 14308,
              "estimatedReadTime": 9
            },
            {
              "type": "section",
              "name": "1.4-Advanced-Patterns",
              "title": "4 Advanced Patterns",
              "path": "01-Union-Find/1.4-Advanced-Patterns",
              "children": [
                {
                  "type": "chapter",
                  "name": "01-Connected-Components.md",
                  "title": "Connected Components Pattern",
                  "description": "> The most common Union-Find application: counting and tracking groups.",
                  "path": "01-Union-Find/1.4-Advanced-Patterns/01-Connected-Components.md",
                  "size": 9918,
                  "estimatedReadTime": 7
                },
                {
                  "type": "chapter",
                  "name": "02-Cycle-Detection.md",
                  "title": "Cycle Detection with Union-Find",
                  "description": "> Detect cycles in undirected graphs: if two nodes are already connected, adding an edge creates a cycle.",
                  "path": "01-Union-Find/1.4-Advanced-Patterns/02-Cycle-Detection.md",
                  "size": 9327,
                  "estimatedReadTime": 8
                },
                {
                  "type": "chapter",
                  "name": "03-Dynamic-Connectivity.md",
                  "title": "Dynamic Connectivity",
                  "description": "> Handle connectivity queries as edges are added incrementally (online).",
                  "path": "01-Union-Find/1.4-Advanced-Patterns/03-Dynamic-Connectivity.md",
                  "size": 11223,
                  "estimatedReadTime": 9
                },
                {
                  "type": "chapter",
                  "name": "04-Union-Find-Variations.md",
                  "title": "Union-Find Variations",
                  "description": "> Advanced Union-Find patterns for complex problems: weighted Union-Find, grouping by property, and path tracking.",
                  "path": "01-Union-Find/1.4-Advanced-Patterns/04-Union-Find-Variations.md",
                  "size": 15034,
                  "estimatedReadTime": 10
                }
              ]
            },
            {
              "type": "chapter",
              "name": "1.5-Practice-Problems.md",
              "title": "Union-Find Practice Problems",
              "description": "> Curated problem set for mastering Union-Find patterns.",
              "path": "01-Union-Find/1.5-Practice-Problems.md",
              "size": 7789,
              "estimatedReadTime": 6
            }
          ]
        },
        {
          "type": "section",
          "name": "02-LRU-Cache",
          "title": "LRU Cache",
          "path": "02-LRU-Cache",
          "children": [
            {
              "type": "chapter",
              "name": "2.1-Cache-Fundamentals.md",
              "title": "Cache Fundamentals",
              "description": "> Understanding caching principles before diving into implementations.",
              "path": "02-LRU-Cache/2.1-Cache-Fundamentals.md",
              "size": 8569,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "2.2-LRU-Implementation.md",
              "title": "LRU Cache Implementation",
              "description": "> The classic design interview question: O(1) get and put with LRU eviction.",
              "path": "02-LRU-Cache/2.2-LRU-Implementation.md",
              "size": 12241,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "2.3-LFU-Cache.md",
              "title": "LFU Cache",
              "description": "> Least Frequently Used: Evict the item with lowest access count.",
              "path": "02-LRU-Cache/2.3-LFU-Cache.md",
              "size": 11281,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "2.4-Cache-Practice.md",
              "title": "Cache Practice Problems",
              "description": "> Practice problems for mastering cache design patterns.",
              "path": "02-LRU-Cache/2.4-Cache-Practice.md",
              "size": 7561,
              "estimatedReadTime": 6
            }
          ]
        },
        {
          "type": "section",
          "name": "03-Segment-Tree",
          "title": "Segment Tree",
          "path": "03-Segment-Tree",
          "children": [
            {
              "type": "chapter",
              "name": "3.1-Segment-Tree-Fundamentals.md",
              "title": "Segment Tree Fundamentals",
              "description": "> Answer range queries and perform point/range updates in O(log n) time.",
              "path": "03-Segment-Tree/3.1-Segment-Tree-Fundamentals.md",
              "size": 10966,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "3.2-Build-Query-Update.md",
              "title": "Segment Tree: Build, Query, Update",
              "description": "> Deep dive into the three core operations of Segment Trees.",
              "path": "03-Segment-Tree/3.2-Build-Query-Update.md",
              "size": 10316,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "3.3-Lazy-Propagation.md",
              "title": "Lazy Propagation",
              "description": "> Efficiently handle range updates in O(log n) instead of O(n).",
              "path": "03-Segment-Tree/3.3-Lazy-Propagation.md",
              "size": 12780,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "3.4-Segment-Tree-Problems.md",
              "title": "Segment Tree Practice Problems",
              "description": "> Curated problems for mastering Segment Trees.",
              "path": "03-Segment-Tree/3.4-Segment-Tree-Problems.md",
              "size": 8178,
              "estimatedReadTime": 6
            }
          ]
        },
        {
          "type": "section",
          "name": "04-Fenwick-Tree",
          "title": "Fenwick Tree",
          "path": "04-Fenwick-Tree",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-BIT-Fundamentals.md",
              "title": "Binary Indexed Tree (Fenwick Tree) Fundamentals",
              "description": "> A simpler, space-efficient alternative to Segment Trees for prefix sum operations.",
              "path": "04-Fenwick-Tree/4.1-BIT-Fundamentals.md",
              "size": 8408,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "4.2-BIT-Operations.md",
              "title": "BIT Operations & Applications",
              "description": "> Advanced BIT operations: range updates, 2D queries, and practical applications.",
              "path": "04-Fenwick-Tree/4.2-BIT-Operations.md",
              "size": 8766,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "4.3-BIT-vs-Segment-Tree.md",
              "title": "BIT vs Segment Tree: When to Use Which",
              "description": "> A practical comparison to help you choose the right data structure.",
              "path": "04-Fenwick-Tree/4.3-BIT-vs-Segment-Tree.md",
              "size": 7424,
              "estimatedReadTime": 6
            }
          ]
        },
        {
          "type": "section",
          "name": "05-Other-Structures",
          "title": "Other Structures",
          "path": "05-Other-Structures",
          "children": [
            {
              "type": "chapter",
              "name": "5.1-Sparse-Table.md",
              "title": "Sparse Table",
              "description": "> O(1) range minimum/maximum queries on static arrays after O(n log n) preprocessing.",
              "path": "05-Other-Structures/5.1-Sparse-Table.md",
              "size": 5944,
              "estimatedReadTime": 5
            },
            {
              "type": "chapter",
              "name": "5.2-Skip-List.md",
              "title": "Skip List",
              "description": "> A probabilistic data structure providing O(log n) average search, insert, delete.",
              "path": "05-Other-Structures/5.2-Skip-List.md",
              "size": 6637,
              "estimatedReadTime": 5
            },
            {
              "type": "chapter",
              "name": "5.3-Monotonic-Review.md",
              "title": "Monotonic Stack/Queue Review",
              "description": "> Quick reference for monotonic data structures commonly used in interviews.",
              "path": "05-Other-Structures/5.3-Monotonic-Review.md",
              "size": 4979,
              "estimatedReadTime": 4
            },
            {
              "type": "chapter",
              "name": "5.4-Ordered-Set.md",
              "title": "Ordered Set (TreeSet/TreeMap)",
              "description": "> Self-balancing BST-based containers providing O(log n) ordered operations.",
              "path": "05-Other-Structures/5.4-Ordered-Set.md",
              "size": 6246,
              "estimatedReadTime": 5
            },
            {
              "type": "chapter",
              "name": "5.5-Bloom-Filter.md",
              "title": "Bloom Filter",
              "description": "> A space-efficient probabilistic data structure for membership testing.",
              "path": "05-Other-Structures/5.5-Bloom-Filter.md",
              "size": 6361,
              "estimatedReadTime": 5
            }
          ]
        },
        {
          "type": "section",
          "name": "06-Interview-Focus",
          "title": "Interview Focus",
          "path": "06-Interview-Focus",
          "children": [
            {
              "type": "chapter",
              "name": "6.1-Quick-Reference.md",
              "title": "Advanced Data Structures - Quick Reference",
              "description": "> One-page cheat sheet for interview preparation.",
              "path": "06-Interview-Focus/6.1-Quick-Reference.md",
              "size": 6521,
              "estimatedReadTime": 5
            },
            {
              "type": "chapter",
              "name": "6.2-Common-Mistakes.md",
              "title": "Common Mistakes in Advanced Data Structures",
              "description": "> Learn from these pitfalls to write bug-free code in interviews.",
              "path": "06-Interview-Focus/6.2-Common-Mistakes.md",
              "size": 7348,
              "estimatedReadTime": 6
            },
            {
              "type": "chapter",
              "name": "6.3-Practice-Roadmap.md",
              "title": "Advanced Data Structures - Practice Roadmap",
              "description": "> Structured study plan from fundamentals to interview-ready.",
              "path": "06-Interview-Focus/6.3-Practice-Roadmap.md",
              "size": 7852,
              "estimatedReadTime": 5
            }
          ]
        }
      ],
      "stats": {
        "sections": 7,
        "chapters": 27
      }
    },
    "bit-manipulation": {
      "id": "bit-manipulation",
      "folderName": "15-Bit-Manipulation",
      "chapters": [
        {
          "type": "section",
          "name": "01-Fundamentals",
          "title": "Fundamentals",
          "path": "01-Fundamentals",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-Binary-Basics.md",
              "title": "Binary Number Basics",
              "description": "> The foundation of all bit manipulation.",
              "path": "01-Fundamentals/1.1-Binary-Basics.md",
              "size": 7231,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "1.2-Bitwise-Operators.md",
              "title": "Bitwise Operators",
              "description": "> The six fundamental operations on bits.",
              "path": "01-Fundamentals/1.2-Bitwise-Operators.md",
              "size": 7974,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "1.3-Twos-Complement.md",
              "title": "Two's Complement",
              "description": "> How computers represent negative numbers.",
              "path": "01-Fundamentals/1.3-Twos-Complement.md",
              "size": 7128,
              "estimatedReadTime": 6
            }
          ]
        },
        {
          "type": "section",
          "name": "02-Bit-Tricks",
          "title": "Bit Tricks",
          "path": "02-Bit-Tricks",
          "children": [
            {
              "type": "chapter",
              "name": "2.1-Essential-Tricks.md",
              "title": "Essential Bit Tricks",
              "description": "> The core bit manipulation operations every developer must know.",
              "path": "02-Bit-Tricks/2.1-Essential-Tricks.md",
              "size": 10343,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "2.2-Counting-Bits.md",
              "title": "Counting Bits",
              "description": "> Multiple approaches to count set bits - from basic to Brian Kernighan's algorithm.",
              "path": "02-Bit-Tricks/2.2-Counting-Bits.md",
              "size": 9738,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "2.3-Power-Of-Two.md",
              "title": "Power of Two & Power of Four",
              "description": "> Using bit patterns to detect powers of 2 and 4.",
              "path": "02-Bit-Tricks/2.3-Power-Of-Two.md",
              "size": 9479,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "03-XOR-Patterns",
          "title": "XOR Patterns",
          "path": "03-XOR-Patterns",
          "children": [
            {
              "type": "chapter",
              "name": "3.1-XOR-Properties.md",
              "title": "XOR Properties",
              "description": "> The foundation of bit manipulation problem solving.",
              "path": "03-XOR-Patterns/3.1-XOR-Properties.md",
              "size": 8622,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "3.2-Single-Number-Variants.md",
              "title": "Single Number Variants",
              "description": "> The most common XOR interview problems - master all three.",
              "path": "03-XOR-Patterns/3.2-Single-Number-Variants.md",
              "size": 11650,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "3.3-XOR-Applications.md",
              "title": "XOR Applications",
              "description": "> Beyond Single Number: practical XOR applications for interviews.",
              "path": "03-XOR-Patterns/3.3-XOR-Applications.md",
              "size": 11586,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "04-Bitmask-Patterns",
          "title": "Bitmask Patterns",
          "path": "04-Bitmask-Patterns",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-Subset-Generation.md",
              "title": "Subset Generation with Bitmasks",
              "description": "> Generate all 2^n subsets of a set using bit manipulation.",
              "path": "04-Bitmask-Patterns/4.1-Subset-Generation.md",
              "size": 9412,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "4.2-State-Compression.md",
              "title": "State Compression with Bitmasks",
              "description": "> Represent complex states in a single integer for efficient manipulation.",
              "path": "04-Bitmask-Patterns/4.2-State-Compression.md",
              "size": 10828,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "4.3-Bitmask-DP.md",
              "title": "Bitmask Dynamic Programming",
              "description": "> Combine state compression with DP for exponential state spaces.",
              "path": "04-Bitmask-Patterns/4.3-Bitmask-DP.md",
              "size": 12637,
              "estimatedReadTime": 9
            }
          ]
        },
        {
          "type": "section",
          "name": "05-Arithmetic-With-Bits",
          "title": "Arithmetic With Bits",
          "path": "05-Arithmetic-With-Bits",
          "children": [
            {
              "type": "chapter",
              "name": "5.1-Addition-Without-Plus.md",
              "title": "Addition Without Plus Operator",
              "description": "> Add two integers using only bitwise operations.",
              "path": "05-Arithmetic-With-Bits/5.1-Addition-Without-Plus.md",
              "size": 8774,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "5.2-Division-With-Shifts.md",
              "title": "Division With Bit Shifts",
              "description": "> Divide integers using only bit operations.",
              "path": "05-Arithmetic-With-Bits/5.2-Division-With-Shifts.md",
              "size": 10073,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "5.3-Multiplication-Division.md",
              "title": "Multiplication and Division with Shifts",
              "description": "> Use bit shifts for fast multiplication and division by powers of 2.",
              "path": "05-Arithmetic-With-Bits/5.3-Multiplication-Division.md",
              "size": 9848,
              "estimatedReadTime": 8
            }
          ]
        },
        {
          "type": "section",
          "name": "06-Interview-Focus",
          "title": "Interview Focus",
          "path": "06-Interview-Focus",
          "children": [
            {
              "type": "chapter",
              "name": "6.1-Quick-Reference.md",
              "title": "Bit Manipulation Quick Reference",
              "description": "> Cheat sheet for bit manipulation operations, formulas, and patterns.",
              "path": "06-Interview-Focus/6.1-Quick-Reference.md",
              "size": 6581,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "6.2-Common-Mistakes.md",
              "title": "Common Bit Manipulation Mistakes",
              "description": "> Avoid these pitfalls that trip up even experienced developers.",
              "path": "06-Interview-Focus/6.2-Common-Mistakes.md",
              "size": 9113,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "6.3-Practice-Roadmap.md",
              "title": "Bit Manipulation Practice Roadmap",
              "description": "> A structured path from zero to interview-ready in 2 weeks.",
              "path": "06-Interview-Focus/6.3-Practice-Roadmap.md",
              "size": 9179,
              "estimatedReadTime": 8
            }
          ]
        }
      ],
      "stats": {
        "sections": 6,
        "chapters": 18
      }
    },
    "math-number-theory": {
      "id": "math-number-theory",
      "folderName": "16-Math-Number-Theory",
      "chapters": [
        {
          "type": "section",
          "name": "01-Fundamentals",
          "title": "Fundamentals",
          "path": "01-Fundamentals",
          "children": [
            {
              "type": "chapter",
              "name": "1.1-Arithmetic-Basics.md",
              "title": "Arithmetic Basics",
              "description": "> Foundation of numerical operations for DSA.",
              "path": "01-Fundamentals/1.1-Arithmetic-Basics.md",
              "size": 11605,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "1.2-Modular-Arithmetic.md",
              "title": "Modular Arithmetic",
              "description": "> Essential for handling large numbers in competitive programming.",
              "path": "01-Fundamentals/1.2-Modular-Arithmetic.md",
              "size": 10493,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "1.3-Fast-Power.md",
              "title": "Fast Power (Binary Exponentiation)",
              "description": "> Compute a^n in O(log n) time.",
              "path": "01-Fundamentals/1.3-Fast-Power.md",
              "size": 12979,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "02-GCD-LCM",
          "title": "GCD LCM",
          "path": "02-GCD-LCM",
          "children": [
            {
              "type": "chapter",
              "name": "2.1-Euclidean-Algorithm.md",
              "title": "Euclidean Algorithm (GCD)",
              "description": "> The most efficient way to compute the Greatest Common Divisor.",
              "path": "02-GCD-LCM/2.1-Euclidean-Algorithm.md",
              "size": 7492,
              "estimatedReadTime": 7
            },
            {
              "type": "chapter",
              "name": "2.2-Extended-GCD.md",
              "title": "Extended Euclidean Algorithm",
              "description": "> Find integers x, y such that ax + by = gcd(a, b)",
              "path": "02-GCD-LCM/2.2-Extended-GCD.md",
              "size": 10436,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "2.3-GCD-Applications.md",
              "title": "GCD Applications (Interview Problems)",
              "description": "> Real interview problems using GCD patterns.",
              "path": "02-GCD-LCM/2.3-GCD-Applications.md",
              "size": 11572,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "03-Prime-Numbers",
          "title": "Prime Numbers",
          "path": "03-Prime-Numbers",
          "children": [
            {
              "type": "chapter",
              "name": "3.1-Prime-Basics.md",
              "title": "Prime Number Basics",
              "description": "> Foundation for divisibility, factorization, and many number theory problems.",
              "path": "03-Prime-Numbers/3.1-Prime-Basics.md",
              "size": 12013,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "3.2-Sieve-of-Eratosthenes.md",
              "title": "Sieve of Eratosthenes",
              "description": "> The most efficient way to find all primes up to n.",
              "path": "03-Prime-Numbers/3.2-Sieve-of-Eratosthenes.md",
              "size": 12864,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "3.3-Factorial-Trailing-Zeros.md",
              "title": "Factorial and Trailing Zeros",
              "description": "> Count factors of a prime in factorial - a classic interview problem.",
              "path": "03-Prime-Numbers/3.3-Factorial-Trailing-Zeros.md",
              "size": 11746,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "04-Combinatorics",
          "title": "Combinatorics",
          "path": "04-Combinatorics",
          "children": [
            {
              "type": "chapter",
              "name": "4.1-nCr-Basics.md",
              "title": "nCr Basics (Combinations)",
              "description": "> Count ways to choose r items from n items without order.",
              "path": "04-Combinatorics/4.1-nCr-Basics.md",
              "size": 12107,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "4.2-Pascals-Triangle.md",
              "title": "Pascal's Triangle Properties",
              "description": "> The visual representation of binomial coefficients.",
              "path": "04-Combinatorics/4.2-Pascals-Triangle.md",
              "size": 9974,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "4.3-Catalan-Numbers.md",
              "title": "Catalan Numbers",
              "description": "> The sequence that counts parentheses, trees, paths, and more.",
              "path": "04-Combinatorics/4.3-Catalan-Numbers.md",
              "size": 10424,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "4.4-Stars-and-Bars.md",
              "title": "Stars and Bars (Multisets)",
              "description": "> Count ways to distribute identical items into distinct groups.",
              "path": "04-Combinatorics/4.4-Stars-and-Bars.md",
              "size": 11627,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "05-Modular-Inverse",
          "title": "Modular Inverse",
          "path": "05-Modular-Inverse",
          "children": [
            {
              "type": "chapter",
              "name": "5.1-Modular-Inverse-Basics.md",
              "title": "Modular Inverse Basics",
              "description": "> Division in modular arithmetic requires the multiplicative inverse.",
              "path": "05-Modular-Inverse/5.1-Modular-Inverse-Basics.md",
              "size": 10219,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "5.2-Chinese-Remainder-Theorem.md",
              "title": "Chinese Remainder Theorem (CRT)",
              "description": "> Find a number that satisfies multiple modular conditions simultaneously.",
              "path": "05-Modular-Inverse/5.2-Chinese-Remainder-Theorem.md",
              "size": 11192,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "06-Geometry",
          "title": "Geometry",
          "path": "06-Geometry",
          "children": [
            {
              "type": "chapter",
              "name": "6.1-Points-Lines.md",
              "title": "Points and Lines",
              "description": "> Computational geometry fundamentals for coding interviews.",
              "path": "06-Geometry/6.1-Points-Lines.md",
              "size": 13068,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "6.2-Rectangle-Problems.md",
              "title": "Rectangle Problems",
              "description": "> Common interview geometry problems involving rectangles and squares.",
              "path": "06-Geometry/6.2-Rectangle-Problems.md",
              "size": 12418,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "6.3-Convex-Hull.md",
              "title": "Convex Hull",
              "description": "> The smallest convex polygon that encloses all points.",
              "path": "06-Geometry/6.3-Convex-Hull.md",
              "size": 13511,
              "estimatedReadTime": 10
            }
          ]
        },
        {
          "type": "section",
          "name": "07-Advanced-Topics",
          "title": "Advanced Topics",
          "path": "07-Advanced-Topics",
          "children": [
            {
              "type": "chapter",
              "name": "7.1-Matrix-Exponentiation.md",
              "title": "Matrix Exponentiation",
              "description": "> Compute the n-th term of linear recurrences in O(log n) time.",
              "path": "07-Advanced-Topics/7.1-Matrix-Exponentiation.md",
              "size": 11461,
              "estimatedReadTime": 9
            },
            {
              "type": "chapter",
              "name": "7.2-Number-Theoretic-Functions.md",
              "title": "Number Theoretic Functions",
              "description": "> Key functions in number theory: Euler's Totient, Divisor functions, and Möbius.",
              "path": "07-Advanced-Topics/7.2-Number-Theoretic-Functions.md",
              "size": 11293,
              "estimatedReadTime": 10
            },
            {
              "type": "chapter",
              "name": "7.3-Randomized-Algorithms.md",
              "title": "Randomized Algorithms",
              "description": "> Using randomness to achieve efficiency or simplicity.",
              "path": "07-Advanced-Topics/7.3-Randomized-Algorithms.md",
              "size": 14378,
              "estimatedReadTime": 11
            }
          ]
        },
        {
          "type": "section",
          "name": "08-Interview-Focus",
          "title": "Interview Focus",
          "path": "08-Interview-Focus",
          "children": [
            {
              "type": "chapter",
              "name": "8.1-Pattern-Recognition.md",
              "title": "Pattern Recognition in Math Problems",
              "description": "> How to identify the right mathematical technique for interview problems.",
              "path": "08-Interview-Focus/8.1-Pattern-Recognition.md",
              "size": 10153,
              "estimatedReadTime": 8
            },
            {
              "type": "chapter",
              "name": "8.2-Common-Templates.md",
              "title": "Common Math Templates",
              "description": "> Copy-paste ready implementations for interview problems.",
              "path": "08-Interview-Focus/8.2-Common-Templates.md",
              "size": 13652,
              "estimatedReadTime": 11
            },
            {
              "type": "chapter",
              "name": "8.3-Practice-Problems.md",
              "title": "Math Practice Problems",
              "description": "> Curated problems organized by pattern and difficulty.",
              "path": "08-Interview-Focus/8.3-Practice-Problems.md",
              "size": 12221,
              "estimatedReadTime": 9
            }
          ]
        }
      ],
      "stats": {
        "sections": 8,
        "chapters": 24
      }
    }
  },
  "stats": {
    "totalTopics": 17,
    "totalSections": 152,
    "totalChapters": 452,
    "totalSize": 0
  }
}