# 2.2 Stack Reverse Operations

> **Grokking Pattern:** #7 Stacks - Classic Applications
>
> **Difficulty:** Easy-Medium | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê Common

---

## Overview

The stack's LIFO (Last-In-First-Out) property makes it perfect for reversing:
- **Reverse a sequence:** Push all, then pop all
- **Reverse a string:** Stack of characters
- **Reverse a number:** Stack of digits
- **Reverse linked list:** Stack of nodes

This file covers common reversal patterns using stacks.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Reversal Problems</strong></summary>

**Look for these signals:**
- "Reverse the order"
- "Process from end to beginning"
- "LIFO behavior needed"
- "Undo operations"

**Key insight:**
Stack naturally reverses order:
```
Push: 1, 2, 3
Pop:  3, 2, 1 (reversed!)
```

</details>

---

## ‚úÖ When to Use Stack for Reversal

- Need to reverse order of elements
- Processing from end to start
- Temporary storage with automatic reversal

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| In-place string reverse | Strings immutable (Python/JS) | Two pointers on array |
| Reverse array in-place |" Extra O(n) space "| Two pointers |
| Reverse linked list in-place |" O(n) extra space "| Pointer manipulation |
| Just need to iterate backwards | Simpler solution | Reverse iterator |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md)
- Basic iteration

**After mastering this:**
- [Valid Parentheses](./2.1-Valid-Parentheses.md)
- [Expression Evaluation](./2.3-Expression-Evaluation.md)

</details>

---

## üìê Common Reversal Problems

### 1. Reverse a String

```
Input: "hello"
Output: "olleh"
```

### 2. Reverse Words in a String

```
Input: "the sky is blue"
Output: "blue is sky the"
```

### 3. Reverse a Number

```
Input: 12345
Output: 54321
```

### 4. Reverse Each Word

```
Input: "hello world"
Output: "olleh dlrow"
```

---

## üíª Code Implementation

### Reverse a String Using Stack

**Python:**
```python
def reverse_string_stack(s: str) -> str:
    """
    Reverse a string using stack.
    
    Time: O(n), Space: O(n)
    
    Note: In practice, use s[::-1] or ''.join(reversed(s))
    This demonstrates the stack concept.
    """
    stack = []
    
    # Push all characters
    for char in s:
        stack.append(char)
    
    # Pop all characters (reversed order)
    result = []
    while stack:
        result.append(stack.pop())
    
    return ''.join(result)


# One-liner using list as stack
def reverse_string_concise(s: str) -> str:
    stack = list(s)
    return ''.join(stack.pop() for _ in range(len(stack)))
```

**JavaScript:**
```javascript
/**
 * Reverse string using stack.
 * Time: O(n), Space: O(n)
 */
function reverseString(s) {
    const stack = [...s];
    let result = '';
    
    while (stack.length > 0) {
        result += stack.pop();
    }
    
    return result;
}
```

### Reverse Words in a String (LC 151)

**Python:**
```python
def reverse_words(s: str) -> str:
    """
    Reverse word order: "hello world" ‚Üí "world hello"
    
    Uses stack to reverse word order.
    Time: O(n), Space: O(n)
    """
    words = s.split()  # Split by whitespace
    stack = []
    
    # Push all words
    for word in words:
        stack.append(word)
    
    # Pop all words (reversed order)
    result = []
    while stack:
        result.append(stack.pop())
    
    return ' '.join(result)


# Without explicit stack (Pythonic)
def reverse_words_pythonic(s: str) -> str:
    return ' '.join(s.split()[::-1])
```

**JavaScript:**
```javascript
/**
 * Reverse word order in string.
 */
function reverseWords(s) {
    return s.trim().split(/\s+/).reverse().join(' ');
}

// Using explicit stack
function reverseWordsStack(s) {
    const words = s.trim().split(/\s+/);
    const stack = [...words];
    const result = [];
    
    while (stack.length > 0) {
        result.push(stack.pop());
    }
    
    return result.join(' ');
}
```

### Reverse Each Word Individually

**Python:**
```python
def reverse_each_word(s: str) -> str:
    """
    Reverse each word: "hello world" ‚Üí "olleh dlrow"
    
    Time: O(n), Space: O(n)
    """
    words = s.split(' ')
    result = []
    
    for word in words:
        # Use stack to reverse each word
        stack = list(word)
        reversed_word = ''.join(stack.pop() for _ in range(len(stack)))
        result.append(reversed_word)
    
    return ' '.join(result)


# Pythonic version
def reverse_each_word_pythonic(s: str) -> str:
    return ' '.join(word[::-1] for word in s.split(' '))
```

### Reverse Polish Notation Concepts

While not strictly "reversal," understanding RPN relates to stack reversal concepts:

**Python:**
```python
def infix_to_postfix_simple(expression: str) -> str:
    """
    Simple infix to postfix for +, -, *, /
    Example: "3 + 4 * 2" ‚Üí "3 4 2 * +"
    
    This reverses the operator placement.
    """
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}
    output = []
    op_stack = []
    
    tokens = expression.split()
    
    for token in tokens:
        if token.isdigit():
            output.append(token)
        elif token in precedence:
            while (op_stack and 
                   op_stack[-1] in precedence and
                   precedence[op_stack[-1]] >= precedence[token]):
                output.append(op_stack.pop())
            op_stack.append(token)
    
    while op_stack:
        output.append(op_stack.pop())
    
    return ' '.join(output)
```

### Reverse a Linked List Using Stack

**Python:**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def reverse_linked_list_stack(head: ListNode) -> ListNode:
    """
    Reverse linked list using stack.
    
    Time: O(n), Space: O(n)
    
    Note: In-place reversal is O(1) space, but this
    demonstrates the stack concept.
    """
    if not head:
        return None
    
    # Push all nodes to stack
    stack = []
    current = head
    while current:
        stack.append(current)
        current = current.next
    
    # Pop and relink
    new_head = stack.pop()
    current = new_head
    
    while stack:
        current.next = stack.pop()
        current = current.next
    
    current.next = None  # Important: terminate the list
    
    return new_head
```

**JavaScript:**
```javascript
/**
 * Reverse linked list using stack.
 * Time: O(n), Space: O(n)
 */
function reverseListStack(head) {
    if (!head) return null;
    
    const stack = [];
    let current = head;
    
    while (current) {
        stack.push(current);
        current = current.next;
    }
    
    const newHead = stack.pop();
    current = newHead;
    
    while (stack.length > 0) {
        current.next = stack.pop();
        current = current.next;
    }
    
    current.next = null;
    return newHead;
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Reverse string |" O(n) "| O(n) | Stack + result |
| Reverse words |" O(n) "| O(n) | Word storage |
| Reverse linked list |" O(n) "| O(n) | Node pointers |

**Trade-off:** Stack reversal uses O(n) extra space. In-place methods exist for arrays and linked lists that use O(1) space.

---

## üîÑ Variations

| Variation | Approach | Problem |
|-----------|----------|---------|
| Reverse in-place | Two pointers | Array reversal |
| Reverse subarray | Stack portion | Custom |
| Reverse k group | Multiple stacks | LC 25 |
| Reverse between indices | Stack subset | LC 92 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Terminate Linked List

```python
# ‚ùå WRONG: Creates cycle
while stack:
    current.next = stack.pop()
    current = current.next
# Old head.next still points somewhere!

# ‚úÖ CORRECT: Set last node's next to None
current.next = None
```

### 2. Empty Input Handling

```python
# ‚ùå WRONG: Crashes on empty input
stack.pop()  # IndexError

# ‚úÖ CORRECT: Check first
if not stack:
    return ""
```

### 3. Mutating During Iteration

```python
# ‚ùå WRONG: Changes list while iterating
for char in stack:
    result += stack.pop()

# ‚úÖ CORRECT: Use separate loop or while
while stack:
    result += stack.pop()
```

---

## üìù Practice Problems (Progressive)

### Easy
- [ ] [Reverse String](https://leetcode.com/problems/reverse-string/) - LC 344
- [ ] [Reverse Vowels of a String](https://leetcode.com/problems/reverse-vowels-of-a-string/) - LC 345

### Medium
- [ ] [Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/) - LC 151
- [ ] [Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) - LC 92
- [ ] [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/) - LC 25 (Hard)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement string reversal with stack
**Day 3:** Implement word reversal
**Day 7:** Implement linked list reversal with stack
**Day 14:** Compare with in-place methods
**Day 21:** Solve LC 92 or LC 25

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**When asked about reversal:**
> "Stack naturally reverses order - push all, pop all. This is O(n) time and O(n) space."

**When to mention alternatives:**
> "For in-place reversal with O(1) space, I'd use two pointers for arrays or pointer manipulation for linked lists. Stack is cleaner but uses extra space."

**Common follow-up:**
> "Can you do it in-place?" ‚Üí Switch to two-pointer approach

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Common warm-up |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Basic stack usage |
| Google | ‚≠ê‚≠ê‚≠ê | Usually want in-place |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Reverse string | 5 min | Basic implementation |
| Reverse words | 8 min | Handle edge cases |
| Reverse linked list | 10 min | Handle termination |

---

> **üí° Key Insight:** The stack's LIFO property is a natural reversal mechanism. Push elements in order, pop them out reversed. While not always the most space-efficient, it's conceptually simple and works universally for any sequence type.

---

## üîó Related

- [Stack Basics](../01-Stack-Fundamentals/1.1-Stack-Basics.md) - Foundation
- [Valid Parentheses](./2.1-Valid-Parentheses.md) - Another stack pattern
- [Expression Evaluation](./2.3-Expression-Evaluation.md) - Uses reversal concepts
