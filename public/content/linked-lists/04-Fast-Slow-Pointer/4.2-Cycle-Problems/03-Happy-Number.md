# 03 - Happy Number (LeetCode 202)

> **Pattern:** Fast & Slow Pointer (Implicit Cycle Detection)  
> **Difficulty:** Easy  
> **Companies:** Amazon, Apple, Uber

---

## Overview

A **happy number** is defined by the following process:
- Starting with any positive integer, replace the number by the sum of the squares of its digits
- Repeat until the number equals 1 (happy), or loops endlessly in a cycle (not happy)
- A number is happy if this process ends in 1

**Why This Problem Matters:** This demonstrates that Fast & Slow pointer technique isn't just for linked lists - it works for ANY sequence that might contain a cycle, including implicit sequences generated by mathematical operations.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- Repeated application of a function
- Checking if a process terminates or loops forever
- Detecting cycles in a sequence of values
- O(1) space constraint for cycle detection

**Keywords in problem statement:**
- "repeat the process", "loop endlessly"
- "eventually reaches", "terminates at"
- "cycle", "infinite loop"

**Key insight:**
Any sequence where you compute the next value from the current value can be treated as a "linked list" where:
- Current value = current node
- Next value = next node
- `getNext(n)` function = following a pointer

</details>

---

## ‚úÖ When to Use

- Detecting cycles in number sequences
- Mathematical processes that might loop
- When values form an implicit linked list
- O(1) space cycle detection in sequences

---

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Need to track all visited values | Pattern only detects cycle | HashSet |
| Sequence is guaranteed to terminate | No cycle to detect | Simple iteration |
| Need the full cycle | Pattern finds one meeting point | HashSet with path |
| Values don't form a sequence | No "next" relationship | Different approach |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Fast & Slow Pointer Concept](../4.1-Concept.md) - Core pattern
- [Cycle Detection](./01-Cycle-Detection.md) - Basic application
- Digit manipulation (extracting digits from numbers)

**After mastering this:**
- Apply cycle detection to other mathematical sequences
- [Find Duplicate Number (LC 287)](https://leetcode.com/problems/find-the-duplicate-number/) - Array as implicit linked list
- Other "implicit graph" problems

**Key insight for similar problems:**
Any function `f(x) ‚Üí y` where you repeatedly apply it creates an implicit linked list. If the domain is finite, it MUST eventually cycle!

</details>

---

## üìê How It Works

### The Problem Visualization

```
Example: n = 19

Step 1: 1¬≤ + 9¬≤ = 1 + 81 = 82
Step 2: 8¬≤ + 2¬≤ = 64 + 4 = 68
Step 3: 6¬≤ + 8¬≤ = 36 + 64 = 100
Step 4: 1¬≤ + 0¬≤ + 0¬≤ = 1
Result: 1 ‚Üí HAPPY NUMBER! ‚úì

Example: n = 2

2 ‚Üí 4 ‚Üí 16 ‚Üí 37 ‚Üí 58 ‚Üí 89 ‚Üí 145 ‚Üí 42 ‚Üí 20 ‚Üí 4 (CYCLE!)
         ‚Üë___________________________________|
         
Result: Never reaches 1 ‚Üí NOT HAPPY ‚úó
```

### Treating as Linked List

```
For n = 2:

Node: 2  ‚Üí 4  ‚Üí 16 ‚Üí 37 ‚Üí 58 ‚Üí 89 ‚Üí 145 ‚Üí 42 ‚Üí 20 ‚Üí 4
            ‚Üë__________________________________|
            
This is exactly like a linked list with a cycle!
We can use Fast & Slow pointer.

If fast reaches 1 ‚Üí happy
If fast meets slow ‚Üí cycle ‚Üí not happy
```

### Why There's Always a Cycle (or 1)

For any number with d digits:
- Maximum digit is 9
- Maximum sum of squares = d * 81

For a 3-digit number (‚â§999):
- Max sum = 3 * 81 = 243

So numbers quickly shrink and stay in a bounded range. Since the range is finite, we MUST eventually:
1. Reach 1, OR
2. Enter a cycle

---

## üíª Code Implementation

### Solution 1: Fast & Slow Pointer (Optimal)

**Python:**
```python
def is_happy(n: int) -> bool:
    """
    Determine if n is a happy number.
    
    Pattern: Fast & Slow Pointer (implicit cycle detection)
    Time: O(log n), Space: O(1)
    
    The sequence either reaches 1 or cycles.
    Use Floyd's algorithm to detect.
    """
    def get_next(num: int) -> int:
        """Calculate sum of squares of digits."""
        total = 0
        while num > 0:
            digit = num % 10
            total += digit * digit
            num //= 10
        return total
    
    slow = n
    fast = get_next(n)
    
    # Continue until fast reaches 1 or they meet
    while fast != 1 and slow != fast:
        slow = get_next(slow)           # 1 step
        fast = get_next(get_next(fast)) # 2 steps
    
    return fast == 1


def is_happy_verbose(n: int) -> bool:
    """Same solution with detailed steps."""
    def sum_of_squares(num):
        total = 0
        while num > 0:
            digit = num % 10
            total += digit ** 2
            num //= 10
        return total
    
    # Both pointers start at n, but fast moves first
    slow = n
    fast = sum_of_squares(n)
    
    while fast != 1 and slow != fast:
        # Slow moves one step
        slow = sum_of_squares(slow)
        # Fast moves two steps
        fast = sum_of_squares(sum_of_squares(fast))
    
    # If fast reached 1, it's happy
    # If slow == fast (cycle), it's not happy
    return fast == 1
```

**JavaScript:**
```javascript
/**
 * Determine if n is a happy number.
 * Pattern: Fast & Slow Pointer
 * Time: O(log n), Space: O(1)
 * 
 * @param {number} n
 * @return {boolean}
 */
function isHappy(n) {
    const getNext = (num) => {
        let total = 0;
        while (num > 0) {
            const digit = num % 10;
            total += digit * digit;
            num = Math.floor(num / 10);
        }
        return total;
    };
    
    let slow = n;
    let fast = getNext(n);
    
    while (fast !== 1 && slow !== fast) {
        slow = getNext(slow);
        fast = getNext(getNext(fast));
    }
    
    return fast === 1;
}
```

### Solution 2: HashSet Approach

**Python:**
```python
def is_happy_hashset(n: int) -> bool:
    """
    HashSet approach - simpler but O(log n) space.
    """
    def get_next(num):
        total = 0
        while num > 0:
            digit = num % 10
            total += digit * digit
            num //= 10
        return total
    
    seen = set()
    
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)
    
    return n == 1
```

**JavaScript:**
```javascript
function isHappyHashSet(n) {
    const getNext = (num) => {
        let total = 0;
        while (num > 0) {
            total += (num % 10) ** 2;
            num = Math.floor(num / 10);
        }
        return total;
    };
    
    const seen = new Set();
    
    while (n !== 1 && !seen.has(n)) {
        seen.add(n);
        n = getNext(n);
    }
    
    return n === 1;
}
```

### Solution 3: Hardcoded Cycle (Interview Trick)

**Python:**
```python
def is_happy_hardcoded(n: int) -> bool:
    """
    The cycle for unhappy numbers always includes 4.
    We can just check if we hit 4.
    
    Cycle: 4 ‚Üí 16 ‚Üí 37 ‚Üí 58 ‚Üí 89 ‚Üí 145 ‚Üí 42 ‚Üí 20 ‚Üí 4
    """
    def get_next(num):
        total = 0
        while num > 0:
            digit = num % 10
            total += digit * digit
            num //= 10
        return total
    
    while n != 1 and n != 4:
        n = get_next(n)
    
    return n == 1
```

---

## ‚ö° Complexity Analysis

### Fast & Slow Pointer

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Happy number |" O(log n) "| O(1) | Quickly reaches 1 |
| Not happy |" O(log n) "| O(1) | Cycle detected |

**Why O(log n) Time:**
- Number of digits = O(log n)
- Each step processes all digits: O(log n) per step
- Number of steps is bounded (values stay small)
- Total: O(log n)

**Why O(1) Space:**
- Only two variables (slow, fast)
- No data structures that grow with input

### HashSet Approach

| Case | Time | Space | Notes |
|------|------|-------|-------|
| All cases |" O(log n) "| O(log n) | Stores visited numbers |

---

## üîÑ Variations

| Variation | Change | Example |
|-----------|--------|---------|
| Sum of cubes | Use n¬≥ instead of n¬≤ | Different cycles |
| Sum of digits | No squares, just sum | Digit root |
| Different base | Base 2, 8, etc. | Binary happy number |
| Find cycle length | Count steps in cycle | Extension |

### Digit Root (Related Problem)

```python
def digit_root(n: int) -> int:
    """
    Repeatedly sum digits until single digit.
    Similar concept but always terminates.
    """
    while n >= 10:
        total = 0
        while n > 0:
            total += n % 10
            n //= 10
        n = total
    return n

# Math trick: digit_root(n) = 1 + (n - 1) % 9
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Incorrect Digit Extraction

```python
# ‚ùå Wrong - string conversion is slower
def get_next_slow(n):
    return sum(int(d) ** 2 for d in str(n))

# ‚úÖ Correct - use modulo and division
def get_next_fast(n):
    total = 0
    while n > 0:
        digit = n % 10
        total += digit * digit
        n //= 10
    return total
```

### 2. Wrong Starting Positions

```python
# ‚ùå Wrong - both start at same position but should differ initially
slow = n
fast = n
while slow != fast:  # Immediately true!

# ‚úÖ Correct - start fast one step ahead OR check condition differently
slow = n
fast = get_next(n)
while fast != 1 and slow != fast:
```

### 3. Forgetting the Happy Condition

```python
# ‚ùå Wrong - only checking for cycle
while slow != fast:
    slow = get_next(slow)
    fast = get_next(get_next(fast))
return False  # What if fast == 1?

# ‚úÖ Correct - check for both conditions
while fast != 1 and slow != fast:
    slow = get_next(slow)
    fast = get_next(get_next(fast))
return fast == 1
```

### 4. Integer Division Issues (JavaScript)

```javascript
// ‚ùå Wrong in JavaScript - floating point division
num = num / 10;  // Gives 1.9 for 19

// ‚úÖ Correct - use Math.floor
num = Math.floor(num / 10);
```

---

## üìù Practice Problems (Progressive)

### Easy (This problem level)
- [ ] [Happy Number](https://leetcode.com/problems/happy-number/) - LC 202 - This problem!
- [ ] [Add Digits](https://leetcode.com/problems/add-digits/) - LC 258 - Similar digit manipulation

### Medium (Apply pattern)
- [ ] [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) - LC 142 - Find cycle start
- [ ] [Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/) - LC 287 - Array as implicit linked list

### Related
- [ ] [Ugly Number](https://leetcode.com/problems/ugly-number/) - LC 263 - Number sequence with condition

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**For LC 202 (Happy Number):**
- **Day 1:** Implement both Fast/Slow and HashSet solutions
- **Day 3:** Explain why the sequence must cycle or reach 1
- **Day 7:** Solve LC 287 (Find Duplicate) - same concept
- **Day 14:** Implement digit manipulation without looking
- **Day 30:** Review the insight: any bounded sequence ‚Üí cycle detection

**Mastery indicators:**
- [ ] Can implement getNext function quickly
- [ ] Understand why O(1) space is possible
- [ ] Can explain the mathematical bound on sequence length
- [ ] Recognize "implicit linked list" patterns

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"I notice this problem has a sequence that either reaches 1 or cycles forever. I can treat this as an implicit linked list and use the Fast & Slow pointer technique to detect if there's a cycle."

**Explaining the insight:**
"The key observation is that the sum of squares of digits for any number creates a bounded sequence. For a 3-digit number, max sum is 243. Since we're in a finite range, we must eventually either hit 1 or repeat a value - which means a cycle."

**Code walkthrough:**
1. "First, I'll write a helper to compute sum of squares of digits"
2. "Then I'll use slow and fast pointers"
3. "If fast reaches 1, we're happy"
4. "If slow meets fast, we've found a cycle, not happy"

**Follow-up questions:**
- "Why O(1) space?" ‚Üí Fast/Slow only needs two variables
- "Why does it terminate?" ‚Üí Bounded sequence must cycle
- "What's the time complexity?" ‚Üí O(log n) per step, bounded steps

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Tests creative thinking |
| Apple | ‚≠ê‚≠ê‚≠ê | Number manipulation focus |
| Uber | ‚≠ê‚≠ê‚≠ê | Pattern recognition |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Standard question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| First solution (HashSet) | 10-12 min | More intuitive |
| Optimal solution | 12-15 min | Understanding the pattern |
| Interview target | 10-12 min | With explanation |
| With follow-ups | 15-18 min | Complexity analysis |

---

> **üí° Key Insight:** Any deterministic sequence in a bounded range MUST eventually cycle (Pigeonhole Principle). This means we can apply Fast & Slow pointer to detect cycles in mathematical sequences, not just linked lists. The "linked list" is implicit - each value "points to" its successor.

---

## üîó Related

- [Fast & Slow Concept](../4.1-Concept.md) - Pattern overview
- [Cycle Detection](./01-Cycle-Detection.md) - Basic linked list version
- [Find Cycle Start](./02-Find-Cycle-Start.md) - Phase 2 algorithm
- [Find Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/) - Array as implicit linked list
