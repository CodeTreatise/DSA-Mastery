# Contains Duplicate II (LeetCode 219)

> **Two Sum pattern with a distance constraint - combining hash map with sliding window logic.**

Given an integer array `nums` and an integer `k`, return `true` if there are two distinct indices `i` and `j` such that `nums[i] == nums[j]` and `abs(i - j) <= k`.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem signals:**
- Find duplicates with **distance constraint** ‚úì
- "within k positions" / "at most k apart"
- Need to track **both value AND index**

**Pattern combination:**
- **Hash Map** for O(1) duplicate lookup
- **Sliding Window** concept for distance constraint
- Store value ‚Üí most recent index

</details>

---

## ‚úÖ When to Use

- Finding duplicates within a distance/window
- Need O(n) time complexity
- Constraint involves both value equality and index distance

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Just check any duplicate | Simpler: just use Set | [LC 217 Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) |
| Find ALL duplicate pairs | Need to track all indices | defaultdict(list) |
| k is very large (close to n) | Hash map approach still works | Same approach |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- [Two Sum](./4.2-Two-Sum-LC1.md) - Hash map for lookup
- [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) - Simpler version
- Sliding Window concept

**After mastering:**
- [Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/) - Value + index constraints
- [Longest Consecutive Sequence](./4.4-Longest-Consecutive-LC128.md)

**Combines with:**
- Sliding Window techniques
- Set operations for window maintenance

</details>

---

## üìê How It Works

### Problem Examples

```
Example 1:
Input: nums = [1,2,3,1], k = 3
Output: true (indices 0 and 3, distance = 3 ‚â§ k)

Example 2:
Input: nums = [1,0,1,1], k = 1
Output: true (indices 2 and 3, distance = 1 ‚â§ k)

Example 3:
Input: nums = [1,2,3,1,2,3], k = 2
Output: false (duplicates exist but all > k apart)
```

### Approach 1: Hash Map (Store Last Index)

**Insight:** For each value, we only care about its **most recent** occurrence. If the current occurrence is within k of the most recent, return true.

```
nums = [1, 2, 3, 1], k = 3

i=0: num=1, seen={}, 1 not in seen ‚Üí seen={1:0}
i=1: num=2, seen={1:0}, 2 not in seen ‚Üí seen={1:0, 2:1}
i=2: num=3, seen={1:0,2:1}, 3 not in seen ‚Üí seen={1:0, 2:1, 3:2}
i=3: num=1, seen={1:0,2:1,3:2}
     1 IS in seen! Last index = 0
     Distance = 3 - 0 = 3 ‚â§ k=3 ‚úì
     Return true
```

### Approach 2: Sliding Window with Set

**Insight:** Maintain a set of values within the last k positions. If we see a duplicate within this window, return true.

```
nums = [1, 2, 3, 1], k = 3

Window size = k = 3 (keep last 3 indices)

i=0: window={1}
i=1: window={1,2}
i=2: window={1,2,3}
i=3: num=1, 1 IS in window! Return true

If window exceeds k, remove oldest element.
```

### Visualization

```
nums = [1, 2, 3, 4, 1], k = 3

Approach 1 (Last Index):
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
i  num  seen                    check
0  1    {}‚Üí{1:0}               -
1  2    {1:0}‚Üí{1:0,2:1}        -
2  3    ‚Üí{1:0,2:1,3:2}         -
3  4    ‚Üí{1:0,2:1,3:2,4:3}     -
4  1    1 in seen, 4-0=4 > 3   update to {1:4,...}
Return: false

Approach 2 (Sliding Window):
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
i  num  window (size ‚â§ k)      action
0  1    {1}                    add 1
1  2    {1,2}                  add 2
2  3    {1,2,3}                add 3
3  4    {1,2,3,4} size=4 > k   remove nums[0]=1, add 4 ‚Üí {2,3,4}
4  1    {2,3,4}, 1 not in      add 1 ‚Üí {2,3,4,1}
Return: false
```

---

## üíª Code Implementation

### Python - Approach 1: Last Index Hash Map

```python
from typing import List

class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        """
        Check if duplicate exists within k distance.
        
        Approach: Store last seen index for each value.
        Time: O(n)
        Space: O(n)
        """
        last_seen = {}  # value ‚Üí last index
        
        for i, num in enumerate(nums):
            if num in last_seen:
                # Check distance to last occurrence
                if i - last_seen[num] <= k:
                    return True
            
            # Update last seen index (always update to most recent)
            last_seen[num] = i
        
        return False
```

### Python - Approach 2: Sliding Window with Set

```python
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        """
        Maintain a sliding window of size k using a set.
        
        Time: O(n)
        Space: O(min(n, k)) - window never exceeds k elements
        """
        window = set()
        
        for i, num in enumerate(nums):
            # Check if duplicate exists in current window
            if num in window:
                return True
            
            # Add current element to window
            window.add(num)
            
            # Maintain window size ‚â§ k
            if len(window) > k:
                # Remove element that's now outside the window
                window.remove(nums[i - k])
        
        return False
```

### JavaScript - Approach 1

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var containsNearbyDuplicate = function(nums, k) {
    // Store last seen index for each value
    const lastSeen = new Map();
    
    for (let i = 0; i < nums.length; i++) {
        const num = nums[i];
        
        if (lastSeen.has(num)) {
            // Check distance to last occurrence
            if (i - lastSeen.get(num) <= k) {
                return true;
            }
        }
        
        // Update last seen index
        lastSeen.set(num, i);
    }
    
    return false;
};
```

### JavaScript - Approach 2

```javascript
var containsNearbyDuplicate = function(nums, k) {
    // Sliding window set
    const window = new Set();
    
    for (let i = 0; i < nums.length; i++) {
        // Check if duplicate in window
        if (window.has(nums[i])) {
            return true;
        }
        
        // Add to window
        window.add(nums[i]);
        
        // Maintain window size
        if (window.size > k) {
            window.delete(nums[i - k]);
        }
    }
    
    return false;
};
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Last Index Map | O(n) | O(n) | Store all unique values |
| Sliding Window | O(n) | O(min(n, k)) | Window bounded by k |

**Why O(n) Time (both):**
- Single pass through array
- Hash set/map operations are O(1) average

**Space Comparison:**
- **Last Index:** Always O(n) for n unique elements
- **Sliding Window:** O(min(n, k)) - bounded by window size
- When k << n, sliding window uses less memory

---

## üîÑ Variations

| Variation | Difference | Link |
|-----------|------------|------|
| Contains Duplicate | No distance constraint | [LC 217](https://leetcode.com/problems/contains-duplicate/) |
| Contains Duplicate III | Value difference + index constraint | [LC 220](https://leetcode.com/problems/contains-duplicate-iii/) |
| Longest Substring Without Repeating | Similar window technique | [LC 3](https://leetcode.com/problems/longest-substring-without-repeating-characters/) |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Wrong Comparison for Distance

```python
# ‚ùå WRONG: Using < instead of <=
if i - last_seen[num] < k:  # Should be <= k

# ‚úÖ CORRECT: Distance can equal k
if i - last_seen[num] <= k:
    return True
```

### 2. Not Updating Last Seen Index

```python
# ‚ùå WRONG: Only storing first occurrence
if num not in last_seen:
    last_seen[num] = i

# ‚úÖ CORRECT: Always update to most recent
last_seen[num] = i  # Outside the if block
```

### 3. Wrong Element Removed in Sliding Window

```python
# ‚ùå WRONG: Removing wrong index
if len(window) > k:
    window.remove(nums[i - k - 1])  # Off by one!

# ‚úÖ CORRECT: Remove element at i - k
if len(window) > k:
    window.remove(nums[i - k])
```

### 4. Edge Case: k = 0

```python
# When k = 0, no two distinct indices can have distance ‚â§ 0
# The sliding window approach handles this naturally
# (window size 0 means immediate duplicates only, which is impossible)
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Link | Notes |
|---------|------------|------|-------|
| Contains Duplicate | üü¢ Easy | [LC 217](https://leetcode.com/problems/contains-duplicate/) | No distance constraint |
| Contains Duplicate II | üü¢ Easy | [LC 219](https://leetcode.com/problems/contains-duplicate-ii/) | This problem |
| Contains Duplicate III | üü° Medium | [LC 220](https://leetcode.com/problems/contains-duplicate-iii/) | Value + index constraints |
| Longest Substring No Repeat | üü° Medium | [LC 3](https://leetcode.com/problems/longest-substring-without-repeating-characters/) | Similar window technique |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve LC 219, implement both approaches
- **Day 3:** Solve LC 217 (simpler) to reinforce hash set
- **Day 7:** Attempt LC 220 (harder) to extend the pattern
- **Day 14:** Solve LC 3 using similar sliding window + set

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interview</strong></summary>

**Clarify:**
> "So I need to find if any duplicate exists where the indices are at most k apart. Let me verify: the constraint is on index distance, not value difference, right?"

**Approach explanation:**
> "I can solve this in O(n) time with a hash map. For each element, I'll store its most recent index. When I see a value again, I check if the distance to its last occurrence is within k. If yes, return true."

**Alternative:**
> "Another approach is to maintain a sliding window set of size k. If I ever try to add a value that's already in the window, I found a duplicate within k distance."

**Trade-off discussion:**
> "The hash map approach uses O(n) space for all unique values. The sliding window approach uses O(min(n,k)) space, which is better when k is small."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Tests hash + window |
| Google | ‚≠ê‚≠ê‚≠ê | May ask follow-up (LC 220) |
| Meta | ‚≠ê‚≠ê‚≠ê | Expects quick solution |

---

## ‚è±Ô∏è Time Estimates

| Activity | Target Time |
|----------|-------------|
| Understand problem | 2 min |
| Code solution | 5-7 min |
| With follow-up discussion | 10-12 min |

---

> **üí° Key Insight:** This problem elegantly combines two concepts: hash map for O(1) lookup and sliding window for bounded-distance constraint. The sliding window set approach is particularly elegant because the window size naturally enforces the distance constraint.

> **üîó Related:** [Two Sum Overview](./4.1-Two-Sum-Overview.md) | [Longest Substring No Repeat](../07-Sliding-Window-Hash/7.2-Longest-Substring-LC3.md) | [Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/)
