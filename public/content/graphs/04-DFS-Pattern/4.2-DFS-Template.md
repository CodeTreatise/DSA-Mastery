# 4.2 DFS Template

> **Universal DFS templates for any problem - memorize these patterns**
>
> â±ï¸ **Time:** 30-40 min | ğŸ“Š **Difficulty:** Core | ğŸ¯ **Interview Frequency:** â­â­â­â­â­

---

## Overview

These templates cover 95% of DFS problems. Master the structure, then adapt for specific problems.

```
The DFS Template Components:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. BASE CASE(S)                                     â”‚
â”‚     - Already visited? Return                       â”‚
â”‚     - Out of bounds? Return                         â”‚
â”‚     - Found target? Return result                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  2. PROCESS CURRENT                                  â”‚
â”‚     - Mark visited                                  â”‚
â”‚     - Do computation (count, collect, etc.)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  3. RECURSE ON NEIGHBORS                             â”‚
â”‚     - For each valid neighbor                       â”‚
â”‚     - Recursive call                                â”‚
â”‚     - (Optional) Backtrack                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  4. RETURN RESULT                                    â”‚
â”‚     - Aggregate from children                       â”‚
â”‚     - Or return status (found/not found)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>Which Template to Use?</strong></summary>

| If you need... | Use Template |
|----------------|--------------|
| Simple traversal | Template 1: Basic |
| Check if something exists | Template 2: Boolean |
| Collect results | Template 3: Accumulator |
| Find in grid | Template 4: Grid |
| Find all solutions | Template 5: Backtracking |
| Track path | Template 6: With Path |
| Detect cycle | Template 7: Three States |

</details>

---

## ğŸ’» Template 1: Basic DFS (Graph Traversal)

**When:** Visit all reachable nodes, count components, check connectivity.

**Python:**
```python
def dfs_basic(graph, start):
    """
    Basic DFS - visit all reachable nodes.
    
    Time: O(V + E)
    Space: O(V)
    """
    visited = set()
    
    def dfs(node):
        if node in visited:
            return
        
        visited.add(node)
        # Process node here
        
        for neighbor in graph[node]:
            dfs(neighbor)
    
    dfs(start)
    return visited


# For disconnected graphs:
def traverse_all(graph, n):
    """Visit ALL nodes, even disconnected."""
    visited = set()
    
    def dfs(node):
        if node in visited:
            return
        visited.add(node)
        for neighbor in graph[node]:
            dfs(neighbor)
    
    for node in range(n):
        if node not in visited:
            dfs(node)
    
    return visited
```

---

## ğŸ’» Template 2: Boolean DFS (Path Exists)

**When:** Check if target is reachable, validate property.

**Python:**
```python
def dfs_exists(graph, start, target):
    """
    Return True if target is reachable from start.
    
    Key: Return immediately when found.
    """
    if start == target:
        return True
    
    visited = set()
    
    def dfs(node):
        if node == target:
            return True
        
        visited.add(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                if dfs(neighbor):  # Found in subtree
                    return True
        
        return False  # Not found in this branch
    
    return dfs(start)


# Alternative: Iterative
def dfs_exists_iterative(graph, start, target):
    if start == target:
        return True
    
    visited = set()
    stack = [start]
    
    while stack:
        node = stack.pop()
        if node == target:
            return True
        if node in visited:
            continue
        visited.add(node)
        for neighbor in graph[node]:
            stack.append(neighbor)
    
    return False
```

---

## ğŸ’» Template 3: Accumulator DFS (Collect Results)

**When:** Collect all nodes with property, sum values, find max depth.

**Python:**
```python
def dfs_collect(graph, start, condition):
    """
    Collect all nodes satisfying condition.
    
    Key: Use accumulator list or return aggregated value.
    """
    visited = set()
    result = []
    
    def dfs(node):
        if node in visited:
            return
        
        visited.add(node)
        
        if condition(node):
            result.append(node)
        
        for neighbor in graph[node]:
            dfs(neighbor)
    
    dfs(start)
    return result


# Return aggregated value (e.g., sum, max depth)
def dfs_aggregate(graph, start):
    """Return max depth from start."""
    visited = set()
    
    def dfs(node, depth):
        if node in visited:
            return depth
        
        visited.add(node)
        max_depth = depth
        
        for neighbor in graph[node]:
            max_depth = max(max_depth, dfs(neighbor, depth + 1))
        
        return max_depth
    
    return dfs(start, 0)
```

---

## ğŸ’» Template 4: Grid DFS

**When:** 2D matrix traversal, flood fill, island counting.

**Python:**
```python
def dfs_grid(grid, start_row, start_col):
    """
    DFS on 2D grid.
    
    Key modifications:
    - Bounds checking
    - 4 or 8 directions
    - Mark cells in grid or use visited set
    """
    if not grid or not grid[0]:
        return
    
    rows, cols = len(grid), len(grid[0])
    DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right
    # For 8-directional: add diagonals
    
    visited = set()
    
    def is_valid(r, c):
        """Check bounds and cell condition."""
        return (0 <= r < rows and 
                0 <= c < cols and 
                (r, c) not in visited and
                grid[r][c] == 1)  # Adapt condition
    
    def dfs(r, c):
        if not is_valid(r, c):
            return
        
        visited.add((r, c))
        # Process cell here
        
        for dr, dc in DIRECTIONS:
            dfs(r + dr, c + dc)
    
    dfs(start_row, start_col)
    return visited


# Common pattern: Count islands
def count_islands(grid):
    """Count connected components in grid."""
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    count = 0
    
    def dfs(r, c):
        if r < 0 or r >= rows or c < 0 or c >= cols:
            return
        if grid[r][c] != '1':
            return
        
        grid[r][c] = '0'  # Mark visited by modifying grid
        
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                dfs(r, c)
                count += 1
    
    return count
```

---

## ğŸ’» Template 5: Backtracking DFS (All Solutions)

**When:** Find ALL paths, generate permutations/combinations, solve puzzles.

**Python:**
```python
def dfs_backtrack(graph, start, end):
    """
    Find ALL paths from start to end.
    
    Key: Add to path before recursing, remove after (backtrack).
    
    Warning: Can be exponential - O(2^N) paths possible.
    """
    all_paths = []
    
    def dfs(node, path):
        if node == end:
            all_paths.append(path[:])  # Copy path
            return
        
        for neighbor in graph[node]:
            if neighbor not in path:  # Avoid cycles
                path.append(neighbor)
                dfs(neighbor, path)
                path.pop()  # Backtrack!
    
    dfs(start, [start])
    return all_paths


# Generic backtracking template
def backtrack(choices, path, result):
    """
    Generic backtracking template.
    
    1. Check if current path is a solution
    2. For each choice:
       - Make choice (modify path)
       - Recurse
       - Undo choice (backtrack)
    """
    if is_solution(path):
        result.append(path[:])
        return
    
    for choice in get_choices(choices, path):
        if is_valid(choice, path):
            path.append(choice)
            backtrack(choices, path, result)
            path.pop()
```

---

## ğŸ’» Template 6: DFS with Path Tracking

**When:** Need to know the path to current node, detect back edges.

**Python:**
```python
def dfs_with_path(graph, start, end):
    """
    Find path from start to end.
    
    Key: Pass path as parameter, copy when found.
    """
    visited = set()
    
    def dfs(node, path):
        if node == end:
            return path
        
        visited.add(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                result = dfs(neighbor, path + [neighbor])
                if result:
                    return result
        
        return None
    
    return dfs(start, [start])


# Alternative: Track parent for path reconstruction
def dfs_with_parent(graph, start, end):
    """Find path using parent tracking (more memory efficient)."""
    visited = set()
    parent = {start: None}
    
    def dfs(node):
        if node == end:
            return True
        
        visited.add(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                parent[neighbor] = node
                if dfs(neighbor):
                    return True
        
        return False
    
    if not dfs(start):
        return []
    
    # Reconstruct path
    path = []
    current = end
    while current is not None:
        path.append(current)
        current = parent[current]
    
    return path[::-1]
```

---

## ğŸ’» Template 7: Three-State DFS (Cycle Detection)

**When:** Detect cycles in directed graphs, topological sort.

**Python:**
```python
def has_cycle_directed(graph, n):
    """
    Detect cycle in directed graph using three states.
    
    States:
    - WHITE (0): Unvisited
    - GRAY (1): Currently in recursion stack (visiting)
    - BLACK (2): Completely processed (visited)
    
    Cycle exists if we reach a GRAY node (back edge to ancestor).
    """
    WHITE, GRAY, BLACK = 0, 1, 2
    state = [WHITE] * n
    
    def dfs(node):
        state[node] = GRAY  # Start visiting
        
        for neighbor in graph[node]:
            if state[neighbor] == GRAY:
                return True  # Back edge! Cycle detected
            if state[neighbor] == WHITE:
                if dfs(neighbor):
                    return True
        
        state[node] = BLACK  # Done visiting
        return False
    
    for node in range(n):
        if state[node] == WHITE:
            if dfs(node):
                return True
    
    return False


# Undirected cycle detection (simpler)
def has_cycle_undirected(graph, n):
    """
    Detect cycle in undirected graph.
    
    Key: Track parent to avoid counting edge to parent as cycle.
    """
    visited = set()
    
    def dfs(node, parent):
        visited.add(node)
        
        for neighbor in graph[node]:
            if neighbor == parent:
                continue  # Skip edge we came from
            if neighbor in visited:
                return True  # Cycle!
            if dfs(neighbor, node):
                return True
        
        return False
    
    for node in range(n):
        if node not in visited:
            if dfs(node, -1):
                return True
    
    return False
```

---

## ğŸ’» Template 8: DFS with Memoization

**When:** Overlapping subproblems, count paths with constraints.

**Python:**
```python
def dfs_memo(grid):
    """
    DFS with memoization - for problems with overlapping subproblems.
    
    Example: Longest increasing path in matrix.
    """
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    memo = {}  # (r, c) -> result
    
    def dfs(r, c):
        if (r, c) in memo:
            return memo[(r, c)]
        
        result = 1  # At least current cell
        
        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nr, nc = r + dr, c + dc
            if (0 <= nr < rows and 0 <= nc < cols and 
                grid[nr][nc] > grid[r][c]):  # Valid increasing
                result = max(result, 1 + dfs(nr, nc))
        
        memo[(r, c)] = result
        return result
    
    return max(dfs(r, c) for r in range(rows) for c in range(cols))
```

**JavaScript:**
```javascript
// Template 1: Basic DFS
function dfsBasic(graph, start) {
    const visited = new Set();
    
    function dfs(node) {
        if (visited.has(node)) return;
        visited.add(node);
        
        for (const neighbor of graph.get(node) || []) {
            dfs(neighbor);
        }
    }
    
    dfs(start);
    return visited;
}

// Template 4: Grid DFS
function dfsGrid(grid, startRow, startCol) {
    const rows = grid.length, cols = grid[0].length;
    const DIRECTIONS = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    const visited = new Set();
    
    function dfs(r, c) {
        if (r < 0 || r >= rows || c < 0 || c >= cols) return;
        const key = `${r},${c}`;
        if (visited.has(key) || grid[r][c] !== 1) return;
        
        visited.add(key);
        
        for (const [dr, dc] of DIRECTIONS) {
            dfs(r + dr, c + dc);
        }
    }
    
    dfs(startRow, startCol);
    return visited;
}

// Template 7: Cycle Detection (Directed)
function hasCycleDirected(graph, n) {
    const WHITE = 0, GRAY = 1, BLACK = 2;
    const state = Array(n).fill(WHITE);
    
    function dfs(node) {
        state[node] = GRAY;
        
        for (const neighbor of graph.get(node) || []) {
            if (state[neighbor] === GRAY) return true;
            if (state[neighbor] === WHITE && dfs(neighbor)) return true;
        }
        
        state[node] = BLACK;
        return false;
    }
    
    for (let i = 0; i < n; i++) {
        if (state[i] === WHITE && dfs(i)) return true;
    }
    
    return false;
}
```

---

## ğŸ“ Template Selection Guide

```
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚ What do you need?    â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼               â–¼              â–¼               â–¼
   Just visit      Boolean         Collect        Find ALL
   all nodes       result         results        solutions
        â”‚               â”‚              â”‚               â”‚
        â–¼               â–¼              â–¼               â–¼
   Template 1      Template 2    Template 3      Template 5
   (Basic)         (Exists)     (Accumulator)  (Backtracking)

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼               â–¼                  â–¼
   Grid problem    Detect cycle      Overlapping
        â”‚               â”‚             subproblems
        â–¼               â–¼                  â–¼
   Template 4      Template 7         Template 8
   (Grid DFS)     (Three State)       (Memo DFS)
```

---

## âš¡ Complexity Analysis

| Template | Time | Space | Notes |
|----------|------|-------|-------|
| Basic | O(V + E) | O(V) | Standard |
| Boolean | O(V + E) | O(V) | Early exit possible |
| Accumulator | O(V + E) | O(V) | Plus result size |
| Grid | O(rows Ã— cols) | O(rows Ã— cols) | Grid size |
| Backtracking | O(k!) or O(2^n) | O(n) | Depends on branching |
| With Path | O(V + E) | O(V) | Path adds O(V) |
| Three State | O(V + E) | O(V) | Cycle detection |
| Memoization | O(V + E) | O(V) | Each node once |

---

## âš ï¸ Common Mistakes

### 1. Wrong Base Case Order

```python
# âŒ Wrong: Check visited after processing
def dfs(node):
    result.append(node)  # Might add duplicates!
    if node in visited:
        return
    visited.add(node)

# âœ… Correct: Check visited first
def dfs(node):
    if node in visited:
        return
    visited.add(node)
    result.append(node)
```

### 2. Forgetting to Backtrack

```python
# âŒ Wrong: Path grows forever
path.append(neighbor)
dfs(neighbor, path)
# Forgot path.pop()!

# âœ… Correct: Always backtrack
path.append(neighbor)
dfs(neighbor, path)
path.pop()  # Backtrack
```

### 3. Modifying Grid Without Restoration

```python
# âš ï¸ Be careful: Sometimes you WANT to modify
grid[r][c] = 0  # Mark visited
dfs(...)
# If you need the original grid, restore it:
grid[r][c] = 1  # Restore
```

---

## ğŸ“ Practice Problems by Template

| Template | Problem | Link |
|----------|---------|------|
| Basic | Number of Provinces | [LC 547](https://leetcode.com/problems/number-of-provinces/) |
| Boolean | Find if Path Exists | [LC 1971](https://leetcode.com/problems/find-if-path-exists-in-graph/) |
| Grid | Number of Islands | [LC 200](https://leetcode.com/problems/number-of-islands/) |
| Backtracking | All Paths Source to Target | [LC 797](https://leetcode.com/problems/all-paths-from-source-to-target/) |
| Three State | Course Schedule | [LC 207](https://leetcode.com/problems/course-schedule/) |
| Memo | Longest Increasing Path | [LC 329](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/) |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Write Templates 1, 2, 4 from memory
- **Day 3:** Write Templates 5, 7 from memory
- **Day 7:** Solve one problem with each template
- **Day 14:** Identify which template to use for 5 new problems

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>Template Discussion in Interviews</strong></summary>

**When starting:**
> "I'll use the standard DFS template. Let me identify which variant... Since I need to find all paths, I'll use the backtracking version."

**When explaining:**
> "The key modification here is [specific adaptation]. Instead of just marking visited, I need to track [state] because..."

**When optimizing:**
> "The basic DFS would work, but since we have overlapping subproblems, I'll add memoization to avoid recomputation."

</details>

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Memorize Templates 1-4 | 30-40 min |
| Learn Templates 5-8 | 30-40 min |
| Apply to first problem | 20-30 min |
| **Master template selection** | **2-3 hours** |

---

> **ğŸ’¡ Key Insight:** DFS templates differ mainly in: (1) what you return, (2) whether you backtrack, and (3) what state you track. Master the basic template, then learn the variations.

> **ğŸ”— Related:** [DFS Fundamentals](./4.1-DFS-Fundamentals.md) | [DFS Applications](./4.3-DFS-Applications.md) | [Backtracking](../../02-Recursion-Backtracking/02-Backtracking/2.2-Backtracking-Template.md)

---

**Previous:** [â† 4.1 DFS Fundamentals](./4.1-DFS-Fundamentals.md)  
**Next:** [4.3 DFS Applications â†’](./4.3-DFS-Applications.md)
