# LFU Cache

> **Least Frequently Used: Evict the item with lowest access count.**
>
> When counts tie, evict the least recently used among them. More complex than LRU!

---

## ðŸŽ¯ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem statement signals:**
- "Evict least frequently used"
- "Track access count"
- "Tie-break by recency"
- LFU explicitly mentioned

**Difference from LRU:**
- LRU: Only cares about when last accessed
- LFU: Cares about how many times accessed (count)

</details>

---

## ðŸ“ The Challenge

```
LFU is harder than LRU because we need to track:
1. Value for each key                    â†’ HashMap
2. Access count for each key             â†’ HashMap
3. Which keys have count = k             â†’ HashMap of Lists
4. Order within same count (for tie-break) â†’ Need ordering
5. Minimum count (for efficient eviction)  â†’ Track separately
```

**Data Structures Needed:**
```
key_to_value: {key: value}           - O(1) value lookup
key_to_count: {key: count}           - O(1) count lookup
count_to_keys: {count: OrderedSet}   - O(1) LRU within count group
min_count: int                       - O(1) find minimum
```

---

## ðŸ’» Implementation

**Python:**
```python
from collections import defaultdict, OrderedDict

class LFUCache:
    """
    LFU Cache with O(1) get and put.
    
    Data structures:
    - key_to_val: key â†’ value
    - key_to_count: key â†’ frequency count
    - count_to_keys: count â†’ OrderedDict of keys (for LRU tie-break)
    - min_count: smallest count with keys (for eviction)
    
    Time: O(1) for get and put
    Space: O(capacity)
    """
    
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.key_to_val = {}
        self.key_to_count = {}
        self.count_to_keys = defaultdict(OrderedDict)  # count â†’ {key: None, ...}
        self.min_count = 0
    
    def _update_count(self, key: int) -> None:
        """Increment count for key and update data structures."""
        count = self.key_to_count[key]
        
        # Remove from current count group
        del self.count_to_keys[count][key]
        
        # If this was the only key at min_count, increment min_count
        if count == self.min_count and not self.count_to_keys[count]:
            self.min_count += 1
        
        # Add to new count group
        new_count = count + 1
        self.key_to_count[key] = new_count
        self.count_to_keys[new_count][key] = None  # Value doesn't matter
    
    def get(self, key: int) -> int:
        """
        Get value if exists, update frequency.
        Returns -1 if key doesn't exist.
        """
        if key not in self.key_to_val:
            return -1
        
        self._update_count(key)
        return self.key_to_val[key]
    
    def put(self, key: int, value: int) -> None:
        """
        Insert or update key-value pair.
        If over capacity, evict LFU (ties broken by LRU).
        """
        if self.capacity == 0:
            return
        
        if key in self.key_to_val:
            # Update existing key
            self.key_to_val[key] = value
            self._update_count(key)
            return
        
        # Need to add new key - check capacity
        if len(self.key_to_val) >= self.capacity:
            # Evict LFU (among those with min_count, evict LRU)
            # OrderedDict.popitem(last=False) gives oldest (LRU)
            evict_key, _ = self.count_to_keys[self.min_count].popitem(last=False)
            del self.key_to_val[evict_key]
            del self.key_to_count[evict_key]
        
        # Add new key with count 1
        self.key_to_val[key] = value
        self.key_to_count[key] = 1
        self.count_to_keys[1][key] = None
        self.min_count = 1  # New key always has count 1


# Example
lfu = LFUCache(2)
lfu.put(1, 1)      # cache: {1: (val=1, count=1)}
lfu.put(2, 2)      # cache: {1: count=1, 2: count=1}
print(lfu.get(1))  # 1, now count of 1 is 2
lfu.put(3, 3)      # Evicts key 2 (count=1, LRU among count=1)
print(lfu.get(2))  # -1 (evicted)
print(lfu.get(3))  # 3
lfu.put(4, 4)      # Evicts key 3 (count=1 < key 1's count=2)
print(lfu.get(1))  # 1
print(lfu.get(3))  # -1 (evicted)
print(lfu.get(4))  # 4
```

**JavaScript:**
```javascript
class LFUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.keyToVal = new Map();
        this.keyToCount = new Map();
        this.countToKeys = new Map();  // count â†’ Map (for LRU order)
        this.minCount = 0;
    }
    
    _updateCount(key) {
        const count = this.keyToCount.get(key);
        
        // Remove from current count group
        this.countToKeys.get(count).delete(key);
        if (count === this.minCount && this.countToKeys.get(count).size === 0) {
            this.minCount++;
        }
        
        // Add to new count group
        const newCount = count + 1;
        this.keyToCount.set(key, newCount);
        if (!this.countToKeys.has(newCount)) {
            this.countToKeys.set(newCount, new Map());
        }
        this.countToKeys.get(newCount).set(key, null);
    }
    
    get(key) {
        if (!this.keyToVal.has(key)) return -1;
        
        this._updateCount(key);
        return this.keyToVal.get(key);
    }
    
    put(key, value) {
        if (this.capacity === 0) return;
        
        if (this.keyToVal.has(key)) {
            this.keyToVal.set(key, value);
            this._updateCount(key);
            return;
        }
        
        if (this.keyToVal.size >= this.capacity) {
            // Evict LFU (LRU among min count)
            const keysAtMin = this.countToKeys.get(this.minCount);
            const evictKey = keysAtMin.keys().next().value;  // First = LRU
            keysAtMin.delete(evictKey);
            this.keyToVal.delete(evictKey);
            this.keyToCount.delete(evictKey);
        }
        
        // Add new key with count 1
        this.keyToVal.set(key, value);
        this.keyToCount.set(key, 1);
        if (!this.countToKeys.has(1)) {
            this.countToKeys.set(1, new Map());
        }
        this.countToKeys.get(1).set(key, null);
        this.minCount = 1;
    }
}
```

---

## ðŸ” Walkthrough

```
Capacity = 2

put(1, 1):
  keyToVal: {1: 1}
  keyToCount: {1: 1}
  countToKeys: {1: [1]}
  minCount: 1

put(2, 2):
  keyToVal: {1: 1, 2: 2}
  keyToCount: {1: 1, 2: 1}
  countToKeys: {1: [1, 2]}  â† Order matters for LRU!
  minCount: 1

get(1) â†’ returns 1:
  keyToVal: {1: 1, 2: 2}
  keyToCount: {1: 2, 2: 1}  â† 1's count increased
  countToKeys: {1: [2], 2: [1]}
  minCount: 1  â† Still 1 because key 2 has count 1

put(3, 3) â†’ need to evict:
  minCount = 1, countToKeys[1] = [2]
  Evict key 2 (LRU at min count)
  
  keyToVal: {1: 1, 3: 3}
  keyToCount: {1: 2, 3: 1}
  countToKeys: {1: [3], 2: [1]}
  minCount: 1  â† Reset to 1 for new key
```

---

## âš¡ Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| get | O(1) | - |
| put | O(1) | - |
| Space | - | O(capacity) |

**Why O(1)?**
- All HashMap lookups are O(1)
- OrderedDict/Map operations are O(1)
- We track min_count explicitly (no search needed)

---

## ðŸ“Š LRU vs LFU Comparison

| Aspect | LRU | LFU |
|--------|-----|-----|
| Eviction criteria | Least recently used | Least frequently used |
| Data structures | HashMap + DLL | 3 HashMaps + tracking |
| Complexity | Simpler | More complex |
| Scan resistance | No | Yes |
| New item advantage | Equal to old | Disadvantaged |
| Use case | General purpose | Frequency matters |

**Scan Resistance:**
```
Sequential scan of 1M items:

LRU: All cache evicted, 0% hit rate afterward
LFU: Popular items survive (have high count), good hit rate

LFU is "scan resistant" - one-time accesses don't evict popular items.
```

---

## âš ï¸ Common Mistakes

### 1. Not Updating min_count Correctly

```python
# âŒ Wrong: Forgot to check if count group is empty
def _update_count(self, key):
    count = self.key_to_count[key]
    del self.count_to_keys[count][key]
    # Missing: check if this was the only key at min_count!
    
    new_count = count + 1
    self.key_to_count[key] = new_count
    self.count_to_keys[new_count][key] = None

# âœ… Correct
def _update_count(self, key):
    count = self.key_to_count[key]
    del self.count_to_keys[count][key]
    
    # Check if we need to update min_count
    if count == self.min_count and not self.count_to_keys[count]:
        self.min_count += 1
    
    new_count = count + 1
    self.key_to_count[key] = new_count
    self.count_to_keys[new_count][key] = None
```

### 2. Not Resetting min_count on New Insert

```python
# âŒ Wrong: min_count not reset for new key
def put(self, key, value):
    ...
    self.key_to_val[key] = value
    self.key_to_count[key] = 1
    self.count_to_keys[1][key] = None
    # Missing: min_count = 1!

# âœ… Correct
def put(self, key, value):
    ...
    self.key_to_val[key] = value
    self.key_to_count[key] = 1
    self.count_to_keys[1][key] = None
    self.min_count = 1  # New key always starts at count 1!
```

### 3. Wrong Eviction (Not Using LRU for Tie-Break)

```python
# âŒ Wrong: Random eviction among same count
evict_key = next(iter(self.count_to_keys[self.min_count]))

# âœ… Correct: LRU eviction (oldest first)
evict_key, _ = self.count_to_keys[self.min_count].popitem(last=False)
```

---

## ðŸ”„ Variations

### 1. LFU with Decay

Over time, reduce counts so old frequent items don't dominate forever.

### 2. Windowed LFU

Only count accesses in recent time window.

### 3. LFU with Minimum Frequency

Don't evict items with count above threshold.

---

## ðŸ“ Practice Problems

| Problem | Difficulty | Key Point |
|---------|------------|-----------|
| [LFU Cache](https://leetcode.com/problems/lfu-cache/) | Hard | This problem! |
| [LRU Cache](https://leetcode.com/problems/lru-cache/) | Medium | Simpler variant |
| [All O'one Data Structure](https://leetcode.com/problems/all-oone-data-structure/) | Hard | Similar min/max tracking |

---

## ðŸŽ¤ Interview Communication

**Opening:**
> "LFU is more complex than LRU because we need to track both the count and the order within each count level for tie-breaking."

**Data structure explanation:**
> "I'll use three hash maps: one for values, one for counts, and one that maps each count to an ordered set of keys. I also track the minimum count for O(1) eviction."

**Key insight:**
> "The trick is that when I update a key's count, I check if it was at min_count. If so and that count group is now empty, min_count increases by 1. When I add a new key, min_count resets to 1."

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 15 min | More complex than LRU |
| Design data structures | 10 min | The hard part |
| Implement | 30 min | Many edge cases |
| Debug | 15 min | min_count tracking |

---

> **ðŸ’¡ Key Insight:** The key to O(1) LFU is tracking `min_count`. We only need it for eviction, and it only changes in two ways: (1) increment when last key at min_count is promoted, (2) reset to 1 when new key is added.

> **ðŸ”— Related:** [LRU Implementation](./2.2-LRU-Implementation.md) | [Cache Practice â†’](./2.4-Cache-Practice.md)

---

**Next:** [Cache Practice â†’](./2.4-Cache-Practice.md)
