# 1.3 - Tree Traversal Overview

> **Foundation:** Understanding all traversal methods before diving into specifics
>
> **Grokking Patterns:** #10 Tree BFS, #11 Tree DFS

---

## Overview

Tree traversal means visiting every node in the tree exactly once in a specific order. There are two main approaches:

| Approach | Method | When to Use |
|----------|--------|-------------|
| **DFS** (Depth-First Search) | Go deep before wide | Most tree problems |
| **BFS** (Breadth-First Search) | Go level by level | Level-based problems |

```
        1
       / \
      2   3
     / \
    4   5

DFS: Goes deep (1 â†’ 2 â†’ 4 â†’ 5 â†’ 3)
BFS: Goes wide (1 â†’ 2 â†’ 3 â†’ 4 â†’ 5)
```

---

## ðŸŽ¯ The Four Main Traversals

### Quick Reference

| Traversal | Order | When Root is Visited | Common Use |
|-----------|-------|---------------------|------------|
| **Preorder** | Root â†’ Left â†’ Right | FIRST | Copy tree, serialize |
| **Inorder** | Left â†’ Root â†’ Right | MIDDLE | BST sorted order |
| **Postorder** | Left â†’ Right â†’ Root | LAST | Delete tree, calculate height |
| **Level-order** | Level by level | Per level | Find width, shortest path |

### Visualization

```
        1
       / \
      2   3

Preorder:    1, 2, 3  (Root FIRST)
Inorder:     2, 1, 3  (Root MIDDLE)
Postorder:   2, 3, 1  (Root LAST)
Level-order: 1, 2, 3  (Top to bottom)
```

---

## ðŸ“ DFS Traversals (Depth-First)

### Preorder: Root â†’ Left â†’ Right

```python
def preorder(root):
    if not root:
        return []
    return [root.val] + preorder(root.left) + preorder(root.right)
```

**Memory trick:** Pre = Root comes FIRST (before children)

**Use cases:**
- Create a copy of the tree
- Serialize tree (save to string)
- Expression tree: prefix notation

### Inorder: Left â†’ Root â†’ Right

```python
def inorder(root):
    if not root:
        return []
    return inorder(root.left) + [root.val] + inorder(root.right)
```

**Memory trick:** In = Root is IN the middle

**Use cases:**
- BST: gives sorted order!
- Expression tree: infix notation
- Validate BST

### Postorder: Left â†’ Right â†’ Root

```python
def postorder(root):
    if not root:
        return []
    return postorder(root.left) + postorder(root.right) + [root.val]
```

**Memory trick:** Post = Root comes LAST (after children)

**Use cases:**
- Delete tree (children before parent)
- Calculate height (need children first)
- Expression tree: postfix notation

---

## ðŸ“ BFS Traversal (Breadth-First)

### Level-Order: Level by Level

```python
from collections import deque

def level_order(root):
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        level = []
        
        for _ in range(level_size):
            node = queue.popleft()
            level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level)
    
    return result
```

**Use cases:**
- Find nodes at specific depth
- Level-based calculations (averages, sums)
- Shortest path in unweighted tree
- Zigzag traversal

---

## ðŸ’» Complete Code Comparison

**Python:**
```python
from collections import deque
from typing import Optional, List

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


# DFS Traversals (Recursive)
def preorder(root: Optional[TreeNode]) -> List[int]:
    """Root â†’ Left â†’ Right"""
    if not root:
        return []
    return [root.val] + preorder(root.left) + preorder(root.right)


def inorder(root: Optional[TreeNode]) -> List[int]:
    """Left â†’ Root â†’ Right"""
    if not root:
        return []
    return inorder(root.left) + [root.val] + inorder(root.right)


def postorder(root: Optional[TreeNode]) -> List[int]:
    """Left â†’ Right â†’ Root"""
    if not root:
        return []
    return postorder(root.left) + postorder(root.right) + [root.val]


# BFS Traversal
def level_order(root: Optional[TreeNode]) -> List[List[int]]:
    """Level by level"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)
    
    return result


# Test
root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))
print(f"Preorder:    {preorder(root)}")     # [1, 2, 4, 5, 3]
print(f"Inorder:     {inorder(root)}")      # [4, 2, 5, 1, 3]
print(f"Postorder:   {postorder(root)}")    # [4, 5, 2, 3, 1]
print(f"Level-order: {level_order(root)}")  # [[1], [2, 3], [4, 5]]
```

**JavaScript:**
```javascript
// DFS Traversals
function preorder(root) {
    if (!root) return [];
    return [root.val, ...preorder(root.left), ...preorder(root.right)];
}

function inorder(root) {
    if (!root) return [];
    return [...inorder(root.left), root.val, ...inorder(root.right)];
}

function postorder(root) {
    if (!root) return [];
    return [...postorder(root.left), ...postorder(root.right), root.val];
}

// BFS Traversal
function levelOrder(root) {
    if (!root) return [];
    
    const result = [];
    const queue = [root];
    
    while (queue.length > 0) {
        const level = [];
        const levelSize = queue.length;
        
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            level.push(node.val);
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        result.push(level);
    }
    
    return result;
}
```

---

## âš¡ Complexity Comparison

| Traversal | Time | Space | Space Details |
|-----------|------|-------|---------------|
| Preorder |" O(n) "| O(h) | Call stack depth = height |
| Inorder |" O(n) "| O(h) | Call stack depth = height |
| Postorder |" O(n) "| O(h) | Call stack depth = height |
| Level-order |" O(n) "| O(w) | Queue width = max level size |

**Where:**
- n = number of nodes
- h = tree height (log n for balanced, n for skewed)
- w = max tree width (can be n/2 at bottom level of perfect tree)

---

## ðŸ”„ Choosing the Right Traversal

### Decision Tree

```
What do you need?
â”‚
â”œâ”€ Sorted order from BST?
â”‚  â””â”€ Inorder
â”‚
â”œâ”€ Process children before parent?
â”‚  â””â”€ Postorder (e.g., calculate height, delete tree)
â”‚
â”œâ”€ Process parent before children?
â”‚  â””â”€ Preorder (e.g., copy tree, serialize)
â”‚
â”œâ”€ Level-by-level processing?
â”‚  â””â”€ Level-order (BFS)
â”‚
â””â”€ Default for most tree problems?
   â””â”€ Preorder (most intuitive)
```

### Pattern Matching

| If the problem mentions... | Use |
|---------------------------|-----|
| "sorted order" + BST | Inorder |
| "copy", "clone", "serialize" | Preorder |
| "height", "depth", "bottom-up" | Postorder |
| "level", "width", "layer" | Level-order (BFS) |
| "path from root" | DFS (any) |
| "shortest path" (unweighted) | BFS |

---

## ðŸŽ¯ Interview Frequency by Pattern

Based on Grokking the Coding Interview analysis:

| Pattern | % of Tree Problems | LeetCode Count |
|---------|-------------------|----------------|
| Tree DFS (#11) | ~60% | 50+ problems |
| Tree BFS (#10) | ~25% | 30+ problems |
| Combined | ~15% | Various |

**DFS is more common** because:
- More versatile for path problems
- Natural for recursive tree structure
- Cleaner code for most problems

**BFS is essential** for:
- Level-based problems
- Shortest path problems
- Right/left side view problems

---

## âš ï¸ Common Mistakes

### 1. Using BFS When DFS is Cleaner

```python
# âŒ Overcomplicated: Using BFS for simple traversal
def find_max_bfs(root):
    queue = deque([root])
    max_val = float('-inf')
    while queue:
        node = queue.popleft()
        max_val = max(max_val, node.val)
        if node.left: queue.append(node.left)
        if node.right: queue.append(node.right)
    return max_val

# âœ… Cleaner: DFS is simpler
def find_max_dfs(root):
    if not root:
        return float('-inf')
    return max(root.val, find_max_dfs(root.left), find_max_dfs(root.right))
```

### 2. Forgetting to Track Levels in BFS

```python
# âŒ WRONG: Not tracking level boundaries
queue = [root]
while queue:
    node = queue.pop(0)  # Loses level information

# âœ… CORRECT: Process level by level
while queue:
    level_size = len(queue)  # Capture current level size
    for _ in range(level_size):
        node = queue.popleft()
```

### 3. Confusing Traversal Orders

```python
# Memory aids:
# PRE-order: Root FIRST (pre = before)
# IN-order: Root IN the middle
# POST-order: Root LAST (post = after)
```

---

## ðŸ“ Practice Progression

### Phase 1: Basic Traversals
- [ ] [Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/) - LC 94
- [ ] [Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/) - LC 144
- [ ] [Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/) - LC 145
- [ ] [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) - LC 102

### Phase 2: Apply Traversals
- [ ] [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) - LC 104 (DFS)
- [ ] [Same Tree](https://leetcode.com/problems/same-tree/) - LC 100 (DFS)
- [ ] [Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/) - LC 107 (BFS)
- [ ] [Average of Levels](https://leetcode.com/problems/average-of-levels-in-binary-tree/) - LC 637 (BFS)

---

## ðŸŽ¤ Interview Context

<details>
<summary><strong>How to Choose and Communicate</strong></summary>

**Choosing approach:**
> "I'll use DFS because we need to explore paths from root to leaf."
> "I'll use BFS because we need to process level by level."

**Trade-off discussion:**
> "DFS uses O(h) space for the call stack, BFS uses O(w) for the queue. For a balanced tree, both are O(log n). For a skewed tree, DFS is O(n) and BFS is O(1)."

**Common follow-up:**
> "Can you convert your recursive DFS to iterative?"
> "What if the tree is very deep - how would you handle stack overflow?"

</details>

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn all 4 traversals | 30-45 min | Conceptual |
| Implement each | 30 min | Practice coding |
| Recognize which to use | 5 min | Pattern matching |

---

> **ðŸ’¡ Key Insight:** Most tree problems use DFS (preorder, inorder, or postorder). BFS is specifically for level-based problems. When in doubt, start with DFS - it's more versatile and often leads to cleaner recursive solutions.

---

## ðŸ”— Related

- [DFS Traversals](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
- [BFS Traversals](../03-Tree-Traversals/3.2-BFS-Traversals/00-BFS-Concept.md)
- [Tree Terminology](./1.1-Tree-Terminology.md)
