# 1.6 - 2D Arrays (Matrices)

> **Foundation:** Multi-dimensional array operations essential for grid/matrix problems
>
> **Priority:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê HIGH - Matrix problems appear frequently in interviews
>
> **Grokking Pattern:** Island (Matrix Traversal) - #28

---

## Overview

A **2D array** (matrix) is an array of arrays, representing data in rows and columns. Matrix problems are interview favorites because they combine array manipulation with algorithmic thinking.

```
Matrix (3x4):
     col 0  col 1  col 2  col 3
row 0 [ 1,    2,     3,     4  ]
row 1 [ 5,    6,     7,     8  ]
row 2 [ 9,   10,    11,    12  ]

Access: matrix[row][col]
Example: matrix[1][2] = 7
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Matrix Problems</strong></summary>

**Look for these signals:**
- Problem mentions "grid", "matrix", "2D array"
- m x n dimensions given
- Moving in 4 or 8 directions (up, down, left, right, diagonals)
- Finding paths, regions, or connected components

**Keywords in problem statement:**
- "given an m x n matrix"
- "traverse the grid"
- "find all cells", "count islands"
- "rotate", "transpose", "spiral order"

</details>

---

## ‚úÖ When to Use

- Grid traversal problems (islands, paths)
- Image manipulation (rotate, flip)
- Game boards (chess, minesweeper)
- Dynamic programming on grids
- Graph problems represented as adjacency matrix

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|-------------------|
| Sparse matrix (mostly zeros) | Hash map of coordinates |
| Very large grids | Segment trees, lazy propagation |
| Need to insert/delete rows frequently | Linked structure |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [1.1 Array Basics](1.1-Array-Basics.md) - 1D array operations
- [1.3 Array Traversal](1.3-Array-Traversal.md) - Loop patterns

**After mastering this:**
- [Grid Traversal (Graphs)](../../10-Graphs/05-Grid-Traversal/) - BFS/DFS on grids
- [Grid DP](../../11-Dynamic-Programming/03-Grid-DP/) - Dynamic programming on matrices

**Combines with:**
- BFS/DFS for island counting, shortest path
- Two Pointers for sorted matrix search
- Prefix Sum for submatrix queries

</details>

---

## üìê Declaration & Initialization

### Python

```python
# Create m x n matrix filled with zeros
rows, cols = 3, 4
matrix = [[0] * cols for _ in range(rows)]

# ‚ö†Ô∏è WRONG: Creates references to same list!
# wrong_matrix = [[0] * cols] * rows

# Initialize with values
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]

# Get dimensions
m, n = len(matrix), len(matrix[0])  # m=3 rows, n=4 cols
```

### JavaScript

```javascript
// Create m x n matrix filled with zeros
const rows = 3, cols = 4;
const matrix = Array.from({ length: rows }, () => Array(cols).fill(0));

// Or using nested map
const matrix2 = Array(rows).fill(null).map(() => Array(cols).fill(0));

// Initialize with values
const matrix3 = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
];

// Get dimensions
const m = matrix3.length;        // 3 rows
const n = matrix3[0].length;     // 4 cols
```

---

## üìê Row-Major vs Column-Major Order

**Memory Layout:**

```
Matrix:     Row-Major (C, Python, JS):    Column-Major (Fortran, MATLAB):
[1, 2, 3]   [1, 2, 3, 4, 5, 6, 7, 8, 9]   [1, 4, 7, 2, 5, 8, 3, 6, 9]
[4, 5, 6]   
[7, 8, 9]   Elements stored row by row    Elements stored column by column
```

**Why it matters:** Cache efficiency. Access elements in the same order they're stored in memory for better performance.

```python
# ‚úÖ Cache-friendly (row-major access)
for row in range(m):
    for col in range(n):
        process(matrix[row][col])

# ‚ùå Cache-unfriendly (column-major access)
for col in range(n):
    for row in range(m):
        process(matrix[row][col])
```

---

## üìê Traversal Patterns

### 1. Row-wise Traversal

```python
def row_wise(matrix):
    """Visit each row, left to right."""
    result = []
    for row in matrix:
        for val in row:
            result.append(val)
    return result

# [1,2,3,4] ‚Üí [5,6,7,8] ‚Üí [9,10,11,12]
```

### 2. Column-wise Traversal

```python
def column_wise(matrix):
    """Visit each column, top to bottom."""
    result = []
    rows, cols = len(matrix), len(matrix[0])
    for col in range(cols):
        for row in range(rows):
            result.append(matrix[row][col])
    return result

# [1,5,9] ‚Üí [2,6,10] ‚Üí [3,7,11] ‚Üí [4,8,12]
```

### 3. Diagonal Traversal

```python
def diagonal_primary(matrix):
    """Primary diagonal: top-left to bottom-right."""
    n = len(matrix)
    return [matrix[i][i] for i in range(n)]
    # [1, 6, 11] for a 3x3 portion

def diagonal_secondary(matrix):
    """Secondary diagonal: top-right to bottom-left."""
    n = len(matrix)
    return [matrix[i][n-1-i] for i in range(n)]
    # [3, 6, 9] for a 3x3 portion

def all_diagonals(matrix):
    """All diagonals (top-left to bottom-right direction)."""
    m, n = len(matrix), len(matrix[0])
    result = []
    
    # Each diagonal has constant (row - col) value
    for d in range(-(n-1), m):
        diagonal = []
        for row in range(m):
            col = row - d
            if 0 <= col < n:
                diagonal.append(matrix[row][col])
        if diagonal:
            result.append(diagonal)
    return result
```

### 4. Spiral Traversal ‚≠ê (Very Common)

```
     ‚Üí  ‚Üí  ‚Üí  ‚Üí
     ‚Üì        ‚Üì
  [  ‚Üí  ‚Üí  ‚Üí  ‚Üì  ]
  [  ‚Üë        ‚Üì  ]
  [  ‚Üë  ‚Üê  ‚Üê  ‚Üê  ]
     ‚Üë
```

**Python:**
```python
def spiral_order(matrix):
    """
    LC 54: Spiral Matrix
    Time: O(m*n), Space: O(1) excluding output
    """
    if not matrix:
        return []
    
    result = []
    top, bottom = 0, len(matrix) - 1
    left, right = 0, len(matrix[0]) - 1
    
    while top <= bottom and left <= right:
        # ‚Üí Move right along top row
        for col in range(left, right + 1):
            result.append(matrix[top][col])
        top += 1
        
        # ‚Üì Move down along right column
        for row in range(top, bottom + 1):
            result.append(matrix[row][right])
        right -= 1
        
        # ‚Üê Move left along bottom row (if rows remain)
        if top <= bottom:
            for col in range(right, left - 1, -1):
                result.append(matrix[bottom][col])
            bottom -= 1
        
        # ‚Üë Move up along left column (if cols remain)
        if left <= right:
            for row in range(bottom, top - 1, -1):
                result.append(matrix[row][left])
            left += 1
    
    return result
```

**JavaScript:**
```javascript
function spiralOrder(matrix) {
    if (!matrix.length) return [];
    
    const result = [];
    let top = 0, bottom = matrix.length - 1;
    let left = 0, right = matrix[0].length - 1;
    
    while (top <= bottom && left <= right) {
        // ‚Üí Right
        for (let col = left; col <= right; col++) {
            result.push(matrix[top][col]);
        }
        top++;
        
        // ‚Üì Down
        for (let row = top; row <= bottom; row++) {
            result.push(matrix[row][right]);
        }
        right--;
        
        // ‚Üê Left
        if (top <= bottom) {
            for (let col = right; col >= left; col--) {
                result.push(matrix[bottom][col]);
            }
            bottom--;
        }
        
        // ‚Üë Up
        if (left <= right) {
            for (let row = bottom; row >= top; row--) {
                result.push(matrix[row][left]);
            }
            left++;
        }
    }
    
    return result;
}
```

### 5. Boundary Traversal

```python
def boundary_traversal(matrix):
    """Only the outer boundary of the matrix."""
    if not matrix:
        return []
    
    m, n = len(matrix), len(matrix[0])
    if m == 1:
        return matrix[0][:]
    if n == 1:
        return [row[0] for row in matrix]
    
    result = []
    
    # Top row (left to right)
    result.extend(matrix[0])
    
    # Right column (excluding corners)
    for row in range(1, m - 1):
        result.append(matrix[row][n - 1])
    
    # Bottom row (right to left)
    result.extend(reversed(matrix[m - 1]))
    
    # Left column (excluding corners)
    for row in range(m - 2, 0, -1):
        result.append(matrix[row][0])
    
    return result
```

---

## üìê Matrix Rotation ‚≠ê

### Rotate 90¬∞ Clockwise (LC 48)

**Approach:** Transpose + Reverse each row

```
Original:    Transpose:    Reverse Rows:
1  2  3      1  4  7       7  4  1
4  5  6  ‚Üí   2  5  8   ‚Üí   8  5  2
7  8  9      3  6  9       9  6  3
```

**Python:**
```python
def rotate_90_clockwise(matrix):
    """
    LC 48: Rotate Image
    In-place rotation. Time: O(n¬≤), Space: O(1)
    """
    n = len(matrix)
    
    # Step 1: Transpose (swap matrix[i][j] with matrix[j][i])
    for i in range(n):
        for j in range(i + 1, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    
    # Step 2: Reverse each row
    for row in matrix:
        row.reverse()
```

**JavaScript:**
```javascript
function rotate90Clockwise(matrix) {
    const n = matrix.length;
    
    // Transpose
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
        }
    }
    
    // Reverse each row
    for (const row of matrix) {
        row.reverse();
    }
}
```

### Rotate 90¬∞ Counter-Clockwise

**Approach:** Transpose + Reverse each column

```python
def rotate_90_counter_clockwise(matrix):
    """Transpose then reverse columns."""
    n = len(matrix)
    
    # Transpose
    for i in range(n):
        for j in range(i + 1, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    
    # Reverse each column (or reverse the order of rows)
    matrix.reverse()
```

### Rotate 180¬∞

**Approach:** Reverse the list of rows, then reverse each row

```python
def rotate_180(matrix):
    """Rotate 180¬∞ = flip vertically + flip horizontally."""
    matrix.reverse()           # Flip vertically
    for row in matrix:
        row.reverse()          # Flip horizontally
```

---

## üìê Matrix Transpose

**Definition:** Swap rows and columns. Element at (i, j) moves to (j, i).

```
Original:          Transposed:
1  2  3            1  4  7
4  5  6      ‚Üí     2  5  8
7  8  9            3  6  9
```

**Python:**
```python
def transpose(matrix):
    """For non-square matrix, need to create new matrix."""
    m, n = len(matrix), len(matrix[0])
    return [[matrix[i][j] for i in range(m)] for j in range(n)]

def transpose_in_place(matrix):
    """In-place transpose for square matrix only."""
    n = len(matrix)
    for i in range(n):
        for j in range(i + 1, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
```

**JavaScript:**
```javascript
function transpose(matrix) {
    const m = matrix.length, n = matrix[0].length;
    const result = Array.from({ length: n }, () => Array(m));
    
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            result[j][i] = matrix[i][j];
        }
    }
    return result;
}
```

---

## üìê Search in Sorted Matrix ‚≠ê

### Search in Row-Sorted & Column-Sorted Matrix (LC 240)

**Properties:**
- Each row is sorted left to right
- Each column is sorted top to bottom

**Approach:** Start from top-right (or bottom-left) corner

```
Matrix:           Find 14
[1,  4,  7,  11]   Start at 15 (top-right)
[2,  5,  8,  12]   15 > 14 ‚Üí move left
[3,  6,  9,  16]   11 < 14 ‚Üí move down
[10, 13, 14, 17]   12 < 14 ‚Üí move down
                   16 > 14 ‚Üí move left
                   14 = 14 ‚Üí found!
```

**Python:**
```python
def search_matrix(matrix, target):
    """
    LC 240: Search a 2D Matrix II
    Time: O(m + n), Space: O(1)
    """
    if not matrix:
        return False
    
    m, n = len(matrix), len(matrix[0])
    row, col = 0, n - 1  # Start top-right
    
    while row < m and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] > target:
            col -= 1  # Move left (smaller values)
        else:
            row += 1  # Move down (larger values)
    
    return False
```

### Search in Fully Sorted Matrix (LC 74)

**Properties:** 
- Each row is sorted
- First element of row > last element of previous row
- Treat as 1D sorted array!

```python
def search_matrix_sorted(matrix, target):
    """
    LC 74: Search a 2D Matrix
    Binary search treating matrix as 1D array
    Time: O(log(m*n)), Space: O(1)
    """
    if not matrix:
        return False
    
    m, n = len(matrix), len(matrix[0])
    left, right = 0, m * n - 1
    
    while left <= right:
        mid = (left + right) // 2
        # Convert 1D index to 2D coordinates
        row, col = mid // n, mid % n
        val = matrix[row][col]
        
        if val == target:
            return True
        elif val < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Access element | O(1) | O(1) | Direct index |
| Row/Column traversal | O(m*n) | O(1) | Visit each cell once |
| Spiral traversal | O(m*n) | O(1) | Visit each cell once |
| Rotate 90¬∞ (in-place) | O(n¬≤) | O(1) | Square matrix |
| Transpose | O(m*n) | O(m*n) | Non-square needs new matrix |
| Transpose (in-place) | O(n¬≤) | O(1) | Square matrix only |
| Search (row+col sorted) | O(m+n) | O(1) | Staircase search |
| Search (fully sorted) | O(log(m*n)) | O(1) | Binary search |

---

## üîÑ Variations

| Variation | Difference | Example Problem |
|-----------|------------|-----------------|
| Spiral Matrix II | Fill matrix in spiral order | LC 59 |
| Set Matrix Zeroes | Mark entire row/col as 0 | LC 73 |
| Game of Life | Cell state based on neighbors | LC 289 |
| Island Counting | Connected component counting | LC 200 |
| Flood Fill | Paint connected region | LC 733 |

---

## ‚ö†Ô∏è Common Mistakes

1. **Index confusion: row vs column**
   - ‚ùå `matrix[col][row]`
   - ‚úÖ `matrix[row][col]` - row first, then column

2. **Off-by-one in boundaries**
   - ‚ùå `for col in range(left, right)` - misses last column
   - ‚úÖ `for col in range(left, right + 1)` - includes right

3. **Modifying matrix while iterating**
   - ‚ùå Changing values during BFS/DFS without marking
   - ‚úÖ Mark visited cells or use separate visited set

4. **Direction vectors wrong**
   - ‚ùå `directions = [(1,0), (0,1), (1,0), (0,-1)]` - duplicate!
   - ‚úÖ `directions = [(0,1), (1,0), (0,-1), (-1,0)]` - right, down, left, up

5. **Boundary check ordering**
   - ‚ùå `matrix[row][col] and row < m` - access before check!
   - ‚úÖ `row < m and col < n and matrix[row][col]` - bounds first

---

## üìù Practice Problems (Progressive)

### Easy (Learn the basics)
- [ ] [Transpose Matrix](https://leetcode.com/problems/transpose-matrix/) - LC 867
- [ ] [Flood Fill](https://leetcode.com/problems/flood-fill/) - LC 733
- [ ] [Island Perimeter](https://leetcode.com/problems/island-perimeter/) - LC 463

### Medium (Core patterns)
- [ ] [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/) - LC 54 ‚≠ê
- [ ] [Rotate Image](https://leetcode.com/problems/rotate-image/) - LC 48 ‚≠ê
- [ ] [Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/) - LC 73 ‚≠ê
- [ ] [Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/) - LC 74 ‚≠ê
- [ ] [Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/) - LC 240 ‚≠ê
- [ ] [Number of Islands](https://leetcode.com/problems/number-of-islands/) - LC 200 ‚≠ê
- [ ] [Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/) - LC 59

### Hard (Advanced techniques)
- [ ] [Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/) - LC 1091
- [ ] [Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/) - LC 85

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

After solving each problem, schedule reviews:
- **Day 1:** Redo without looking at solution
- **Day 3:** Explain the approach out loud
- **Day 7:** Solve Spiral Matrix + Rotate Image together
- **Day 14:** Solve a Search in Matrix problem
- **Day 30:** Review if you struggled

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Company Frequency:**
| Company | Frequency | Focus Areas |
|---------|-----------|-------------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Spiral, Rotation, Search |
| Meta | ‚≠ê‚≠ê‚≠ê | Islands, Grid BFS/DFS |
| Google | ‚≠ê‚≠ê‚≠ê | Novel matrix problems |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Standard matrix ops |

**When explaining your approach:**
1. "I'll use four boundary pointers to track the spiral"
2. "For rotation, I'll transpose then reverse rows - this is O(n¬≤) in-place"
3. "Since rows and columns are sorted, I can start from top-right corner"

**Questions interviewer might ask:**
- "Can you do this in-place?" ‚Üí Yes for rotation, transpose of square matrix
- "What's the time complexity?" ‚Üí Most traversals are O(m*n)
- "What about a sparse matrix?" ‚Üí Consider hash map representation

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn traversal patterns | 30-45 min | Row, column, diagonal, spiral |
| Understand rotation/transpose | 20-30 min | Key insight: transpose + reverse |
| Practice Easy problems | 15-20 min each | Build confidence |
| Practice Medium problems | 25-35 min each | Interview standard |
| Master the pattern | 2-3 hours | Complete problem set above |

---

> **üí° Key Insight:** Most matrix problems use one of these building blocks: spiral traversal, transpose + reverse (rotation), or staircase search (sorted matrices). Master these three and you can solve most matrix problems!

> **üîó Related:** [Grid Traversal (BFS/DFS)](../../10-Graphs/05-Grid-Traversal/) | [Grid DP](../../11-Dynamic-Programming/03-Grid-DP/) | [Binary Search](../../03-Sorting-Searching/02-Searching/)
