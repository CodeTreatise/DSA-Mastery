# Basic Union-Find Implementation

> **Start with the naive approach to understand the core ideas, then optimize.**
>
> The naive implementation is O(n) per operation but reveals what needs optimization.

---

## ðŸŽ¯ Core Operations

Union-Find has only two operations:

| Operation | Purpose | Goal |
|-----------|---------|------|
| `find(x)` | Find the root/representative of x's set | Identify which set x belongs to |
| `union(x, y)` | Merge the sets containing x and y | Connect two elements |

**Additional common operations:**
- `connected(x, y)`: Check if x and y are in the same set
- `count()`: Number of disjoint sets

---

## ðŸ“ Naive Implementation (Array-Based)

### The Parent Array

```
Each element points to its parent.
Root elements point to themselves.

Index:    0   1   2   3   4
Parent:  [0,  1,  1,  3,  3]
          â†‘   â†‘       â†‘
        root root   root

Sets: {0}, {1, 2}, {3, 4}
```

### Finding the Root

```
To find which set element 2 belongs to:
1. parent[2] = 1  â†’ not pointing to self, go to parent
2. parent[1] = 1  â†’ pointing to self, found root!

Root of element 2 is 1
```

---

## ðŸ’» Naive Implementation

**Python:**
```python
class NaiveUnionFind:
    """
    Basic Union-Find without optimizations.
    
    Time Complexity:
    - find: O(n) worst case (linear chain)
    - union: O(n) worst case
    
    Space: O(n)
    """
    
    def __init__(self, n: int):
        """Initialize n elements, each in its own set."""
        # Each element is its own parent initially (n separate sets)
        self.parent = list(range(n))
        self.count = n  # Track number of sets
    
    def find(self, x: int) -> int:
        """
        Find the root (representative) of the set containing x.
        
        Walk up the parent chain until we find an element
        that points to itself.
        """
        while self.parent[x] != x:
            x = self.parent[x]
        return x
    
    def union(self, x: int, y: int) -> bool:
        """
        Merge the sets containing x and y.
        
        Returns True if merge happened, False if already in same set.
        """
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False  # Already in same set
        
        # Attach root_y under root_x (arbitrary choice in naive version)
        self.parent[root_y] = root_x
        self.count -= 1
        return True
    
    def connected(self, x: int, y: int) -> bool:
        """Check if x and y are in the same set."""
        return self.find(x) == self.find(y)
    
    def get_count(self) -> int:
        """Return the number of disjoint sets."""
        return self.count


# Example usage
uf = NaiveUnionFind(5)
print(uf.get_count())        # 5 (each element in own set)

uf.union(0, 1)
print(uf.connected(0, 1))    # True
print(uf.connected(0, 2))    # False
print(uf.get_count())        # 4

uf.union(2, 3)
uf.union(0, 2)               # Merges {0,1} and {2,3}
print(uf.get_count())        # 2
print(uf.connected(1, 3))    # True (both in same set now)
```

**JavaScript:**
```javascript
class NaiveUnionFind {
    constructor(n) {
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.count = n;
    }
    
    find(x) {
        while (this.parent[x] !== x) {
            x = this.parent[x];
        }
        return x;
    }
    
    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);
        
        if (rootX === rootY) return false;
        
        this.parent[rootY] = rootX;
        this.count--;
        return true;
    }
    
    connected(x, y) {
        return this.find(x) === this.find(y);
    }
    
    getCount() {
        return this.count;
    }
}

// Example
const uf = new NaiveUnionFind(5);
console.log(uf.getCount());        // 5
uf.union(0, 1);
console.log(uf.connected(0, 1));   // true
console.log(uf.connected(0, 2));   // false
```

---

## ðŸ” Step-by-Step Walkthrough

```
Initial: n = 5
Index:   0   1   2   3   4
Parent: [0,  1,  2,  3,  4]  â† Each points to self (5 sets)

Step 1: union(0, 1)
  find(0) = 0, find(1) = 1
  Set parent[1] = 0
  Parent: [0,  0,  2,  3,  4]  (4 sets)
  
  Structure: 0 â† 1   2   3   4

Step 2: union(2, 3)
  find(2) = 2, find(3) = 3
  Set parent[3] = 2
  Parent: [0,  0,  2,  2,  4]  (3 sets)
  
  Structure: 0 â† 1   2 â† 3   4

Step 3: union(1, 3)  (connects the two groups)
  find(1) = 0 (1 â†’ 0, 0 points to self)
  find(3) = 2 (3 â†’ 2, 2 points to self)
  Set parent[2] = 0
  Parent: [0,  0,  0,  2,  4]  (2 sets)
  
  Structure:   0
              /|\
             1 2 â† 3
             
             4 (separate)

Step 4: connected(1, 3)?
  find(1) = 0
  find(3): 3 â†’ 2 â†’ 0 = 0
  Same root â†’ True!
```

---

## âš¡ Complexity Analysis

### Worst Case: Linear Chain

The problem with naive implementation:

```
If we always attach second root under first:

union(1, 0): 0 â† 1
union(2, 1): 0 â† 1 â† 2
union(3, 2): 0 â† 1 â† 2 â† 3
union(4, 3): 0 â† 1 â† 2 â† 3 â† 4

Now find(4) takes O(n) steps!
```

| Operation | Best | Worst | Average |
|-----------|------|-------|---------|
| find | O(1) | O(n) | O(n) |
| union | O(1) | O(n) | O(n) |
| connected | O(1) | O(n) | O(n) |

**Space:** O(n) for parent array

---

## ðŸ”„ Tree Representation

Union-Find creates a **forest** (collection of trees):

```
Initial (5 separate trees):
  0   1   2   3   4

After some unions:
     0           4
    /|\
   1 2 3

After more unions:
        0
      / | \
     1  2  4
     |
     3
```

**Key insight:** The "set" is identified by its root. All nodes in the same tree belong to the same set.

---

## âš ï¸ Common Mistakes

### 1. Wrong Base Case for Find

```python
# âŒ Wrong: Infinite loop!
def find(self, x):
    while self.parent[x] != x:
        pass  # Forgot to update x!
    return x

# âœ… Correct
def find(self, x):
    while self.parent[x] != x:
        x = self.parent[x]  # Move up the tree
    return x
```

### 2. Not Checking if Already Connected

```python
# âŒ Wrong: Creates self-loop or wrong count
def union(self, x, y):
    root_x = self.find(x)
    root_y = self.find(y)
    self.parent[root_y] = root_x  # Even if same!
    self.count -= 1  # Decrements even when no merge!

# âœ… Correct: Check first
def union(self, x, y):
    root_x = self.find(x)
    root_y = self.find(y)
    if root_x == root_y:
        return False  # No merge needed
    self.parent[root_y] = root_x
    self.count -= 1
    return True
```

### 3. Off-by-One in Initialization

```python
# âŒ Wrong for 0-indexed problems
def __init__(self, n):
    self.parent = list(range(1, n + 1))  # 1 to n, but indices are 0 to n-1!

# âœ… Correct: 0-indexed
def __init__(self, n):
    self.parent = list(range(n))  # 0 to n-1
```

---

## ðŸŽ¤ Interview Tips

**When explaining this approach:**
1. "I'll use a parent array where each element points to its parent"
2. "Roots point to themselves"
3. "Find walks up to the root, Union connects roots"
4. "This naive version is O(n), but I can optimize to nearly O(1) with path compression and union by rank"

**Always mention optimizations:**
> "The naive version can degrade to O(n) with a linear chain. With path compression and union by rank, we get amortized O(Î±(n)) which is effectively O(1)."

---

## ðŸ“ Visualization: Find Operation

```
Tree structure:
        0 (root)
       /|\
      1 2 3
      |
      4
      |
      5

find(5):
  Step 1: parent[5] = 4, not root, move up
  Step 2: parent[4] = 1, not root, move up
  Step 3: parent[1] = 0, not root, move up
  Step 4: parent[0] = 0, IS root, return 0

Path: 5 â†’ 4 â†’ 1 â†’ 0
Result: 0
```

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 10-15 min | Parent pointer idea |
| Implement naive version | 10-15 min | Simple while loop |
| Trace through examples | 10 min | Build intuition |
| Learn optimizations | 15-20 min | Path compression, rank |

---

> **ðŸ’¡ Key Insight:** The naive implementation reveals the core idea: parent pointers create implicit trees, and the root identifies the set. The linear chain problem motivates the optimizations we'll learn next.

> **ðŸ”— Related:** [Union-Find Fundamentals](./1.1-Union-Find-Fundamentals.md) | [Optimizations â†’](./1.3-Optimizations.md)

---

**Next:** [Optimizations â†’](./1.3-Optimizations.md)
