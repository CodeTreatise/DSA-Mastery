# TrieNode Structure

> **The TrieNode is the building block of every Trie - understanding its design is crucial for implementing efficient Trie operations.**

---

## üéØ Pattern Recognition

<details>
<summary><strong>When Node Design Matters</strong></summary>

**Choose HashMap-based node when:**
- Mixed characters (uppercase, lowercase, digits, symbols)
- Unicode/international characters
- Sparse character set (few of many possible characters)
- Flexibility is more important than speed

**Choose Array[26]-based node when:**
- Only lowercase letters (or known fixed alphabet)
- Maximum performance needed
- Interview explicitly states "lowercase English letters"
- Dense character distribution

</details>

---

## ‚úÖ When to Use Each Design

| Design | Use Case | Space | Time |
|--------|----------|-------|------|
| **HashMap** | Flexible characters | O(actual children) | O(1) avg |
| **Array[26]** | Lowercase only | O(26) per node | O(1) guaranteed |
| **Array[128]** | ASCII characters | O(128) per node | O(1) guaranteed |

---

## ‚ùå Common Design Mistakes

| Mistake | Problem | Solution |
|---------|---------|----------|
| Using Array[26] for Unicode | Index out of bounds | Use HashMap |
| HashMap for lowercase only | Unnecessary overhead | Use Array[26] |
| Not tracking word count | Can't support duplicates | Add `count` field |
| No end marker | Can't distinguish prefixes | Add `is_end` field |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Trie](./1.1-What-Is-Trie.md) - Basic understanding
- [Hash Maps](../../09-Hashing.md) - For HashMap implementation
- [Classes/OOP basics](../../00-Prerequisites.md) - Object design

**After mastering this:**
- [Trie Class Design](./2.2-Trie-Class-Design.md) - Complete class
- [Insert Operation](../02-Trie-Operations/3.1-Insert-Operation.md) - Uses nodes
- [Delete Operation](../02-Trie-Operations/3.4-Delete-Operation.md) - Complex node handling

**Design considerations combine with:**
- **Memory optimization** for large dictionaries
- **Serialization** for persistent storage
- **Thread safety** for concurrent access

</details>

---

## üìê How It Works

### The Role of TrieNode

Each TrieNode stores:
1. **Children references** - Mapping to next characters
2. **End marker** - Is this node the end of a word?
3. **Optional metadata** - Count, stored word, etc.

```
        TrieNode Structure
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ children: {char ‚Üí Node}  ‚îÇ  ‚Üê Links to child nodes
        ‚îÇ is_end: boolean          ‚îÇ  ‚Üê Word completion marker
        ‚îÇ count: int (optional)    ‚îÇ  ‚Üê Number of words ending here
        ‚îÇ word: str (optional)     ‚îÇ  ‚Üê Store complete word
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Visual: Node Relationships

```
Words: ["cat", "car", "card"]

    (root)
       ‚îÇ
       c ‚îÄ‚îÄ TrieNode(is_end=False)
       ‚îÇ
       a ‚îÄ‚îÄ TrieNode(is_end=False)
      / \
     t   r
     ‚îÇ   ‚îÇ
   (‚úì)  (‚úì) ‚Üê car ends
           ‚îÇ
           d
           ‚îÇ
          (‚úì) ‚Üê card ends
     ‚îÇ
  cat ends
```

---

## üíª Implementation Approaches

### Approach 1: HashMap-Based (Flexible)

**Python:**
```python
class TrieNode:
    """
    HashMap-based TrieNode.
    
    Pros: Handles any characters, memory-efficient for sparse nodes
    Cons: Hash overhead, slightly slower than array
    """
    
    def __init__(self):
        self.children = {}  # char -> TrieNode
        self.is_end = False
    
    def has_child(self, char: str) -> bool:
        """Check if child exists for character."""
        return char in self.children
    
    def get_child(self, char: str) -> 'TrieNode':
        """Get child node for character (or None)."""
        return self.children.get(char)
    
    def add_child(self, char: str) -> 'TrieNode':
        """Add child and return it."""
        if char not in self.children:
            self.children[char] = TrieNode()
        return self.children[char]
    
    def is_empty(self) -> bool:
        """Check if node has no children."""
        return len(self.children) == 0
```

**JavaScript:**
```javascript
class TrieNode {
    /**
     * HashMap-based TrieNode
     */
    constructor() {
        this.children = new Map();  // or {} for plain object
        this.isEnd = false;
    }
    
    hasChild(char) {
        return this.children.has(char);
    }
    
    getChild(char) {
        return this.children.get(char) || null;
    }
    
    addChild(char) {
        if (!this.children.has(char)) {
            this.children.set(char, new TrieNode());
        }
        return this.children.get(char);
    }
    
    isEmpty() {
        return this.children.size === 0;
    }
}
```

---

### Approach 2: Array[26]-Based (Optimized)

**Python:**
```python
class TrieNode:
    """
    Array-based TrieNode for lowercase letters only.
    
    Pros: O(1) guaranteed lookup, cache-friendly
    Cons: Fixed alphabet, wastes space if sparse
    """
    
    ALPHABET_SIZE = 26
    
    def __init__(self):
        self.children = [None] * self.ALPHABET_SIZE
        self.is_end = False
    
    def _char_to_index(self, char: str) -> int:
        """Convert character to array index."""
        return ord(char) - ord('a')
    
    def has_child(self, char: str) -> bool:
        """Check if child exists for character."""
        return self.children[self._char_to_index(char)] is not None
    
    def get_child(self, char: str) -> 'TrieNode':
        """Get child node for character (or None)."""
        return self.children[self._char_to_index(char)]
    
    def add_child(self, char: str) -> 'TrieNode':
        """Add child and return it."""
        index = self._char_to_index(char)
        if self.children[index] is None:
            self.children[index] = TrieNode()
        return self.children[index]
    
    def is_empty(self) -> bool:
        """Check if node has no children."""
        return all(child is None for child in self.children)
    
    def get_all_children(self) -> list:
        """Return list of (char, node) for existing children."""
        result = []
        for i, node in enumerate(self.children):
            if node is not None:
                result.append((chr(i + ord('a')), node))
        return result
```

**JavaScript:**
```javascript
class TrieNode {
    /**
     * Array-based TrieNode for lowercase letters only
     */
    constructor() {
        this.children = new Array(26).fill(null);
        this.isEnd = false;
    }
    
    _charToIndex(char) {
        return char.charCodeAt(0) - 'a'.charCodeAt(0);
    }
    
    _indexToChar(index) {
        return String.fromCharCode(index + 'a'.charCodeAt(0));
    }
    
    hasChild(char) {
        return this.children[this._charToIndex(char)] !== null;
    }
    
    getChild(char) {
        return this.children[this._charToIndex(char)];
    }
    
    addChild(char) {
        const index = this._charToIndex(char);
        if (this.children[index] === null) {
            this.children[index] = new TrieNode();
        }
        return this.children[index];
    }
    
    isEmpty() {
        return this.children.every(child => child === null);
    }
    
    getAllChildren() {
        const result = [];
        for (let i = 0; i < 26; i++) {
            if (this.children[i] !== null) {
                result.push([this._indexToChar(i), this.children[i]]);
            }
        }
        return result;
    }
}
```

---

### Approach 3: Extended Node (With Metadata)

**Python:**
```python
class TrieNode:
    """
    Extended TrieNode with additional metadata.
    
    Use when you need:
    - Word count (for duplicates or frequency)
    - Prefix count (how many words share this prefix)
    - The complete word stored at end node
    """
    
    def __init__(self):
        self.children = {}
        self.is_end = False
        
        # Count of words ending at this node
        self.end_count = 0
        
        # Count of words passing through this node
        self.prefix_count = 0
        
        # Store the complete word (useful for Word Search II)
        self.word = None
    
    def mark_word(self, word: str) -> None:
        """Mark this node as end of word."""
        self.is_end = True
        self.end_count += 1
        self.word = word
    
    def unmark_word(self) -> None:
        """Remove word ending at this node."""
        if self.end_count > 0:
            self.end_count -= 1
        if self.end_count == 0:
            self.is_end = False
            self.word = None
```

**JavaScript:**
```javascript
class TrieNode {
    /**
     * Extended TrieNode with metadata
     */
    constructor() {
        this.children = new Map();
        this.isEnd = false;
        this.endCount = 0;
        this.prefixCount = 0;
        this.word = null;
    }
    
    markWord(word) {
        this.isEnd = true;
        this.endCount++;
        this.word = word;
    }
    
    unmarkWord() {
        if (this.endCount > 0) {
            this.endCount--;
        }
        if (this.endCount === 0) {
            this.isEnd = false;
            this.word = null;
        }
    }
}
```

---

## ‚ö° Complexity Analysis

| Approach | Child Lookup | Memory per Node | Best For |
|----------|--------------|-----------------|----------|
| **HashMap** | O(1) average | O(k) where k = children | Flexible |
| **Array[26]** | O(1) worst | O(26) = O(1) | Lowercase only |
| **Array[128]** | O(1) worst | O(128) = O(1) | ASCII |

### Memory Comparison

For a Trie with **N nodes**:

| Approach | Sparse (avg 2 children) | Dense (avg 10 children) |
|----------|-------------------------|-------------------------|
| HashMap | N √ó (2 √ó ptr + overhead) | N √ó (10 √ó ptr + overhead) |
| Array[26] | N √ó (26 √ó ptr) | N √ó (26 √ó ptr) |

**Rule of thumb:**
- Less than ~4 children per node ‚Üí HashMap is more space-efficient
- More than ~4 children per node ‚Üí Array might be similar
- If you need speed ‚Üí Array is always faster

---

## üîÑ Design Variations

| Variation | Changes | Use Case |
|-----------|---------|----------|
| **Compressed Trie** | Store strings in edges, not just chars | Long common prefixes |
| **Suffix Trie** | Store all suffixes | Pattern matching |
| **Radix Tree** | Compressed, binary-optimized | IP routing |
| **DAWG** | Directed Acyclic Word Graph | Memory-critical |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Index Calculation

**‚ùå Wrong:**
```python
def _char_to_index(self, char):
    return ord(char)  # 'a' = 97, index out of bounds!
```

**‚úÖ Correct:**
```python
def _char_to_index(self, char):
    return ord(char) - ord('a')  # 'a' = 0, 'z' = 25
```

### 2. Modifying Node While Iterating

**‚ùå Wrong:**
```python
for char in node.children:
    if should_delete(node.children[char]):
        del node.children[char]  # RuntimeError!
```

**‚úÖ Correct:**
```python
to_delete = [char for char in node.children 
             if should_delete(node.children[char])]
for char in to_delete:
    del node.children[char]
```

### 3. Not Checking Node Existence

**‚ùå Wrong:**
```python
def get_child(self, char):
    return self.children[char]  # KeyError if not exists!
```

**‚úÖ Correct:**
```python
def get_child(self, char):
    return self.children.get(char)  # Returns None if not exists
```

---

## üìù Practice Problems

### Easy (Understand node structure)
- [ ] [Implement Trie](https://leetcode.com/problems/implement-trie-prefix-tree/) - LC 208

### Medium (Work with node metadata)
- [ ] [Design Add and Search Words](https://leetcode.com/problems/design-add-and-search-words-data-structure/) - LC 211
- [ ] [Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/) - LC 677

### Hard (Complex node manipulation)
- [ ] [Word Search II](https://leetcode.com/problems/word-search-ii/) - LC 212 - Uses word storage
- [ ] [Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/) - LC 336

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

For node structure mastery:
- **Day 1:** Implement both HashMap and Array versions
- **Day 3:** Add metadata fields, test with examples
- **Day 7:** Solve problem requiring word storage (Word Search II)
- **Day 14:** Choose optimal design for a given problem
- **Day 30:** Implement from memory, explain trade-offs

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Discuss Node Design</strong></summary>

**When asked about implementation choice:**
> "I'll use a HashMap for children since the problem doesn't specify lowercase-only. This gives us flexibility at a small performance cost. If it were guaranteed lowercase letters, I'd use an Array[26] for O(1) guaranteed lookup."

**When asked about optimization:**
> "To optimize space, we could compress single-child paths into edges storing multiple characters - that's a Radix Tree or Patricia Trie. For this problem though, the standard Trie should work fine."

**When storing complete words:**
> "I'll add a `word` field to each node that stores the complete word when `is_end` is true. This is helpful for problems like Word Search II where we need to collect all found words."

</details>

**Interview Tip:**
| Situation | Recommendation |
|-----------|----------------|
| "Implement Trie" basic | Use HashMap (simpler code) |
| "Lowercase only" stated | Use Array[26] (shows optimization awareness) |
| Need to collect words | Add `word` field |
| Word frequency needed | Add `count` field |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand node concept | 15-20 min | This file |
| Implement HashMap version | 10-15 min | Simpler |
| Implement Array version | 15-20 min | Indexing logic |
| Add metadata fields | 5-10 min | Extension |
| Choose right design for problem | 2-3 min | With practice |

---

> **üí° Key Insight:** The TrieNode design should match your problem constraints. HashMap gives flexibility, Array gives speed. Adding metadata like `word` or `count` unlocks solutions for more complex problems.

> **üîó Related:** [What Is a Trie](./1.1-What-Is-Trie.md) | [Trie Class Design](./2.2-Trie-Class-Design.md) | [Insert Operation](../02-Trie-Operations/3.1-Insert-Operation.md)
