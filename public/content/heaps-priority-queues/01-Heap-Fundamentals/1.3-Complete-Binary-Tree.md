# 1.3 Complete Binary Tree

## Definition

A **Complete Binary Tree** is a binary tree where:
1. **All levels are fully filled**, except possibly the last level
2. **The last level is filled from left to right** (no gaps)

This structure is crucial for heaps because it enables efficient **array representation**.

```
Complete Binary Tree:           NOT Complete (gap):
        1                              1
       / \                            / \
      2   3                          2   3
     / \ /                          /     \
    4  5 6                         4       5
                                   (missing child of 2)
    
Last level fills L‚ÜíR ‚úì           Gap in last level ‚úó
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>Why Complete Trees Matter for Heaps</strong></summary>

**The key insight:**
- Complete tree = **no wasted space** in array representation
- Height = **‚åälog‚ÇÇ(n)‚åã** (minimum possible for n nodes)
- Parent/child relationships calculable by **index formulas**

**Without completeness:**
- Would need pointers (extra memory)
- Gaps would waste array space
- Height could be O(n) worst case

</details>

---

## ‚úÖ Benefits of Complete Trees

| Benefit | Explanation |
|---------|-------------|
| Array storage | No pointers needed, indices work |
| No wasted space | Every array index used |
| Balanced height |" Always O(log n) height "|
| Cache-friendly | Contiguous memory access |
| Easy navigation | Index formulas for parent/children |

## ‚ùå When Trees Are NOT Complete

| Example | Problem |
|---------|---------|
| BST (unbalanced) |" Can degenerate to O(n) height "|
| Arbitrary binary tree | Gaps require pointer representation |
| AVL/Red-Black | Balanced but not necessarily complete |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Heap](./1.1-What-Is-Heap.md)
- [Heap Property](./1.2-Heap-Property.md)
- Binary tree basics

**After mastering this:**
- [Array Representation](./1.4-Array-Representation.md)
- [Heap Operations](../02-Heap-Operations/2.1-Insert.md)

**Related concepts:**
- Full binary tree (all internal nodes have 2 children)
- Perfect binary tree (all levels completely filled)
- Balanced tree (height difference ‚â§ 1)

</details>

---

## üìê How It Works

### Complete vs Other Tree Types

```
PERFECT Binary Tree:        FULL Binary Tree:        COMPLETE Binary Tree:
(All levels full)           (0 or 2 children)        (Left-to-right fill)

        1                        1                         1
       / \                      / \                       / \
      2   3                    2   3                     2   3
     /\ /\                    /\                        / \  /
    4 5 6 7                  4 5                       4  5 6

Perfect ‚Üí Complete ‚úì        Full ‚â† Complete          Complete ‚â† Full
Complete ‚Üí NOT necessarily  (gap at right)           (node 3 has 1 child)
   Perfect
```

### Filling Order for Complete Trees

```
Level 0:    1              Fill position 1 (root)

Level 1:    1              Fill positions 2, 3 (left to right)
           / \
          2   3

Level 2:    1              Fill positions 4, 5, 6, 7 (left to right)
           / \
          2   3
         /\ /\
        4 5 6 7

If we have 6 nodes:
           1
          / \
         2   3
        /\ /
       4 5 6            Position 7 is empty, but that's OK
                        (last level fills L‚ÜíR, can be partial)
```

### Array Mapping

```
Tree:           Array (0-indexed):
    1           [1, 2, 3, 4, 5, 6]
   / \           0  1  2  3  4  5
  2   3
 /\ /
4 5 6

No gaps! Every index from 0 to n-1 is used.

Index formulas (0-indexed):
  Parent of i:     ‚åä(i-1)/2‚åã
  Left child of i:  2i + 1
  Right child of i: 2i + 2
```

---

## üíª Code Implementation

### Checking if Tree is Complete (BFS)

**Python:**
```python
from collections import deque
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def is_complete_tree(root: Optional[TreeNode]) -> bool:
    """
    Check if binary tree is complete using BFS.
    
    Key insight: Once we see a None, all remaining must be None.
    
    Time: O(n), Space: O(w) where w = max width
    """
    if not root:
        return True
    
    queue = deque([root])
    seen_none = False
    
    while queue:
        node = queue.popleft()
        
        if node is None:
            seen_none = True
        else:
            # If we've seen None but now see a node, NOT complete
            if seen_none:
                return False
            queue.append(node.left)
            queue.append(node.right)
    
    return True


# Examples:
# Complete:       Not Complete:
#     1               1
#    / \             / \
#   2   3           2   3
#  / \               \
# 4   5               5

root1 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))
root2 = TreeNode(1, TreeNode(2, None, TreeNode(5)), TreeNode(3))

print(is_complete_tree(root1))  # True
print(is_complete_tree(root2))  # False
```

**JavaScript:**
```javascript
function isCompleteTree(root) {
    if (!root) return true;
    
    const queue = [root];
    let seenNull = false;
    
    while (queue.length > 0) {
        const node = queue.shift();
        
        if (node === null) {
            seenNull = true;
        } else {
            if (seenNull) return false;  // Node after null = not complete
            queue.push(node.left);
            queue.push(node.right);
        }
    }
    
    return true;
}
```

### Checking if Array Represents Complete Tree

**Python:**
```python
def is_array_complete_tree(arr: list, root_idx: int = 0) -> bool:
    """
    For a heap stored as array, check if it represents a complete tree.
    
    A valid heap array (no gaps) is always complete by definition.
    This function checks if we use indices correctly.
    """
    n = len(arr)
    
    # Check no gaps up to n-1
    # In a proper heap array, indices 0 to n-1 are all valid
    # So an array [1, 2, 3, None, 5] would NOT be valid
    
    for i in range(n):
        if arr[i] is None:  # Gap found
            return False
    
    return True


# For heap arrays, we typically don't have None values
# The array length itself determines the tree structure
```

### Counting Nodes in Complete Tree (O(log¬≤ n))

**Python:**
```python
def count_nodes(root: Optional[TreeNode]) -> int:
    """
    Count nodes in complete binary tree.
    
    Trick: Use binary search on last level.
    Time: O(log¬≤ n) instead of O(n)
    
    This is LeetCode 222.
    """
    if not root:
        return 0
    
    def get_depth(node):
        """Get depth of leftmost path (height of tree)"""
        depth = 0
        while node.left:
            depth += 1
            node = node.left
        return depth
    
    def exists(idx, depth, node):
        """Check if node at index `idx` in last level exists"""
        left, right = 0, 2**depth - 1
        for _ in range(depth):
            mid = (left + right) // 2
            if idx <= mid:
                node = node.left
                right = mid
            else:
                node = node.right
                left = mid + 1
        return node is not None
    
    depth = get_depth(root)
    
    if depth == 0:
        return 1
    
    # Binary search for rightmost node in last level
    left, right = 0, 2**depth - 1
    while left < right:
        mid = (left + right + 1) // 2
        if exists(mid, depth, root):
            left = mid
        else:
            right = mid - 1
    
    # Total = nodes in complete levels + nodes in last level
    return 2**depth - 1 + left + 1
```

---

## ‚ö° Complexity Analysis

| Property | Value | Notes |
|----------|-------|-------|
| Height | ‚åälog‚ÇÇ(n)‚åã | Minimum possible |
| Nodes at level k | 2^k | Except last level |
| Last level nodes | 1 to 2^h | At least 1 |
| Array space | Exactly n | No wasted space |

**Height proof:**
```
For n nodes in complete binary tree:
- First h levels have 2^0 + 2^1 + ... + 2^(h-1) = 2^h - 1 nodes
- Last level has 1 to 2^h nodes
- Total: 2^h ‚â§ n < 2^(h+1)
- Therefore: h = ‚åälog‚ÇÇ(n)‚åã
```

---

## üîÑ Variations

| Tree Type | Definition | Complete? |
|-----------|------------|-----------|
| **Complete** | All levels full except last, fills L‚ÜíR | Yes |
| **Perfect** | All levels completely full | Yes (subset) |
| **Full** | Every node has 0 or 2 children | Not necessarily |
| **Balanced** | Height difference ‚â§ 1 at each node | Not necessarily |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Confusing Complete with Full

```
Full but NOT Complete:        Complete but NOT Full:
        1                            1
       / \                          / \
      2   3                        2   3
     / \                          /
    4   5                        4

All nodes have 0 or 2 children  Last level fills L‚ÜíR
But gap exists (right of 3)     But node 3 has only 1 child
```

### 2. Confusing Complete with Perfect

```
Complete but NOT Perfect:     Perfect (also Complete):
        1                            1
       / \                          / \
      2   3                        2   3
     /                            / \ / \
    4                            4  5 6  7

Last level partial             All levels completely filled
Still complete ‚úì               Special case of complete
```

### 3. Assuming All Heaps Are Perfect

```python
# ‚ùå Wrong assumption: heap always has 2^k - 1 elements
heap_size = 2**k - 1

# ‚úÖ Correct: heap can have any number of elements
# The array just represents the complete tree
heap = [1, 2, 3, 4, 5]  # 5 elements is valid
```

---

## üìù Practice Problems (Progressive)

### Easy (Understand concept)
- [ ] [Check Completeness of Binary Tree (LC 958)](https://leetcode.com/problems/check-completeness-of-a-binary-tree/)
- [ ] Draw complete trees for n = 1, 2, ..., 10 nodes

### Medium (Apply concept)
- [ ] [Count Complete Tree Nodes (LC 222)](https://leetcode.com/problems/count-complete-tree-nodes/) - O(log¬≤ n)
- [ ] Implement level-order traversal using array indices

### Hard (Master concept)
- [ ] Prove height of complete tree is ‚åälog‚ÇÇ(n)‚åã
- [ ] Implement array-based binary tree operations

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Draw complete vs full vs perfect trees
- **Day 3:** Solve LC 958 (check completeness)
- **Day 7:** Solve LC 222 with O(log¬≤ n) approach
- **Day 14:** Explain array representation benefits
- **Day 30:** Derive index formulas from scratch

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Explain This in Interviews</strong></summary>

**Defining complete tree:**
"A complete binary tree has all levels full except possibly the last, which fills left to right. This structure allows us to store the tree in an array without wasting space."

**Explaining array benefit:**
"Because there are no gaps, node at index i has children at 2i+1 and 2i+2. No pointers needed, which saves memory and improves cache performance."

**Why heaps use complete trees:**
"The complete tree property guarantees O(log n) height, which means heap operations are O(log n). If the tree weren't complete, it could degenerate to a linked list with O(n) height."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 10-15 min | Draw examples |
| Implement completeness check | 15-20 min | BFS approach |
| Solve LC 222 | 25-30 min | Binary search trick |
| Master index formulas | 10-15 min | Memorize |

---

## üí° Key Insight

> **The complete binary tree property is what makes heaps efficient.** By guaranteeing no gaps and left-to-right filling, we can use an array (not pointers), achieve O(log n) height (guaranteed), and calculate parent/child positions with simple formulas. Without completeness, we'd need a different data structure entirely.

---

## üîó Related

- **Previous:** [Heap Property](./1.2-Heap-Property.md)
- **Next:** [Array Representation](./1.4-Array-Representation.md)
- **Practice:** [Check Completeness (LC 958)](https://leetcode.com/problems/check-completeness-of-a-binary-tree/)
- **Practice:** [Count Nodes (LC 222)](https://leetcode.com/problems/count-complete-tree-nodes/)
