# Sparse Table

> **O(1) range minimum/maximum queries on static arrays after O(n log n) preprocessing.**
>
> When the array never changes, Sparse Table beats Segment Tree for RMQ.

---

## ğŸ¯ When to Use

| Scenario | Why Sparse Table |
|----------|------------------|
| Static array (no updates) | O(1) query after preprocessing |
| Many min/max queries | Faster than segment tree O(log n) |
| Idempotent operations | min, max, GCD, AND, OR |

**Limitation:** Cannot handle updates. Use Segment Tree if array changes.

---

## ğŸ“ How It Works

### The Key Insight

Precompute answers for all ranges of length 2^k.

```
Array: [3, 1, 4, 1, 5, 9, 2, 6]

Sparse Table for MIN:
                    Indices:  0  1  2  3  4  5  6  7
Length 1 (2^0):              [3, 1, 4, 1, 5, 9, 2, 6]
Length 2 (2^1):              [1, 1, 1, 1, 5, 2, 2, -]
Length 4 (2^2):              [1, 1, 1, 1, 2, 2, -, -]
Length 8 (2^3):              [1, -, -, -, -, -, -, -]

sparse[k][i] = min of arr[i : i + 2^k]
```

### Answering Queries

For query [L, R], find k such that 2^k â‰¤ (R - L + 1):

```
Query min(1, 5):  R - L + 1 = 5
  k = floor(log2(5)) = 2  (2^2 = 4)
  
  Two overlapping ranges of length 4:
  Range 1: [1, 4] â†’ sparse[2][1] = 1
  Range 2: [2, 5] â†’ sparse[2][2] = 1
  
  Answer = min(1, 1) = 1
```

**Why overlapping works:** min(A âˆª B) = min(min(A), min(B)), even if A and B overlap!

---

## ğŸ’» Implementation

**Python:**
```python
import math

class SparseTable:
    """
    Sparse Table for O(1) Range Minimum Queries.
    
    Build: O(n log n)
    Query: O(1)
    Space: O(n log n)
    """
    
    def __init__(self, arr: list):
        self.n = len(arr)
        if self.n == 0:
            return
        
        # Precompute log values
        self.log = [0] * (self.n + 1)
        for i in range(2, self.n + 1):
            self.log[i] = self.log[i // 2] + 1
        
        self.k = self.log[self.n] + 1  # Number of levels
        
        # sparse[j][i] = min of arr[i : i + 2^j]
        self.sparse = [[0] * self.n for _ in range(self.k)]
        
        # Base case: length 1
        for i in range(self.n):
            self.sparse[0][i] = arr[i]
        
        # Fill for lengths 2, 4, 8, ...
        for j in range(1, self.k):
            for i in range(self.n - (1 << j) + 1):
                # Combine two halves
                self.sparse[j][i] = min(
                    self.sparse[j - 1][i],
                    self.sparse[j - 1][i + (1 << (j - 1))]
                )
    
    def query(self, L: int, R: int) -> int:
        """Return min of arr[L:R+1] in O(1)."""
        length = R - L + 1
        k = self.log[length]
        
        # Two overlapping ranges of length 2^k
        return min(
            self.sparse[k][L],
            self.sparse[k][R - (1 << k) + 1]
        )


# Example
arr = [3, 1, 4, 1, 5, 9, 2, 6]
st = SparseTable(arr)

print(st.query(0, 3))  # min(3,1,4,1) = 1
print(st.query(4, 7))  # min(5,9,2,6) = 2
print(st.query(0, 7))  # min of all = 1
```

**JavaScript:**
```javascript
class SparseTable {
    constructor(arr) {
        this.n = arr.length;
        if (this.n === 0) return;
        
        // Precompute logs
        this.log = new Array(this.n + 1).fill(0);
        for (let i = 2; i <= this.n; i++) {
            this.log[i] = this.log[Math.floor(i / 2)] + 1;
        }
        
        this.k = this.log[this.n] + 1;
        this.sparse = Array.from({ length: this.k }, 
            () => new Array(this.n).fill(0));
        
        // Base case
        for (let i = 0; i < this.n; i++) {
            this.sparse[0][i] = arr[i];
        }
        
        // Fill table
        for (let j = 1; j < this.k; j++) {
            for (let i = 0; i + (1 << j) <= this.n; i++) {
                this.sparse[j][i] = Math.min(
                    this.sparse[j - 1][i],
                    this.sparse[j - 1][i + (1 << (j - 1))]
                );
            }
        }
    }
    
    query(L, R) {
        const len = R - L + 1;
        const k = this.log[len];
        return Math.min(
            this.sparse[k][L],
            this.sparse[k][R - (1 << k) + 1]
        );
    }
}
```

---

## âš¡ Complexity

| Operation | Time | Space |
|-----------|------|-------|
| Build | O(n log n) | O(n log n) |
| Query | O(1) | - |

**Why O(1) query?** We precomputed all power-of-2 length ranges. Any range can be covered by at most 2 overlapping precomputed ranges.

---

## âš ï¸ Important: Idempotent Operations Only

Sparse Table with overlapping ranges only works for **idempotent** operations:

| Operation | Idempotent? | Sparse Table? |
|-----------|-------------|---------------|
| min | âœ… min(a, a) = a | âœ… Yes |
| max | âœ… max(a, a) = a | âœ… Yes |
| GCD | âœ… gcd(a, a) = a | âœ… Yes |
| AND | âœ… a & a = a | âœ… Yes |
| OR | âœ… a \| a = a | âœ… Yes |
| sum | âŒ a + a â‰  a | âŒ No (use O(log n) variant) |
| XOR | âŒ a ^ a = 0 | âŒ No |

For sum, you need non-overlapping ranges â†’ O(log n) query.

---

## ğŸ“Š Sparse Table vs Segment Tree

| Aspect | Sparse Table | Segment Tree |
|--------|--------------|--------------|
| Query time | O(1) | O(log n) |
| Build time | O(n log n) | O(n) |
| Space | O(n log n) | O(n) |
| Updates | âŒ | âœ… |
| Sum queries | O(log n) | O(log n) |
| Min/Max | O(1) | O(log n) |

**Use Sparse Table when:** Array is static, need many min/max queries.

**Use Segment Tree when:** Array can be updated.

---

## ğŸ“ Practice Problems

| Problem | Difficulty | Notes |
|---------|------------|-------|
| Range Minimum Query (SPOJ) | Easy | Classic Sparse Table |
| [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) | Hard | Can use Sparse Table |

---

> **ğŸ’¡ Key Insight:** The magic is that min/max don't "double count" overlapping elements. min(min([1,2,3]), min([2,3,4])) = min([1,2,3,4]) even though 2,3 appear twice.

> **ğŸ”— Related:** [Segment Tree](../03-Segment-Tree/3.1-Segment-Tree-Fundamentals.md) | [Skip List â†’](./5.2-Skip-List.md)
