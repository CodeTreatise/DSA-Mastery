# LC 1268: Search Suggestions System

> **Real-world autocomplete implementation - use Trie to return top 3 lexicographically sorted suggestions for each prefix.**

---

## üìã Problem Statement

**LeetCode 1268 - Medium**

You are given an array of strings `products` and a string `searchWord`.

Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix, return the three lexicographically minimum products.

Return a list of lists of the suggested products after each character of searchWord is typed.

```
Input: products = ["mobile","mouse","moneypot","monitor","mousepad"]
       searchWord = "mouse"

Output: [
  ["mobile","moneypot","monitor"],  // prefix "m"
  ["mobile","moneypot","monitor"],  // prefix "mo"
  ["mouse","mousepad"],              // prefix "mou"
  ["mouse","mousepad"],              // prefix "mous"
  ["mouse","mousepad"]               // prefix "mouse"
]
```

**Constraints:**
- 1 <= products.length <= 1000
- 1 <= products[i].length <= 3000
- 1 <= searchWord.length <= 1000
- All strings consist of lowercase English letters

---

## üéØ Pattern Recognition

**This is the Collect Words pattern with constraints:**
- Get all words with prefix
- Sort lexicographically
- Return top 3

**Key insight:** Pre-sorting products makes DFS naturally return in order.

---

## üìê Approach

### Approach 1: Trie + DFS

1. Sort products (for lexicographic order)
2. Build Trie from sorted products
3. For each prefix of searchWord:
   - Navigate to prefix node
   - DFS to collect up to 3 words

### Approach 2: Binary Search (Simpler)

1. Sort products
2. For each prefix:
   - Binary search for first product with prefix
   - Take up to 3 products starting there

---

## üíª Solution

### Solution 1: Trie + DFS

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.suggestions = []  # Store up to 3 suggestions


class Solution:
    """
    Time: O(n √ó l √ó log(n) + m √ó 3) 
        = O(n √ó l √ó log(n)) for sorting and building
        + O(m) for searching (m = searchWord length)
    Space: O(n √ó l) for Trie
    """
    
    def suggestedProducts(self, products: list[str], searchWord: str) -> list[list[str]]:
        # Step 1: Sort products (lexicographic order)
        products.sort()
        
        # Step 2: Build Trie with suggestions at each node
        root = self._build_trie(products)
        
        # Step 3: Get suggestions for each prefix
        result = []
        node = root
        
        for char in searchWord:
            if node and char in node.children:
                node = node.children[char]
                result.append(node.suggestions)
            else:
                node = None  # No more matches possible
                result.append([])
        
        return result
    
    def _build_trie(self, products: list[str]) -> TrieNode:
        """Build Trie storing up to 3 suggestions at each node."""
        root = TrieNode()
        
        for product in products:
            node = root
            for char in product:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
                
                # Add to suggestions if less than 3
                if len(node.suggestions) < 3:
                    node.suggestions.append(product)
        
        return root


# Usage:
# sol = Solution()
# products = ["mobile","mouse","moneypot","monitor","mousepad"]
# searchWord = "mouse"
# print(sol.suggestedProducts(products, searchWord))
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = new Map();
        this.suggestions = [];
    }
}

class Solution {
    suggestedProducts(products, searchWord) {
        // Sort for lexicographic order
        products.sort();
        
        // Build Trie
        const root = this._buildTrie(products);
        
        // Get suggestions
        const result = [];
        let node = root;
        
        for (const char of searchWord) {
            if (node && node.children.has(char)) {
                node = node.children.get(char);
                result.push([...node.suggestions]);
            } else {
                node = null;
                result.push([]);
            }
        }
        
        return result;
    }
    
    _buildTrie(products) {
        const root = new TrieNode();
        
        for (const product of products) {
            let node = root;
            for (const char of product) {
                if (!node.children.has(char)) {
                    node.children.set(char, new TrieNode());
                }
                node = node.children.get(char);
                
                if (node.suggestions.length < 3) {
                    node.suggestions.push(product);
                }
            }
        }
        
        return root;
    }
}
```

---

### Solution 2: Binary Search (No Trie)

**Python:**
```python
import bisect

class Solution:
    """
    Binary search approach - simpler, similar performance.
    
    Time: O(n √ó log(n) + m √ó (log(n) + l))
    Space: O(1) extra (excluding output)
    """
    
    def suggestedProducts(self, products: list[str], searchWord: str) -> list[list[str]]:
        products.sort()
        result = []
        prefix = ""
        
        for char in searchWord:
            prefix += char
            
            # Find insertion point for prefix
            start = bisect.bisect_left(products, prefix)
            
            # Collect up to 3 products starting with prefix
            suggestions = []
            for i in range(start, min(start + 3, len(products))):
                if products[i].startswith(prefix):
                    suggestions.append(products[i])
                else:
                    break
            
            result.append(suggestions)
        
        return result
```

**JavaScript:**
```javascript
class Solution {
    suggestedProducts(products, searchWord) {
        products.sort();
        const result = [];
        let prefix = "";
        
        for (const char of searchWord) {
            prefix += char;
            
            // Binary search for first product >= prefix
            let left = 0, right = products.length;
            while (left < right) {
                const mid = Math.floor((left + right) / 2);
                if (products[mid] < prefix) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            
            // Collect up to 3 matches
            const suggestions = [];
            for (let i = left; i < Math.min(left + 3, products.length); i++) {
                if (products[i].startsWith(prefix)) {
                    suggestions.push(products[i]);
                } else {
                    break;
                }
            }
            
            result.push(suggestions);
        }
        
        return result;
    }
}
```

---

### Solution 3: Trie + DFS (Alternative)

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False
        self.word = None


class Solution:
    """
    Alternative: DFS to collect suggestions on-demand.
    """
    
    def suggestedProducts(self, products: list[str], searchWord: str) -> list[list[str]]:
        root = self._build_trie(products)
        
        result = []
        node = root
        
        for char in searchWord:
            if node and char in node.children:
                node = node.children[char]
                suggestions = self._get_suggestions(node, [])
                result.append(suggestions)
            else:
                node = None
                result.append([])
        
        return result
    
    def _build_trie(self, products):
        root = TrieNode()
        for product in products:
            node = root
            for char in product:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
            node.is_end = True
            node.word = product
        return root
    
    def _get_suggestions(self, node, result):
        """DFS to get up to 3 lexicographically sorted suggestions."""
        if len(result) >= 3:
            return result
        
        if node.is_end:
            result.append(node.word)
        
        # Visit children in sorted order for lexicographic results
        for char in sorted(node.children.keys()):
            if len(result) >= 3:
                break
            self._get_suggestions(node.children[char], result)
        
        return result
```

---

## ‚ö° Complexity Analysis

### Trie Approach (Solution 1)

| Phase | Time | Space |
|-------|------|-------|
| Sort | O(n √ó l √ó log(n)) | O(log n) |
| Build Trie | O(n √ó l) | O(n √ó l) |
| Search | O(m) | O(1) |
| **Total** | **O(n √ó l √ó log(n))** | **O(n √ó l)** |

### Binary Search Approach (Solution 2)

| Phase | Time | Space |
|-------|------|-------|
| Sort | O(n √ó l √ó log(n)) | O(log n) |
| Search | O(m √ó (log(n) + l)) | O(1) |
| **Total** | **O(n √ó l √ó log(n))** | **O(1) extra** |

**Where:**
- n = number of products
- l = average product length
- m = searchWord length

---

## ‚ö†Ô∏è Edge Cases

| Case | Handling |
|------|----------|
| No products match | Return [] for that prefix |
| Fewer than 3 matches | Return all matches |
| searchWord longer than any product | Later prefixes return [] |
| Duplicate products | Include duplicates |

---

## üîç Walkthrough

```
products = ["mobile","moneypot","monitor","mouse","mousepad"]
After sort: ["mobile","moneypot","monitor","mouse","mousepad"]

Trie with suggestions at each node:

     (root)
        ‚îÇ
        m ‚Üê suggestions: ["mobile","moneypot","monitor"]
        ‚îÇ
        o ‚Üê suggestions: ["mobile","moneypot","monitor"]
       / \
      n   u
      ‚îÇ   ‚îÇ
      ...  s ‚Üê suggestions: ["mouse","mousepad"]
           ‚îÇ
           e ‚Üê suggestions: ["mouse","mousepad"]
           ‚îÇ
           ...

searchWord = "mouse"

Prefix "m":   ‚Üí node.suggestions = ["mobile","moneypot","monitor"]
Prefix "mo":  ‚Üí node.suggestions = ["mobile","moneypot","monitor"]
Prefix "mou": ‚Üí node.suggestions = ["mouse","mousepad"]
Prefix "mous":‚Üí node.suggestions = ["mouse","mousepad"]
Prefix "mouse":‚Üí node.suggestions = ["mouse","mousepad"]
```

---

## üé§ Interview Tips

**What to say:**

1. **Understand:** "I need to return top 3 suggestions for each prefix, sorted lexicographically."

2. **Approach 1 (Trie):** "If I sort products first, then build a Trie storing up to 3 suggestions at each node, I can answer each query in O(1)."

3. **Approach 2 (Binary Search):** "Alternatively, sorting and binary search works well - find the first product matching the prefix and take up to 3."

4. **Trade-off:** "Trie uses more space but faster queries. Binary search uses less space but O(log n) per query."

**Common follow-ups:**
- "What if products update frequently?" ‚Üí Trie is better for dynamic data
- "What if we need top K by popularity?" ‚Üí Add frequency, use heap
- "Memory constraints?" ‚Üí Binary search approach

---

## üìù Practice Checklist

- [ ] Solve in < 25 minutes
- [ ] Explain why sorting first works
- [ ] Know both Trie and binary search approaches
- [ ] Handle no-match case correctly
- [ ] Optimize by storing suggestions at nodes

---

> **üí° Key Insight:** Sorting products first is crucial - it ensures our DFS/binary search naturally returns results in lexicographic order. Store up to 3 suggestions at each Trie node for O(1) query time.

> **üîó Related:** [Collect All Words](../03-Trie-Patterns/4.3-Collect-All-Words.md) | [Autocomplete System](../06-Applications/7.1-Autocomplete-System.md)
