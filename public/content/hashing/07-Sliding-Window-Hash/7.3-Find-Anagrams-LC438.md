# Find All Anagrams in a String (LeetCode 438)

> **Medium** | Given a string s and a pattern p, return all start indices of p's anagrams in s. An anagram is a permutation of a string.

This problem combines fixed-size sliding window with hash map comparison - a foundational pattern for substring search problems.

---

## üéØ Pattern Recognition

<details>
<summary><strong>Problem Signals</strong></summary>

**Keywords indicating this pattern:**
- "Find all anagrams"
- "Permutation exists in string"
- "Fixed-length substring matching"
- "All occurrences of rearrangement"

**Problem classification:**
```
Category: Sliding Window + Hash
Subcategory: Fixed window with frequency matching
Key insight: Window size = pattern length, compare frequency maps
```

</details>

---

## üìã Problem Statement

**LeetCode 438:** [Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

```
Given two strings s and p, return an array of all start indices 
of p's anagrams in s. You may return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters 
of a different word or phrase, using all the original letters exactly once.

Example 1:
Input: s = "cbaebabacd", p = "abc"
Output: [0, 6]
Explanation:
- Substring starting at 0: "cba" is anagram of "abc"
- Substring starting at 6: "bac" is anagram of "abc"

Example 2:
Input: s = "abab", p = "ab"
Output: [0, 1, 2]
Explanation: All substrings "ab", "ba", "ab" are anagrams

Constraints:
- 1 <= s.length, p.length <= 3 * 10^4
- s and p consist of lowercase English letters only
```

---

## ‚úÖ When to Use This Approach

- Finding all occurrences of anagrams/permutations
- Fixed-size window pattern matching
- Substring problems where order doesn't matter

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Variable length match | Window size not fixed | Variable sliding window |
| Exact substring match | Order matters | KMP / Z-algorithm |
| Just checking existence | Overkill | Single check |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Related</strong></summary>

**Before this:**
- [Sliding Window + Hash](./7.1-Sliding-Hash-Overview.md)
- [Frequency Pattern](../03-Frequency-Pattern/3.1-Frequency-Overview.md)
- [Group Anagrams (LC 49)](../06-Grouping-Pattern/6.2-Group-Anagrams-LC49.md)

**Related problems:**
- [Permutation in String (LC 567)](https://leetcode.com/problems/permutation-in-string/) - Boolean version
- [Minimum Window Substring (LC 76)](https://leetcode.com/problems/minimum-window-substring/)

</details>

---

## üìê Solution Approaches

### Approach 1: Sliding Window with Map Comparison

**Key Insight:** Use a fixed-size sliding window equal to pattern length. Compare window frequency map with pattern frequency map at each position.

### Visualization

```
s = "cbaebabacd", p = "abc"
p_count = {a:1, b:1, c:1}
window_size = 3

Sliding window (size = 3):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Window    ‚îÇ window_count        ‚îÇ Match? ‚îÇ Result             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ [c,b,a]   ‚îÇ {c:1, b:1, a:1}     ‚îÇ ‚úì      ‚îÇ [0]                ‚îÇ
‚îÇ [b,a,e]   ‚îÇ {b:1, a:1, e:1}     ‚îÇ ‚úó      ‚îÇ [0]                ‚îÇ
‚îÇ [a,e,b]   ‚îÇ {a:1, e:1, b:1}     ‚îÇ ‚úó      ‚îÇ [0]                ‚îÇ
‚îÇ [e,b,a]   ‚îÇ {e:1, b:1, a:1}     ‚îÇ ‚úó      ‚îÇ [0]                ‚îÇ
‚îÇ [b,a,b]   ‚îÇ {b:2, a:1}          ‚îÇ ‚úó      ‚îÇ [0]                ‚îÇ
‚îÇ [a,b,a]   ‚îÇ {a:2, b:1}          ‚îÇ ‚úó      ‚îÇ [0]                ‚îÇ
‚îÇ [b,a,c]   ‚îÇ {b:1, a:1, c:1}     ‚îÇ ‚úì      ‚îÇ [0, 6]             ‚îÇ
‚îÇ [a,c,d]   ‚îÇ {a:1, c:1, d:1}     ‚îÇ ‚úó      ‚îÇ [0, 6]             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Answer: [0, 6]
```

### Approach 2: Optimized Counting (Track Matches)

**Key Insight:** Instead of comparing entire maps, track how many characters have the correct frequency. When `matches == number of unique chars in pattern`, we have an anagram.

```
p = "abc" ‚Üí need = {a:1, b:1, c:1}, unique chars = 3

Track 'matches' = count of chars with correct frequency

When matches == 3, we have an anagram!

This avoids O(26) or O(map_size) comparison at each step.
```

---

## üíª Code Implementation

### Python - Approach 1: Map Comparison

```python
from collections import Counter

def findAnagrams(s: str, p: str) -> list[int]:
    """
    Find all anagram starting indices using map comparison.
    
    Algorithm:
    1. Create frequency map of pattern
    2. Slide fixed-size window across s
    3. At each position, compare window map with pattern map
    
    Time: O(n * 26) = O(n) where n = len(s)
    Space: O(1) - fixed size maps (at most 26 chars)
    """
    result = []
    
    if len(p) > len(s):
        return result
    
    p_count = Counter(p)
    window_count = Counter()
    window_size = len(p)
    
    for i in range(len(s)):
        # Add new character to window
        window_count[s[i]] += 1
        
        # Remove character leaving window
        if i >= window_size:
            left_char = s[i - window_size]
            window_count[left_char] -= 1
            if window_count[left_char] == 0:
                del window_count[left_char]
        
        # Check if current window is an anagram
        if i >= window_size - 1:
            if window_count == p_count:
                result.append(i - window_size + 1)
    
    return result


# Example trace: s = "cbaebabacd", p = "abc"
# p_count = {a:1, b:1, c:1}
#
# i=0: add 'c' ‚Üí {c:1}, window not full yet
# i=1: add 'b' ‚Üí {c:1, b:1}, window not full yet
# i=2: add 'a' ‚Üí {c:1, b:1, a:1}, full! == p_count ‚úì ‚Üí result=[0]
# i=3: add 'e', remove 'c' ‚Üí {b:1, a:1, e:1}, ‚â† p_count
# ... continues
# i=8: {b:1, a:1, c:1} == p_count ‚úì ‚Üí result=[0, 6]
```

### Python - Approach 2: Optimized Match Counting

```python
from collections import defaultdict

def findAnagrams(s: str, p: str) -> list[int]:
    """
    Optimized: track number of matching character counts.
    
    Instead of comparing entire maps (O(26)), track how many
    characters currently have the exact required count.
    
    Time: O(n) - truly linear, no map comparison
    Space: O(1) - fixed size arrays
    """
    result = []
    
    if len(p) > len(s):
        return result
    
    # Arrays for character counts (a-z = 26 chars)
    p_count = [0] * 26
    window_count = [0] * 26
    
    # Build pattern count
    for c in p:
        p_count[ord(c) - ord('a')] += 1
    
    # Count how many character positions match
    matches = 0
    
    for i in range(len(s)):
        # Add new character
        idx = ord(s[i]) - ord('a')
        window_count[idx] += 1
        
        # Update matches based on change
        if window_count[idx] == p_count[idx]:
            matches += 1
        elif window_count[idx] == p_count[idx] + 1:
            matches -= 1  # Was matching, now exceeds
        
        # Remove old character (if window is full)
        if i >= len(p):
            left_idx = ord(s[i - len(p)]) - ord('a')
            
            if window_count[left_idx] == p_count[left_idx]:
                matches -= 1  # Was matching, will change
            elif window_count[left_idx] == p_count[left_idx] + 1:
                matches += 1  # Was exceeding, now matches
            
            window_count[left_idx] -= 1
        
        # Check if all 26 positions match
        if i >= len(p) - 1 and matches == 26:
            result.append(i - len(p) + 1)
    
    return result
```

### Python - Clean Version with Counter

```python
from collections import Counter

def findAnagrams(s: str, p: str) -> list[int]:
    """
    Clean implementation using Counter.
    """
    if len(p) > len(s):
        return []
    
    result = []
    p_count = Counter(p)
    window = Counter(s[:len(p)])
    
    # Check first window
    if window == p_count:
        result.append(0)
    
    # Slide window
    for i in range(len(p), len(s)):
        # Add new char
        window[s[i]] += 1
        
        # Remove old char
        old_char = s[i - len(p)]
        window[old_char] -= 1
        if window[old_char] == 0:
            del window[old_char]
        
        # Check
        if window == p_count:
            result.append(i - len(p) + 1)
    
    return result
```

### JavaScript - Approach 1: Map Comparison

```javascript
/**
 * Find all anagram starting indices.
 * 
 * @param {string} s - Source string
 * @param {string} p - Pattern string
 * @return {number[]} - Starting indices of anagrams
 * 
 * Time: O(n)
 * Space: O(1)
 */
function findAnagrams(s, p) {
    const result = [];
    
    if (p.length > s.length) return result;
    
    // Build frequency arrays (26 letters)
    const pCount = new Array(26).fill(0);
    const windowCount = new Array(26).fill(0);
    
    for (const c of p) {
        pCount[c.charCodeAt(0) - 97]++;
    }
    
    const windowSize = p.length;
    
    for (let i = 0; i < s.length; i++) {
        // Add new character
        windowCount[s.charCodeAt(i) - 97]++;
        
        // Remove old character
        if (i >= windowSize) {
            windowCount[s.charCodeAt(i - windowSize) - 97]--;
        }
        
        // Check for match
        if (i >= windowSize - 1) {
            if (arraysEqual(windowCount, pCount)) {
                result.push(i - windowSize + 1);
            }
        }
    }
    
    return result;
}

function arraysEqual(a, b) {
    for (let i = 0; i < 26; i++) {
        if (a[i] !== b[i]) return false;
    }
    return true;
}
```

### JavaScript - Optimized Match Counting

```javascript
/**
 * Optimized version tracking match count.
 * 
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
function findAnagrams(s, p) {
    const result = [];
    
    if (p.length > s.length) return result;
    
    const pCount = new Array(26).fill(0);
    const windowCount = new Array(26).fill(0);
    
    // Build pattern count
    for (const c of p) {
        pCount[c.charCodeAt(0) - 97]++;
    }
    
    let matches = 0;
    
    for (let i = 0; i < s.length; i++) {
        // Add new character
        const newIdx = s.charCodeAt(i) - 97;
        windowCount[newIdx]++;
        
        if (windowCount[newIdx] === pCount[newIdx]) {
            matches++;
        } else if (windowCount[newIdx] === pCount[newIdx] + 1) {
            matches--;
        }
        
        // Remove old character
        if (i >= p.length) {
            const oldIdx = s.charCodeAt(i - p.length) - 97;
            
            if (windowCount[oldIdx] === pCount[oldIdx]) {
                matches--;
            } else if (windowCount[oldIdx] === pCount[oldIdx] + 1) {
                matches++;
            }
            
            windowCount[oldIdx]--;
        }
        
        // Check if all positions match
        if (i >= p.length - 1 && matches === 26) {
            result.push(i - p.length + 1);
        }
    }
    
    return result;
}
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Map comparison | O(n * 26) = O(n) | O(26) = O(1) | Compare maps each step |
| Match counting | O(n) | O(26) = O(1) | Truly linear |
| Counter (Python) | O(n) | O(26) = O(1) | Clean but comparison overhead |

**Where n = len(s)**

**Why O(26) space is O(1):**
- Fixed alphabet size (26 lowercase letters)
- Space doesn't grow with input size

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Boolean version | Just return true/false | LC 567 |
| Minimum window | Variable size, contain all | LC 76 |
| With wildcards | Pattern has wildcards | Custom |
| Case insensitive | Normalize first | Custom |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Off-by-One in Window Start Index

```python
# ‚ùå WRONG: Index calculation error
if window_count == p_count:
    result.append(i)  # Wrong! This is end index

# When i = 2 (for "cba" in "cbae..."), window starts at 0
# i = 2, window_size = 3
# start_index = i - window_size + 1 = 2 - 3 + 1 = 0 ‚úì

# ‚úÖ CORRECT
if window_count == p_count:
    result.append(i - len(p) + 1)
```

### 2. Not Deleting Zero Counts from Counter

```python
# ‚ùå WRONG: Zero counts cause comparison failure
window_count[left_char] -= 1  # Now 0, but key still exists

# {a:1, b:0} != {a:1}

# ‚úÖ CORRECT: Delete zero entries
window_count[left_char] -= 1
if window_count[left_char] == 0:
    del window_count[left_char]
```

### 3. Starting Comparison Too Early

```python
# ‚ùå WRONG: Comparing before window is full
for i in range(len(s)):
    window_count[s[i]] += 1
    if window_count == p_count:  # Window might not be full!
        result.append(...)

# ‚úÖ CORRECT: Wait until window is full
for i in range(len(s)):
    window_count[s[i]] += 1
    if i >= len(p):  # Remove old char
        # ...
    if i >= len(p) - 1:  # Window is now full
        if window_count == p_count:
            # ...
```

### 4. Forgetting Edge Case: p Longer Than s

```python
# ‚ùå WRONG: May cause issues
def findAnagrams(s, p):
    # If len(p) > len(s), no possible anagrams
    # But loop logic might still run incorrectly

# ‚úÖ CORRECT: Check early
def findAnagrams(s, p):
    if len(p) > len(s):
        return []
    # Continue with algorithm
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Key Insight |
|---------|------------|-------------|
| Find All Anagrams | üü° Medium | This problem |
| Permutation in String | üü° Medium | Boolean version |
| Minimum Window Substring | üî¥ Hard | Variable window |
| Substring with Concat of All Words | üî¥ Hard | Word-level anagrams |

**Related LeetCode:**
- [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/)
- [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)
- [30. Substring with Concatenation of All Words](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement map comparison version
- **Day 3:** Implement match counting optimization
- **Day 7:** Solve LC 567 (boolean variant)
- **Day 14:** Compare approaches and explain trade-offs
- **Day 30:** < 12 min implementation

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Communication Template</strong></summary>

**1. Clarify:**
> "So I need to find all starting positions where a permutation of p appears in s. Are both strings lowercase letters only?"

**2. Brute Force (mention briefly):**
> "Brute force would check each substring of length p and sort it, but that's O(n * k log k). We can do better."

**3. Optimal Approach:**
> "I'll use a fixed-size sliding window of length p. I'll maintain a frequency map of the current window and compare it with p's frequency map. This is O(n) time."

**4. Optimization (if asked):**
> "I can optimize the comparison by tracking how many character counts match instead of comparing entire maps. That removes the O(26) comparison factor."

**5. Walk through example:**
> "For 'cbaebabacd' and 'abc': window 'cba' has same frequencies as 'abc', so index 0 is valid..."

</details>

**Company Frequency:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Frequently asked |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask optimizations |
| Bloomberg | ‚≠ê‚≠ê‚≠ê‚≠ê | String focus |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand problem | 2 min |
| Plan approach | 2 min |
| Implement (basic) | 8-10 min |
| Implement (optimized) | 12-15 min |
| Test edge cases | 2 min |
| **Total** | **15-20 min** |

---

> **üí° Key Insight:** Use a fixed-size sliding window equal to pattern length. Instead of sorting each substring (O(k log k)), maintain a frequency map and update incrementally (O(1) per position). For further optimization, track match count instead of comparing maps.

> **üîó Related:** [Sliding Window + Hash](./7.1-Sliding-Hash-Overview.md) | [Longest Substring (LC 3)](./7.2-Longest-Substring-LC3.md) | [Group Anagrams](../06-Grouping-Pattern/6.2-Group-Anagrams-LC49.md)
