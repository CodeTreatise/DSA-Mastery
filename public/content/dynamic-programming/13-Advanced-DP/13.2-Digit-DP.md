# Digit DP Pattern

> **When counting numbers with specific digit properties.** Digit DP systematically counts integers in a range that satisfy certain constraints on their digits. Instead of checking each number, we build valid numbers digit by digit.

---

## ðŸ“‹ Overview

**Digit DP** answers questions like:
- "How many numbers from 0 to N have digit sum = K?"
- "How many numbers in [L, R] contain no digit 4?"
- "How many numbers have exactly K distinct digits?"

**Key Idea:** Count numbers by constructing them digit-by-digit from left to right, tracking:
1. **Position**: Which digit we're filling
2. **Tight constraint**: Are we still bounded by the limit?
3. **Problem-specific state**: Sum, count, last digit, etc.

---

## ðŸŽ¯ Pattern Recognition

**Digit DP signals:**
- "Count numbers from 1 to N with property X"
- "Find K-th number with property X"
- "Sum of digits", "distinct digits", "specific digit patterns"
- Range is huge (up to 10^18) but properties depend on digits

**Keywords:**
- "count numbers", "from L to R"
- "digit sum", "divisible by"
- "contains digit", "no consecutive"

---

## ðŸ“ The Framework

### General State

```python
def digit_dp(num_str: str) -> int:
    """
    Count numbers from 0 to int(num_str) with some property.
    """
    n = len(num_str)
    
    @lru_cache(maxsize=None)
    def dp(pos: int, state: Any, tight: bool, started: bool) -> int:
        """
        pos: current digit position (0 to n-1)
        state: problem-specific (sum, count, last digit, etc.)
        tight: if True, current prefix equals limit prefix
        started: if True, we've placed a non-zero digit (handles leading zeros)
        """
        if pos == n:
            # Check if number is valid
            return 1 if is_valid(state) and started else 0
        
        limit = int(num_str[pos]) if tight else 9
        result = 0
        
        for digit in range(0, limit + 1):
            new_tight = tight and (digit == limit)
            new_started = started or (digit > 0)
            new_state = update_state(state, digit, new_started)
            result += dp(pos + 1, new_state, new_tight, new_started)
        
        return result
    
    return dp(0, initial_state, True, False)
```

### The "Tight" Constraint

```
Example: Count numbers from 0 to 523

Position 0: Can place 0-5
  If we place 5 â†’ tight=True (still bounded)
  If we place 0-4 â†’ tight=False (already less than limit)

Position 1 (after placing 5): Can place 0-2
  If we place 2 â†’ tight=True
  If we place 0-1 â†’ tight=False

Position 2 (after placing 52): Can place 0-3
  If we place 3 â†’ exactly 523
  If we place 0-2 â†’ 520, 521, 522
```

### The "Started" Flag

Handles leading zeros:
```
For 3-digit limit like 523:
- "005" should count as 5, not as three digits
- "000" should not count at all (unless counting 0)
- started=False until we place a non-zero digit
```

---

## ðŸ’» Classic Problems

### 1. Count Numbers with Digit Sum = K

```python
from functools import lru_cache

def count_digit_sum(n: int, k: int) -> int:
    """Count numbers from 1 to n with digit sum exactly k."""
    if n <= 0:
        return 0
    
    num_str = str(n)
    length = len(num_str)
    
    @lru_cache(maxsize=None)
    def dp(pos: int, current_sum: int, tight: bool, started: bool) -> int:
        if pos == length:
            return 1 if started and current_sum == k else 0
        
        limit = int(num_str[pos]) if tight else 9
        result = 0
        
        for digit in range(0, limit + 1):
            new_tight = tight and (digit == limit)
            new_started = started or (digit > 0)
            new_sum = current_sum + (digit if new_started else 0)
            
            # Pruning: sum already exceeds k
            if new_sum > k:
                continue
            
            result += dp(pos + 1, new_sum, new_tight, new_started)
        
        return result
    
    return dp(0, 0, True, False)
```

### 2. Numbers with No Consecutive Same Digits (LC 1012)

```python
def nums_dup_digits_at_most_n(n: int) -> int:
    """
    LC 1012: Count numbers with at least one repeated digit.
    Strategy: Count numbers WITH repeated digits = Total - No repeated
    """
    # Count numbers with all distinct digits
    def count_distinct(n: int) -> int:
        if n <= 0:
            return 0
        
        num_str = str(n)
        length = len(num_str)
        
        @lru_cache(maxsize=None)
        def dp(pos: int, mask: int, tight: bool, started: bool) -> int:
            """mask: bitmask of used digits (0-9)"""
            if pos == length:
                return 1 if started else 0
            
            limit = int(num_str[pos]) if tight else 9
            result = 0
            
            for digit in range(0, limit + 1):
                if started and (mask & (1 << digit)):
                    continue  # Digit already used
                
                new_mask = mask | (1 << digit) if started or digit > 0 else mask
                result += dp(pos + 1, new_mask, tight and digit == limit, started or digit > 0)
            
            return result
        
        return dp(0, 0, True, False)
    
    return n - count_distinct(n)
```

### 3. Count Numbers Divisible by K (LC 2999 style)

```python
def count_divisible_by_k(n: int, k: int) -> int:
    """Count numbers from 1 to n divisible by k, using digit DP."""
    num_str = str(n)
    length = len(num_str)
    
    @lru_cache(maxsize=None)
    def dp(pos: int, remainder: int, tight: bool, started: bool) -> int:
        if pos == length:
            return 1 if started and remainder == 0 else 0
        
        limit = int(num_str[pos]) if tight else 9
        result = 0
        
        for digit in range(0, limit + 1):
            new_started = started or digit > 0
            new_rem = (remainder * 10 + digit) % k if new_started else 0
            result += dp(pos + 1, new_rem, tight and digit == limit, new_started)
        
        return result
    
    return dp(0, 0, True, False)
```

### 4. Count Numbers in Range [L, R]

```python
def count_in_range(left: int, right: int, property_func) -> int:
    """
    Count numbers in [L, R] with a property.
    Use: count(0, R) - count(0, L-1)
    """
    def count_up_to(n: int) -> int:
        if n < 0:
            return 0
        # Apply digit DP to count numbers from 0 to n
        return property_func(n)
    
    return count_up_to(right) - count_up_to(left - 1)
```

### 5. K-th Number with Property (Binary Search + Digit DP)

```python
def find_kth_number(k: int) -> int:
    """Find k-th number with a specific property."""
    def count_with_property(n: int) -> int:
        # Digit DP counting function
        pass
    
    # Binary search for the answer
    lo, hi = 1, 10**18
    while lo < hi:
        mid = (lo + hi) // 2
        if count_with_property(mid) < k:
            lo = mid + 1
        else:
            hi = mid
    
    return lo
```

---

## ðŸ“Š Template with Detailed Comments

```python
from functools import lru_cache

def digit_dp_template(n: int) -> int:
    """
    Comprehensive Digit DP template.
    Modify the state and transitions based on the problem.
    """
    if n < 0:
        return 0
    
    num_str = str(n)
    length = len(num_str)
    
    @lru_cache(maxsize=None)
    def dp(pos: int, state: int, tight: bool, started: bool) -> int:
        """
        pos: Current position (0 = leftmost digit)
        state: Problem-specific state (sum, remainder, mask, etc.)
        tight: True if we're still bounded by the limit
        started: True if we've placed a non-zero digit
        
        Returns: Count of valid numbers
        """
        # Base case: finished all digits
        if pos == length:
            # Return 1 if the number is valid, 0 otherwise
            if not started:
                return 0  # Don't count 0 (or 1 if 0 is valid)
            return 1 if is_valid_final_state(state) else 0
        
        # Determine digit range
        limit = int(num_str[pos]) if tight else 9
        result = 0
        
        # Try each possible digit
        for digit in range(0, limit + 1):
            # Skip invalid transitions
            if not is_valid_transition(state, digit, started):
                continue
            
            # Compute new state
            new_state = compute_new_state(state, digit, started or digit > 0)
            new_tight = tight and (digit == limit)
            new_started = started or (digit > 0)
            
            result += dp(pos + 1, new_state, new_tight, new_started)
        
        return result
    
    return dp(0, initial_state(), True, False)
```

---

## âš¡ Complexity Analysis

| Factor | Contribution |
|--------|--------------|
| Positions | O(d) where d = number of digits |
| State | O(S) where S = state space size |
| Tight | O(2) (True or False) |
| Started | O(2) (True or False) |
| Digit choices | O(10) per position |

**Total: O(d Ã— S Ã— 2 Ã— 2 Ã— 10) = O(d Ã— S Ã— 40)**

**Examples:**
- Digit sum â‰¤ K: S = K+1, Total = O(d Ã— K)
- Distinct digits: S = 2^10 = 1024, Total = O(d Ã— 1024)
- Divisibility: S = K (remainder), Total = O(d Ã— K)

---

## âš ï¸ Common Mistakes

### 1. Forgetting the "Started" Flag

**âŒ Wrong:**
```python
# Counts "007" as having 3 digits
def dp(pos, state, tight):
    ...
```

**âœ… Correct:**
```python
# Properly handles leading zeros
def dp(pos, state, tight, started):
    if not started and digit == 0:
        # Don't count this as a real digit
    ...
```

### 2. Wrong Tight Transition

**âŒ Wrong:**
```python
new_tight = digit == limit  # Forgets previous tight!
```

**âœ… Correct:**
```python
new_tight = tight and (digit == limit)
```

### 3. Memoization Key Missing State

**âŒ Wrong:**
```python
@lru_cache
def dp(pos, state, tight):  # Missing started!
```

**âœ… Correct:**
```python
@lru_cache
def dp(pos, state, tight, started):
```

### 4. Off-by-One in Range Queries

```python
# To count in [L, R]:
count_in_range = count(R) - count(L - 1)  # NOT count(L)!
```

---

## ðŸ“ Practice Problems

| Problem | Difficulty | Key Insight |
|---------|------------|-------------|
| [233. Number of Digit One](https://leetcode.com/problems/number-of-digit-one/) | Hard | Count specific digit |
| [357. Count Numbers with Unique Digits](https://leetcode.com/problems/count-numbers-with-unique-digits/) | Medium | Mask state |
| [600. Non-negative Integers without Consecutive Ones](https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/) | Hard | Last digit state |
| [902. Numbers At Most N Given Digit Set](https://leetcode.com/problems/numbers-at-most-n-given-digit-set/) | Hard | Limited digit set |
| [1012. Numbers With Repeated Digits](https://leetcode.com/problems/numbers-with-repeated-digits/) | Hard | Complementary counting |
| [2376. Count Special Integers](https://leetcode.com/problems/count-special-integers/) | Hard | Same as 1012 |

---

## ðŸŽ¤ Interview Context

**Company Frequency:**
| Problem Type | Google | Meta | Amazon |
|--------------|--------|------|--------|
| Digit Count | â­â­â­â­ | â­â­â­ | â­â­ |
| Range Queries | â­â­â­ | â­â­ | â­â­ |
| K-th Number | â­â­â­ | â­â­ | â­ |

**Time allocation:**
| Problem | Target Time |
|---------|-------------|
| Basic Digit Count | 25-30 min |
| With State (sum, mask) | 30-35 min |
| K-th Number | 35-40 min |

---

## ðŸ’¡ Key Insights

1. **Tight constraint**: "Am I still bounded by the limit?"
2. **Started flag**: "Have I placed a meaningful digit?"
3. **State captures property**: Sum, mask, remainder, last digit
4. **Range = difference**: count[L, R] = count[0, R] - count[0, L-1]
5. **Complementary counting**: Sometimes easier to count invalid numbers

---

> **ðŸ’¡ Key Pattern:** Digit DP builds numbers left-to-right, tracking whether we're still "tight" (bounded by the limit) and whether we've "started" (placed a non-zero digit). The state captures whatever property we're counting.

> **ðŸ”— Related:** [Bitmask DP](./13.1-Bitmask-DP.md) | [DP Fundamentals](../01-DP-Fundamentals/1.1-What-Is-DP.md) | [Binary Search](../../03-Sorting-Searching/03-Sorting-Searching.md)
