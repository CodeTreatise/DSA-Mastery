# 1.1 Stack Basics

> **Grokking Pattern:** #7 Stacks
>
> **Foundation Concept** | Essential for all stack problems

---

## Definition

A **Stack** is a linear data structure that follows the **LIFO** (Last-In-First-Out) principle. The last element added is the first one removed.

**Real-world analogies:**
- Stack of plates: take from the top
- Browser back button: last visited page is first to go back
- Undo operation: last action is first to undo
- Function call stack: last called function returns first

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use a Stack</strong></summary>

**Look for these signals:**
- "Most recent" or "last" processing
- Matching pairs (parentheses, brackets)
- Undo/redo operations
- Backtracking
- Reversing order
- Nested structures (recursion simulation)
- Expression evaluation

**Keywords:**
- "LIFO", "last-in-first-out"
- "most recent", "latest"
- "matching", "balanced"
- "nested", "recursive"
- "reverse", "undo"

</details>

---

## ‚úÖ When to Use Stack

- Matching brackets/parentheses
- Expression evaluation (RPN, infix)
- Monotonic stack problems (Next Greater Element)
- DFS (iterative implementation)
- Backtracking simulation
- Function call simulation
- Undo operations

---

## ‚ùå When NOT to Use Stack

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| FIFO order needed | Stack is LIFO | Queue |
| Need both ends | Stack has one end | Deque |
| Random access | Stack is sequential | Array/List |
| Need minimum/maximum efficiently |" Basic stack is O(n) "| Min Stack or Heap |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Array Basics](../../01-Arrays-Strings/01-Arrays/1.1-Array-Basics.md)
- Basic programming concepts

**After mastering this:**
- [Stack Operations](./1.2-Stack-Operations.md)
- [Valid Parentheses](../02-Basic-Stack-Problems/2.1-Valid-Parentheses.md)
- [Monotonic Stack](../03-Monotonic-Stack/3.1-Monotonic-Stack-Concept.md)
- [Min Stack](../04-Design-Problems/4.1-Min-Stack.md)

**Related structures:**
- Queue (FIFO counterpart)
- Deque (double-ended)
- Call Stack (system implementation)

</details>

---

## üìê How It Works

### Core Operations

| Operation | Description | Time |
|-----------|-------------|------|
| `push(x)` | Add element to top |" O(1) "|
| `pop()` | Remove and return top |" O(1) "|
| `peek()`/`top()` | Return top without removing |" O(1) "|
| `isEmpty()` | Check if stack is empty |" O(1) "|
| `size()` | Return number of elements |" O(1) "|

### Visual Representation

```
PUSH operations:
push(1) ‚Üí push(2) ‚Üí push(3)

    ‚îå‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ 1 ‚îÇ      ‚îÇ 2 ‚îÇ      ‚îÇ 3 ‚îÇ ‚Üê TOP
    ‚îî‚îÄ‚îÄ‚îÄ‚îò      ‚îú‚îÄ‚îÄ‚îÄ‚î§      ‚îú‚îÄ‚îÄ‚îÄ‚î§
               ‚îÇ 1 ‚îÇ      ‚îÇ 2 ‚îÇ
               ‚îî‚îÄ‚îÄ‚îÄ‚îò      ‚îú‚îÄ‚îÄ‚îÄ‚î§
                          ‚îÇ 1 ‚îÇ
                          ‚îî‚îÄ‚îÄ‚îÄ‚îò

POP operations:
pop() ‚Üí pop() ‚Üí pop()
Returns: 3, 2, 1 (LIFO order)
```

### Stack vs Array Access

```
Array: Random access O(1)
       arr[0], arr[1], arr[2] all accessible

Stack: Sequential access from top only
       Only stack[-1] (top) is accessible
```

---

## üíª Code Implementation

### Using Built-in List/Array (Recommended)

**Python:**
```python
# Python list works perfectly as a stack
stack = []

# Push: append to end
stack.append(1)
stack.append(2)
stack.append(3)
print(stack)  # [1, 2, 3]

# Peek: access last element
top = stack[-1]  # 3

# Pop: remove and return last element
val = stack.pop()  # 3
print(stack)  # [1, 2]

# Is empty?
is_empty = len(stack) == 0  # or: not stack

# Size
size = len(stack)  # 2
```

**JavaScript:**
```javascript
// JavaScript array as stack
const stack = [];

// Push
stack.push(1);
stack.push(2);
stack.push(3);
console.log(stack);  // [1, 2, 3]

// Peek
const top = stack[stack.length - 1];  // 3

// Pop
const val = stack.pop();  // 3
console.log(stack);  // [1, 2]

// Is empty
const isEmpty = stack.length === 0;

// Size
const size = stack.length;
```

### Stack Class Implementation

**Python:**
```python
class Stack:
    """
    Stack implementation using Python list.
    All operations are O(1) amortized.
    """
    
    def __init__(self):
        self._items = []
    
    def push(self, item) -> None:
        """Add item to top of stack."""
        self._items.append(item)
    
    def pop(self):
        """Remove and return top item. Raises if empty."""
        if self.is_empty():
            raise IndexError("pop from empty stack")
        return self._items.pop()
    
    def peek(self):
        """Return top item without removing. Raises if empty."""
        if self.is_empty():
            raise IndexError("peek from empty stack")
        return self._items[-1]
    
    def is_empty(self) -> bool:
        """Return True if stack is empty."""
        return len(self._items) == 0
    
    def size(self) -> int:
        """Return number of items in stack."""
        return len(self._items)
    
    def __len__(self) -> int:
        """Support len() function."""
        return self.size()
    
    def __bool__(self) -> bool:
        """Support boolean evaluation."""
        return not self.is_empty()
    
    def __repr__(self) -> str:
        """String representation."""
        return f"Stack({self._items})"


# Usage
stack = Stack()
stack.push(1)
stack.push(2)
print(stack.peek())  # 2
print(stack.pop())   # 2
print(len(stack))    # 1
```

**JavaScript:**
```javascript
class Stack {
    constructor() {
        this.items = [];
    }
    
    push(item) {
        this.items.push(item);
    }
    
    pop() {
        if (this.isEmpty()) {
            throw new Error("pop from empty stack");
        }
        return this.items.pop();
    }
    
    peek() {
        if (this.isEmpty()) {
            throw new Error("peek from empty stack");
        }
        return this.items[this.items.length - 1];
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    size() {
        return this.items.length;
    }
    
    toString() {
        return `Stack(${JSON.stringify(this.items)})`;
    }
}

// Usage
const stack = new Stack();
stack.push(1);
stack.push(2);
console.log(stack.peek());  // 2
console.log(stack.pop());   // 2
console.log(stack.size());  // 1
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| push |" O(1)* "| O(1) |
| pop |" O(1) "| O(1) |
| peek |" O(1) "| O(1) |
| isEmpty |" O(1) "| O(1) |
| size |" O(1) "| O(1) |
| Overall storage | - |" O(n) "|

*Amortized O(1) due to dynamic array resizing.

---

## üîÑ Stack Variants

| Variant | Description | Use Case |
|---------|-------------|----------|
| Min Stack |" O(1) getMin() "| LC 155 |
| Max Stack |" O(1) getMax() "| LC 716 |
| Monotonic Stack | Maintains order | Next Greater Element |
| Two Stacks ‚Üí Queue | Simulates FIFO | LC 232 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Popping from Empty Stack

```python
# ‚ùå WRONG: Crashes if empty
val = stack.pop()

# ‚úÖ CORRECT: Check first
if stack:
    val = stack.pop()
# or use try/except
```

### 2. Peeking Empty Stack

```python
# ‚ùå WRONG: IndexError
top = stack[-1]

# ‚úÖ CORRECT: Check first
if stack:
    top = stack[-1]
```

### 3. Using Wrong End of List

```python
# ‚ùå WRONG: O(n) operations
stack.insert(0, item)  # "push" at front
stack.pop(0)           # "pop" from front

# ‚úÖ CORRECT: O(1) operations at end
stack.append(item)     # push at back
stack.pop()            # pop from back
```

---

## üìù Practice Problems

### Foundation
- [ ] [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/) - LC 20

### Classic Stack
- [ ] [Min Stack](https://leetcode.com/problems/min-stack/) - LC 155
- [ ] [Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/) - LC 150

### Monotonic Stack
- [ ] [Daily Temperatures](https://leetcode.com/problems/daily-temperatures/) - LC 739
- [ ] [Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/) - LC 496

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement Stack class from memory
**Day 3:** Solve Valid Parentheses
**Day 7:** Solve Min Stack
**Day 14:** Solve Daily Temperatures
**Day 21:** Review all stack problems

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Stack Interview Tips</strong></summary>

**When to mention stack:**
- "This has a LIFO requirement, so I'll use a stack"
- "I need to track the most recent element, perfect for a stack"
- "The matching/nested structure suggests a stack"

**Common interview patterns:**
1. Parentheses matching
2. Expression evaluation
3. Monotonic stack for next/previous greater
4. DFS implementation
5. Backtracking simulation

**Complexity discussion:**
> "All basic stack operations are O(1). The space is O(n) for the elements stored."

</details>

**Company Focus:**

| Company | Frequency | Common Problems |
|---------|-----------|-----------------|
| All | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Valid Parentheses |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Min Stack, Daily Temps |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Expression evaluation |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Monotonic stack |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn concept | 15-20 min | First exposure |
| Implement class | 10-15 min | From memory |
| Solve Easy problem | 10-15 min | Valid Parentheses |
| Master pattern | 2-3 hours | Multiple problems |

---

> **üí° Key Insight:** The stack's power comes from its restriction, not despite it. By only allowing access to the most recent element, we get O(1) operations and a natural fit for "most recent first" problems. Think of stack whenever you see nesting, matching, or reversal.

---

## üîó Related

- [Stack Operations](./1.2-Stack-Operations.md) - Detailed operations
- [Stack Implementation](./1.3-Stack-Implementation.md) - Low-level details
- [Queue Basics](../05-Queue-Fundamentals/5.1-Queue-Basics.md) - FIFO counterpart
