# 1.4 Array Representation of Heaps

## Definition

A heap is stored as an **array** where the parent-child relationships are determined by **index formulas**:

```
For 0-indexed array:
- Parent of i:      (i - 1) // 2
- Left child of i:  2 * i + 1
- Right child of i: 2 * i + 2

Tree:                    Array:
       10                [10, 7, 8, 3, 5, 2, 6]
      /  \                 0  1  2  3  4  5  6
     7    8
    / \  / \
   3  5 2  6

Node 7 (index 1):
  Parent: (1-1)//2 = 0 â†’ value 10 âœ“
  Left:   2*1+1 = 3    â†’ value 3 âœ“
  Right:  2*1+2 = 4    â†’ value 5 âœ“
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>Why Array Representation?</strong></summary>

**Key benefits:**
- **No pointers** â†’ Less memory overhead
- **Cache-friendly** â†’ Contiguous memory
- **Simple navigation** â†’ Index formulas
- **No wasted space** â†’ Complete tree fills array

**Made possible by:**
- Complete binary tree property
- Predictable structure (no gaps)
- Level-order mapping to indices

</details>

---

## âœ… Benefits of Array Storage

| Benefit | Explanation |
|---------|-------------|
| Memory efficient | No pointer overhead (2 pointers per node saved) |
| Cache-friendly | Contiguous memory, good locality |
| Simple indexing |" O(1) parent/child access via formulas "|
| Easy implementation | Just array operations, no node management |

## âŒ Limitations

| Limitation | Impact |
|------------|--------|
| Fixed size (sometimes) | May need resizing |
| Insertion/deletion gaps | Must maintain completeness |
| Not for general trees | Only works for complete binary trees |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Heap](./1.1-What-Is-Heap.md)
- [Heap Property](./1.2-Heap-Property.md)
- [Complete Binary Tree](./1.3-Complete-Binary-Tree.md)

**After mastering this:**
- [Insert Operation](../02-Heap-Operations/2.1-Insert.md)
- [Extract Operation](../02-Heap-Operations/2.2-Extract.md)
- [Heapify](../02-Heap-Operations/2.4-Heapify.md)

**Related:**
- Array vs linked representation of trees
- Memory layout and cache efficiency

</details>

---

## ğŸ“ How It Works

### Level-Order Mapping

```
Level 0 (root):     indices 0
Level 1:            indices 1, 2
Level 2:            indices 3, 4, 5, 6
Level 3:            indices 7, 8, 9, 10, 11, 12, 13, 14
...

Level k starts at index 2^k - 1
Level k has 2^k positions
```

### Index Formula Derivation

```
Why 2i+1 and 2i+2 for children?

At each level, the number of nodes doubles.
If parent is at position i in level-order:
  - There are i nodes before it
  - Each has 2 children = 2i children of previous nodes
  - Plus 1 for left child = 2i + 1
  - Plus 1 more for right child = 2i + 2

Why (i-1)//2 for parent?

If child is at index i:
  - If left child:  2*parent + 1 = i  â†’ parent = (i-1)/2
  - If right child: 2*parent + 2 = i  â†’ parent = (i-2)/2
  
Both cases: parent = floor((i-1)/2)
```

### 0-Indexed vs 1-Indexed

```
0-indexed (more common):          1-indexed (textbook):
Index:  0  1  2  3  4  5  6       Index:  1  2  3  4  5  6  7
Array: [A, B, C, D, E, F, G]      Array: [_, A, B, C, D, E, F, G]

Parent: (i-1)//2                  Parent: i//2
Left:   2i + 1                    Left:   2i
Right:  2i + 2                    Right:  2i + 1

Most implementations use 0-indexed because:
- Arrays naturally 0-indexed in most languages
- No wasted index 0 position
```

---

## ğŸ’» Code Implementation

### Index Navigation Functions

**Python:**
```python
def parent(i: int) -> int:
    """Return index of parent node (0-indexed)"""
    return (i - 1) // 2

def left_child(i: int) -> int:
    """Return index of left child (0-indexed)"""
    return 2 * i + 1

def right_child(i: int) -> int:
    """Return index of right child (0-indexed)"""
    return 2 * i + 2

def has_parent(i: int) -> bool:
    """Check if node has parent (not root)"""
    return i > 0

def has_left_child(i: int, heap_size: int) -> bool:
    """Check if left child exists"""
    return left_child(i) < heap_size

def has_right_child(i: int, heap_size: int) -> bool:
    """Check if right child exists"""
    return right_child(i) < heap_size

def is_leaf(i: int, heap_size: int) -> bool:
    """Check if node is a leaf (no children)"""
    return left_child(i) >= heap_size


# Example usage:
heap = [10, 7, 8, 3, 5, 2, 6]
#        0  1  2  3  4  5  6

print(parent(4))      # 1 (parent of 5 is 7)
print(left_child(1))  # 3 (left of 7 is 3)
print(right_child(1)) # 4 (right of 7 is 5)
print(is_leaf(3, 7))  # True (index 3 is a leaf)
print(is_leaf(1, 7))  # False (index 1 has children)
```

**JavaScript:**
```javascript
const parent = (i) => Math.floor((i - 1) / 2);
const leftChild = (i) => 2 * i + 1;
const rightChild = (i) => 2 * i + 2;

const hasParent = (i) => i > 0;
const hasLeftChild = (i, heapSize) => leftChild(i) < heapSize;
const hasRightChild = (i, heapSize) => rightChild(i) < heapSize;
const isLeaf = (i, heapSize) => leftChild(i) >= heapSize;

// Example:
const heap = [10, 7, 8, 3, 5, 2, 6];
console.log(parent(4));      // 1
console.log(leftChild(1));   // 3
console.log(rightChild(1));  // 4
```

### Complete Heap Class with Array

**Python:**
```python
class MinHeap:
    """
    Min-heap implementation using array.
    Demonstrates array representation clearly.
    """
    
    def __init__(self):
        self.heap = []  # Array storage
    
    def _parent(self, i):
        return (i - 1) // 2
    
    def _left(self, i):
        return 2 * i + 1
    
    def _right(self, i):
        return 2 * i + 2
    
    def _swap(self, i, j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
    
    def peek(self):
        """O(1) - Get minimum (root)"""
        return self.heap[0] if self.heap else None
    
    def push(self, val):
        """O(log n) - Insert value"""
        # Add at end (maintains completeness)
        self.heap.append(val)
        # Bubble up to restore heap property
        self._bubble_up(len(self.heap) - 1)
    
    def pop(self):
        """O(log n) - Remove and return minimum"""
        if not self.heap:
            return None
        
        min_val = self.heap[0]
        
        # Move last element to root (maintains completeness)
        last = self.heap.pop()
        if self.heap:
            self.heap[0] = last
            # Bubble down to restore heap property
            self._bubble_down(0)
        
        return min_val
    
    def _bubble_up(self, i):
        """Restore heap property upward"""
        while i > 0 and self.heap[self._parent(i)] > self.heap[i]:
            self._swap(i, self._parent(i))
            i = self._parent(i)
    
    def _bubble_down(self, i):
        """Restore heap property downward"""
        n = len(self.heap)
        while True:
            smallest = i
            left = self._left(i)
            right = self._right(i)
            
            if left < n and self.heap[left] < self.heap[smallest]:
                smallest = left
            if right < n and self.heap[right] < self.heap[smallest]:
                smallest = right
            
            if smallest == i:
                break
            
            self._swap(i, smallest)
            i = smallest
    
    def __len__(self):
        return len(self.heap)
    
    def __repr__(self):
        return f"MinHeap({self.heap})"


# Usage:
heap = MinHeap()
for val in [5, 3, 8, 1, 2, 7]:
    heap.push(val)
print(heap)  # MinHeap([1, 2, 7, 5, 3, 8])

while len(heap):
    print(heap.pop(), end=" ")  # 1 2 3 5 7 8
```

**JavaScript:**
```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    _parent(i) { return Math.floor((i - 1) / 2); }
    _left(i) { return 2 * i + 1; }
    _right(i) { return 2 * i + 2; }
    _swap(i, j) { [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]]; }
    
    peek() { return this.heap[0]; }
    size() { return this.heap.length; }
    
    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        if (this.heap.length === 0) return undefined;
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return min;
    }
    
    _bubbleUp(i) {
        while (i > 0 && this.heap[this._parent(i)] > this.heap[i]) {
            this._swap(i, this._parent(i));
            i = this._parent(i);
        }
    }
    
    _bubbleDown(i) {
        const n = this.heap.length;
        while (true) {
            let smallest = i;
            const left = this._left(i);
            const right = this._right(i);
            
            if (left < n && this.heap[left] < this.heap[smallest]) smallest = left;
            if (right < n && this.heap[right] < this.heap[smallest]) smallest = right;
            
            if (smallest === i) break;
            this._swap(i, smallest);
            i = smallest;
        }
    }
}
```

---

## âš¡ Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Parent/Child access |" O(1) "| O(1) | Index formula |
| Peek |" O(1) "| O(1) | Array[0] |
| Push |" O(log n) "| O(1) | Bubble up |
| Pop |" O(log n) "| O(1) | Bubble down |
| Build heap |" O(n) "| O(1) | Bottom-up |
| Space | - |" O(n) "| Array of n elements |

**Memory comparison:**
```
Array representation:
  - n integers for values
  - No overhead
  - Total: n * sizeof(int)

Pointer representation:
  - n integers for values
  - 2n pointers for left/right children
  - n pointers for parent (optional)
  - Total: n * sizeof(int) + 2n * sizeof(pointer)
  
For n=1000 with 8-byte pointers, 4-byte ints:
  Array: 4,000 bytes
  Pointer: 4,000 + 16,000 = 20,000 bytes (5x more!)
```

---

## ğŸ”„ Variations

| Representation | When Used |
|---------------|-----------|
| **0-indexed** | Most programming languages (C, Python, JS) |
| **1-indexed** | Textbooks, some contest programming |
| **Implicit** | Standard heap (indices calculated) |
| **Explicit pointers** | When tree structure varies (BST, etc.) |

---

## âš ï¸ Common Mistakes

### 1. Using 1-Indexed Formulas with 0-Indexed Array

```python
# âŒ Wrong: 1-indexed formulas
parent = i // 2              # Wrong for 0-indexed
left = 2 * i                 # Wrong for 0-indexed

# âœ… Correct: 0-indexed formulas
parent = (i - 1) // 2
left = 2 * i + 1
right = 2 * i + 2
```

### 2. Forgetting Bounds Check

```python
# âŒ Wrong: Accessing without bounds check
left_val = heap[2 * i + 1]  # IndexError if no left child!

# âœ… Correct: Check bounds first
left_idx = 2 * i + 1
if left_idx < len(heap):
    left_val = heap[left_idx]
```

### 3. Breaking Completeness During Operations

```python
# âŒ Wrong: Removing from middle (creates gap)
def bad_remove(heap, i):
    del heap[i]  # Breaks completeness!

# âœ… Correct: Always remove from end, then fix
def correct_remove(heap, i):
    # Swap with last element
    heap[i] = heap[-1]
    heap.pop()
    # Then bubble up or down to restore property
```

### 4. Modifying While Iterating

```python
# âŒ Wrong: Modifying heap during iteration
for i in range(len(heap)):
    if heap[i] < threshold:
        heap.pop()  # Modifies while iterating!

# âœ… Correct: Collect elements first, then process
to_remove = [i for i in range(len(heap)) if heap[i] < threshold]
# Handle removals separately
```

---

## ğŸ“ Practice Problems (Progressive)

### Easy (Understand representation)
- [ ] Implement index navigation functions
- [ ] Given array, draw the corresponding heap tree
- [ ] Given tree, write the array representation

### Medium (Apply representation)
- [ ] [Kth Largest Element (LC 215)](https://leetcode.com/problems/kth-largest-element-in-an-array/)
- [ ] Implement MinHeap class from scratch

### Hard (Master representation)
- [ ] Implement heap with decrease-key operation
- [ ] [Merge K Sorted Lists (LC 23)](https://leetcode.com/problems/merge-k-sorted-lists/)

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Memorize index formulas
- **Day 3:** Implement MinHeap from scratch
- **Day 7:** Implement MaxHeap from scratch
- **Day 14:** Draw array-to-tree and tree-to-array
- **Day 30:** Implement heap with custom comparator

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Explain This in Interviews</strong></summary>

**Explaining array representation:**
"A heap is stored as an array where for node at index i, its children are at 2i+1 and 2i+2, and parent is at (i-1)/2. This works because a heap is a complete binary tree with no gaps."

**When asked why array:**
"Array representation saves memory - no pointers needed - and is cache-friendly since elements are contiguous. The complete tree property guarantees no wasted space."

**Drawing it:**
```
"Let me draw the mapping:
       10
      /  \      â†’    [10, 7, 8, 3, 5]
     7    8           0   1  2  3  4
    / \
   3   5

Index 1 (value 7):
  Parent: (1-1)/2 = 0 (value 10) âœ“
  Left:   2*1+1 = 3 (value 3) âœ“
  Right:  2*1+2 = 4 (value 5) âœ“"
```

</details>

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn index formulas | 10-15 min | Memorize |
| Implement navigation | 10-15 min | Simple functions |
| Implement full heap | 30-40 min | With bubble up/down |
| Debug off-by-one | Variable | Common issue |

---

## ğŸ’¡ Key Insight

> **The array representation transforms tree navigation into arithmetic.** Instead of following pointers (parent, left, right), we compute indices with simple formulas. This works because a complete binary tree has a predictable, gap-free structure. Every node's position in the array corresponds exactly to its position in level-order traversal.

---

## ğŸ”— Related

- **Previous:** [Complete Binary Tree](./1.3-Complete-Binary-Tree.md)
- **Next:** [Insert Operation](../02-Heap-Operations/2.1-Insert.md)
- **Related:** [Heapify](../02-Heap-Operations/2.4-Heapify.md)
