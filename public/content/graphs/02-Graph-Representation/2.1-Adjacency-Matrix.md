# 2.1 Adjacency Matrix

> **2D array representation for dense graphs**
>
> â±ï¸ **Time:** 25-30 min | ğŸ“Š **Difficulty:** Beginner | ğŸ¯ **Interview Frequency:** Medium

---

## Overview

An **adjacency matrix** is a 2D array of size VÃ—V where V is the number of vertices. Entry `matrix[i][j]` indicates whether an edge exists between vertex i and vertex j.

```
Graph:                    Adjacency Matrix:
    [0] â”€â”€â”€ [1]              0  1  2  3
     â”‚       â”‚           0 [ 0  1  1  0 ]
     â”‚       â”‚           1 [ 1  0  0  1 ]
    [2] â”€â”€â”€ [3]          2 [ 1  0  0  1 ]
                         3 [ 0  1  1  0 ]
    
    1 = edge exists, 0 = no edge
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>When Adjacency Matrix is Mentioned</strong></summary>

**Use adjacency matrix when you see:**
- "Check if edge exists frequently" â†’ O(1) lookup
- "Dense graph" (many edges)
- "Complete graph" or near-complete
- "Floyd-Warshall all-pairs shortest path"
- "Graph has fixed number of vertices"
- Matrix operations on the graph

**Keywords:**
- "adjacency", "matrix", "2D array"
- "edge weight", "cost matrix"
- "check connection in O(1)"

</details>

---

## âœ… When to Use

| Scenario | Why Matrix is Good |
|----------|-------------------|
| Dense graphs (E â‰ˆ VÂ²) | Space is O(VÂ²) anyway |
| Frequent edge queries | O(1) edge lookup |
| Small vertex count | VÂ² is manageable |
| Floyd-Warshall algorithm | Requires matrix form |
| Graph with weighted edges | Easy weight storage |
| Checking self-loops | matrix[i][i] check |

---

## âŒ When NOT to Use

| Scenario | Why Not | Better Alternative |
|----------|---------|-------------------|
| Sparse graphs (E << VÂ²) | Wastes space | Adjacency List |
| Large vertex count | VÂ² memory explodes | Adjacency List |
| Adding/removing vertices | Resize is O(VÂ²) | Adjacency List |
| Iterating neighbors | O(V) per vertex | Adjacency List O(degree) |
| Unknown vertex count | Can't pre-allocate | Adjacency List |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Graph?](../01-Graph-Fundamentals/1.1-What-Is-Graph.md)
- [Graph Terminology](../01-Graph-Fundamentals/1.2-Graph-Terminology.md)
- [Types of Graphs](../01-Graph-Fundamentals/1.3-Types-Of-Graphs.md)

**After mastering this:**
- [Adjacency List](./2.2-Adjacency-List.md) - More common representation
- [Representation Comparison](./2.4-Representation-Comparison.md)
- [Floyd-Warshall](../08-Shortest-Path/8.4-Floyd-Warshall-Algorithm.md) - Uses matrix

**Related algorithms that use matrix:**
- Floyd-Warshall (all-pairs shortest path)
- Transitive closure
- Graph powers

</details>

---

## ğŸ“ How It Works

### Basic Structure

```
Vertices: {A, B, C, D} â†’ Indices: {0, 1, 2, 3}

    A â”€â”€â”€ B                     A   B   C   D
    â”‚     â”‚               A [ [ 0   1   1   0 ]
    â”‚     â”‚               B   [ 1   0   0   1 ]
    C â”€â”€â”€ D               C   [ 1   0   0   1 ]
                          D   [ 0   1   1   0 ] ]
    
Edges: (A,B), (A,C), (B,D), (C,D)
matrix[0][1] = 1 (A-B edge)
matrix[1][0] = 1 (B-A edge, same as A-B for undirected)
```

### Weighted Graph Matrix

```
    A â”€â”€5â”€â”€ B                   A    B    C    D
    â”‚       â”‚             A [ [ 0    5    3    âˆ  ]
    3       2             B   [ 5    0    âˆ    2  ]
    â”‚       â”‚             C   [ 3    âˆ    0    4  ]
    C â”€â”€4â”€â”€ D             D   [ âˆ    2    4    0  ] ]
    
âˆ (infinity) = no edge
Diagonal = 0 (distance to self)
```

### Directed Graph Matrix

```
    A â”€â”€â†’ B                     A   B   C   D
    â”‚     â”‚               A [ [ 0   1   1   0 ]  â† Aâ†’B, Aâ†’C
    â†“     â†“               B   [ 0   0   0   1 ]  â† Bâ†’D only
    C â”€â”€â†’ D               C   [ 0   0   0   1 ]  â† Câ†’D only
                          D   [ 0   0   0   0 ] ]
    
Note: Matrix is NOT symmetric for directed graphs
matrix[i][j] â‰  matrix[j][i] generally
```

---

## ğŸ’» Code Implementation

**Python:**
```python
class AdjacencyMatrix:
    """Graph represented as a 2D matrix."""
    
    def __init__(self, num_vertices, directed=False, weighted=False):
        self.V = num_vertices
        self.directed = directed
        self.weighted = weighted
        
        # Initialize matrix with 0 (unweighted) or infinity (weighted)
        if weighted:
            self.matrix = [[float('inf')] * num_vertices for _ in range(num_vertices)]
            # Distance to self is 0
            for i in range(num_vertices):
                self.matrix[i][i] = 0
        else:
            self.matrix = [[0] * num_vertices for _ in range(num_vertices)]
    
    def add_edge(self, u, v, weight=1):
        """Add edge from u to v (and v to u if undirected)."""
        if self.weighted:
            self.matrix[u][v] = weight
            if not self.directed:
                self.matrix[v][u] = weight
        else:
            self.matrix[u][v] = 1
            if not self.directed:
                self.matrix[v][u] = 1
    
    def remove_edge(self, u, v):
        """Remove edge between u and v."""
        if self.weighted:
            self.matrix[u][v] = float('inf')
            if not self.directed:
                self.matrix[v][u] = float('inf')
        else:
            self.matrix[u][v] = 0
            if not self.directed:
                self.matrix[v][u] = 0
    
    def has_edge(self, u, v):
        """Check if edge exists between u and v. O(1)"""
        if self.weighted:
            return self.matrix[u][v] != float('inf')
        return self.matrix[u][v] == 1
    
    def get_weight(self, u, v):
        """Get weight of edge (u, v)."""
        return self.matrix[u][v]
    
    def get_neighbors(self, v):
        """Return all neighbors of vertex v. O(V)"""
        neighbors = []
        for i in range(self.V):
            if self.weighted:
                if self.matrix[v][i] != float('inf') and i != v:
                    neighbors.append((i, self.matrix[v][i]))
            else:
                if self.matrix[v][i] == 1:
                    neighbors.append(i)
        return neighbors
    
    def degree(self, v):
        """Return degree of vertex v."""
        if self.weighted:
            return sum(1 for i in range(self.V) 
                      if self.matrix[v][i] != float('inf') and i != v)
        return sum(self.matrix[v])
    
    def in_degree(self, v):
        """Return in-degree for directed graph."""
        if self.weighted:
            return sum(1 for i in range(self.V) 
                      if self.matrix[i][v] != float('inf') and i != v)
        return sum(self.matrix[i][v] for i in range(self.V))
    
    def out_degree(self, v):
        """Return out-degree for directed graph."""
        return self.degree(v)
    
    def print_matrix(self):
        """Display the matrix."""
        for row in self.matrix:
            print([x if x != float('inf') else 'âˆ' for x in row])


# Example usage
print("Unweighted undirected graph:")
g = AdjacencyMatrix(4, directed=False, weighted=False)
g.add_edge(0, 1)  # A-B
g.add_edge(0, 2)  # A-C
g.add_edge(1, 3)  # B-D
g.add_edge(2, 3)  # C-D
g.print_matrix()
# [0, 1, 1, 0]
# [1, 0, 0, 1]
# [1, 0, 0, 1]
# [0, 1, 1, 0]

print(f"\nHas edge (0,1): {g.has_edge(0, 1)}")  # True
print(f"Has edge (0,3): {g.has_edge(0, 3)}")  # False
print(f"Neighbors of 0: {g.get_neighbors(0)}")  # [1, 2]
print(f"Degree of 1: {g.degree(1)}")  # 2
```

**JavaScript:**
```javascript
class AdjacencyMatrix {
    constructor(numVertices, directed = false, weighted = false) {
        this.V = numVertices;
        this.directed = directed;
        this.weighted = weighted;
        
        // Initialize matrix
        if (weighted) {
            this.matrix = Array.from({ length: numVertices }, (_, i) =>
                Array.from({ length: numVertices }, (_, j) => 
                    i === j ? 0 : Infinity
                )
            );
        } else {
            this.matrix = Array.from({ length: numVertices }, () =>
                Array(numVertices).fill(0)
            );
        }
    }
    
    addEdge(u, v, weight = 1) {
        if (this.weighted) {
            this.matrix[u][v] = weight;
            if (!this.directed) {
                this.matrix[v][u] = weight;
            }
        } else {
            this.matrix[u][v] = 1;
            if (!this.directed) {
                this.matrix[v][u] = 1;
            }
        }
    }
    
    removeEdge(u, v) {
        const noEdge = this.weighted ? Infinity : 0;
        this.matrix[u][v] = noEdge;
        if (!this.directed) {
            this.matrix[v][u] = noEdge;
        }
    }
    
    hasEdge(u, v) {
        if (this.weighted) {
            return this.matrix[u][v] !== Infinity;
        }
        return this.matrix[u][v] === 1;
    }
    
    getWeight(u, v) {
        return this.matrix[u][v];
    }
    
    getNeighbors(v) {
        const neighbors = [];
        for (let i = 0; i < this.V; i++) {
            if (this.weighted) {
                if (this.matrix[v][i] !== Infinity && i !== v) {
                    neighbors.push([i, this.matrix[v][i]]);
                }
            } else {
                if (this.matrix[v][i] === 1) {
                    neighbors.push(i);
                }
            }
        }
        return neighbors;
    }
    
    degree(v) {
        if (this.weighted) {
            return this.matrix[v].filter((w, i) => w !== Infinity && i !== v).length;
        }
        return this.matrix[v].reduce((sum, val) => sum + val, 0);
    }
    
    printMatrix() {
        for (const row of this.matrix) {
            console.log(row.map(x => x === Infinity ? 'âˆ' : x).join(' '));
        }
    }
}

// Example
const g = new AdjacencyMatrix(4, false, false);
g.addEdge(0, 1);
g.addEdge(0, 2);
g.addEdge(1, 3);
g.addEdge(2, 3);
g.printMatrix();
// 0 1 1 0
// 1 0 0 1
// 1 0 0 1
// 0 1 1 0

console.log(`Has edge (0,1): ${g.hasEdge(0, 1)}`);  // true
console.log(`Neighbors of 0: ${g.getNeighbors(0)}`);  // [1, 2]
```

---

## âš¡ Complexity Analysis

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| Create graph | O(VÂ²) | Initialize VÃ—V matrix |
| Add edge | O(1) | Direct array access |
| Remove edge | O(1) | Direct array access |
| Check edge exists | O(1) | â­ Best feature! |
| Get all neighbors | O(V) | Must scan entire row |
| Get degree | O(V) | Sum/count row |
| **Space** | O(VÂ²) | Always, regardless of E |

**Why these complexities:**
- Matrix provides O(1) random access to any cell
- Finding neighbors requires scanning V cells even if only few edges exist
- Space is always VÂ² even for sparse graphs

---

## ğŸ”„ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| Boolean matrix | 0/1 values | Unweighted graphs |
| Weight matrix | Numeric values | Weighted graphs |
| Sparse matrix | Only non-zero stored | Large sparse graphs |
| Bit matrix | Single bits per edge | Memory optimization |

### Special Matrix Patterns

```
SYMMETRIC (Undirected)        UPPER TRIANGULAR (Space saving)
    0  1  2  3                    0  1  2  3
0 [ 0  1  1  0 ]              0 [ -  1  1  0 ]
1 [ 1  0  0  1 ]              1 [ -  -  0  1 ]
2 [ 1  0  0  1 ]              2 [ -  -  -  1 ]
3 [ 0  1  1  0 ]              3 [ -  -  -  - ]

matrix[i][j] = matrix[j][i]   Store only i < j entries
```

---

## âš ï¸ Common Mistakes

### 1. Forgetting to Add Both Directions for Undirected

```python
# âŒ Wrong: Only one direction added
def add_edge_wrong(matrix, u, v):
    matrix[u][v] = 1  # Missing vâ†’u!

# âœ… Correct: Add both directions
def add_edge_correct(matrix, u, v, directed=False):
    matrix[u][v] = 1
    if not directed:
        matrix[v][u] = 1
```

### 2. Off-by-One Indexing

```python
# âŒ Wrong: If vertices are 1-indexed in problem
matrix = [[0] * 4 for _ in range(4)]  # Only handles 0-3
add_edge(matrix, 4, 1)  # IndexError!

# âœ… Correct: Account for 1-indexing
matrix = [[0] * 5 for _ in range(5)]  # Handles 0-4 (ignore 0)
# Or convert: matrix[u-1][v-1] = 1
```

### 3. Wrong Initialization for Weighted Graphs

```python
# âŒ Wrong: Using 0 for no edge in weighted graph
matrix = [[0] * V for _ in range(V)]  # 0 looks like zero-weight edge!

# âœ… Correct: Use infinity for no edge
matrix = [[float('inf')] * V for _ in range(V)]
for i in range(V):
    matrix[i][i] = 0  # Distance to self is 0
```

---

## ğŸ“ Practice Problems

### Matrix-Specific Problems
| Problem | Difficulty | Focus |
|---------|------------|-------|
| [Find the Town Judge](https://leetcode.com/problems/find-the-town-judge/) | ğŸŸ¢ Easy | In/out degree from matrix |
| [Find the Celebrity](https://leetcode.com/problems/find-the-celebrity/) | ğŸŸ¡ Medium | Matrix queries |
| [Number of Provinces](https://leetcode.com/problems/number-of-provinces/) | ğŸŸ¡ Medium | Given as matrix |

### Algorithms Using Matrix Form
| Problem | Difficulty | Focus |
|---------|------------|-------|
| [Floyd Warshall](https://practice.geeksforgeeks.org/problems/implementing-floyd-warshall2042/1) | ğŸŸ¡ Medium | All-pairs shortest path |
| [Transitive Closure](https://practice.geeksforgeeks.org/problems/transitive-closure-of-a-graph0930/1) | ğŸŸ¡ Medium | Reachability matrix |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement AdjacencyMatrix class from memory
- **Day 3:** Convert between matrix and visual graph
- **Day 7:** Solve a matrix-based graph problem
- **Day 14:** Compare matrix vs list for a problem
- **Day 30:** Quickly choose representation for 5 problems

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>When to Mention Matrix in Interviews</strong></summary>

**Say this when choosing matrix:**
> "I'll use an adjacency matrix here because we need O(1) edge lookups and the graph is dense."

**Or for specific algorithms:**
> "Floyd-Warshall requires a matrix representation, so let me set that up first."

**When asked about trade-offs:**
> "Matrix gives O(1) edge checks but O(V) for neighbors and O(VÂ²) space. For this sparse graph, I'd prefer an adjacency list."

**Red flags:**
- âŒ Using matrix for sparse graph without justification
- âŒ Forgetting O(VÂ²) space limitation
- âŒ Not initializing weighted matrix correctly

</details>

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Understand concept | 10-15 min |
| Implement class | 15-20 min |
| Practice conversion | 10-15 min |
| **Total to master** | **35-50 min** |

---

> **ğŸ’¡ Key Insight:** Adjacency matrix trades space (O(VÂ²)) for O(1) edge lookup. Use it when you need fast edge checks or when the graph is dense enough that O(VÂ²) space is acceptable anyway.

> **ğŸ”— Related:** [Adjacency List](./2.2-Adjacency-List.md) | [Edge List](./2.3-Edge-List.md) | [Representation Comparison](./2.4-Representation-Comparison.md)

---

**Previous:** [â† 1.3 Types of Graphs](../01-Graph-Fundamentals/1.3-Types-Of-Graphs.md)  
**Next:** [2.2 Adjacency List â†’](./2.2-Adjacency-List.md)
