# 1.2 Stack Operations

> **Foundation Reference** | All O(1) Operations Detailed

---

## Overview

This file provides detailed reference for all stack operations, edge cases, and common patterns. Use as a quick reference during problem-solving.

---

## ‚úÖ When to Use This Reference

- Quick lookup during problem-solving
- Reviewing operation syntax before interviews
- Understanding edge cases for each operation
- Finding safe patterns for common operations

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Learning stack concepts | Too detailed | [Stack Basics](./1.1-Stack-Basics.md) |
| Need full problem solutions | Reference only | Problem-specific files |
| Understanding implementation | Different scope | [Stack Implementation](./1.3-Stack-Implementation.md) |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Stack Basics](./1.1-Stack-Basics.md) - Core concepts
- Basic Python/JavaScript syntax

**After mastering this:**
- [Valid Parentheses](../02-Basic-Stack-Problems/2.1-Valid-Parentheses.md) - Apply operations
- [Monotonic Stack](../03-Monotonic-Stack/3.1-Monotonic-Stack-Concept.md) - Advanced patterns

**Use this alongside:**
- Any stack problem for quick syntax reference

</details>

---

## üéØ Core Operations Reference

### Push - Add Element to Top

**Purpose:** Add new element to the stack

```python
# Python
stack = []
stack.append(10)      # Stack: [10]
stack.append(20)      # Stack: [10, 20]
stack.append(30)      # Stack: [10, 20, 30] ‚Üê TOP
```

```javascript
// JavaScript
const stack = [];
stack.push(10);       // Stack: [10]
stack.push(20);       // Stack: [10, 20]
stack.push(30);       // Stack: [10, 20, 30] ‚Üê TOP
```

**Time:** O(1) amortized

---

### Pop - Remove and Return Top

**Purpose:** Remove the top element and return it

```python
# Python
stack = [10, 20, 30]
val = stack.pop()     # val = 30, Stack: [10, 20]
val = stack.pop()     # val = 20, Stack: [10]

# DANGER: Empty stack
stack = []
stack.pop()           # IndexError: pop from empty list
```

```javascript
// JavaScript
const stack = [10, 20, 30];
let val = stack.pop();  // val = 30, Stack: [10, 20]
val = stack.pop();      // val = 20, Stack: [10]

// Empty stack
const empty = [];
empty.pop();            // Returns undefined (no error)
```

**Time:** O(1)

**Safe Pop Pattern:**
```python
# Python
val = stack.pop() if stack else None

# Or with default
val = stack.pop() if stack else default_value
```

```javascript
// JavaScript
const val = stack.length > 0 ? stack.pop() : null;
```

---

### Peek / Top - View Top Without Removing

**Purpose:** See the top element without modifying the stack

```python
# Python
stack = [10, 20, 30]
top = stack[-1]       # top = 30, Stack unchanged

# DANGER: Empty stack
stack = []
top = stack[-1]       # IndexError: list index out of range
```

```javascript
// JavaScript
const stack = [10, 20, 30];
const top = stack[stack.length - 1];  // top = 30

// Empty stack
const empty = [];
const top2 = empty[empty.length - 1]; // Returns undefined
```

**Time:** O(1)

**Safe Peek Pattern:**
```python
# Python
top = stack[-1] if stack else None
```

```javascript
// JavaScript
const top = stack.length > 0 ? stack[stack.length - 1] : null;
```

---

### isEmpty - Check if Stack is Empty

```python
# Python
stack = [1, 2, 3]
is_empty = len(stack) == 0      # False
is_empty = not stack            # False (Pythonic)

stack = []
is_empty = not stack            # True
```

```javascript
// JavaScript
const stack = [1, 2, 3];
const isEmpty = stack.length === 0;  // false

const empty = [];
const isEmpty2 = empty.length === 0; // true
```

**Time:** O(1)

---

### Size - Get Number of Elements

```python
# Python
stack = [1, 2, 3]
size = len(stack)    # 3
```

```javascript
// JavaScript
const stack = [1, 2, 3];
const size = stack.length;  // 3
```

**Time:** O(1)

---

## üìê Common Operation Patterns

### Pattern 1: Process Until Empty

```python
# Process all elements
while stack:
    item = stack.pop()
    process(item)
```

### Pattern 2: Conditional Pop

```python
# Pop only if condition met
while stack and condition(stack[-1]):
    stack.pop()
```

### Pattern 3: Pop and Compare

```python
# Pop if matches expected value
if stack and stack[-1] == expected:
    stack.pop()
    # matched
else:
    # no match
```

### Pattern 4: Peek Before Decide

```python
# Check top before deciding action
if stack:
    top = stack[-1]
    if should_pop(top):
        stack.pop()
    else:
        stack.append(new_item)
```

### Pattern 5: Transfer Between Stacks

```python
# Move all from stack1 to stack2 (reverses order)
while stack1:
    stack2.append(stack1.pop())
```

---

## ‚ö†Ô∏è Edge Cases Reference

### Empty Stack Operations

| Operation | Python | JavaScript |
|-----------|--------|------------|
| `pop()` | IndexError | undefined |
| `peek()` / `[-1]` | IndexError | undefined |
| `isEmpty` | True | true |
| `size` | 0 | 0 |

### Safe Operations Template

**Python:**
```python
class SafeStack:
    def __init__(self):
        self._items = []
    
    def push(self, item):
        self._items.append(item)
    
    def pop(self, default=None):
        """Return default if empty instead of raising."""
        return self._items.pop() if self._items else default
    
    def peek(self, default=None):
        """Return default if empty instead of raising."""
        return self._items[-1] if self._items else default
    
    def is_empty(self):
        return len(self._items) == 0
    
    def size(self):
        return len(self._items)
```

**JavaScript:**
```javascript
class SafeStack {
    constructor() {
        this.items = [];
    }
    
    push(item) {
        this.items.push(item);
    }
    
    pop(defaultVal = null) {
        return this.items.length > 0 ? this.items.pop() : defaultVal;
    }
    
    peek(defaultVal = null) {
        return this.items.length > 0 
            ? this.items[this.items.length - 1] 
            : defaultVal;
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    size() {
        return this.items.length;
    }
}
```

---

## üîÑ Operation Combinations

### Push-Pop-Push (Modify Top)

```python
# Replace top element
if stack:
    old = stack.pop()
    new = transform(old)
    stack.push(new)
```

### Multi-Pop (Clear N Elements)

```python
# Remove n elements
for _ in range(min(n, len(stack))):
    stack.pop()
```

### Conditional Push

```python
# Push only if different from top
if not stack or stack[-1] != value:
    stack.append(value)
```

### Pop While Condition

```python
# Pop while top satisfies condition
while stack and stack[-1] < threshold:
    stack.pop()
```

---

## üíª Operation Complexity Summary

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| push |" O(1)* "| O(1) | *Amortized due to resizing |
| pop |" O(1) "| O(1) | |
| peek |" O(1) "| O(1) | |
| isEmpty |" O(1) "| O(1) | |
| size |" O(1) "| O(1) | |
| clear |" O(1)** "| O(1) |" **O(n) if needs deallocation "|

---

## üé§ Interview Quick Reference

**Always check before pop/peek:**
```python
if stack:
    val = stack.pop()
```

**Common mistake to avoid:**
```python
# ‚ùå Don't modify while iterating
for item in stack:
    if condition:
        stack.pop()  # Modifies during iteration!

# ‚úÖ Use while loop instead
while stack and condition(stack[-1]):
    stack.pop()
```

**Debugging tip:**
```python
# Print stack state for debugging
print(f"Stack state: {stack}, Top: {stack[-1] if stack else 'empty'}")
```

---

## üìù Practice Problems

| Problem | Difficulty | Operations Used |
|---------|------------|----------------|
| [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/) | Easy | push, pop, peek |
| [Min Stack](https://leetcode.com/problems/min-stack/) | Medium | All + design |
| [Daily Temperatures](https://leetcode.com/problems/daily-temperatures/) | Medium | Conditional pop |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Review all operations, practice safe patterns
**Day 3:** Solve Valid Parentheses using patterns from this file
**Day 7:** Implement without looking at reference
**Day 14:** Use patterns in a new problem

</details>

---

## üé§ Interview Context

**Quick syntax during interviews:**
```python
stack = []           # Initialize
stack.append(x)      # Push
stack.pop()          # Pop
stack[-1]            # Peek
len(stack)           # Size
not stack            # isEmpty
```

**Always say:** "I'll check if the stack is empty before popping."

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Review all operations | 10 min | Quick refresh |
| Memorize safe patterns | 15 min | Focus on edge cases |
| Apply in problem | 5 min | Should be automatic |

---

> **üí° Key Insight:** Stack operations are simple but the patterns they create are powerful. Master the basic operations, then focus on recognizing when to apply common patterns like "pop while condition" or "peek before decide."

---

## üîó Related

- [Stack Basics](./1.1-Stack-Basics.md) - Conceptual overview
- [Stack Implementation](./1.3-Stack-Implementation.md) - Internal details
- [Valid Parentheses](../02-Basic-Stack-Problems/2.1-Valid-Parentheses.md) - Pattern application
