# LCS Pattern: Longest Common Subsequence Fundamentals

> **The foundation of string/sequence DP.** LCS teaches you how to think about comparing two sequences‚Äîa skill that extends to Edit Distance, Longest Palindromic Subsequence, and dozens of other problems. Master this, and you unlock a whole family of DP patterns!

---

## üìã Overview

The **Longest Common Subsequence (LCS)** pattern handles problems where you need to find relationships between two sequences by comparing elements.

**Core Problems:**
- Longest Common Subsequence (LCS)
- Longest Palindromic Subsequence
- Edit Distance (Levenshtein)
- Shortest Common Supersequence
- Minimum Deletions/Insertions

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify LCS Pattern</strong></summary>

**Look for these signals:**
- Two strings/sequences to compare
- Finding common/matching elements
- Subsequence (not substring‚Äîorder matters, but not contiguous)
- Transforming one sequence into another

**Keywords in problem statement:**
- "common subsequence"
- "transform string A to string B"
- "minimum operations to make equal"
- "longest matching"
- "palindromic subsequence"

**Mental Model:**
If the problem involves:
1. Two sequences (often strings)
2. Character-by-character or element-by-element decisions
3. "Include or exclude" choices at each position

‚Üí Think **LCS pattern!**

</details>

---

## ‚úÖ When to Use LCS Pattern

| Scenario | Example Problem |
|----------|-----------------|
| Find longest matching subsequence | LCS, LPS |
| Count minimum operations to transform | Edit Distance |
| Find shortest sequence containing both | Shortest Common Supersequence |
| String comparison/similarity | Diff tools, spell check |
| DNA sequence alignment | Bioinformatics applications |

## ‚ùå When NOT to Use

| Scenario | Use Instead |
|----------|-------------|
| Contiguous matching (substring) | Sliding Window or Z-algorithm |
| Single string, not comparing two | Fibonacci/Linear DP |
| Pattern matching with wildcards | Special pattern matching DP |
| Need actual character positions | Suffix arrays/trees |

---

## üìê The Core LCS Template

### 2D DP Setup

For comparing two sequences `s1` and `s2`:

```python
def lcs_template(s1: str, s2: str) -> int:
    """
    Template for LCS-style problems.
    
    State: dp[i][j] = answer for s1[0:i] and s2[0:j]
    """
    m, n = len(s1), len(s2)
    
    # dp[i][j] represents result for first i chars of s1
    # and first j chars of s2
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Base case: dp[0][j] = 0 (empty s1)
    #            dp[i][0] = 0 (empty s2)
    # Usually already 0 from initialization
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                # Characters match
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                # Characters don't match
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]
```

### Visualization of 2D Grid

```
         ""   a    c    e
    ""    0   0    0    0
    a     0   1    1    1    ‚Üê match 'a'
    b     0   1    1    1
    c     0   1    2    2    ‚Üê match 'c'
    d     0   1    2    2
    e     0   1    2    3    ‚Üê match 'e'

s1 = "abcde", s2 = "ace"
LCS = "ace", length = 3
```

---

## üíª Core LCS Implementation

### Problem: Longest Common Subsequence (LC 1143)

```python
def longest_common_subsequence(text1: str, text2: str) -> int:
    """
    Find length of longest common subsequence.
    Time: O(m √ó n), Space: O(m √ó n)
    """
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                # Found a match! Extend previous LCS
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                # No match: best of skipping char from either string
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]
```

```javascript
function longestCommonSubsequence(text1, text2) {
    const m = text1.length, n = text2.length;
    const dp = Array.from({length: m + 1}, 
                          () => new Array(n + 1).fill(0));
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (text1[i-1] === text2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    
    return dp[m][n];
}
```

### Recovering the Actual LCS

```python
def lcs_string(text1: str, text2: str) -> str:
    """Return the actual LCS string, not just length."""
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Fill DP table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    # Backtrack to find actual LCS
    lcs = []
    i, j = m, n
    while i > 0 and j > 0:
        if text1[i-1] == text2[j-1]:
            lcs.append(text1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1
    
    return ''.join(reversed(lcs))
```

---

## ‚ö° Space Optimization

### Two-Row Optimization: O(n) Space

```python
def lcs_optimized(text1: str, text2: str) -> int:
    """
    Space-optimized: O(min(m, n))
    We only need the previous row!
    """
    # Use shorter string for columns (saves space)
    if len(text1) < len(text2):
        text1, text2 = text2, text1
    
    m, n = len(text1), len(text2)
    prev = [0] * (n + 1)
    curr = [0] * (n + 1)
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                curr[j] = prev[j-1] + 1
            else:
                curr[j] = max(prev[j], curr[j-1])
        prev, curr = curr, prev
    
    return prev[n]
```

### One-Row Optimization (Tricky!)

```python
def lcs_one_row(text1: str, text2: str) -> int:
    """
    Single row with diagonal tracking.
    Saves space but harder to understand.
    """
    if len(text1) < len(text2):
        text1, text2 = text2, text1
    
    n = len(text2)
    dp = [0] * (n + 1)
    
    for i in range(len(text1)):
        prev = 0  # dp[i-1][j-1]
        for j in range(1, n + 1):
            temp = dp[j]  # Save before overwriting
            if text1[i] == text2[j-1]:
                dp[j] = prev + 1
            else:
                dp[j] = max(dp[j], dp[j-1])
            prev = temp
    
    return dp[n]
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space |
|----------|------|-------|
| Standard 2D | O(m √ó n) | O(m √ó n) |
| Two-Row | O(m √ó n) | O(min(m, n)) |
| One-Row | O(m √ó n) | O(min(m, n)) |

---

## üîÑ LCS Family of Problems

### 1. Longest Palindromic Subsequence (LC 516)

**Key insight:** LPS of string s = LCS of s and reverse(s)

```python
def longest_palindrome_subseq(s: str) -> int:
    """LPS = LCS(s, reverse(s))"""
    return longest_common_subsequence(s, s[::-1])
```

### 2. Edit Distance (LC 72)

**Key insight:** Minimum operations (insert, delete, replace) to transform s1 to s2.

```python
def min_distance(word1: str, word2: str) -> int:
    """
    Edit distance with insert/delete/replace.
    """
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Base cases: transforming to/from empty string
    for i in range(m + 1):
        dp[i][0] = i  # Delete all chars
    for j in range(n + 1):
        dp[0][j] = j  # Insert all chars
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]  # No operation needed
            else:
                dp[i][j] = 1 + min(
                    dp[i-1][j-1],  # Replace
                    dp[i-1][j],    # Delete from word1
                    dp[i][j-1]     # Insert into word1
                )
    
    return dp[m][n]
```

### 3. Shortest Common Supersequence (LC 1092)

**Key insight:** SCS length = m + n - LCS length

```python
def shortest_common_supersequence(str1: str, str2: str) -> str:
    """
    Build SCS using LCS as guide.
    """
    m, n = len(str1), len(str2)
    
    # First compute LCS table
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    # Backtrack to build SCS
    result = []
    i, j = m, n
    
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            result.append(str1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            result.append(str1[i-1])
            i -= 1
        else:
            result.append(str2[j-1])
            j -= 1
    
    # Add remaining characters
    while i > 0:
        result.append(str1[i-1])
        i -= 1
    while j > 0:
        result.append(str2[j-1])
        j -= 1
    
    return ''.join(reversed(result))
```

### 4. Minimum Deletions to Make Palindrome

**Key insight:** min_deletions = n - LPS(s)

```python
def min_deletions_palindrome(s: str) -> int:
    """Remove chars to make palindrome."""
    lps = longest_common_subsequence(s, s[::-1])
    return len(s) - lps
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Off-by-One with 1-Indexed vs 0-Indexed

**‚ùå Wrong:**
```python
if text1[i] == text2[j]:  # i, j go 1 to len
    dp[i][j] = dp[i-1][j-1] + 1
```

**‚úÖ Correct:**
```python
if text1[i-1] == text2[j-1]:  # Strings are 0-indexed!
    dp[i][j] = dp[i-1][j-1] + 1
```

### 2. Confusing Subsequence with Substring

**Subsequence:** Characters in order, but not necessarily contiguous
- "ace" is a subsequence of "abcde"

**Substring:** Characters must be contiguous
- "bcd" is a substring of "abcde"

### 3. Wrong Base Case Initialization

**‚ùå Wrong:**
```python
dp = [[1] * (n + 1) for _ in range(m + 1)]  # Wrong default
```

**‚úÖ Correct:**
```python
dp = [[0] * (n + 1) for _ in range(m + 1)]  # Empty string has LCS 0
```

### 4. Reversing Logic for LPS

**‚ùå Wrong:**
```python
def lps(s):
    return lcs(s, s)  # Comparing with self!
```

**‚úÖ Correct:**
```python
def lps(s):
    return lcs(s, s[::-1])  # Compare with REVERSE
```

---

## üìù Practice Problems (Progressive)

### Easy-Medium
- [ ] [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/) - Core problem
- [ ] [583. Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/) - LCS application

### Medium
- [ ] [72. Edit Distance](https://leetcode.com/problems/edit-distance/) - Classic interview problem
- [ ] [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/) - LCS transformation
- [ ] [1092. Shortest Common Supersequence](https://leetcode.com/problems/shortest-common-supersequence/) - LCS + reconstruction

### Hard
- [ ] [115. Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/) - Count matching
- [ ] [97. Interleaving String](https://leetcode.com/problems/interleaving-string/) - Three-string DP

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: LCS (basic)
- Day 3: Edit Distance
- Day 5: LPS (transformation insight)
- Day 7: Review all three

**Week 2:**
- Day 8: SCS (using LCS)
- Day 10: Delete Operations
- Day 12: Distinct Subsequences
- Day 14: Full pattern review

</details>

---

## üé§ Interview Context

**The 4-Step Approach for LCS Problems:**

1. **Recognize the pattern** (2 sequences, comparing elements)
2. **Define the DP state** (dp[i][j] = answer for prefixes)
3. **Write the recurrence** (match vs. no-match cases)
4. **Handle base cases** (empty strings)

**Communication template:**
> "This is a classic LCS-style problem. I'll use dp[i][j] to represent the answer for the first i characters of string A and first j characters of string B. When characters match, I extend from dp[i-1][j-1]. Otherwise, I take the max/min of dp[i-1][j] and dp[i][j-1]."

**Company frequency:**
| Company | Frequency | Focus |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Edit Distance, variations |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | LCS, spell check |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | String similarity |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Basic LCS |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Learn LCS pattern | 45-60 min |
| Solve basic LCS | 15-20 min |
| Solve Edit Distance | 25-30 min |
| Master pattern | 8-10 problems |

---

> **üí° Key Insight:** LCS creates a 2D grid where each cell represents the best answer for two prefixes. The brilliance is that matching characters always come from the diagonal (dp[i-1][j-1]), while non-matches take the best from left or above.

> **üîó Related:** [Edit Distance Practice](./6.6-LCS-Practice/02-Edit-Distance-LC72.md) | [Longest Palindromic Subsequence](./6.6-LCS-Practice/03-Longest-Palindromic-Subseq-LC516.md) | [Grid DP](../03-Grid-DP/)
