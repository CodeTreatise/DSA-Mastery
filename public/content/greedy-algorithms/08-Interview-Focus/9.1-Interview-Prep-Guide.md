# Greedy Interview Preparation Guide

> **Your complete guide to greedy algorithm interviews**

---

## ðŸŽ¯ Interview Statistics

Based on analysis from AlgoMonster, interviewing.io, and LeetCode data:

| Company | Greedy Frequency | Focus Areas |
|---------|------------------|-------------|
| **Amazon** | High (~20%) | Intervals, Scheduling, Classic |
| **Google** | Medium (~15%) | Proof-based, Combined patterns |
| **Meta** | Medium (~15%) | Bug-free coding, Edge cases |
| **Microsoft** | Medium (~12%) | Standard problems |
| **Unicorns** | High (~18%) | Intervals, Optimization |

**Overall:** Greedy appears in ~15-20% of coding interviews.

---

## ðŸ“Š Most Common Interview Problems

### Tier 1: Must Know (Asked Frequently)

| Problem | Pattern | Link | Est. Time |
|---------|---------|------|-----------|
| Merge Intervals | Sort by start | [LC 56](https://leetcode.com/problems/merge-intervals/) | 10-15 min |
| Jump Game | Reachability | [LC 55](https://leetcode.com/problems/jump-game/) | 10 min |
| Jump Game II | Min jumps | [LC 45](https://leetcode.com/problems/jump-game-ii/) | 15 min |
| Meeting Rooms II | Heap/Sweep line | [LC 253](https://leetcode.com/problems/meeting-rooms-ii/) | 15 min |
| Task Scheduler | Frequency greedy | [LC 621](https://leetcode.com/problems/task-scheduler/) | 15-20 min |
| Gas Station | Circular greedy | [LC 134](https://leetcode.com/problems/gas-station/) | 15 min |

### Tier 2: Should Know (Common)

| Problem | Pattern | Link | Est. Time |
|---------|---------|------|-----------|
| Non-overlapping Intervals | Sort by end | [LC 435](https://leetcode.com/problems/non-overlapping-intervals/) | 10 min |
| Assign Cookies | Sort both | [LC 455](https://leetcode.com/problems/assign-cookies/) | 8 min |
| Candy | Two-pass | [LC 135](https://leetcode.com/problems/candy/) | 15 min |
| Partition Labels | Last occurrence | [LC 763](https://leetcode.com/problems/partition-labels/) | 12 min |
| Two City Scheduling | Sort by diff | [LC 1029](https://leetcode.com/problems/two-city-scheduling/) | 12 min |

### Tier 3: Good to Know (Less Frequent)

| Problem | Pattern | Link |
|---------|---------|------|
| Minimum Arrows | Interval counting | [LC 452](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/) |
| Boats to Save People | Two pointers | [LC 881](https://leetcode.com/problems/boats-to-save-people/) |
| Lemonade Change | Simulation | [LC 860](https://leetcode.com/problems/lemonade-change/) |
| Course Schedule III | Heap + swap | [LC 630](https://leetcode.com/problems/course-schedule-iii/) |

---

## ðŸ§  The 4-Step Interview Framework

### Step 1: Clarify (1-2 min)

**Ask about:**
- Input constraints (size, values, sorted?)
- Edge cases (empty, single element?)
- Output format (count, indices, value?)
- Can elements be reused?

**Example questions:**
```
"Is the input sorted?"
"Can intervals overlap at endpoints?"
"Should I return the count or the actual selection?"
```

### Step 2: Plan (2-4 min)

**Greedy recognition checklist:**
- [ ] Does local optimal lead to global optimal?
- [ ] Is there a clear "best" choice at each step?
- [ ] Do choices not affect future options negatively?
- [ ] Can I prove greedy works (even informally)?

**State your approach:**
```
"I think this is a greedy problem because [reason].
My greedy choice will be [choice].
I'll need to sort by [criterion] first."
```

### Step 3: Code (10-15 min)

**Communication during coding:**
```
"I'm sorting by end time because..."
"Now I'll iterate and make the greedy choice..."
"Let me handle this edge case..."
```

**Code structure:**
1. Sort (if needed)
2. Initialize trackers
3. Greedy loop
4. Return result

### Step 4: Verify (3-5 min)

**Walk through example:**
```
"Let me trace through the example...
After sorting: [...]
Iteration 1: pick this because...
Iteration 2: skip this because...
Final result: X"
```

**Discuss complexity:**
```
"Time: O(n log n) due to sorting
Space: O(1) if we modify input, O(n) otherwise"
```

---

## ðŸŽ¤ Communication Templates

### When Identifying Greedy

```
"This looks like a greedy problem because we're optimizing [X]
and each decision is independent - choosing now doesn't prevent
better choices later."
```

### When Explaining Sort Strategy

```
"I'll sort by [end time / start / ratio / difference] because
[earlier end = more room / ratio = best value per unit / etc]."
```

### When Proving Correctness (Optional but Impressive)

```
"This greedy choice is correct because if we didn't take [X],
we could always swap it in and get an equal or better result.
This is an exchange argument."
```

### When Comparing to DP

```
"At first this might seem like DP, but notice that we don't need
to consider multiple subproblems - there's always a clear best
choice, which is [X]."
```

---

## âš ï¸ Interview Pitfalls

### 1. Not Sorting When Needed

```
âŒ "I'll iterate through and pick the best..."
   (But order matters! Need to sort first)

âœ… "First I'll sort by [criterion], then iterate..."
```

### 2. Not Handling Edge Cases

**Always check:**
- Empty input
- Single element
- All same elements
- Already optimal input
- Worst case input

### 3. Wrong Greedy Choice

```
âŒ Sort by start time for activity selection
   (Should be end time)

âœ… "Let me verify this is correct... 
   If I sort by start instead of end..."
```

### 4. Not Explaining Why Greedy Works

```
âŒ "I'll just pick the [X] each time"
   (Interviewer: "But why is that optimal?")

âœ… "Picking [X] is optimal because [informal proof].
   Any other choice would [worse outcome]."
```

---

## ðŸ“ Greedy Proof Cheat Sheet

### Greedy Stays Ahead

```
"At each step, greedy's solution is at least as good as OPT's.
By induction, the final solution is optimal."
```

**Use for:** Counting problems, Activity Selection

### Exchange Argument

```
"If OPT differs from greedy at some point, we can swap in 
greedy's choice without making things worse."
```

**Use for:** Optimization problems, Scheduling

### Contradiction

```
"Assume greedy isn't optimal. Then there exists a better solution.
But [show this leads to contradiction]."
```

**Use for:** When other proofs are tricky

---

## â±ï¸ Time Management

| Phase | Time | Notes |
|-------|------|-------|
| Clarify | 1-2 min | Don't skip! |
| Plan | 2-4 min | State approach clearly |
| Code | 10-15 min | Talk while coding |
| Verify | 3-5 min | Trace + complexity |
| **Total** | **16-26 min** | Typical 30-40 min slot |

---

## ðŸ”„ Common Follow-ups

### "Can you optimize?"

- If O(nÂ²): "I can sort and use two pointers/binary search for O(n log n)"
- If O(n log n): "Sorting is necessary, so this is likely optimal"
- If using heap: "I could try to avoid heap operations in certain cases"

### "What if [constraint changes]?"

- "If unsorted input is required, I'd consider [different approach]"
- "If intervals can touch, I'd change the comparison to [>=]"
- "For larger input, I'd consider [streaming/approximation]"

### "How would you prove this is optimal?"

- Give informal exchange argument
- "Any deviation from greedy can be swapped back without loss"
- "I can show greedy stays ahead by induction"

---

## ðŸ“Š Quick Reference: Pattern â†’ Sort

| Pattern | Sort By | Why |
|---------|---------|-----|
| Max non-overlapping | End â†‘ | Leave room |
| Merge intervals | Start â†‘ | Process order |
| Meet deadlines | Deadline â†‘ | Urgent first |
| Value per unit | Ratio â†“ | Best value |
| Binary choice split | Difference | Benefit delta |
| Matching | Both arrays | Two pointer |

---

## ðŸŽ¯ Day-Before Checklist

### Must Review

- [ ] Merge Intervals (sort by start)
- [ ] Activity Selection (sort by end)
- [ ] Jump Game (reachability)
- [ ] Gas Station (circular)
- [ ] Two-pass greedy (Candy)

### Must Practice

- [ ] Write Kadane's from memory
- [ ] Write interval merge from memory
- [ ] Explain exchange argument out loud
- [ ] Time yourself on 2-3 problems

### Must Remember

- [ ] Sort is usually O(n log n) and dominates
- [ ] Check edge cases: empty, single, all same
- [ ] Greedy = local optimal â†’ global optimal
- [ ] If unsure, DP is safer (but slower)

---

> **ðŸ’¡ Interview Success Formula:** Recognize pattern â†’ State approach clearly â†’ Code efficiently â†’ Verify with example â†’ Explain complexity

> **ðŸ”— Related:** [Pattern Recognition](../01-Greedy-Fundamentals/3.1-Greedy-Recognition-Guide.md) | [Problem Solving Framework](../01-Greedy-Fundamentals/3.0-Greedy-Problem-Solving-Framework.md)
