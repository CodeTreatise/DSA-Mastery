# 1.2 Singly Linked List Operations

> **Foundation:** Core CRUD operations for linked lists
>
> ‚è±Ô∏è Estimated Learning Time: 45-60 minutes

---

## Overview

This section covers all essential operations on a singly linked list: **traversal, insertion, deletion, and search**. Mastering these operations is crucial because they form the building blocks for all linked list algorithms.

**Operations covered:**
- Traversal (visiting all nodes)
- Insertion (beginning, end, at position)
- Deletion (beginning, end, by value, at position)
- Search and access

---

## üéØ Pattern Recognition

<details>
<summary><strong>Which Operation to Use</strong></summary>

**Operation selection guide:**
| Need | Operation | Time |
|------|-----------|------|
| Visit all nodes | Traversal |" O(n) "|
| Add to front | Insert at beginning |" O(1) "|
| Add to back | Insert at end |" O(n)* "|
| Add at specific spot | Insert at position |" O(n) "|
| Remove from front | Delete from beginning |" O(1) "|
| Remove from back | Delete from end |" O(n) "|
| Find an element | Search |" O(n) "|

*O(1) with tail pointer

</details>

---

## ‚úÖ When Each Operation Excels

| Operation | Best For | Linked List Advantage |
|-----------|----------|----------------------|
| Insert at beginning | Stack implementation |" O(1) vs O(n) for arrays "|
| Delete from beginning | Queue dequeue |" O(1) vs O(n) for arrays "|
| Insert/Delete in middle | Given node reference |" O(1) local, O(n) to find "|
| Traversal | Sequential processing | Same as arrays |

---

## ‚ùå Operations to Avoid

| Operation | Why Problematic | Alternative |
|-----------|-----------------|-------------|
| Access by index |" O(n) traversal "| Use array if frequent |
| Delete from end |" O(n) to find prev "| Use doubly linked list |
| Frequent random access | No indexing | Use array |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Singly Linked List Basics](./1.1-Basics.md) - Node structure
- Pointer manipulation concepts

**After mastering this:**
- [Basic Problems](./1.3-Basic-Problems.md) - Apply operations
- [Fast & Slow Pointer](../04-Fast-Slow-Pointer/4.1-Concept.md) - Advanced traversal
- [In-Place Reversal](../05-In-Place-Reversal/5.1-Reversal-Technique.md) - Node rearrangement

</details>

---

## üìê How Each Operation Works

### 1. Traversal

Visit each node from head to tail.

```
Start at head, follow next pointers until null:

HEAD ‚Üí [1] ‚Üí [2] ‚Üí [3] ‚Üí [4] ‚Üí null
        ‚Üì      ‚Üì      ‚Üì      ‚Üì
      visit  visit  visit  visit
```

### 2. Insertion at Beginning

Create new node, point it to current head, update head.

```
Before: HEAD ‚Üí [2] ‚Üí [3] ‚Üí null
Insert 1:
  1. Create [1]
  2. [1].next = HEAD (points to [2])
  3. HEAD = [1]
After:  HEAD ‚Üí [1] ‚Üí [2] ‚Üí [3] ‚Üí null
```

### 3. Insertion at End

Traverse to last node, update its next pointer.

```
Before: HEAD ‚Üí [1] ‚Üí [2] ‚Üí null
Insert 3:
  1. Traverse to [2] (last.next == null)
  2. [2].next = [3]
After:  HEAD ‚Üí [1] ‚Üí [2] ‚Üí [3] ‚Üí null
```

### 4. Insertion at Position

Traverse to position-1, insert between nodes.

```
Before: HEAD ‚Üí [1] ‚Üí [3] ‚Üí null
Insert 2 at position 1 (0-indexed):
  1. Traverse to position 0: [1]
  2. [2].next = [1].next (which is [3])
  3. [1].next = [2]
After:  HEAD ‚Üí [1] ‚Üí [2] ‚Üí [3] ‚Üí null
```

### 5. Deletion from Beginning

Update head to head.next.

```
Before: HEAD ‚Üí [1] ‚Üí [2] ‚Üí [3] ‚Üí null
Delete first:
  1. HEAD = HEAD.next
After:  HEAD ‚Üí [2] ‚Üí [3] ‚Üí null
(Node [1] is garbage collected)
```

### 6. Deletion from End

Traverse to second-to-last, set its next to null.

```
Before: HEAD ‚Üí [1] ‚Üí [2] ‚Üí [3] ‚Üí null
Delete last:
  1. Traverse to [2] (where next.next == null)
  2. [2].next = null
After:  HEAD ‚Üí [1] ‚Üí [2] ‚Üí null
```

---

## üíª Code Implementation

### Complete LinkedList Class with All Operations

**Python:**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class LinkedList:
    """
    Singly Linked List with all standard operations.
    """
    def __init__(self):
        self.head = None
        self.size = 0
    
    # ==================== TRAVERSAL ====================
    
    def traverse(self) -> list:
        """
        Visit all nodes and return values.
        Time: O(n), Space: O(n) for result
        """
        result = []
        current = self.head
        while current:
            result.append(current.val)
            current = current.next
        return result
    
    def print_list(self) -> None:
        """Print all values in order."""
        values = self.traverse()
        print(" ‚Üí ".join(map(str, values)) + " ‚Üí None")
    
    # ==================== INSERTION ====================
    
    def insert_at_beginning(self, val) -> None:
        """
        Insert new node at the head.
        Time: O(1)
        """
        new_node = ListNode(val)
        new_node.next = self.head  # Point to current head
        self.head = new_node       # Update head
        self.size += 1
    
    def insert_at_end(self, val) -> None:
        """
        Insert new node at the tail.
        Time: O(n) - must traverse to end
        """
        new_node = ListNode(val)
        
        # Edge case: empty list
        if not self.head:
            self.head = new_node
            self.size += 1
            return
        
        # Traverse to last node
        current = self.head
        while current.next:
            current = current.next
        
        current.next = new_node
        self.size += 1
    
    def insert_at_position(self, val, position: int) -> bool:
        """
        Insert at specific position (0-indexed).
        Time: O(n)
        Returns False if position is invalid.
        """
        if position < 0 or position > self.size:
            return False
        
        # Insert at beginning
        if position == 0:
            self.insert_at_beginning(val)
            return True
        
        # Traverse to position - 1
        new_node = ListNode(val)
        current = self.head
        for _ in range(position - 1):
            current = current.next
        
        # Insert after current
        new_node.next = current.next
        current.next = new_node
        self.size += 1
        return True
    
    # ==================== DELETION ====================
    
    def delete_from_beginning(self) -> int:
        """
        Delete first node and return its value.
        Time: O(1)
        Returns None if list is empty.
        """
        if not self.head:
            return None
        
        value = self.head.val
        self.head = self.head.next
        self.size -= 1
        return value
    
    def delete_from_end(self) -> int:
        """
        Delete last node and return its value.
        Time: O(n)
        Returns None if list is empty.
        """
        if not self.head:
            return None
        
        # Only one node
        if not self.head.next:
            value = self.head.val
            self.head = None
            self.size -= 1
            return value
        
        # Traverse to second-to-last
        current = self.head
        while current.next.next:
            current = current.next
        
        value = current.next.val
        current.next = None
        self.size -= 1
        return value
    
    def delete_by_value(self, val) -> bool:
        """
        Delete first occurrence of value.
        Time: O(n)
        Returns True if deleted, False if not found.
        """
        if not self.head:
            return False
        
        # Check head
        if self.head.val == val:
            self.head = self.head.next
            self.size -= 1
            return True
        
        # Search for value
        current = self.head
        while current.next:
            if current.next.val == val:
                current.next = current.next.next  # Skip the node
                self.size -= 1
                return True
            current = current.next
        
        return False
    
    def delete_at_position(self, position: int) -> int:
        """
        Delete node at position and return value.
        Time: O(n)
        Returns None if position invalid.
        """
        if position < 0 or position >= self.size or not self.head:
            return None
        
        if position == 0:
            return self.delete_from_beginning()
        
        # Traverse to position - 1
        current = self.head
        for _ in range(position - 1):
            current = current.next
        
        value = current.next.val
        current.next = current.next.next
        self.size -= 1
        return value
    
    # ==================== SEARCH ====================
    
    def search(self, val) -> int:
        """
        Find first occurrence of value.
        Time: O(n)
        Returns index if found, -1 otherwise.
        """
        current = self.head
        index = 0
        while current:
            if current.val == val:
                return index
            current = current.next
            index += 1
        return -1
    
    def contains(self, val) -> bool:
        """Check if value exists in list."""
        return self.search(val) != -1
    
    def get(self, index: int) -> int:
        """
        Get value at index.
        Time: O(n)
        Returns None if index invalid.
        """
        if index < 0 or index >= self.size:
            return None
        
        current = self.head
        for _ in range(index):
            current = current.next
        return current.val
    
    # ==================== UTILITY ====================
    
    def is_empty(self) -> bool:
        return self.head is None
    
    def get_size(self) -> int:
        return self.size
    
    def clear(self) -> None:
        """Remove all nodes."""
        self.head = None
        self.size = 0


# Usage example
ll = LinkedList()
ll.insert_at_end(1)
ll.insert_at_end(2)
ll.insert_at_end(3)
ll.print_list()  # 1 ‚Üí 2 ‚Üí 3 ‚Üí None

ll.insert_at_beginning(0)
ll.print_list()  # 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí None

ll.insert_at_position(1.5, 2)
ll.print_list()  # 0 ‚Üí 1 ‚Üí 1.5 ‚Üí 2 ‚Üí 3 ‚Üí None

ll.delete_by_value(1.5)
ll.print_list()  # 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí None

print(ll.search(2))  # 2 (index)
print(ll.get(1))     # 1 (value)
```

**JavaScript:**
```javascript
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
        this.size = 0;
    }
    
    // ==================== TRAVERSAL ====================
    
    traverse() {
        const result = [];
        let current = this.head;
        while (current) {
            result.push(current.val);
            current = current.next;
        }
        return result;
    }
    
    printList() {
        const values = this.traverse();
        console.log(values.join(' ‚Üí ') + ' ‚Üí null');
    }
    
    // ==================== INSERTION ====================
    
    insertAtBeginning(val) {
        const newNode = new ListNode(val);
        newNode.next = this.head;
        this.head = newNode;
        this.size++;
    }
    
    insertAtEnd(val) {
        const newNode = new ListNode(val);
        
        if (!this.head) {
            this.head = newNode;
            this.size++;
            return;
        }
        
        let current = this.head;
        while (current.next) {
            current = current.next;
        }
        current.next = newNode;
        this.size++;
    }
    
    insertAtPosition(val, position) {
        if (position < 0 || position > this.size) {
            return false;
        }
        
        if (position === 0) {
            this.insertAtBeginning(val);
            return true;
        }
        
        const newNode = new ListNode(val);
        let current = this.head;
        for (let i = 0; i < position - 1; i++) {
            current = current.next;
        }
        
        newNode.next = current.next;
        current.next = newNode;
        this.size++;
        return true;
    }
    
    // ==================== DELETION ====================
    
    deleteFromBeginning() {
        if (!this.head) return null;
        
        const value = this.head.val;
        this.head = this.head.next;
        this.size--;
        return value;
    }
    
    deleteFromEnd() {
        if (!this.head) return null;
        
        if (!this.head.next) {
            const value = this.head.val;
            this.head = null;
            this.size--;
            return value;
        }
        
        let current = this.head;
        while (current.next.next) {
            current = current.next;
        }
        
        const value = current.next.val;
        current.next = null;
        this.size--;
        return value;
    }
    
    deleteByValue(val) {
        if (!this.head) return false;
        
        if (this.head.val === val) {
            this.head = this.head.next;
            this.size--;
            return true;
        }
        
        let current = this.head;
        while (current.next) {
            if (current.next.val === val) {
                current.next = current.next.next;
                this.size--;
                return true;
            }
            current = current.next;
        }
        
        return false;
    }
    
    // ==================== SEARCH ====================
    
    search(val) {
        let current = this.head;
        let index = 0;
        while (current) {
            if (current.val === val) return index;
            current = current.next;
            index++;
        }
        return -1;
    }
    
    contains(val) {
        return this.search(val) !== -1;
    }
    
    get(index) {
        if (index < 0 || index >= this.size) return null;
        
        let current = this.head;
        for (let i = 0; i < index; i++) {
            current = current.next;
        }
        return current.val;
    }
    
    // ==================== UTILITY ====================
    
    isEmpty() { return this.head === null; }
    getSize() { return this.size; }
    clear() { this.head = null; this.size = 0; }
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Traversal |" O(n) "| O(1) | Visit all nodes |
| Insert at beginning |" **O(1)** "| O(1) | Just pointer update |
| Insert at end |" O(n) "| O(1) |" O(1) with tail pointer "|
| Insert at position |" O(n) "| O(1) | Traverse to position |
| Delete from beginning |" **O(1)** "| O(1) | Just pointer update |
| Delete from end |" O(n) "| O(1) | Find second-to-last |
| Delete by value |" O(n) "| O(1) | Search + delete |
| Delete at position |" O(n) "| O(1) | Traverse to position |
| Search |" O(n) "| O(1) | May visit all nodes |
| Get by index |" O(n) "| O(1) | No random access |

---

## üîÑ Variations

| Variation | Benefit | Trade-off |
|-----------|---------|-----------|
| With tail pointer |" O(1) append "| Extra pointer to maintain |
| With size tracking |" O(1) length "| Must update on every operation |
| Sorted linked list | Binary search possible (sort of) |" O(n) insert to maintain order "|
| Circular singly linked | No null checks for tail | Extra logic for operations |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Handling Empty List

```python
# ‚ùå Wrong - crashes on empty list
def get_first(self):
    return self.head.val  # NullPointerException!

# ‚úÖ Correct - check first
def get_first(self):
    if not self.head:
        return None
    return self.head.val
```

### 2. Wrong Insertion Order

```python
# ‚ùå Wrong - loses rest of list
def insert_after(node, val):
    new_node = ListNode(val)
    node.next = new_node  # Lost everything after node!

# ‚úÖ Correct - save link first
def insert_after(node, val):
    new_node = ListNode(val)
    new_node.next = node.next  # Save first
    node.next = new_node
```

### 3. Off-by-One in Position Operations

```python
# ‚ùå Wrong - stops one position early
for i in range(position):  # Should be position - 1
    current = current.next

# ‚úÖ Correct - traverse to position - 1
for i in range(position - 1):
    current = current.next
# Now current is the node BEFORE the target position
```

### 4. Not Updating Size

```python
# ‚ùå Wrong - size becomes incorrect
def insert(self, val):
    # ... insert logic
    # Forgot self.size += 1

# ‚úÖ Correct - always update size
def insert(self, val):
    # ... insert logic
    self.size += 1
```

---

## üìù Practice Problems (Progressive)

### Easy (Apply operations)
- [ ] [Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/) - LC 203 - Delete by value
- [ ] [Delete Node in a Linked List](https://leetcode.com/problems/delete-node-in-a-linked-list/) - LC 237 - Tricky deletion
- [ ] [Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/) - LC 83 - Conditional deletion

### Medium (Combine operations)
- [ ] [Remove Nth Node From End](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) - LC 19 - Delete at position
- [ ] [Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/) - LC 24 - Pointer manipulation

### Hard (Master operations)
- [ ] [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/) - LC 25 - Complex manipulation

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**For operations:**
- **Day 1:** Implement all insert operations from memory
- **Day 3:** Implement all delete operations from memory
- **Day 7:** Solve LC 203 (remove elements) - applies delete
- **Day 14:** Solve LC 19 (remove nth) - two pointers
- **Day 30:** Implement full LinkedList class without reference

</details>

---

## üé§ Interview Context

<details>
<summary><strong>What Interviewers Look For</strong></summary>

**Operations they expect you to know instantly:**
1. Insert at beginning - O(1)
2. Insert at end - O(n) or O(1) with tail
3. Delete from beginning - O(1)
4. Search - O(n)

**Common interview patterns:**
- "Given a node (not head), delete it" ‚Üí LC 237
- "Remove nth from end in one pass" ‚Üí LC 19
- "Remove all occurrences of X" ‚Üí LC 203

**Questions about trade-offs:**
- "Why is delete from end O(n)?" ‚Üí Need to find previous node
- "How would you make insert at end O(1)?" ‚Üí Maintain tail pointer
- "When would you use LL over array?" ‚Üí Frequent insertions/deletions at front

</details>

**Company Focus:**

| Company | Focus | Notes |
|---------|-------|-------|
| Amazon | All operations | Expect to implement from scratch |
| Meta | Deletion patterns | Edge cases important |
| Google | Optimization questions | "Can you do it in one pass?" |
| Microsoft | Standard operations | Clean code expected |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn all insertions | 20-25 min | 3 variations |
| Learn all deletions | 25-30 min | 4 variations |
| Practice with problems | 45-60 min | Apply operations |
| Master all operations | 2-3 hours | Total |

---

> **üí° Key Insight:** The order of pointer updates is CRITICAL in linked list operations. Always save the "next" reference before breaking any links. When inserting, point the new node to its successor before updating the predecessor's pointer.

---

## üîó Related

- [Singly Linked List Basics](./1.1-Basics.md) - Node structure
- [Basic Problems](./1.3-Basic-Problems.md) - Apply operations
- [Fast & Slow Pointer](../04-Fast-Slow-Pointer/4.1-Concept.md) - Traversal pattern
- [Doubly Linked List](../02-Doubly-LL/2.1-Doubly-LL-Complete.md) - O(1) delete from end
