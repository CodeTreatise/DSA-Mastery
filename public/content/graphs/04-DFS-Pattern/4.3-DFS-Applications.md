# 4.3 DFS Applications

> **Practical applications of DFS - cycle detection, connectivity, and more**
>
> ‚è±Ô∏è **Time:** 45-60 min | üìä **Difficulty:** Medium-Hard | üéØ **Interview Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

---

## Overview

DFS is the foundation for many classic graph algorithms. This module covers the most important applications you'll encounter in interviews.

```
DFS Application Map:

                    DFS
                     ‚îÇ
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ               ‚îÇ               ‚îÇ
Connectivity    Cycle Detection  Topological
     ‚îÇ               ‚îÇ               ‚îÇ
  ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îê
  ‚îÇ     ‚îÇ         ‚îÇ     ‚îÇ         ‚îÇ     ‚îÇ
Components  Connected  Directed  Undirected  Sort  Valid
Counting    Check      Cycle    Cycle       Order Check
```

---

## üéØ Application Overview

| Application | Use Case | Interview Frequency |
|------------|----------|---------------------|
| Connected Components | Count separate groups | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| Cycle Detection (Directed) | Course scheduling | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| Cycle Detection (Undirected) | Detect extra edge | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Topological Sort | Task ordering | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| Path Finding | Any path between nodes | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Clone Graph | Deep copy with DFS | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Bipartite Check | Two-coloring | ‚≠ê‚≠ê‚≠ê‚≠ê |

---

## 1. Connected Components

### Problem

Count the number of connected groups in an undirected graph.

### Key Insight

Each DFS from an unvisited node explores one complete component.

**Python:**
```python
def count_components(graph, n):
    """
    Count connected components in undirected graph.
    
    Algorithm:
    1. For each unvisited node, start DFS
    2. DFS marks all reachable nodes
    3. Each DFS = one component
    
    Time: O(V + E)
    Space: O(V)
    """
    visited = set()
    components = 0
    
    def dfs(node):
        visited.add(node)
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                dfs(neighbor)
    
    for node in range(n):
        if node not in visited:
            dfs(node)
            components += 1  # Found new component
    
    return components


# Example
graph = {
    0: [1],       # Component 1: nodes 0, 1
    1: [0],
    2: [3],       # Component 2: nodes 2, 3
    3: [2],
    4: []         # Component 3: node 4 (isolated)
}
print(count_components(graph, 5))  # 3
```

### Variation: Get All Components

```python
def get_all_components(graph, n):
    """Return list of components (each is a list of nodes)."""
    visited = set()
    components = []
    
    def dfs(node, component):
        visited.add(node)
        component.append(node)
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                dfs(neighbor, component)
    
    for node in range(n):
        if node not in visited:
            component = []
            dfs(node, component)
            components.append(component)
    
    return components
```

### Classic Problems

| Problem | Link |
|---------|------|
| Number of Provinces | [LC 547](https://leetcode.com/problems/number-of-provinces/) |
| Number of Connected Components | [LC 323](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/) |
| Number of Islands | [LC 200](https://leetcode.com/problems/number-of-islands/) |

---

## 2. Cycle Detection in Directed Graphs

### Problem

Detect if a directed graph contains a cycle. Critical for:
- Course scheduling (prerequisites)
- Deadlock detection
- Topological sort validity

### Key Insight: Three-State DFS

```
Node states during DFS:

WHITE (unvisited) ‚Üí GRAY (in current path) ‚Üí BLACK (done)

Cycle exists ‚ü∫ We encounter a GRAY node
                 (back edge to ancestor in current path)

     A (GRAY)
    / 
   B (GRAY)
    \
     C (GRAY) ‚Üí A?  ‚Üê CYCLE! (A is GRAY)
```

**Python:**
```python
def has_cycle_directed(graph, n):
    """
    Detect cycle in directed graph.
    
    Key: Track three states:
    - WHITE: Not yet visited
    - GRAY: In current DFS path (being processed)
    - BLACK: Completely finished
    
    Cycle = back edge to GRAY node
    
    Time: O(V + E)
    Space: O(V)
    """
    WHITE, GRAY, BLACK = 0, 1, 2
    state = [WHITE] * n
    
    def dfs(node):
        state[node] = GRAY  # Start processing
        
        for neighbor in graph.get(node, []):
            if state[neighbor] == GRAY:
                # Back edge to node in current path
                return True
            if state[neighbor] == WHITE:
                if dfs(neighbor):
                    return True
        
        state[node] = BLACK  # Done processing
        return False
    
    # Check all nodes (graph might be disconnected)
    for node in range(n):
        if state[node] == WHITE:
            if dfs(node):
                return True
    
    return False


# Example: Course Schedule (LC 207)
def canFinish(numCourses, prerequisites):
    """
    True if possible to finish all courses (no cycle in dependency graph).
    """
    # Build graph: course -> list of courses that depend on it
    graph = {i: [] for i in range(numCourses)}
    for course, prereq in prerequisites:
        graph[prereq].append(course)
    
    return not has_cycle_directed(graph, numCourses)


# Test
print(canFinish(2, [[1, 0]]))  # True: 0 ‚Üí 1
print(canFinish(2, [[1, 0], [0, 1]]))  # False: cycle 0 ‚Üî 1
```

### Find the Cycle

```python
def find_cycle_directed(graph, n):
    """Return nodes in cycle, or empty list if no cycle."""
    WHITE, GRAY, BLACK = 0, 1, 2
    state = [WHITE] * n
    parent = {}
    
    def dfs(node):
        state[node] = GRAY
        
        for neighbor in graph.get(node, []):
            if state[neighbor] == GRAY:
                # Reconstruct cycle
                cycle = [neighbor]
                current = node
                while current != neighbor:
                    cycle.append(current)
                    current = parent.get(current, neighbor)
                cycle.append(neighbor)
                return cycle[::-1]
            
            if state[neighbor] == WHITE:
                parent[neighbor] = node
                result = dfs(neighbor)
                if result:
                    return result
        
        state[node] = BLACK
        return None
    
    for node in range(n):
        if state[node] == WHITE:
            result = dfs(node)
            if result:
                return result
    
    return []
```

---

## 3. Cycle Detection in Undirected Graphs

### Problem

Detect if an undirected graph contains a cycle.

### Key Insight

Track parent to avoid counting the edge we came from as a cycle.

```
Edge (A - B):
When at B (came from A), seeing A is NOT a cycle
When at B (came from C), seeing A IS a cycle

    A ‚îÄ‚îÄ B    Visiting B from A, seeing A ‚Üí NOT cycle
    ‚îÇ    ‚îÇ    
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò    Visiting B from C, seeing A ‚Üí CYCLE!
         C
```

**Python:**
```python
def has_cycle_undirected(graph, n):
    """
    Detect cycle in undirected graph.
    
    Key: Track parent to ignore the edge we came from.
    Cycle = non-parent back edge
    
    Time: O(V + E)
    Space: O(V)
    """
    visited = set()
    
    def dfs(node, parent):
        visited.add(node)
        
        for neighbor in graph.get(node, []):
            if neighbor == parent:
                continue  # Skip edge we came from
            
            if neighbor in visited:
                return True  # Cycle! (back edge)
            
            if dfs(neighbor, node):
                return True
        
        return False
    
    for node in range(n):
        if node not in visited:
            if dfs(node, -1):
                return True
    
    return False


# Classic problem: Find Redundant Connection
def findRedundantConnection(edges):
    """
    Find the edge that creates a cycle.
    When added to a tree, one extra edge creates exactly one cycle.
    """
    from collections import defaultdict
    
    graph = defaultdict(list)
    
    for u, v in edges:
        # Check if adding this edge creates cycle
        if graph:  # Non-empty graph
            visited = set()
            if has_path(graph, u, v, visited):
                return [u, v]  # This edge creates cycle
        
        # Add edge
        graph[u].append(v)
        graph[v].append(u)
    
    return []

def has_path(graph, start, end, visited):
    """Check if path exists between start and end."""
    if start == end:
        return True
    visited.add(start)
    for neighbor in graph[start]:
        if neighbor not in visited:
            if has_path(graph, neighbor, end, visited):
                return True
    return False
```

---

## 4. Topological Sort (DFS Approach)

### Problem

Order vertices so that for every edge (u, v), u comes before v.

### Key Insight

Post-order DFS gives reverse topological order.

```
When DFS finishes a node, all its descendants are done.
So add to result when leaving (post-order).
Reverse at the end.

DFS from A:
A ‚Üí B ‚Üí D (finish D, add D)
      ‚Üí (back at B, finish B, add B)
  ‚Üí C ‚Üí E (finish E, add E)
      ‚Üí (back at C, finish C, add C)
  ‚Üí (back at A, finish A, add A)

Result: [D, B, E, C, A]
Reverse: [A, C, E, B, D] ‚Üê Topological order!
```

**Python:**
```python
def topological_sort_dfs(graph, n):
    """
    Topological sort using DFS.
    
    Algorithm:
    1. DFS with post-order processing
    2. Add to result when ALL descendants are processed
    3. Reverse result at end
    
    Returns: Topological order, or empty list if cycle exists
    
    Time: O(V + E)
    Space: O(V)
    """
    WHITE, GRAY, BLACK = 0, 1, 2
    state = [WHITE] * n
    result = []
    has_cycle = False
    
    def dfs(node):
        nonlocal has_cycle
        if has_cycle:
            return
        
        state[node] = GRAY
        
        for neighbor in graph.get(node, []):
            if state[neighbor] == GRAY:
                has_cycle = True
                return
            if state[neighbor] == WHITE:
                dfs(neighbor)
        
        state[node] = BLACK
        result.append(node)  # Post-order: add when done
    
    for node in range(n):
        if state[node] == WHITE:
            dfs(node)
    
    if has_cycle:
        return []
    
    return result[::-1]  # Reverse for correct order


# Example: Course Schedule II (LC 210)
def findOrder(numCourses, prerequisites):
    """
    Return topological order of courses, or [] if impossible.
    """
    from collections import defaultdict
    
    # Build graph: prerequisite -> courses
    graph = defaultdict(list)
    for course, prereq in prerequisites:
        graph[prereq].append(course)
    
    return topological_sort_dfs(dict(graph), numCourses)


# Test
print(findOrder(4, [[1,0],[2,0],[3,1],[3,2]]))
# [0, 1, 2, 3] or [0, 2, 1, 3] (both valid)
```

### Alternative: Kahn's Algorithm (BFS)

See [Topological Sort section](../06-Topological-Sort/6.2-Kahns-Algorithm.md) for BFS approach.

---

## 5. Clone Graph

### Problem

Deep copy a graph where nodes contain references to neighbors.

### Key Insight

Use DFS with a map from old nodes to new nodes.

**Python:**
```python
class Node:
    def __init__(self, val=0, neighbors=None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []

def cloneGraph(node):
    """
    Deep copy a graph.
    
    Algorithm:
    1. Create map: old node -> new node
    2. DFS: For each node, clone it and recursively clone neighbors
    3. Use map to avoid duplicates (handle cycles)
    
    Time: O(V + E)
    Space: O(V)
    """
    if not node:
        return None
    
    old_to_new = {}
    
    def dfs(old_node):
        if old_node in old_to_new:
            return old_to_new[old_node]
        
        # Create new node
        new_node = Node(old_node.val)
        old_to_new[old_node] = new_node
        
        # Clone all neighbors
        for neighbor in old_node.neighbors:
            new_node.neighbors.append(dfs(neighbor))
        
        return new_node
    
    return dfs(node)
```

---

## 6. Bipartite Check

### Problem

Check if graph can be 2-colored (no adjacent nodes have same color).

### Key Insight

Use DFS with alternating colors.

```
Bipartite:        Not Bipartite:
A(0) ‚îÄ‚îÄ B(1)      A(0) ‚îÄ‚îÄ B(1)
‚îÇ       ‚îÇ         ‚îÇ ‚ï≤     ‚îÇ
C(1) ‚îÄ‚îÄ D(0)      ‚îÇ  ‚ï≤    ‚îÇ
                  C(1) ‚îÄ‚îÄ D(?)  ‚Üê D needs 0 (from B) and 0 (from C)
                                  Can't satisfy both!
```

**Python:**
```python
def isBipartite(graph):
    """
    Check if graph is bipartite (2-colorable).
    
    Algorithm:
    1. Start coloring from each uncolored node
    2. Alternate colors during DFS
    3. If neighbor already has same color ‚Üí not bipartite
    
    Time: O(V + E)
    Space: O(V)
    """
    n = len(graph)
    color = [-1] * n  # -1: uncolored, 0: color A, 1: color B
    
    def dfs(node, c):
        color[node] = c
        
        for neighbor in graph[node]:
            if color[neighbor] == c:
                return False  # Same color ‚Üí not bipartite
            if color[neighbor] == -1:
                if not dfs(neighbor, 1 - c):  # Alternate color
                    return False
        
        return True
    
    for node in range(n):
        if color[node] == -1:
            if not dfs(node, 0):
                return False
    
    return True


# Test
print(isBipartite([[1,3], [0,2], [1,3], [0,2]]))  # True
print(isBipartite([[1,2,3], [0,2], [0,1,3], [0,2]]))  # False
```

---

## 7. DFS with State (Advanced)

### Problem

DFS where nodes can be visited multiple times with different states.

**Example: Shortest Path with Keys (LC 864)**

```python
def shortestPathAllKeys(grid):
    """
    Find shortest path collecting all keys.
    State: (row, col, collected_keys)
    Same cell can be visited with different key sets.
    """
    from collections import deque
    
    rows, cols = len(grid), len(grid[0])
    start = None
    num_keys = 0
    
    # Find start and count keys
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '@':
                start = (r, c)
            elif grid[r][c].islower():
                num_keys += 1
    
    # State: (row, col, keys_bitmask)
    # Need BFS for shortest path, but state concept from DFS
    all_keys = (1 << num_keys) - 1
    
    visited = set()
    queue = deque([(start[0], start[1], 0, 0)])  # row, col, keys, steps
    
    while queue:
        r, c, keys, steps = queue.popleft()
        
        if keys == all_keys:
            return steps
        
        state = (r, c, keys)
        if state in visited:
            continue
        visited.add(state)
        
        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < rows and 0 <= nc < cols:
                cell = grid[nr][nc]
                
                if cell == '#':
                    continue  # Wall
                
                new_keys = keys
                
                if cell.islower():
                    new_keys |= (1 << (ord(cell) - ord('a')))  # Collect key
                
                if cell.isupper():
                    if not (keys & (1 << (ord(cell) - ord('A')))):
                        continue  # Don't have key for this lock
                
                queue.append((nr, nc, new_keys, steps + 1))
    
    return -1
```

---

## ‚ö° Complexity Summary

| Application | Time | Space |
|-------------|------|-------|
| Connected Components | O(V + E) | O(V) |
| Cycle Detection (Directed) | O(V + E) | O(V) |
| Cycle Detection (Undirected) | O(V + E) | O(V) |
| Topological Sort | O(V + E) | O(V) |
| Clone Graph | O(V + E) | O(V) |
| Bipartite Check | O(V + E) | O(V) |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Wrong Cycle Detection Algorithm

```python
# ‚ùå Wrong: Using undirected cycle detection for directed graph
def has_cycle_wrong(graph, n):
    visited = set()
    def dfs(node, parent):  # Parent tracking doesn't work for directed!
        # ...

# ‚úÖ Correct: Use three-state for directed graphs
def has_cycle_directed(graph, n):
    state = [WHITE] * n  # THREE states needed
```

### 2. Missing Edge Case: Disconnected Graphs

```python
# ‚ùå Wrong: Only starts DFS from node 0
dfs(0)  # Misses other components

# ‚úÖ Correct: Start from all unvisited
for node in range(n):
    if node not in visited:
        dfs(node)
```

---

## üìù Practice Problems

| Application | Problem | Link |
|-------------|---------|------|
| Components | Number of Provinces | [LC 547](https://leetcode.com/problems/number-of-provinces/) |
| Cycle (Directed) | Course Schedule | [LC 207](https://leetcode.com/problems/course-schedule/) |
| Cycle (Undirected) | Redundant Connection | [LC 684](https://leetcode.com/problems/redundant-connection/) |
| Topological Sort | Course Schedule II | [LC 210](https://leetcode.com/problems/course-schedule-ii/) |
| Clone | Clone Graph | [LC 133](https://leetcode.com/problems/clone-graph/) |
| Bipartite | Is Graph Bipartite | [LC 785](https://leetcode.com/problems/is-graph-bipartite/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement connected components and directed cycle detection
- **Day 3:** Implement topological sort and clone graph
- **Day 7:** Solve Course Schedule and related problems
- **Day 14:** Implement bipartite check, review all applications

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Application Selection</strong></summary>

**When asked about cycle detection:**
> "First, I need to clarify: is this a directed or undirected graph? For directed, I use three-state DFS to detect back edges to ancestors. For undirected, I track the parent to ignore the edge I came from."

**When asked about ordering:**
> "This sounds like topological sort. I'll use DFS and add nodes to result in post-order, then reverse. If there's a cycle, no valid ordering exists."

**When asked about grouping:**
> "I need to find connected components. I'll start DFS from each unvisited node; each DFS explores one complete component."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Learn all applications | 45-60 min |
| Implement each | 10-15 min each |
| Solve related problems | 20-30 min each |
| **Master DFS applications** | **4-6 hours** |

---

> **üí° Key Insight:** Most DFS applications follow the same template with different state tracking: connected components track components, cycle detection tracks node states, topological sort tracks finish times.

> **üîó Related:** [DFS Template](./4.2-DFS-Template.md) | [Topological Sort](../06-Topological-Sort/6.1-Topological-Basics.md) | [Union-Find](../07-Union-Find/7.1-Union-Find-Basics.md)

---

**Previous:** [‚Üê 4.2 DFS Template](./4.2-DFS-Template.md)  
**Next:** [DFS Practice Problems ‚Üí](./4.4-DFS-Practice/)
