# 6.3 Kahn's Algorithm (BFS Approach)

> **Iteratively remove nodes with no dependencies - intuitive and parallel-friendly**
>
> üéØ **Best For:** Intuitive understanding, cycle detection, parallel processing

---

## Overview

Kahn's Algorithm is a BFS-based approach that repeatedly removes nodes with **in-degree 0** (no incoming edges = no unmet dependencies).

```
Key Insight:
- In a DAG, there's always at least one node with in-degree 0
- Remove it, update in-degrees, repeat
- If we process all nodes, we have a valid order
- If we get stuck (no in-degree 0 nodes left), there's a cycle
```

---

## üìê How It Works

### Algorithm Steps

```
1. Calculate in-degree for every node
2. Add all nodes with in-degree 0 to queue
3. While queue not empty:
   a. Remove node from queue ‚Üí add to result
   b. For each neighbor:
      - Decrease in-degree by 1
      - If in-degree becomes 0, add to queue
4. If result.length == num_nodes ‚Üí valid order
   Else ‚Üí cycle exists
```

### Visualization

```
Graph: A ‚Üí B ‚Üí D
       A ‚Üí C ‚Üí D

Initial in-degrees:
A: 0, B: 1, C: 1, D: 2

Step 1: Queue = [A], Result = []
        Process A, reduce B and C
        In-degrees: A: -, B: 0, C: 0, D: 2

Step 2: Queue = [B, C], Result = [A]
        Process B, reduce D
        In-degrees: B: -, C: 0, D: 1

Step 3: Queue = [C], Result = [A, B]
        Process C, reduce D
        In-degrees: C: -, D: 0

Step 4: Queue = [D], Result = [A, B, C]
        Process D
        
Final: Result = [A, B, C, D] ‚úì
```

---

## üíª Implementation

**Python:**
```python
from collections import deque, defaultdict
from typing import List

def topological_sort_kahn(num_nodes: int, edges: List[List[int]]) -> List[int]:
    """
    Kahn's Algorithm for topological sort.
    
    Args:
        num_nodes: Number of vertices (0 to n-1)
        edges: List of [from, to] directed edges
        
    Returns:
        Topological order, or empty list if cycle exists
        
    Time: O(V + E)
    Space: O(V + E)
    """
    # Build adjacency list and calculate in-degrees
    graph = defaultdict(list)
    in_degree = [0] * num_nodes
    
    for src, dst in edges:
        graph[src].append(dst)
        in_degree[dst] += 1
    
    # Initialize queue with all zero in-degree nodes
    queue = deque()
    for node in range(num_nodes):
        if in_degree[node] == 0:
            queue.append(node)
    
    result = []
    
    while queue:
        node = queue.popleft()
        result.append(node)
        
        # Reduce in-degree of neighbors
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Check if all nodes were processed
    if len(result) == num_nodes:
        return result
    else:
        return []  # Cycle detected - couldn't process all nodes


def can_finish_courses(num_courses: int, prerequisites: List[List[int]]) -> bool:
    """
    Course Schedule I - just check if possible.
    prerequisites[i] = [course, prereq] means prereq ‚Üí course
    """
    graph = defaultdict(list)
    in_degree = [0] * num_courses
    
    for course, prereq in prerequisites:
        graph[prereq].append(course)
        in_degree[course] += 1
    
    queue = deque([i for i in range(num_courses) if in_degree[i] == 0])
    processed = 0
    
    while queue:
        node = queue.popleft()
        processed += 1
        
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    return processed == num_courses


def find_course_order(num_courses: int, prerequisites: List[List[int]]) -> List[int]:
    """
    Course Schedule II - return the order.
    """
    graph = defaultdict(list)
    in_degree = [0] * num_courses
    
    for course, prereq in prerequisites:
        graph[prereq].append(course)
        in_degree[course] += 1
    
    queue = deque([i for i in range(num_courses) if in_degree[i] == 0])
    order = []
    
    while queue:
        course = queue.popleft()
        order.append(course)
        
        for next_course in graph[course]:
            in_degree[next_course] -= 1
            if in_degree[next_course] == 0:
                queue.append(next_course)
    
    return order if len(order) == num_courses else []


# Test
edges = [[5,0], [5,2], [4,0], [4,1], [2,3], [3,1]]
print(topological_sort_kahn(6, edges))
# Output: [4, 5, 0, 2, 3, 1] or similar valid order

prerequisites = [[1,0], [2,0], [3,1], [3,2]]
print(find_course_order(4, prerequisites))
# Output: [0, 1, 2, 3] or [0, 2, 1, 3]
```

**JavaScript:**
```javascript
function topologicalSortKahn(numNodes, edges) {
    // Build graph and calculate in-degrees
    const graph = new Map();
    const inDegree = new Array(numNodes).fill(0);
    
    for (let i = 0; i < numNodes; i++) {
        graph.set(i, []);
    }
    
    for (const [src, dst] of edges) {
        graph.get(src).push(dst);
        inDegree[dst]++;
    }
    
    // Start with nodes having no prerequisites
    const queue = [];
    for (let i = 0; i < numNodes; i++) {
        if (inDegree[i] === 0) {
            queue.push(i);
        }
    }
    
    const result = [];
    
    while (queue.length > 0) {
        const node = queue.shift();
        result.push(node);
        
        for (const neighbor of graph.get(node)) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] === 0) {
                queue.push(neighbor);
            }
        }
    }
    
    return result.length === numNodes ? result : [];
}


function canFinishCourses(numCourses, prerequisites) {
    const graph = new Map();
    const inDegree = new Array(numCourses).fill(0);
    
    for (let i = 0; i < numCourses; i++) {
        graph.set(i, []);
    }
    
    for (const [course, prereq] of prerequisites) {
        graph.get(prereq).push(course);
        inDegree[course]++;
    }
    
    const queue = [];
    for (let i = 0; i < numCourses; i++) {
        if (inDegree[i] === 0) queue.push(i);
    }
    
    let processed = 0;
    while (queue.length > 0) {
        const course = queue.shift();
        processed++;
        
        for (const next of graph.get(course)) {
            inDegree[next]--;
            if (inDegree[next] === 0) queue.push(next);
        }
    }
    
    return processed === numCourses;
}
```

---

## üîÑ Variations

### Finding All Topological Orders

```python
def all_topological_sorts(num_nodes: int, edges: List[List[int]]) -> List[List[int]]:
    """
    Find all valid topological orderings using backtracking.
    Warning: Can be exponentially many!
    """
    graph = defaultdict(list)
    in_degree = [0] * num_nodes
    
    for src, dst in edges:
        graph[src].append(dst)
        in_degree[dst] += 1
    
    result = []
    current = []
    visited = [False] * num_nodes
    
    def backtrack():
        # Check if all nodes are included
        if len(current) == num_nodes:
            result.append(current[:])
            return
        
        # Try each node with in-degree 0
        for node in range(num_nodes):
            if not visited[node] and in_degree[node] == 0:
                # Choose
                visited[node] = True
                current.append(node)
                for neighbor in graph[node]:
                    in_degree[neighbor] -= 1
                
                # Explore
                backtrack()
                
                # Unchoose
                for neighbor in graph[node]:
                    in_degree[neighbor] += 1
                current.pop()
                visited[node] = False
    
    backtrack()
    return result
```

### Parallel Courses (Minimum Semesters)

```python
def minimum_semesters(num_courses: int, relations: List[List[int]]) -> int:
    """
    LC 1136: Minimum number of semesters to take all courses.
    Uses level-by-level BFS.
    """
    graph = defaultdict(list)
    in_degree = [0] * (num_courses + 1)  # 1-indexed
    
    for prev, next_course in relations:
        graph[prev].append(next_course)
        in_degree[next_course] += 1
    
    # Start with all courses having no prerequisites
    queue = deque()
    for course in range(1, num_courses + 1):
        if in_degree[course] == 0:
            queue.append(course)
    
    semesters = 0
    taken = 0
    
    while queue:
        semesters += 1
        # Take all courses available this semester
        for _ in range(len(queue)):
            course = queue.popleft()
            taken += 1
            
            for next_course in graph[course]:
                in_degree[next_course] -= 1
                if in_degree[next_course] == 0:
                    queue.append(next_course)
    
    return semesters if taken == num_courses else -1
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Initializing Graph for All Nodes

```python
# ‚ùå Wrong: Missing nodes without edges
graph = {}
for src, dst in edges:
    if src not in graph:
        graph[src] = []
    graph[src].append(dst)
# What about nodes with no outgoing edges?

# ‚úÖ Correct: Initialize all nodes
graph = defaultdict(list)  # Or:
graph = {i: [] for i in range(num_nodes)}
```

### 2. Wrong Edge Direction for Course Schedule

```python
# ‚ùå Wrong: Edge direction reversed
# prerequisites[i] = [course, prereq]
for course, prereq in prerequisites:
    graph[course].append(prereq)  # Wrong direction!
    in_degree[prereq] += 1

# ‚úÖ Correct: prereq ‚Üí course
for course, prereq in prerequisites:
    graph[prereq].append(course)
    in_degree[course] += 1
```

### 3. Forgetting Cycle Detection

```python
# ‚ùå Wrong: No cycle check
while queue:
    # ...process...
return result  # May be incomplete!

# ‚úÖ Correct: Verify all nodes processed
return result if len(result) == num_nodes else []
```

---

## ‚ö° Complexity Analysis

| Aspect | Complexity | Explanation |
|--------|------------|-------------|
| **Time** | O(V + E) | Calculate in-degrees O(E), process nodes O(V), reduce degrees O(E) |
| **Space** | O(V + E) | Graph storage + in-degree array + queue |

---

## üé§ Interview Tips

<details>
<summary><strong>Communication Template</strong></summary>

**Explain the approach:**
> "I'll use Kahn's algorithm, which is BFS-based. The key insight is that in a DAG, there's always a node with no incoming edges. I start with those, process them, and update the in-degrees of their neighbors."

**Cycle detection:**
> "If I can't process all nodes (queue becomes empty but nodes remain with non-zero in-degree), there's a cycle."

**Trade-offs:**
> "Kahn's is more intuitive than DFS and naturally handles cycle detection. It's also parallelizable - nodes with in-degree 0 can be processed simultaneously."

</details>

---

## üìù Practice Problems

| Problem | Key Concept | Link |
|---------|-------------|------|
| Course Schedule | Basic cycle detection | [LC 207](https://leetcode.com/problems/course-schedule/) |
| Course Schedule II | Return the order | [LC 210](https://leetcode.com/problems/course-schedule-ii/) |
| Parallel Courses | Level-by-level processing | [LC 1136](https://leetcode.com/problems/parallel-courses/) |
| Alien Dictionary | Build graph from comparisons | [LC 269](https://leetcode.com/problems/alien-dictionary/) |

---

> **üí° Key Insight:** Kahn's algorithm is like a simulation: "What can I do now? Do it, then update what's possible next." If you get stuck with nothing to do but work remaining, there's a cycle.

---

**Next:** [Practice: Course Schedule ‚Üí](./6.4-Topo-Practice/01-Course-Schedule-LC207.md)
