# 7.4 Palindrome Linked List (LC 234)

> **Grokking Pattern:** Fast & Slow + In-Place Reversal
>
> **Difficulty:** Easy | **Frequency:** â­â­â­â­â­ Very High

---

## Problem Statement

Given the head of a singly linked list, return `true` if it is a **palindrome** or `false` otherwise.

```
Input:  1 â†’ 2 â†’ 2 â†’ 1
Output: true

Input:  1 â†’ 2 â†’ 3 â†’ 2 â†’ 1
Output: true

Input:  1 â†’ 2
Output: false
```

[LeetCode 234 - Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- Need to compare elements from both ends
- Linked list (can't directly access by index)
- O(1) space constraint

**Keywords:**
- "palindrome", "reads the same backwards"

**This problem combines two patterns:**
1. **Fast & Slow** - Find the middle
2. **In-Place Reversal** - Reverse second half
3. **Two Pointers** - Compare both halves

</details>

---

## âœ… When to Use This Approach

- Checking palindrome in linked list with O(1) space
- Any problem requiring comparison from both ends of a list
- When you can temporarily modify the list

---

## âŒ When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Can't modify list | Reversal changes structure | Stack-based approach |
| Array input | Direct comparison easier | Two pointers on array |
| Need to preserve list | Must restore after | Stack or restore after |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Find Middle](./7.1-Find-Middle.md) - Fast & Slow
- [Reverse Linked List](../05-In-Place-Reversal/5.2-Reversal-Problems/01-Reverse-Entire-List.md)

**After mastering this:**
- Palindrome Linked List with doubly linked list
- Reorder List (LC 143) - Similar techniques

**This combines:**
- Fast & Slow Pointers
- In-Place Reversal
- Two-Pointer Comparison

</details>

---

## ğŸ“ Approaches Overview

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Copy to Array |" O(n) "| O(n) | Simple but extra space |
| Stack (half) |" O(n) "| O(n/2) | Stack for first half |
| **Reverse Half** |" O(n) "| O(1) | **Optimal** |

---

## ğŸ“ How the Optimal Solution Works

### Algorithm Steps

1. **Find the middle** using fast & slow pointers
2. **Reverse the second half** in-place
3. **Compare** first half with reversed second half
4. (Optional) **Restore** the list by reversing again

### Visualization

```
Original: 1 â†’ 2 â†’ 3 â†’ 2 â†’ 1

Step 1: Find middle (using fast/slow)
1 â†’ 2 â†’ 3 â†’ 2 â†’ 1
        â†‘
      middle

Step 2: Reverse second half (3 â†’ 2 â†’ 1 becomes 1 â†’ 2 â†’ 3)
First half:  1 â†’ 2 â†’ (3)
Second half: 1 â†’ 2 â†’ 3 (reversed)

Step 3: Compare
1 == 1 âœ“
2 == 2 âœ“
3 == 3 âœ“ (middle, compare with itself or skip)
Result: true
```

---

## ğŸ’» Code Implementation

### Optimal O(1) Space Solution

**Python:**

```python
def is_palindrome(head: ListNode) -> bool:
    """
    Check if linked list is palindrome using O(1) space.
    
    Pattern: Fast/Slow + Reverse + Compare
    Time: O(n), Space: O(1)
    """
    if not head or not head.next:
        return True
    
    # Step 1: Find middle (slow will be at middle)
    slow = head
    fast = head
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next
    
    # Step 2: Reverse second half
    second_half_head = slow.next  # Save reference for restoration
    second_half = reverse_list(second_half_head)
    
    # Step 3: Compare first and second halves
    first_half = head
    second_half_ptr = second_half  # Save head of reversed for restoration
    result = True
    while second_half:  # Second half is shorter or equal
        if first_half.val != second_half.val:
            result = False
            break
        first_half = first_half.next
        second_half = second_half.next
    
    # Step 4: (Optional) Restore the list
    slow.next = reverse_list(second_half_ptr)
    
    return result


def reverse_list(head: ListNode) -> ListNode:
    """Reverse a linked list in-place."""
    prev = None
    current = head
    while current:
        next_temp = current.next
        current.next = prev
        prev = current
        current = next_temp
    return prev
```

**JavaScript:**

```javascript
function isPalindrome(head) {
    if (!head || !head.next) return true;
    
    // Step 1: Find middle
    let slow = head;
    let fast = head;
    while (fast.next && fast.next.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Step 2: Reverse second half
    let secondHalf = reverseList(slow.next);
    
    // Step 3: Compare
    let firstHalf = head;
    while (secondHalf) {
        if (firstHalf.val !== secondHalf.val) {
            return false;
        }
        firstHalf = firstHalf.next;
        secondHalf = secondHalf.next;
    }
    
    return true;
}

function reverseList(head) {
    let prev = null;
    let current = head;
    while (current) {
        const next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    return prev;
}
```

### Stack-Based Solution (O(n/2) Space)

```python
def is_palindrome_stack(head: ListNode) -> bool:
    """
    Use stack for first half, compare with second half.
    Time: O(n), Space: O(n/2)
    """
    if not head or not head.next:
        return True
    
    # Find middle and push first half to stack
    slow = head
    fast = head
    stack = []
    
    while fast and fast.next:
        stack.append(slow.val)
        slow = slow.next
        fast = fast.next.next
    
    # If odd length, skip middle element
    if fast:  # fast is not None means odd length
        slow = slow.next
    
    # Compare second half with stack
    while slow:
        if slow.val != stack.pop():
            return False
        slow = slow.next
    
    return True
```

---

## âš¡ Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Copy to Array |" O(n) "| O(n) | Full list copy |
| Stack |" O(n) "| O(n/2) | Half list in stack |
| Reverse Half |" O(n) "| O(1) | In-place modification |

**Why O(n) time for optimal:**
- Find middle: O(n/2)
- Reverse half: O(n/2)
- Compare: O(n/2)
- Total: O(n)

---

## ğŸ”„ Variations

| Variation | Difference | Approach |
|-----------|------------|----------|
| Must preserve list | Restore after | Reverse again at end |
| Doubly linked list | Easier | Compare from both ends directly |
| Array input | Much easier | Two pointers |
| Ignore non-alphanumeric | String problem | Filter + compare |

---

## âš ï¸ Common Mistakes

### 1. Wrong Middle for Even vs Odd Length

```python
# For palindrome, we want first middle for even length
# List: 1 â†’ 2 â†’ 2 â†’ 1 (length 4)
# We want slow at second '2' (index 1)

# This condition gives us first middle:
while fast.next and fast.next.next:  # âœ“ First middle
    ...

# This gives second middle (wrong for this problem):
while fast and fast.next:  # âœ— Second middle
    ...
```

### 2. Forgetting to Handle Odd Length

```python
# Odd: 1 â†’ 2 â†’ 3 â†’ 2 â†’ 1
# After finding middle, slow is at 3
# We reverse from slow.next (2 â†’ 1 becomes 1 â†’ 2)
# Compare: 1 vs 1, 2 vs 2 âœ“
# The middle element (3) doesn't need comparison!

# The code handles this automatically because:
# - Second half has fewer elements
# - We compare only while second_half is not None
```

### 3. Not Reversing from Correct Point

```python
# âŒ Wrong - reversing from slow
second_half = reverse_list(slow)  # Includes middle in reversal

# âœ… Correct - reverse from slow.next
second_half = reverse_list(slow.next)  # Excludes middle
```

---

## ğŸ“ Practice Problems (Progressive)

### Easy (This problem)
- [ ] [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/) - LC 234 â­

### Related
- [ ] [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) - LC 206
- [ ] [Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) - LC 876
- [ ] [Reorder List](https://leetcode.com/problems/reorder-list/) - LC 143 (similar technique)

### String Variant
- [ ] [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/) - LC 125

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement full solution with all 3 steps
- **Day 3:** Practice finding correct middle for palindrome
- **Day 7:** Solve without reference
- **Day 14:** Add restoration step
- **Day 30:** Apply similar technique to Reorder List

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
> "I'll solve this in O(1) space by: finding the middle, reversing the second half, then comparing both halves."

**Explain each step:**
> "First, I'll use fast and slow pointers to find the middle. Then I'll reverse the second half in-place. Finally, I'll compare nodes from both halves."

**Mention restoration:**
> "If needed, I can restore the list by reversing the second half again."

**Common follow-ups:**
- "Can you do it without modifying?" â†’ Yes, with stack (O(n/2) space)
- "What about restoring the list?" â†’ Reverse second half again
- "Why this middle finding method?" â†’ Need first middle for correct split

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | â­â­â­â­â­ | Very common |
| Meta | â­â­â­â­ |" O(1) space expected "|
| Google | â­â­â­â­ | May ask about restoration |
| Microsoft | â­â­â­â­ | Classic question |

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand | 3-5 min | Three-step approach |
| Implement | 10-15 min | Combine three techniques |
| Handle edge cases | 3-5 min | Single node, two nodes |
| Interview target | 15-20 min | Including explanation |

---

> **ğŸ’¡ Key Insight:** This problem elegantly combines three patterns: Fast & Slow (find middle), In-Place Reversal (reverse half), and Two Pointers (compare). Recognizing that you need to combine multiple patterns is a key interview skill.

---

## ğŸ”— Related

- [Find Middle](./7.1-Find-Middle.md) - Step 1 of this solution
- [Reverse Linked List](../05-In-Place-Reversal/5.2-Reversal-Problems/01-Reverse-Entire-List.md) - Step 2
- [Reorder List](https://leetcode.com/problems/reorder-list/) - LC 143, similar technique
