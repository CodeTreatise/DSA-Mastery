# 6.1 Monotonic Deque Concept

> **Grokking Pattern:** #32 Monotonic Queue
>
> **Interview Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê High | **Difficulty:** Medium-Hard

---

## Definition

A **Monotonic Deque** (or Monotonic Queue) is a deque (double-ended queue) that maintains elements in either strictly increasing or strictly decreasing order. It efficiently tracks the maximum or minimum value in a sliding window.

The key insight: as the window slides, we need O(1) access to the current max/min, but elements may need to be removed from both ends:
- **Front:** Remove elements that fall outside the window
- **Back:** Remove elements that will never be the answer

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Sliding window" + "maximum/minimum"
- Finding max/min in each window of size k
- Need O(1) access to extrema as window moves
- Window "pushes out" old elements from front

**Keywords in problem statement:**
- "sliding window", "subarray of size k"
- "maximum in window", "minimum in window"
- "contiguous subarray", "k elements"

**Why not just Monotonic Stack?**
- Stack only allows removal from one end
- Sliding window needs removal from both ends
- Deque = Double-Ended Queue = O(1) operations at both ends

</details>

---

## ‚úÖ When to Use

- Finding max/min in sliding windows of size k
- Range maximum/minimum queries
- Problems requiring O(1) extrema access with element expiration

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Fixed array, no sliding | No expiration needed | Monotonic Stack |
| Need both max AND min | Maintain two deques | Dual deque |
| Need median or arbitrary statistics | Deque tracks extrema only | Two heaps / Sorted container |
| Non-contiguous elements | Deque tracks indices | Different structure |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Deque Basics](../05-Queue-Fundamentals/5.3-Deque.md)
- [Sliding Window Pattern](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/02-Sliding-Window.md)
- [Monotonic Stack Concept](../03-Monotonic-Stack/3.1-Monotonic-Stack-Concept.md)

**After mastering this:**
- [Sliding Window Maximum](./6.2-Sliding-Window-Maximum.md) - LC 239
- [Jump Game VI](https://leetcode.com/problems/jump-game-vi/) - LC 1696
- [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/) - LC 862

**Related patterns:**
- Monotonic Stack (one-directional removal)
- Segment Tree / RMQ (range queries, but O(log n))
- Sparse Table (static range queries)

</details>

---

## üìê How It Works

### Core Concept

The deque stores **indices** (not values) and maintains:
1. **Monotonic order:** Values at indices are decreasing (for max) or increasing (for min)
2. **Window validity:** All indices are within the current window

### Visual Walkthrough: Maximum in Sliding Window

```
Array: [1, 3, -1, -3, 5, 3, 6, 7]  Window size k = 3

We maintain a DECREASING deque (for maximum)

i=0: val=1
     Deque: []
     Push index 0
     Deque: [0]  ‚Üí values: [1]
     Window not complete yet

i=1: val=3
     3 > arr[0]=1, pop 0
     Deque: []
     Push 1
     Deque: [1]  ‚Üí values: [3]
     Window not complete yet

i=2: val=-1
     -1 < arr[1]=3, no pop
     Push 2
     Deque: [1, 2]  ‚Üí values: [3, -1]
     Window [0,2] complete! Max = arr[Deque[0]] = arr[1] = 3

i=3: val=-3
     -3 < arr[2]=-1, no pop
     Push 3
     Deque: [1, 2, 3]  ‚Üí values: [3, -1, -3]
     Check front: 1 >= 3-3+1 = 1, still valid
     Window [1,3] Max = arr[1] = 3

i=4: val=5
     5 > arr[3]=-3, pop 3
     5 > arr[2]=-1, pop 2
     5 > arr[1]=3, pop 1
     Deque: []
     Push 4
     Deque: [4]  ‚Üí values: [5]
     Window [2,4] Max = 5

i=5: val=3
     3 < arr[4]=5, no pop
     Push 5
     Deque: [4, 5]  ‚Üí values: [5, 3]
     Check front: 4 >= 5-3+1 = 3, still valid
     Window [3,5] Max = 5

i=6: val=6
     6 > arr[5]=3, pop 5
     6 > arr[4]=5, pop 4
     Deque: []
     Push 6
     Deque: [6]  ‚Üí values: [6]
     Window [4,6] Max = 6

i=7: val=7
     7 > arr[6]=6, pop 6
     Deque: []
     Push 7
     Deque: [7]  ‚Üí values: [7]
     Window [5,7] Max = 7

Result: [3, 3, 5, 5, 6, 7]
```

### Why Store Indices?

1. **Window expiration:** Need to check if front element is still in window
2. **Value lookup:** Can get value from arr[index]
3. **Range tracking:** Know exact position of elements

---

## üíª Code Templates

### Template: Monotonic Deque (for Maximum)

**Python:**
```python
from collections import deque
from typing import List

def sliding_window_maximum(nums: List[int], k: int) -> List[int]:
    """
    Find maximum in each sliding window of size k.
    
    Pattern: Monotonic Deque (decreasing)
    Time: O(n), Space: O(k)
    
    Deque invariant: indices with values in decreasing order
    """
    result = []
    dq = deque()  # stores indices
    
    for i, val in enumerate(nums):
        # Step 1: Remove expired elements from front
        # (indices outside current window)
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Step 2: Remove smaller elements from back
        # (they'll never be the maximum)
        while dq and nums[dq[-1]] < val:
            dq.pop()
        
        # Step 3: Add current index
        dq.append(i)
        
        # Step 4: Record result when window is complete
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result


def sliding_window_minimum(nums: List[int], k: int) -> List[int]:
    """
    Find minimum in each sliding window of size k.
    
    Pattern: Monotonic Deque (increasing)
    Time: O(n), Space: O(k)
    """
    result = []
    dq = deque()  # stores indices
    
    for i, val in enumerate(nums):
        # Step 1: Remove expired elements from front
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Step 2: Remove larger elements from back
        # (they'll never be the minimum)
        while dq and nums[dq[-1]] > val:  # Changed < to >
            dq.pop()
        
        # Step 3: Add current index
        dq.append(i)
        
        # Step 4: Record result
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result
```

**JavaScript:**
```javascript
/**
 * Sliding window maximum using monotonic deque.
 * Pattern: Monotonic Deque (decreasing)
 * Time: O(n), Space: O(k)
 */
function slidingWindowMaximum(nums, k) {
    const result = [];
    const deque = []; // stores indices
    
    for (let i = 0; i < nums.length; i++) {
        // Remove expired elements from front
        if (deque.length > 0 && deque[0] < i - k + 1) {
            deque.shift();
        }
        
        // Remove smaller elements from back
        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop();
        }
        
        // Add current index
        deque.push(i);
        
        // Record result when window complete
        if (i >= k - 1) {
            result.push(nums[deque[0]]);
        }
    }
    
    return result;
}

/**
 * Sliding window minimum using monotonic deque.
 * Pattern: Monotonic Deque (increasing)
 */
function slidingWindowMinimum(nums, k) {
    const result = [];
    const deque = []; // stores indices
    
    for (let i = 0; i < nums.length; i++) {
        // Remove expired elements from front
        if (deque.length > 0 && deque[0] < i - k + 1) {
            deque.shift();
        }
        
        // Remove larger elements from back (for minimum)
        while (deque.length > 0 && nums[deque[deque.length - 1]] > nums[i]) {
            deque.pop();
        }
        
        deque.push(i);
        
        if (i >= k - 1) {
            result.push(nums[deque[0]]);
        }
    }
    
    return result;
}
```

---

## Comparison: Monotonic Stack vs Monotonic Deque

| Feature | Monotonic Stack | Monotonic Deque |
|---------|-----------------|-----------------|
| **Remove from** | Back only (pop) | Both ends |
| **Element expiration** | No | Yes (window boundary) |
| **Use case** | Next Greater/Smaller | Sliding window max/min |
| **Complexity** |" O(n) time, O(n) space "| O(n) time, O(k) space |
| **Data structure** | List/Stack | collections.deque / array |

---

## ‚ö° Complexity Analysis

| Operation | Time | Notes |
|-----------|------|-------|
| Add element |" Amortized O(1) "| Each element added once |
| Remove from front |" O(1) "| Deque front removal |
| Remove from back |" Amortized O(1) "| Each element removed once |
| Query max/min |" O(1) "| Front of deque |
| Overall |" O(n) "| Each element pushed/popped once |

**Space:** O(k) where k is window size

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| Minimum instead of Maximum | Maintain increasing order | Sliding Window Minimum |
| Variable window size | Different expiration logic | Shortest Subarray with Sum ‚â• K |
| With additional constraint | Combine with other conditions | Constrained Subsequence Sum |
| Maximum of minimums | Two passes or nested deques | Min-Max Problem |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Storing Values Instead of Indices

```python
# ‚ùå WRONG: Storing values, can't check expiration
dq.append(val)

# ‚úÖ CORRECT: Store indices, lookup values
dq.append(i)
if dq[0] < i - k + 1:  # Can check window bounds
    dq.popleft()
```

### 2. Wrong Removal Order

```python
# ‚ùå WRONG: Removing from wrong end
dq.popleft()  # For monotonic removal

# ‚úÖ CORRECT: Remove from back for monotonic, front for expiration
while dq and nums[dq[-1]] < val:
    dq.pop()  # Back - smaller elements
if dq and dq[0] < i - k + 1:
    dq.popleft()  # Front - expired elements
```

### 3. Off-by-One in Window Check

```python
# ‚ùå WRONG: Incorrect window boundary
if dq[0] <= i - k:  # Wrong boundary
    dq.popleft()

# ‚úÖ CORRECT: Element at index i-k+1 is the first valid
if dq[0] < i - k + 1:  # Index must be >= left boundary
    dq.popleft()
```

### 4. Wrong Comparison for Min vs Max

```python
# For MAXIMUM (decreasing deque):
while dq and nums[dq[-1]] < val:  # Remove smaller
    dq.pop()

# For MINIMUM (increasing deque):
while dq and nums[dq[-1]] > val:  # Remove larger
    dq.pop()
```

---

## üìù Practice Problems (Progressive)

### Core Problems
- [ ] [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) - LC 239 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

### Applications
- [ ] [Jump Game VI](https://leetcode.com/problems/jump-game-vi/) - LC 1696
- [ ] [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/) - LC 1425
- [ ] [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/) - LC 862

### Related
- [ ] [Max Value of Equation](https://leetcode.com/problems/max-value-of-equation/) - LC 1499

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement Sliding Window Maximum
**Day 3:** Implement Sliding Window Minimum (just flip comparison)
**Day 7:** Solve Jump Game VI
**Day 14:** Tackle Shortest Subarray with Sum at Least K
**Day 21:** Revisit all problems without notes

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
> "For sliding window maximum, I need O(1) access to the current max, but elements expire as the window moves. A monotonic deque handles both - it maintains elements in decreasing order and allows removal from both ends."

**Explain the two-end removals:**
> "From the front, I remove expired elements outside the window. From the back, I remove smaller elements that can never be the maximum while larger elements exist."

**Why not a heap?**
> "A heap gives O(log k) per operation, but the deque gives amortized O(1) because each element is added and removed at most once."

**Handle minimum variant:**
> "For minimum, I just flip the comparison - maintain increasing order instead of decreasing."

</details>

**Company Focus:**

| Company | Frequency | Focus |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | LC 239 very common |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Sliding window problems |
| Microsoft | ‚≠ê‚≠ê‚≠ê | May ask variations |
| Meta | ‚≠ê‚≠ê‚≠ê | Tests data structure choice |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 20-30 min | First exposure |
| Implement LC 239 | 20-25 min | Interview target |
| Debug edge cases | 10-15 min | Window bounds, empty deque |
| Master pattern | 3-5 hours | Multiple problems |

---

> **üí° Key Insight:** The monotonic deque is essentially a "priority queue with expiration." It maintains the potential maximum/minimum candidates in sorted order, and automatically discards elements that either fall outside the window (from front) or will never be the answer (from back). Each element is added once and removed once, giving O(n) total time.

---

## üîó Related

- [Monotonic Stack Concept](../03-Monotonic-Stack/3.1-Monotonic-Stack-Concept.md) - One-directional variant
- [Sliding Window Technique](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/02-Sliding-Window.md) - Pattern foundation
- [Deque Basics](../05-Queue-Fundamentals/5.3-Deque.md) - Data structure fundamentals
