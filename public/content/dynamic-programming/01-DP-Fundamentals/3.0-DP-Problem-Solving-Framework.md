# 3.0 DP Problem-Solving Framework

> **The 5-Step DP Framework** is a systematic approach to solve any dynamic programming problem. Master this framework and you can tackle any DP problem in interviews.

---

## üéØ The 5-Step Framework

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Step 1: DEFINE THE STATE                                   ‚îÇ
‚îÇ  ‚Üí What variables uniquely identify a subproblem?           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Step 2: WRITE THE RECURRENCE                               ‚îÇ
‚îÇ  ‚Üí How does the answer relate to smaller subproblems?       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Step 3: IDENTIFY BASE CASES                                ‚îÇ
‚îÇ  ‚Üí What are the smallest subproblems with known answers?    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Step 4: DETERMINE COMPUTATION ORDER                        ‚îÇ
‚îÇ  ‚Üí Top-down (memo) or Bottom-up (tabulation)?               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Step 5: OPTIMIZE (if needed)                               ‚îÇ
‚îÇ  ‚Üí Can we reduce space? Time?                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìê Step-by-Step Deep Dive

### Step 1: Define the State

**The state is what you're asking at each subproblem.**

**Questions to ask:**
- What changes as we move through the problem?
- What information do we need to make a decision?
- What parameters define the "current situation"?

**Common State Patterns:**

| Problem Type | State | Meaning |
|-------------|-------|---------|
| Linear array | `dp[i]` | Answer considering elements 0...i |
| Two sequences | `dp[i][j]` | Answer for first i chars of s1, first j chars of s2 |
| Grid | `dp[i][j]` | Answer at cell (i, j) |
| Knapsack | `dp[i][w]` | Answer using items 0...i with capacity w |
| Interval | `dp[i][j]` | Answer for subarray i...j |

**Example: House Robber**
```
Problem: Rob houses, can't rob adjacent houses, maximize profit

State: dp[i] = maximum money robbing houses 0...i

Why this state?
- "i" tells us which houses we've considered
- The answer for houses 0...i depends on answers for 0...(i-1) and 0...(i-2)
```

---

### Step 2: Write the Recurrence

**The recurrence expresses the answer in terms of smaller problems.**

**Template:**
```
dp[current_state] = combine(
    dp[subproblem_1],
    dp[subproblem_2],
    ...
)
```

**Common Recurrence Patterns:**

| Pattern | Recurrence | Example |
|---------|------------|---------|
| Linear choice | `dp[i] = max(dp[i-1], dp[i-2] + val[i])` | House Robber |
| Grid paths | `dp[i][j] = dp[i-1][j] + dp[i][j-1]` | Unique Paths |
| Matching | `dp[i][j] = dp[i-1][j-1] + 1` if match | LCS |
| Optimization | `dp[i] = min(dp[j] + cost)` for valid j | Coin Change |
| Interval | `dp[i][j] = max(dp[i][k] + dp[k][j])` for k in range | Matrix Chain |

**Example: House Robber**
```
Recurrence: dp[i] = max(
    dp[i-1],           # Skip house i
    dp[i-2] + nums[i]  # Rob house i (can't use i-1)
)

Why?
- If we skip house i: best we can do is dp[i-1]
- If we rob house i: we get nums[i] + best without house i-1, which is dp[i-2]
```

---

### Step 3: Identify Base Cases

**Base cases are the smallest subproblems with known answers.**

**Questions:**
- What's the answer when input is empty?
- What's the answer for size 0 or 1?
- What can't be broken down further?

**Common Base Cases:**

| Problem Type | Base Case | Value |
|-------------|-----------|-------|
| Empty | `dp[0] = 0` | Often 0 |
| Single element | `dp[0] = arr[0]` | First element |
| Two sequences | `dp[0][j] = 0`, `dp[i][0] = 0` | Empty string |
| Grid first row/col | `dp[0][j] = 1`, `dp[i][0] = 1` | Only one path |
| Impossible state | `dp[i] = inf` or `-inf` | Signal invalid |

**Example: House Robber**
```
Base cases:
- dp[0] = nums[0]        # Only house 0, must rob it
- dp[1] = max(nums[0], nums[1])  # Two houses, pick better one

Why?
- With 0 houses: no problem (handle separately)
- With 1 house: rob it
- With 2 houses: rob the more valuable one
```

---

### Step 4: Determine Computation Order

**Choose between top-down (memoization) and bottom-up (tabulation).**

**Decision Guide:**

| Factor | Memoization | Tabulation |
|--------|-------------|------------|
| Speed to implement | Faster (just add cache) | Slower (derive iteration) |
| Stack overflow risk | Yes (deep recursion) | No (iterative) |
| Space optimization | Harder | Easier |
| When all subproblems needed | Less efficient | More efficient |
| Sparse subproblems | More efficient | Wastes computation |

**Iteration Order for Tabulation:**

Look at your recurrence to determine order:
```
If dp[i] depends on dp[i-1], dp[i-2]:
   ‚Üí Iterate i from small to large (0, 1, 2, ...)

If dp[i][j] depends on dp[i-1][j], dp[i][j-1]:
   ‚Üí Iterate i from 0 to m, j from 0 to n

If dp[i] depends on dp[i+1]:
   ‚Üí Iterate i from large to small (n-1, n-2, ...)
```

**Example: House Robber**
```
Recurrence: dp[i] = max(dp[i-1], dp[i-2] + nums[i])

Dependencies: dp[i] needs dp[i-1] and dp[i-2]
‚Üí Iterate from 2 to n (small to large)

Order: dp[0] ‚Üí dp[1] ‚Üí dp[2] ‚Üí ... ‚Üí dp[n-1]
```

---

### Step 5: Optimize (If Needed)

**After solving, look for optimization opportunities.**

**Space Optimization:**
```
If dp[i] only uses dp[i-1], dp[i-2]:
   ‚Üí Use two variables instead of array

If dp[i][j] only uses previous row:
   ‚Üí Use single row (or two rows)
```

**Time Optimization:**
```
If finding minimum over a range:
   ‚Üí Consider monotonic data structures

If LIS pattern:
   ‚Üí O(n¬≤) ‚Üí O(n log n) with binary search
```

**Example: House Robber**
```
Original: dp = [0] * n, O(n) space
Observation: dp[i] only uses dp[i-1] and dp[i-2]
Optimized: Two variables, O(1) space

def rob(nums):
    prev2, prev1 = 0, 0
    for num in nums:
        curr = max(prev1, prev2 + num)
        prev2, prev1 = prev1, curr
    return prev1
```

---

## üíª Complete Example: House Robber

### Problem Statement
```
Given an array of non-negative integers representing the amount of money 
in each house, determine the maximum amount you can rob tonight without 
alerting the police (can't rob two adjacent houses).
```

### Applying the 5-Step Framework

```python
def rob(nums: list[int]) -> int:
    """
    STEP 1: State
    dp[i] = max money robbing from houses 0 to i
    
    STEP 2: Recurrence
    dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    - Skip house i: dp[i-1]
    - Rob house i: dp[i-2] + nums[i]
    
    STEP 3: Base Cases
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    
    STEP 4: Order
    Left to right (dp[i] depends on dp[i-1], dp[i-2])
    
    STEP 5: Optimization
    Only need prev two values ‚Üí O(1) space
    """
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    # Optimized: O(1) space
    prev2 = nums[0]
    prev1 = max(nums[0], nums[1])
    
    for i in range(2, len(nums)):
        curr = max(prev1, prev2 + nums[i])
        prev2 = prev1
        prev1 = curr
    
    return prev1

# Test
print(rob([2, 7, 9, 3, 1]))  # 12 (2 + 9 + 1)
print(rob([1, 2, 3, 1]))     # 4 (1 + 3)
```

---

## üíª Complete Example: Longest Common Subsequence

### Problem Statement
```
Given two strings text1 and text2, return the length of their longest 
common subsequence. A subsequence maintains relative order but doesn't 
need to be contiguous.
```

### Applying the 5-Step Framework

```python
def longest_common_subsequence(text1: str, text2: str) -> int:
    """
    STEP 1: State
    dp[i][j] = LCS length of text1[0:i] and text2[0:j]
    
    STEP 2: Recurrence
    If text1[i-1] == text2[j-1]:
        dp[i][j] = dp[i-1][j-1] + 1  (match, extend LCS)
    Else:
        dp[i][j] = max(dp[i-1][j], dp[i][j-1])  (skip one char)
    
    STEP 3: Base Cases
    dp[0][j] = 0 (empty text1)
    dp[i][0] = 0 (empty text2)
    
    STEP 4: Order
    Left to right, top to bottom (i from 1 to m, j from 1 to n)
    
    STEP 5: Optimization
    Can reduce to O(min(m,n)) using single row
    """
    m, n = len(text1), len(text2)
    
    # Full 2D solution (for clarity)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

# Test
print(longest_common_subsequence("abcde", "ace"))  # 3 ("ace")
print(longest_common_subsequence("abc", "def"))    # 0
```

---

## üîÑ Framework Applied to Common Patterns

### Pattern: Fibonacci-like (1D Linear)

```
State:     dp[i] = answer at position i
Recurrence: dp[i] = f(dp[i-1], dp[i-2], ...)
Base:      dp[0], dp[1] = known values
Order:     i from 0 to n
Optimize:  O(1) space with rolling variables

Examples: Fibonacci, Climbing Stairs, House Robber
```

### Pattern: Grid DP (2D Paths)

```
State:     dp[i][j] = answer at cell (i, j)
Recurrence: dp[i][j] = f(dp[i-1][j], dp[i][j-1], grid[i][j])
Base:      First row and column
Order:     i from 0 to m, j from 0 to n
Optimize:  O(n) space with single row

Examples: Unique Paths, Minimum Path Sum
```

### Pattern: Two Sequences (LCS/Edit Distance)

```
State:     dp[i][j] = answer for first i of seq1, first j of seq2
Recurrence: Compare seq1[i-1] and seq2[j-1], decide action
Base:      dp[0][j] = dp[i][0] = 0 (or initial values)
Order:     i from 1 to m, j from 1 to n
Optimize:  O(min(m,n)) with single row + diagonal variable

Examples: LCS, Edit Distance, Distinct Subsequences
```

### Pattern: Knapsack (Item Selection)

```
State:     dp[i][w] = answer using items 0..i with capacity w
Recurrence: dp[i][w] = max(skip item, take item if fits)
Base:      dp[0][w] = 0 (no items)
Order:     Items outer, capacity inner
Optimize:  O(W) space, backwards iteration for 0/1

Examples: 0/1 Knapsack, Subset Sum, Coin Change
```

### Pattern: Interval DP (Subarray/Substring)

```
State:     dp[i][j] = answer for subarray/substring i..j
Recurrence: dp[i][j] = f(dp[i][k], dp[k][j]) for k in range
Base:      dp[i][i] = base value (single element)
Order:     By length: len from 1 to n, then i from 0
Optimize:  Usually can't reduce easily

Examples: Matrix Chain Multiplication, Burst Balloons
```

---

## ‚ö†Ô∏è Common Mistakes in Each Step

### Step 1 Mistakes: Wrong State

**‚ùå Too little information:**
```
Problem: Edit distance between strings
Wrong state: dp[i] = distance after i operations
(Can't tell which chars are processed)
```

**‚úÖ Correct state:**
```
dp[i][j] = distance for text1[0:i] and text2[0:j]
```

### Step 2 Mistakes: Wrong Recurrence

**‚ùå Missing cases:**
```
LCS: dp[i][j] = dp[i-1][j-1] + 1 if match
(Forgot the else case!)
```

**‚úÖ Complete:**
```
if match: dp[i][j] = dp[i-1][j-1] + 1
else:     dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

### Step 3 Mistakes: Wrong Base Cases

**‚ùå Uninitialized:**
```
dp[0] = 0  # But what if dp[1] = dp[0] + dp[-1]?
```

**‚úÖ Handle all edges:**
```
dp[0] = base_0
dp[1] = base_1
# Or handle in the loop with bounds checking
```

### Step 4 Mistakes: Wrong Order

**‚ùå Forward when backward needed:**
```
# 0/1 Knapsack with forward iteration
for w in range(weight, capacity + 1):  # WRONG
    dp[w] = max(dp[w], dp[w - weight] + value)
# Same item used multiple times!
```

**‚úÖ Backward for 0/1:**
```
for w in range(capacity, weight - 1, -1):  # CORRECT
    dp[w] = max(dp[w], dp[w - weight] + value)
```

---

## üìù Framework Worksheet

Use this template for every DP problem:

```
PROBLEM: [Name]

STEP 1: State
What does dp[...] represent?
dp[____] = ________________________________

STEP 2: Recurrence
How does dp[i] relate to smaller subproblems?
dp[____] = ________________________________

STEP 3: Base Cases
What are the smallest known answers?
dp[____] = ____
dp[____] = ____

STEP 4: Order
What's the iteration order?
for ____ in range(____):
    for ____ in range(____):

STEP 5: Optimization
What space reduction is possible?
Original: O(____) ‚Üí Optimized: O(____)
```

---

## üìù Practice Problems (By Framework Pattern)

**Linear (Fibonacci-like):**
- [ ] [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)
- [ ] [House Robber](https://leetcode.com/problems/house-robber/)
- [ ] [Decode Ways](https://leetcode.com/problems/decode-ways/)

**Grid DP:**
- [ ] [Unique Paths](https://leetcode.com/problems/unique-paths/)
- [ ] [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)
- [ ] [Triangle](https://leetcode.com/problems/triangle/)

**Two Sequences:**
- [ ] [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)
- [ ] [Edit Distance](https://leetcode.com/problems/edit-distance/)

**Knapsack:**
- [ ] [Coin Change](https://leetcode.com/problems/coin-change/)
- [ ] [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)

---

## üé§ Interview Context

<details>
<summary><strong>How to Present the Framework</strong></summary>

**Say this to your interviewer:**

> "Let me work through this systematically. First, I'll define what state I need to track. Then I'll figure out the recurrence relation. After that, I'll identify base cases and the iteration order."

**Step through out loud:**
1. "The state I need is... because..."
2. "The recurrence is... because at each step we can..."
3. "Base cases are... because..."
4. "I'll iterate from... to..."
5. "For optimization, I notice we only need... so we can reduce to..."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Learn framework | 30-45 min |
| Apply to simple problem | 15-20 min |
| Apply to medium problem | 25-35 min |
| Master framework | 10-15 problems |

---

> **üí° Key Insight:** The 5-step framework isn't about memorizing‚Äîit's about building a systematic approach. Every DP problem, no matter how complex, can be broken down using these steps. Trust the process.

> **üîó Related:** [What Is DP](./1.1-What-Is-DP.md) | [Memoization](./2.1-Top-Down-Memoization.md) | [Tabulation](./2.2-Bottom-Up-Tabulation.md) | [Space Optimization](./2.3-Space-Optimization.md)
