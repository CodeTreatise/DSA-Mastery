# 4.1 Top K Elements Pattern Overview

## Introduction

The **Top K Elements** pattern is one of the highest-ROI patterns for coding interviews, covering approximately **8% of all interview problems**. This pattern uses a heap to efficiently find the K largest, smallest, most frequent, or closest elements from a collection.

> üí° **Core Insight:** Instead of sorting the entire array O(n log n), use a heap of size K to achieve O(n log k) time complexity.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Top K Problems</strong></summary>

**Look for these signals:**
- "Find K largest/smallest elements"
- "Find Kth largest/smallest element"
- "K most frequent elements"
- "K closest points/elements"
- "Top K" anything

**Keywords in problem statement:**
- "k largest", "k smallest", "kth element"
- "top k", "k most frequent"
- "k closest", "k nearest"
- "k highest", "k lowest"

**Pattern variations:**
| Variant | Heap Type | Why |
|---------|-----------|-----|
| K largest | Min-heap size K | Root is Kth largest |
| K smallest | Max-heap size K | Root is Kth smallest |
| Kth largest | Min-heap size K | Root = answer |
| Kth smallest | Max-heap size K | Root = answer |

</details>

---

## ‚úÖ When to Use

- Finding top/bottom K elements from unsorted data
- Kth largest/smallest element problems
- K most frequent elements
- K closest points to a target
- Streaming data where you need running top K
- When K << n (heap is more efficient than full sort)

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Need all elements sorted | Heap gives only K |" Full sort O(n log n) "|
| K ‚âà n | Heap loses advantage | Just sort |
| Single min/max | Overkill |" Linear scan O(n) "|
| Need quick random access | Heap doesn't support | Array + sort |
| Exact median only | Specialized pattern | Two Heaps |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Heap Fundamentals](../01-Heap-Fundamentals/1.1-What-Is-Heap.md)
- [Heap Operations](../02-Heap-Operations/2.1-Insert.md)
- [Priority Queue Implementation](../03-Priority-Queue/3.2-PQ-Implementation.md)

**After mastering this:**
- [Two Heaps Pattern](../05-Two-Heaps-Pattern/5.1-Two-Heaps-Overview.md)
- [K-Way Merge Pattern](../06-K-Way-Merge-Pattern/6.1-K-Way-Merge-Overview.md)

**Combines with:**
- Frequency counting (Top K Frequent)
- Distance calculation (K Closest Points)
- Streaming data (Kth Largest in Stream)

</details>

---

## üìê How It Works

### The Core Trick: Use the OPPOSITE Heap

```
‚ùå WRONG Intuition:
   "For K LARGEST, use MAX-heap of size K"
   
‚úÖ CORRECT Approach:
   "For K LARGEST, use MIN-heap of size K"

Why? The min-heap of size K keeps the K largest elements.
     Its ROOT is the SMALLEST of those K largest = Kth largest!
```

### Visualization

```
Find 3 largest from [5, 2, 9, 1, 7, 6, 8]:

Min-heap of size K=3:

Step 1: Add 5      [5]
Step 2: Add 2      [2, 5]
Step 3: Add 9      [2, 5, 9]     (size = K, heap full)
Step 4: Add 1      1 < root(2), skip
Step 5: Add 7      7 > root(2), replace: [5, 7, 9]
Step 6: Add 6      6 > root(5), replace: [6, 7, 9]
Step 7: Add 8      8 > root(6), replace: [7, 8, 9]

Final heap: [7, 8, 9] ‚Üê The 3 largest elements!
Root (7) = 3rd largest = Kth largest ‚úì
```

### Why Min-Heap for K Largest?

```
Min-heap of size K acts as a "bouncer":
- Only lets in elements larger than the smallest VIP
- Root is always the "weakest" of the K VIPs
- New element must beat the root to get in

        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   TOP K CLUB (Min-Heap)     ‚îÇ
        ‚îÇ   Capacity: K               ‚îÇ
        ‚îÇ                             ‚îÇ
  7 ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫   [5, 8, 9]                 ‚îÇ
        ‚îÇ    ‚Üë                        ‚îÇ
        ‚îÇ   Root = bouncer threshold  ‚îÇ
        ‚îÇ   7 > 5? YES, come in!      ‚îÇ
        ‚îÇ   Kick out 5                ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üíª Code Template

### Template 1: K Largest Elements

**Python:**
```python
import heapq

def k_largest(nums: list[int], k: int) -> list[int]:
    """
    Find K largest elements using min-heap of size K.
    
    Time: O(n log k) - n elements, each heap op is O(log k)
    Space: O(k) - heap size
    
    Pattern: Min-heap keeps K largest, root is Kth largest
    """
    if k <= 0:
        return []
    if k >= len(nums):
        return nums[:]
    
    # Build min-heap of first K elements
    min_heap = nums[:k]
    heapq.heapify(min_heap)  # O(k)
    
    # Process remaining elements
    for num in nums[k:]:
        if num > min_heap[0]:  # Larger than smallest in heap
            heapq.heapreplace(min_heap, num)  # O(log k)
    
    return min_heap  # K largest elements (unsorted)
```

**JavaScript:**
```javascript
function kLargest(nums, k) {
    // JavaScript: Use MinHeap class or sort-based approach
    // For interviews, often implement a simple MinHeap
    
    class MinHeap {
        constructor() { this.heap = []; }
        
        size() { return this.heap.length; }
        peek() { return this.heap[0]; }
        
        push(val) {
            this.heap.push(val);
            this._bubbleUp(this.heap.length - 1);
        }
        
        pop() {
            if (this.size() === 0) return undefined;
            const min = this.heap[0];
            const last = this.heap.pop();
            if (this.size() > 0) {
                this.heap[0] = last;
                this._bubbleDown(0);
            }
            return min;
        }
        
        _bubbleUp(i) {
            while (i > 0) {
                const parent = Math.floor((i - 1) / 2);
                if (this.heap[parent] <= this.heap[i]) break;
                [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
                i = parent;
            }
        }
        
        _bubbleDown(i) {
            const n = this.size();
            while (true) {
                let smallest = i;
                const left = 2 * i + 1, right = 2 * i + 2;
                if (left < n && this.heap[left] < this.heap[smallest]) smallest = left;
                if (right < n && this.heap[right] < this.heap[smallest]) smallest = right;
                if (smallest === i) break;
                [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
                i = smallest;
            }
        }
    }
    
    const minHeap = new MinHeap();
    
    for (const num of nums) {
        minHeap.push(num);
        if (minHeap.size() > k) {
            minHeap.pop();  // Remove smallest, keep K largest
        }
    }
    
    return minHeap.heap;  // K largest elements
}
```

### Template 2: Kth Largest Element

**Python:**
```python
import heapq

def kth_largest(nums: list[int], k: int) -> int:
    """
    Find Kth largest element.
    
    Time: O(n log k), Space: O(k)
    """
    min_heap = []
    
    for num in nums:
        heapq.heappush(min_heap, num)
        if len(min_heap) > k:
            heapq.heappop(min_heap)  # Remove smallest
    
    return min_heap[0]  # Root = Kth largest
```

### Template 3: K Smallest Elements

**Python:**
```python
import heapq

def k_smallest(nums: list[int], k: int) -> list[int]:
    """
    Find K smallest elements using max-heap of size K.
    
    Python trick: Negate values to simulate max-heap.
    
    Time: O(n log k), Space: O(k)
    """
    if k <= 0:
        return []
    if k >= len(nums):
        return nums[:]
    
    # Max-heap (negate for Python's min-heap)
    max_heap = [-x for x in nums[:k]]
    heapq.heapify(max_heap)
    
    for num in nums[k:]:
        if num < -max_heap[0]:  # Smaller than largest in heap
            heapq.heapreplace(max_heap, -num)
    
    return [-x for x in max_heap]  # K smallest (negate back)
```

### Template 4: Top K Frequent

**Python:**
```python
import heapq
from collections import Counter

def top_k_frequent(nums: list[int], k: int) -> list[int]:
    """
    Find K most frequent elements.
    
    Step 1: Count frequencies O(n)
    Step 2: Use min-heap of size K on frequencies O(n log k)
    
    Time: O(n log k), Space: O(n) for counter
    """
    # Count frequencies
    freq = Counter(nums)
    
    # Min-heap of (frequency, element)
    min_heap = []
    
    for num, count in freq.items():
        heapq.heappush(min_heap, (count, num))
        if len(min_heap) > k:
            heapq.heappop(min_heap)
    
    return [num for count, num in min_heap]
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | When to Use |
|----------|------|-------|-------------|
| Heap of size K |" O(n log k) "| O(k) | k << n |
| Full sort |" O(n log n) "| O(1) or O(n) | k ‚âà n |
| QuickSelect |" O(n) avg, O(n¬≤) worst "| O(1) | Single kth element |
| Bucket sort |" O(n) "| O(n) | Limited value range |

**Why O(n log k) for heap:**
- Process n elements: O(n)
- Each heap operation (push/pop): O(log k)
- Total: O(n * log k) = O(n log k)

**When heap beats sorting:**
```
n = 1,000,000, k = 10

Heap:   O(n log k) = O(1M * log 10) ‚âà 3.3M operations
Sort:   O(n log n) = O(1M * log 1M) ‚âà 20M operations

Heap is 6x faster!
```

---

## üîÑ Variations

| Variation | Heap Type | Comparator | Example |
|-----------|-----------|------------|---------|
| K largest values | Min-heap | Default | LC 215 |
| K smallest values | Max-heap | Negate | - |
| K most frequent | Min-heap | By frequency | LC 347 |
| K closest points | Max-heap | By distance | LC 973 |
| K closest to target | Max-heap | By |x - target| | LC 658 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Wrong Heap Type

```python
# ‚ùå Wrong: Max-heap for K largest
def k_largest_wrong(nums, k):
    max_heap = [-x for x in nums]
    heapq.heapify(max_heap)
    return [-heapq.heappop(max_heap) for _ in range(k)]
    # This works but is O(n + k log n), not O(n log k)!

# ‚úÖ Correct: Min-heap of size K
def k_largest_correct(nums, k):
    min_heap = []
    for num in nums:
        heapq.heappush(min_heap, num)
        if len(min_heap) > k:
            heapq.heappop(min_heap)
    return min_heap  # O(n log k)
```

### 2. Forgetting Edge Cases

```python
# ‚ùå Wrong: No validation
def kth_largest(nums, k):
    # Crashes if k > len(nums)!
    ...

# ‚úÖ Correct: Handle edge cases
def kth_largest(nums, k):
    if not nums or k <= 0 or k > len(nums):
        return None  # or raise exception
    ...
```

### 3. Incorrect Comparison for Custom Objects

```python
# ‚ùå Wrong: Tuple comparison fails when frequencies are equal
heap = []
heapq.heappush(heap, (3, "apple"))
heapq.heappush(heap, (3, "banana"))  # Compares strings when freq equal!

# ‚úÖ Correct: Add unique tiebreaker
heap = []
counter = 0
heapq.heappush(heap, (3, counter, "apple")); counter += 1
heapq.heappush(heap, (3, counter, "banana")); counter += 1
```

### 4. Returning Heap Instead of Sorted Result

```python
# ‚ùå Wrong: Heap is NOT sorted
return min_heap  # [7, 9, 8] - heap order, not sorted!

# ‚úÖ Correct: Sort if order matters
return sorted(min_heap, reverse=True)  # [9, 8, 7] - sorted
# Or if you need heap order to be maintained:
return [heapq.heappop(min_heap) for _ in range(len(min_heap))]
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)
- [ ] [Kth Largest Element in Stream (LC 703)](https://leetcode.com/problems/kth-largest-element-in-a-stream/) - Streaming intro
- [ ] [Last Stone Weight (LC 1046)](https://leetcode.com/problems/last-stone-weight/) - Max-heap simulation

### Medium (Apply variations)
- [ ] [Kth Largest Element (LC 215)](https://leetcode.com/problems/kth-largest-element-in-an-array/) - Classic, compare with QuickSelect
- [ ] [Top K Frequent Elements (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/) - Frequency + heap
- [ ] [K Closest Points to Origin (LC 973)](https://leetcode.com/problems/k-closest-points-to-origin/) - Distance + heap
- [ ] [Top K Frequent Words (LC 692)](https://leetcode.com/problems/top-k-frequent-words/) - Custom comparator
- [ ] [Sort Characters by Frequency (LC 451)](https://leetcode.com/problems/sort-characters-by-frequency/) - Frequency + heap

### Hard (Master edge cases)
- [ ] [Find K Closest Elements (LC 658)](https://leetcode.com/problems/find-k-closest-elements/) - Binary search alternative

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement K largest with min-heap
- **Day 3:** Solve LC 215 without looking
- **Day 7:** Solve LC 347 (frequency variant)
- **Day 14:** Solve LC 973 (distance variant)
- **Day 30:** Explain why min-heap for K largest

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"This is a Top K problem. I'll use a min-heap of size K. The key insight is that a min-heap of size K naturally keeps the K largest elements, and its root is the Kth largest."

**Why this approach:**
"Sorting would be O(n log n), but with a heap of size K, I only do O(n log k) operations. Since K is typically much smaller than n, this is more efficient."

**Common follow-ups:**
- "What if K is close to n?" ‚Üí "Then sorting might be simpler with same complexity"
- "Can you do better?" ‚Üí "QuickSelect gives O(n) average for single Kth element"
- "What about streaming data?" ‚Üí "Heap is perfect, just maintain size K"

</details>

**Company Focus:**

| Company | Frequency | Focus |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | LC 215, 347, 973 very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Top K Frequent variants |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | K Closest, custom comparators |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Basic Top K |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn pattern | 30-45 min | Understand heap type choice |
| Solve Easy | 10-15 min | LC 703 |
| Solve Medium | 20-25 min | LC 215, 347 |
| Master pattern | 3-4 hours | Multiple variations |

---

## üí° Key Insight

> **For K LARGEST, use a MIN-heap of size K. The root is automatically the Kth largest.** Think of it as a "bouncer" that only lets in elements larger than the current weakest VIP. This counterintuitive choice is the key to mastering Top K problems.

---

## üîó Related

- **Next:** [Kth Largest Element (LC 215)](./4.2-Kth-Largest-LC215.md)
- **Pattern:** [Two Heaps](../05-Two-Heaps-Pattern/5.1-Two-Heaps-Overview.md) for median problems
- **Foundation:** [Heap Operations](../02-Heap-Operations/2.1-Insert.md)
