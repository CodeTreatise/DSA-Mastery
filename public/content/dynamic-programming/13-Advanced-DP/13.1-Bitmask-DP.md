# Bitmask DP Pattern

> **When your state is a subset.** Bitmask DP uses binary representation to track which elements have been selected. Perfect for problems with small sets (n ‚â§ 20) where we need to track "which elements are used."

---

## üìã Overview

**Bitmask DP** represents subsets using integers:
- Bit `i` is 1 if element `i` is in the subset
- Bit `i` is 0 if element `i` is not in the subset

**Example:**
```
Set: {A, B, C, D}  (indices 0, 1, 2, 3)
Mask 0b1010 = 10 means: {B, D} (bits 1 and 3 are set)
```

---

## üéØ Pattern Recognition

**Bitmask DP signals:**
- "Assign n items to n positions" (permutation-like)
- "Partition into k groups"
- "Visit all nodes exactly once" (TSP)
- "Select subset with constraint"
- **n ‚â§ 20** (otherwise 2^n states too large)

**Keywords:**
- "permutation", "arrangement"
- "all subsets", "partition"
- "visit all", "Hamiltonian path"
- "exactly once"

---

## üìê Core Concepts

### Bit Operations

```python
# Check if bit i is set
if mask & (1 << i):
    # Bit i is 1

# Set bit i
new_mask = mask | (1 << i)

# Clear bit i
new_mask = mask & ~(1 << i)

# Toggle bit i
new_mask = mask ^ (1 << i)

# Count set bits
count = bin(mask).count('1')
# Or: count = mask.bit_count()  # Python 3.10+

# Iterate over set bits
while mask:
    i = (mask & -mask).bit_length() - 1  # Lowest set bit
    # Process bit i
    mask &= mask - 1  # Remove lowest set bit

# Enumerate all subsets of mask
sub = mask
while sub:
    # Process subset 'sub'
    sub = (sub - 1) & mask
```

### State Space

```
n = number of elements
Total masks = 2^n

For n = 15: 32,768 states
For n = 20: ~1,000,000 states
For n = 25: ~33,000,000 states (often too large)
```

---

## üíª Classic Problems

### 1. Traveling Salesman Problem (TSP)

```python
def tsp(dist: list[list[int]]) -> int:
    """
    Find minimum cost to visit all cities exactly once and return.
    dist[i][j] = distance from city i to city j
    Time: O(n¬≤ √ó 2‚Åø), Space: O(n √ó 2‚Åø)
    """
    n = len(dist)
    INF = float('inf')
    
    # dp[mask][i] = min cost to reach city i, having visited cities in mask
    dp = [[INF] * n for _ in range(1 << n)]
    dp[1][0] = 0  # Start at city 0, only city 0 visited
    
    for mask in range(1, 1 << n):
        for last in range(n):
            if not (mask & (1 << last)):
                continue  # last not in mask
            if dp[mask][last] == INF:
                continue
            
            # Try going to each unvisited city
            for next_city in range(n):
                if mask & (1 << next_city):
                    continue  # Already visited
                
                new_mask = mask | (1 << next_city)
                new_cost = dp[mask][last] + dist[last][next_city]
                dp[new_mask][next_city] = min(dp[new_mask][next_city], new_cost)
    
    # Return to starting city (city 0)
    full_mask = (1 << n) - 1
    return min(dp[full_mask][i] + dist[i][0] for i in range(n))
```

```javascript
function tsp(dist) {
    const n = dist.length;
    const INF = Infinity;
    const dp = Array.from({length: 1 << n}, () => new Array(n).fill(INF));
    dp[1][0] = 0;
    
    for (let mask = 1; mask < (1 << n); mask++) {
        for (let last = 0; last < n; last++) {
            if (!(mask & (1 << last))) continue;
            if (dp[mask][last] === INF) continue;
            
            for (let next = 0; next < n; next++) {
                if (mask & (1 << next)) continue;
                
                const newMask = mask | (1 << next);
                dp[newMask][next] = Math.min(dp[newMask][next], dp[mask][last] + dist[last][next]);
            }
        }
    }
    
    const fullMask = (1 << n) - 1;
    let ans = INF;
    for (let i = 0; i < n; i++) {
        ans = Math.min(ans, dp[fullMask][i] + dist[i][0]);
    }
    return ans;
}
```

### 2. Partition to K Equal Sum Subsets (LC 698)

```python
def can_partition_k_subsets(nums: list[int], k: int) -> bool:
    """
    Partition array into k subsets with equal sum.
    """
    total = sum(nums)
    if total % k != 0:
        return False
    
    target = total // k
    n = len(nums)
    nums.sort(reverse=True)  # Pruning: try large numbers first
    
    if nums[0] > target:
        return False
    
    # dp[mask] = True if we can partition 'mask' subset into groups of 'target'
    # But this is complex. Better approach: track current bucket sum
    
    # Alternative: dp[mask] = remaining sum in current bucket
    dp = [-1] * (1 << n)
    dp[0] = 0  # Empty set, bucket sum is 0
    
    for mask in range(1 << n):
        if dp[mask] == -1:
            continue
        
        for i in range(n):
            if mask & (1 << i):
                continue  # Already used
            
            # Add nums[i] to current bucket
            new_sum = dp[mask] + nums[i]
            if new_sum > target:
                continue  # Would overflow bucket
            
            new_mask = mask | (1 << i)
            if new_sum == target:
                dp[new_mask] = 0  # Bucket complete, start new
            else:
                dp[new_mask] = new_sum
    
    return dp[(1 << n) - 1] == 0
```

### 3. Number of Ways to Wear Hats (LC 1434)

```python
def number_ways(hats: list[list[int]]) -> int:
    """
    n people, 40 hats. Each person has preferences.
    Count ways to assign distinct hats.
    
    Key insight: Iterate over HATS (up to 40), mask over PEOPLE (up to 10).
    """
    MOD = 10**9 + 7
    n = len(hats)
    
    # hat_to_people[h] = list of people who like hat h
    hat_to_people = [[] for _ in range(41)]
    for person, hat_list in enumerate(hats):
        for hat in hat_list:
            hat_to_people[hat].append(person)
    
    # dp[mask] = ways to assign hats such that people in 'mask' have hats
    dp = [0] * (1 << n)
    dp[0] = 1  # No one has a hat yet
    
    full_mask = (1 << n) - 1
    
    for hat in range(1, 41):
        # Iterate in reverse to use previous state
        for mask in range(full_mask, -1, -1):
            for person in hat_to_people[hat]:
                if mask & (1 << person):
                    continue  # Person already has a hat
                dp[mask | (1 << person)] = (dp[mask | (1 << person)] + dp[mask]) % MOD
    
    return dp[full_mask]
```

### 4. Minimum Cost to Connect Two Groups (LC 1595)

```python
def connect_two_groups(cost: list[list[int]]) -> int:
    """
    Connect all points in group 1 to group 2, minimum cost.
    Each point must be connected to at least one in other group.
    """
    m, n = len(cost), len(cost[0])
    INF = float('inf')
    
    # Precompute: for each group2 point, min cost to connect
    min_cost = [min(cost[i][j] for i in range(m)) for j in range(n)]
    
    # dp[mask] = min cost where mask indicates which group2 points are connected
    dp = [INF] * (1 << n)
    dp[0] = 0
    
    for i in range(m):  # For each group1 point
        new_dp = [INF] * (1 << n)
        for mask in range(1 << n):
            if dp[mask] == INF:
                continue
            # Connect group1[i] to at least one group2 point
            for j in range(n):
                new_mask = mask | (1 << j)
                new_dp[new_mask] = min(new_dp[new_mask], dp[mask] + cost[i][j])
        dp = new_dp
    
    # Ensure all group2 points are connected
    full = (1 << n) - 1
    result = INF
    for mask in range(1 << n):
        if dp[mask] == INF:
            continue
        # Connect remaining group2 points with minimum cost
        extra = 0
        for j in range(n):
            if not (mask & (1 << j)):
                extra += min_cost[j]
        result = min(result, dp[mask] + extra)
    
    return result
```

---

## ‚ö° Complexity Analysis

| Problem | Time | Space |
|---------|------|-------|
| TSP | O(n¬≤ √ó 2‚Åø) | O(n √ó 2‚Åø) |
| Partition to K | O(n √ó 2‚Åø) | O(2‚Åø) |
| Hat Assignment | O(40 √ó n √ó 2‚Åø) | O(2‚Åø) |

**When is Bitmask DP feasible?**
- n ‚â§ 15: Very comfortable
- n ‚â§ 20: Usually OK
- n ‚â§ 25: Might need optimization
- n > 25: Usually too slow

---

## ‚ö†Ô∏è Common Mistakes

### 1. Iterating Mask in Wrong Order

**‚ùå Wrong (for some problems):**
```python
# If dp[new_mask] depends on dp[mask], and new_mask < mask
for mask in range(1 << n):  # Low to high
```

**‚úÖ Correct:**
```python
# Iterate high to low if updating same dp array
for mask in range((1 << n) - 1, -1, -1):
```

### 2. Forgetting the Empty Mask

```python
dp[0] = base_case  # Don't forget the empty set!
```

### 3. Wrong Bit Check

**‚ùå Wrong:**
```python
if mask & i:  # WRONG! Should be (1 << i)
```

**‚úÖ Correct:**
```python
if mask & (1 << i):  # Check if bit i is set
```

### 4. Integer Overflow in Other Languages

```cpp
// In C++, for n > 30:
long long mask = 1LL << i;  // Use 1LL, not 1
```

---

## üîÑ Subset Enumeration Pattern

```python
def enumerate_subsets(mask):
    """Enumerate all subsets of mask (including empty)."""
    subsets = []
    sub = mask
    while True:
        subsets.append(sub)
        if sub == 0:
            break
        sub = (sub - 1) & mask
    return subsets

# Example: mask = 0b101 (5)
# Subsets: 0b101, 0b100, 0b001, 0b000 = [5, 4, 1, 0]
```

---

## üìù Practice Problems

| Problem | Difficulty | Key Insight |
|---------|------------|-------------|
| [78. Subsets](https://leetcode.com/problems/subsets/) | Medium | Basic bitmask |
| [698. Partition to K Equal Sum](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/) | Medium | Bitmask + backtracking |
| [847. Shortest Path Visiting All Nodes](https://leetcode.com/problems/shortest-path-visiting-all-nodes/) | Hard | BFS + bitmask |
| [943. Find Shortest Superstring](https://leetcode.com/problems/find-the-shortest-superstring/) | Hard | TSP variant |
| [1434. Number of Ways to Wear Hats](https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/) | Hard | Flip the mask |
| [1595. Min Cost Connect Two Groups](https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/) | Hard | Both groups connected |

---

## üé§ Interview Context

**Company Frequency:**
| Problem Type | Google | Meta | Amazon |
|--------------|--------|------|--------|
| TSP variants | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| Partition | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| Assignment | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê |

**Time allocation:**
| Problem | Target Time |
|---------|-------------|
| Simple Bitmask | 20-25 min |
| TSP | 30-35 min |
| Complex Assignment | 35-40 min |

---

## üí° Key Insights

1. **Masks represent subsets**: Bit i = 1 means element i is included
2. **2^n states**: Only feasible for n ‚â§ 20
3. **TSP pattern**: dp[mask][last] = min cost visiting mask, ending at last
4. **Flip the mask**: If items are many but "slots" are few, mask the slots
5. **Subset enumeration**: (sub - 1) & mask iterates all subsets

---

> **üí° Key Pattern:** When you see "assign N items to N slots" or "visit all N nodes" with N ‚â§ 20, think Bitmask DP. The mask tracks which elements are "used," and transitions add one more element.

> **üîó Related:** [Backtracking](../../02-Recursion-Backtracking/02-Backtracking/2.1-Backtracking-Basics.md) | [Graph Algorithms](../../10-Graphs.md) | [DP Fundamentals](../01-DP-Fundamentals/1.1-What-Is-DP.md)
