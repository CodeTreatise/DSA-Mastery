# Collision Handling

> **When two keys hash to the same bucket, we need strategies to resolve the conflict.**

Collisions are inevitable in hash tables (Pigeonhole Principle). Understanding collision resolution is crucial for implementing hash tables and analyzing their performance.

---

## üéØ Pattern Recognition

<details>
<summary><strong>Understanding Collisions</strong></summary>

**What is a collision?**
```
hash("cat") % 10 = 5
hash("dog") % 10 = 5  ‚Üê Same bucket! Collision!
```

**Why collisions happen:**
- Hash codes map infinite keys to finite buckets
- Pigeonhole Principle: n+1 items ‚Üí n buckets = at least one collision
- Even with good hash functions, collisions are mathematically unavoidable

**Two main strategies:**
1. **Chaining**: Store multiple items per bucket (linked list)
2. **Open Addressing**: Find another empty bucket (probing)

</details>

---

## ‚úÖ When to Use Each Strategy

### Chaining
- Simple implementation
- Works well with high load factors
- Good when memory allocation is cheap
- Hash table size doesn't need to grow often

### Open Addressing
- Better cache performance
- Less memory overhead (no pointers)
- When deletions are rare
- Predictable memory usage

## ‚ùå Trade-offs

| Aspect | Chaining | Open Addressing |
|--------|----------|-----------------|
| Cache locality | Poor | Good |
| Memory overhead | Pointers | None |
| Max load factor | Can exceed 1.0 | Must stay < 1.0 |
| Deletion | Easy | Complex |
| Implementation | Simple | More complex |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- [What Is Hashing](./1.1-What-Is-Hashing.md)
- [Hash Functions](./1.2-Hash-Functions.md)
- Linked list basics

**After this, learn:**
- [Load Factor & Resizing](./1.4-Load-Factor.md)
- [Design HashMap (LC 706)](../08-Design-Problems/8.2-Design-HashMap-LC706.md)
- [Design HashSet (LC 705)](../08-Design-Problems/8.3-Design-HashSet-LC705.md)

**Used in:**
- All hash table implementations
- Database indexing
- Compiler symbol tables

</details>

---

## üìê How It Works

### Strategy 1: Separate Chaining

Each bucket contains a linked list (or other collection) of entries.

```
Hash Table with Chaining (size = 5)

Insert: "cat"‚Üí1, "dog"‚Üí2, "bird"‚Üí1 (collision!), "fish"‚Üí3

Bucket 0: []
Bucket 1: [("cat",1)] ‚Üí [("bird",1)]  ‚Üê Collision resolved!
Bucket 2: [("dog",2)]
Bucket 3: [("fish",3)]
Bucket 4: []

Lookup "bird":
1. hash("bird") % 5 = 1
2. Search bucket 1's linked list
3. Find ("bird",1) ‚úì
```

### Visualization: Chaining

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               SEPARATE CHAINING                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                      ‚îÇ
‚îÇ  Buckets (Array)           Linked Lists             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îê                                              ‚îÇ
‚îÇ  ‚îÇ 0 ‚îÇ ‚Üí null                                       ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚î§                                              ‚îÇ
‚îÇ  ‚îÇ 1 ‚îÇ ‚Üí [cat:1] ‚Üí [bird:1] ‚Üí null                 ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚î§                                              ‚îÇ
‚îÇ  ‚îÇ 2 ‚îÇ ‚Üí [dog:2] ‚Üí null                            ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚î§                                              ‚îÇ
‚îÇ  ‚îÇ 3 ‚îÇ ‚Üí [fish:3] ‚Üí null                           ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚î§                                              ‚îÇ
‚îÇ  ‚îÇ 4 ‚îÇ ‚Üí null                                       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îò                                              ‚îÇ
‚îÇ                                                      ‚îÇ
‚îÇ  Lookup("bird"):                                    ‚îÇ
‚îÇ  1. hash("bird") = 1                                ‚îÇ
‚îÇ  2. Traverse bucket[1]'s list                       ‚îÇ
‚îÇ  3. Compare keys until match                        ‚îÇ
‚îÇ                                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Strategy 2: Open Addressing (Linear Probing)

If bucket is occupied, try the next one.

```
Hash Table with Linear Probing (size = 5)

Insert: "cat"‚Üíidx 1, "dog"‚Üíidx 2, "bird"‚Üíidx 1 (collision!)

Step 1: "cat" ‚Üí hash = 1 ‚Üí bucket[1] empty ‚Üí insert
        [_, "cat", _, _, _]

Step 2: "dog" ‚Üí hash = 2 ‚Üí bucket[2] empty ‚Üí insert
        [_, "cat", "dog", _, _]

Step 3: "bird" ‚Üí hash = 1 ‚Üí bucket[1] occupied!
        ‚Üí Try bucket[2] ‚Üí occupied!
        ‚Üí Try bucket[3] ‚Üí empty ‚Üí insert
        [_, "cat", "dog", "bird", _]

Lookup "bird":
1. hash("bird") = 1 ‚Üí bucket[1] = "cat" ‚â† "bird"
2. Try bucket[2] ‚Üí "dog" ‚â† "bird"
3. Try bucket[3] ‚Üí "bird" ‚úì Found!
```

### Visualization: Linear Probing

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               LINEAR PROBING                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                      ‚îÇ
‚îÇ  Index:   0       1       2       3       4         ‚îÇ
‚îÇ          ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  Table:  ‚îÇ   ‚îÇ "cat" ‚îÇ "dog" ‚îÇ "bird" ‚îÇ   ‚îÇ        ‚îÇ
‚îÇ          ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ                ‚Üë                ‚Üë                   ‚îÇ
‚îÇ           original          probed                  ‚îÇ
‚îÇ           hash=1            hash=1+2                ‚îÇ
‚îÇ                                                      ‚îÇ
‚îÇ  Probe Sequence for hash=1: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 0      ‚îÇ
‚îÇ                              ‚Üë   ‚Üë   ‚Üë              ‚îÇ
‚îÇ                            try try SUCCESS          ‚îÇ
‚îÇ                                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Strategy 3: Quadratic Probing

Reduces clustering by probing at quadratic intervals.

```
Probe sequence: hash, hash+1¬≤, hash+2¬≤, hash+3¬≤, ...

If hash("bird") = 1:
  Try: 1, 1+1=2, 1+4=5, 1+9=10%size, ...
```

### Strategy 4: Double Hashing

Use a second hash function to determine probe step.

```
hash1("bird") = 1
hash2("bird") = 3

Probe sequence: 1, 1+3=4, 1+6=7, 1+9=10%size, ...
```

---

## üíª Code Implementation

### Python - Chaining Implementation

```python
class HashTableChaining:
    """Hash table using separate chaining for collisions."""
    
    def __init__(self, capacity: int = 16):
        self.capacity = capacity
        self.size = 0
        # Each bucket is a list of (key, value) pairs
        self.buckets = [[] for _ in range(capacity)]
    
    def _hash(self, key) -> int:
        """Compute bucket index for key."""
        return hash(key) % self.capacity
    
    def put(self, key, value) -> None:
        """Insert or update key-value pair."""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        # Check if key exists (update)
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        
        # Key not found (insert)
        bucket.append((key, value))
        self.size += 1
    
    def get(self, key, default=None):
        """Get value by key."""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        for k, v in bucket:
            if k == key:
                return v
        
        return default
    
    def remove(self, key) -> bool:
        """Remove key-value pair. Returns True if removed."""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                self.size -= 1
                return True
        
        return False
    
    def contains(self, key) -> bool:
        """Check if key exists."""
        return self.get(key) is not None


# Usage
ht = HashTableChaining()
ht.put("apple", 1)
ht.put("banana", 2)  # May collide with "apple"
print(ht.get("apple"))  # 1
```

### Python - Linear Probing Implementation

```python
class HashTableLinearProbing:
    """Hash table using linear probing for collisions."""
    
    def __init__(self, capacity: int = 16):
        self.capacity = capacity
        self.size = 0
        self.keys = [None] * capacity
        self.values = [None] * capacity
        self.DELETED = object()  # Tombstone marker
    
    def _hash(self, key) -> int:
        return hash(key) % self.capacity
    
    def _probe(self, key, for_insert: bool = False):
        """Find index for key using linear probing."""
        index = self._hash(key)
        start = index
        first_deleted = None
        
        while True:
            if self.keys[index] is None:
                # Empty slot
                if for_insert and first_deleted is not None:
                    return first_deleted
                return index
            
            if self.keys[index] is self.DELETED:
                # Tombstone - remember for insertion
                if first_deleted is None:
                    first_deleted = index
            elif self.keys[index] == key:
                # Found the key
                return index
            
            # Linear probe: try next slot
            index = (index + 1) % self.capacity
            
            if index == start:
                # Full circle - table is full
                if for_insert and first_deleted is not None:
                    return first_deleted
                raise Exception("Hash table is full")
    
    def put(self, key, value) -> None:
        """Insert or update key-value pair."""
        if self.size >= self.capacity * 0.7:  # Load factor check
            self._resize(self.capacity * 2)
        
        index = self._probe(key, for_insert=True)
        
        if self.keys[index] is None or self.keys[index] is self.DELETED:
            self.size += 1
        
        self.keys[index] = key
        self.values[index] = value
    
    def get(self, key, default=None):
        """Get value by key."""
        index = self._probe(key)
        
        if self.keys[index] == key:
            return self.values[index]
        
        return default
    
    def remove(self, key) -> bool:
        """Remove key-value pair using tombstone."""
        index = self._probe(key)
        
        if self.keys[index] == key:
            self.keys[index] = self.DELETED
            self.values[index] = None
            self.size -= 1
            return True
        
        return False
    
    def _resize(self, new_capacity: int) -> None:
        """Resize and rehash all entries."""
        old_keys = self.keys
        old_values = self.values
        
        self.capacity = new_capacity
        self.keys = [None] * new_capacity
        self.values = [None] * new_capacity
        self.size = 0
        
        for i, key in enumerate(old_keys):
            if key is not None and key is not self.DELETED:
                self.put(key, old_values[i])


# Usage
ht = HashTableLinearProbing()
ht.put("apple", 1)
ht.put("banana", 2)
print(ht.get("apple"))  # 1
ht.remove("apple")
print(ht.get("apple"))  # None
```

### JavaScript - Chaining

```javascript
class HashTableChaining {
    constructor(capacity = 16) {
        this.capacity = capacity;
        this.size = 0;
        this.buckets = Array.from({ length: capacity }, () => []);
    }
    
    _hash(key) {
        let hash = 0;
        for (const char of String(key)) {
            hash = (hash * 31 + char.charCodeAt(0)) % this.capacity;
        }
        return hash;
    }
    
    put(key, value) {
        const index = this._hash(key);
        const bucket = this.buckets[index];
        
        // Check if key exists
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                bucket[i][1] = value;
                return;
            }
        }
        
        // New key
        bucket.push([key, value]);
        this.size++;
    }
    
    get(key) {
        const index = this._hash(key);
        const bucket = this.buckets[index];
        
        for (const [k, v] of bucket) {
            if (k === key) return v;
        }
        
        return undefined;
    }
    
    remove(key) {
        const index = this._hash(key);
        const bucket = this.buckets[index];
        
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                bucket.splice(i, 1);
                this.size--;
                return true;
            }
        }
        
        return false;
    }
}
```

### JavaScript - Linear Probing

```javascript
class HashTableLinearProbing {
    constructor(capacity = 16) {
        this.capacity = capacity;
        this.size = 0;
        this.keys = new Array(capacity).fill(null);
        this.values = new Array(capacity).fill(null);
        this.DELETED = Symbol('DELETED');
    }
    
    _hash(key) {
        let hash = 0;
        for (const char of String(key)) {
            hash = (hash * 31 + char.charCodeAt(0)) % this.capacity;
        }
        return hash;
    }
    
    _probe(key, forInsert = false) {
        let index = this._hash(key);
        const start = index;
        let firstDeleted = null;
        
        while (true) {
            if (this.keys[index] === null) {
                return forInsert && firstDeleted !== null ? firstDeleted : index;
            }
            
            if (this.keys[index] === this.DELETED) {
                if (firstDeleted === null) firstDeleted = index;
            } else if (this.keys[index] === key) {
                return index;
            }
            
            index = (index + 1) % this.capacity;
            if (index === start) {
                if (forInsert && firstDeleted !== null) return firstDeleted;
                throw new Error('Hash table is full');
            }
        }
    }
    
    put(key, value) {
        if (this.size >= this.capacity * 0.7) {
            this._resize(this.capacity * 2);
        }
        
        const index = this._probe(key, true);
        
        if (this.keys[index] === null || this.keys[index] === this.DELETED) {
            this.size++;
        }
        
        this.keys[index] = key;
        this.values[index] = value;
    }
    
    get(key) {
        const index = this._probe(key);
        return this.keys[index] === key ? this.values[index] : undefined;
    }
    
    remove(key) {
        const index = this._probe(key);
        
        if (this.keys[index] === key) {
            this.keys[index] = this.DELETED;
            this.values[index] = null;
            this.size--;
            return true;
        }
        
        return false;
    }
    
    _resize(newCapacity) {
        const oldKeys = this.keys;
        const oldValues = this.values;
        
        this.capacity = newCapacity;
        this.keys = new Array(newCapacity).fill(null);
        this.values = new Array(newCapacity).fill(null);
        this.size = 0;
        
        for (let i = 0; i < oldKeys.length; i++) {
            if (oldKeys[i] !== null && oldKeys[i] !== this.DELETED) {
                this.put(oldKeys[i], oldValues[i]);
            }
        }
    }
}
```

---

## ‚ö° Complexity Analysis

### Chaining

| Operation | Average | Worst (all collide) |
|-----------|---------|---------------------|
| Insert | O(1) | O(n) |
| Lookup | O(1 + Œ±) | O(n) |
| Delete | O(1 + Œ±) | O(n) |

Where Œ± = n/m (load factor, n items, m buckets)

### Linear Probing

| Operation | Average | Worst |
|-----------|---------|-------|
| Insert | O(1/(1-Œ±)) | O(n) |
| Lookup | O(1/(1-Œ±)) | O(n) |
| Delete | O(1/(1-Œ±)) | O(n) |

**Note:** Performance degrades rapidly as Œ± ‚Üí 1

---

## üîÑ Probing Strategies Comparison

| Strategy | Formula | Clustering | Cache |
|----------|---------|------------|-------|
| Linear | h + i | Primary clustering | Best |
| Quadratic | h + i¬≤ | Secondary clustering | Good |
| Double Hash | h‚ÇÅ + i¬∑h‚ÇÇ | No clustering | Worst |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Handling Deletions in Open Addressing

```python
# ‚ùå WRONG: Just set to None
def remove(self, key):
    index = self._find(key)
    self.keys[index] = None  # Breaks probe chains!

# ‚úÖ CORRECT: Use tombstone
DELETED = object()

def remove(self, key):
    index = self._find(key)
    self.keys[index] = DELETED  # Preserves probe chain
```

### 2. Infinite Loop in Probing

```python
# ‚ùå WRONG: No termination condition
while self.keys[index] is not None:
    index = (index + 1) % self.capacity
    # If table is full, infinite loop!

# ‚úÖ CORRECT: Track starting point
start = index
while self.keys[index] is not None:
    index = (index + 1) % self.capacity
    if index == start:
        raise Exception("Table full")
```

### 3. Forgetting Load Factor Check

```python
# ‚ùå WRONG: Insert without checking load
def put(self, key, value):
    # May cause excessive collisions!

# ‚úÖ CORRECT: Check and resize
def put(self, key, value):
    if self.size >= self.capacity * 0.7:
        self._resize(self.capacity * 2)
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Focus | Link |
|---------|------------|-------|------|
| Design HashSet | üü¢ Easy | Chaining basics | [LC 705](https://leetcode.com/problems/design-hashset/) |
| Design HashMap | üü¢ Easy | Full implementation | [LC 706](https://leetcode.com/problems/design-hashmap/) |
| First Unique Character | üü¢ Easy | Using hash table | [LC 387](https://leetcode.com/problems/first-unique-character-in-a-string/) |
| LRU Cache | üü° Medium | Hash + linked list | [LC 146](https://leetcode.com/problems/lru-cache/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement chaining from scratch
- **Day 3:** Implement linear probing with tombstones
- **Day 7:** Solve LC 706 (Design HashMap)
- **Day 14:** Compare performance of both strategies
- **Day 30:** Explain trade-offs in interview context

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Collision Handling in Interviews</strong></summary>

**Common questions:**
- "How do you handle collisions?"
- "What's the difference between chaining and probing?"
- "How does deletion work with probing?"
- "Implement a hash table from scratch"

**What to explain:**
> "Chaining uses linked lists per bucket - simple but uses more memory. Probing finds the next empty slot - better cache performance but needs tombstones for deletion."

**Key trade-offs:**
- Chaining: Simpler, handles high load, but pointer overhead
- Probing: Better cache, no pointers, but clustering issues

</details>

**Company Focus:**

| Company | Implementation Questions | Notes |
|---------|------------------------|-------|
| Google | Sometimes | System design |
| Meta | Rarely | Focus on usage |
| Amazon | Occasionally | Design questions |
| Bloomberg | More common | Implementation detail |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand both strategies | 30 min |
| Implement chaining | 20 min |
| Implement linear probing | 30 min |
| Handle edge cases (deletion, resize) | 20 min |

---

> **üí° Key Insight:** Chaining is simpler and more forgiving, while open addressing has better cache performance but requires careful handling of deletions with tombstones.

> **üîó Related:** [Hash Functions](./1.2-Hash-Functions.md) | [Load Factor](./1.4-Load-Factor.md) | [Design HashMap](../08-Design-Problems/8.2-Design-HashMap-LC706.md)
