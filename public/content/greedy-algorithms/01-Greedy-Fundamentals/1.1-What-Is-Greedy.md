# 1.1 What Is Greedy?

> **Definition:** A greedy algorithm makes the locally optimal choice at each step, hoping that these local choices lead to a globally optimal solution.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Greedy Problems</strong></summary>

**Look for these signals:**
- Optimization problem (minimize or maximize something)
- Making sequential choices or decisions
- Each choice can be evaluated independently
- No need to revisit or undo previous decisions
- Problem has "obvious" best choice at each step

**Keywords in problem statement:**
- "Maximum/minimum number of..."
- "Optimal selection/scheduling"
- "Most/least/fewest..."
- "Earliest/latest ending..."
- "Non-overlapping", "schedule", "assign"

**Greedy-friendly problem types:**
- Interval scheduling (meetings, activities)
- Resource allocation (cookies, boats)
- Traversal decisions (jump games)
- Ordering problems (queue reconstruction)

</details>

---

## ‚úÖ When Greedy Works

Greedy algorithms work when the problem has these two properties:

### 1. Greedy Choice Property
The globally optimal solution can be constructed by making locally optimal choices.

```
At each step, we can choose what looks best RIGHT NOW
without worrying about future consequences.
```

### 2. Optimal Substructure
An optimal solution contains optimal solutions to its subproblems.

```
After making a greedy choice, the remaining problem
is a smaller instance of the same problem.
```

**Examples where greedy works:**
- Activity Selection (sort by end time, pick earliest ending)
- Fractional Knapsack (pick highest value/weight ratio)
- Huffman Coding (combine lowest frequency nodes)
- Dijkstra's Algorithm (pick nearest unvisited node)
- Kruskal's/Prim's MST (pick minimum weight edge)

---

## ‚ùå When Greedy Does NOT Work

| Scenario | Why Greedy Fails | Use Instead |
|----------|------------------|-------------|
| 0/1 Knapsack | Can't take fractions, greedy may miss optimal | Dynamic Programming |
| Coin Change (arbitrary) | Greedy may use more coins | Dynamic Programming |
| Longest Path | Local best edge may lead to dead end | DFS/DP |
| Traveling Salesman | Nearest neighbor heuristic isn't optimal | DP with bitmask |
| All-pairs shortest | Needs to consider all paths | Floyd-Warshall |

**Key insight:** If you can find a **counterexample** where greedy fails, you need DP.

### Classic Counterexample: Coin Change

```
Coins: [1, 3, 4], Target: 6

Greedy: 4 + 1 + 1 = 3 coins ‚ùå
Optimal: 3 + 3 = 2 coins ‚úÖ

Greedy fails because taking the largest coin first
doesn't always minimize the total count.
```

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Connections</strong></summary>

**Before this, you should know:**
- [Sorting Algorithms](../../03-Sorting-Searching.md) - Most greedy solutions require sorting first
- [Basic Complexity Analysis](../../00-Prerequisites.md) - Understanding O(n log n) from sorting

**After mastering this:**
- [Greedy Proof Techniques](./2.1-Greedy-Stays-Ahead.md) - Prove greedy works
- [Interval Problems](../02-Interval-Pattern/4.1-Interval-Greedy-Overview.md) - High-value pattern
- [Dynamic Programming](../../11-Dynamic-Programming.md) - When greedy fails

**Related concepts:**
- Sorting + processing = common greedy template
- Priority queues/heaps for dynamic greedy decisions

</details>

---

## üìê How Greedy Works

### The Greedy Template

```
1. SORT or ORGANIZE input by some criteria
2. ITERATE through items in order
3. For each item: DECIDE to take or skip based on local criteria
4. ACCUMULATE result
5. RETURN final answer
```

### Visualization: Activity Selection

```
Activities (sorted by end time):
A: [1,3]  ‚ñà‚ñà‚ñà‚ñà
B: [2,5]    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
C: [4,6]      ‚ñà‚ñà‚ñà‚ñà
D: [6,8]          ‚ñà‚ñà‚ñà‚ñà
E: [5,9]        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
F: [8,10]            ‚ñà‚ñà‚ñà‚ñà

Greedy selection (pick earliest ending, non-overlapping):
Step 1: Pick A [1,3]  ‚úì (first to end)
Step 2: Skip B [2,5]  ‚úó (overlaps with A)
Step 3: Pick C [4,6]  ‚úì (starts after A ends)
Step 4: Pick D [6,8]  ‚úì (starts when C ends)
Step 5: Skip E [5,9]  ‚úó (overlaps with D)
Step 6: Pick F [8,10] ‚úì (starts when D ends)

Result: 4 activities (A, C, D, F) - Maximum possible!
```

---

## üíª Code Implementation

**Python - Generic Greedy Template:**
```python
def greedy_template(items, key_func, valid_func):
    """
    Generic greedy algorithm template.
    
    Args:
        items: List of items to process
        key_func: Function to sort items (criteria)
        valid_func: Function to check if item can be taken
    
    Returns:
        List of selected items
    
    Time: O(n log n) for sorting + O(n) for processing
    Space: O(n) for result
    """
    # Step 1: Sort by greedy criteria
    sorted_items = sorted(items, key=key_func)
    
    result = []
    state = None  # Track current state (e.g., last end time)
    
    # Step 2: Iterate and make greedy choices
    for item in sorted_items:
        # Step 3: Decide - can we take this item?
        if valid_func(item, state):
            result.append(item)
            state = item  # Update state
    
    return result


# Example: Activity Selection
def activity_selection(activities):
    """Select maximum non-overlapping activities."""
    
    # Sort by end time (greedy criteria)
    sorted_acts = sorted(activities, key=lambda x: x[1])
    
    result = []
    last_end = 0
    
    for start, end in sorted_acts:
        if start >= last_end:  # Non-overlapping
            result.append((start, end))
            last_end = end
    
    return result


# Test
activities = [(1,3), (2,5), (4,6), (6,8), (5,9), (8,10)]
print(activity_selection(activities))
# Output: [(1,3), (4,6), (6,8), (8,10)]
```

**JavaScript:**
```javascript
/**
 * Generic greedy algorithm template.
 * @param {Array} items - Items to process
 * @param {Function} keyFunc - Sorting criteria
 * @param {Function} validFunc - Selection criteria
 * @returns {Array} Selected items
 */
function greedyTemplate(items, keyFunc, validFunc) {
    // Sort by greedy criteria
    const sortedItems = [...items].sort((a, b) => keyFunc(a) - keyFunc(b));
    
    const result = [];
    let state = null;
    
    for (const item of sortedItems) {
        if (validFunc(item, state)) {
            result.push(item);
            state = item;
        }
    }
    
    return result;
}

// Activity Selection
function activitySelection(activities) {
    // Sort by end time
    const sorted = [...activities].sort((a, b) => a[1] - b[1]);
    
    const result = [];
    let lastEnd = 0;
    
    for (const [start, end] of sorted) {
        if (start >= lastEnd) {
            result.push([start, end]);
            lastEnd = end;
        }
    }
    
    return result;
}

// Test
console.log(activitySelection([[1,3], [2,5], [4,6], [6,8], [5,9], [8,10]]));
// Output: [[1,3], [4,6], [6,8], [8,10]]
```

---

## ‚ö° Complexity Analysis

| Aspect | Complexity | Explanation |
|--------|------------|-------------|
| **Sorting** | O(n log n) | Required for most greedy algorithms |
| **Processing** | O(n) | Single pass through sorted items |
| **Total Time** | O(n log n) | Dominated by sorting |
| **Space** | O(1) to O(n) | Depends on result storage |

**Why greedy is efficient:**
- No backtracking (unlike backtracking algorithms)
- No memoization table (unlike DP)
- Single pass after sorting
- Decisions are final

---

## üîÑ Variations of Greedy

| Variation | Description | Example |
|-----------|-------------|---------|
| **Sort-then-Greedy** | Sort first, process in order | Activity Selection |
| **Heap-based Greedy** | Use priority queue for dynamic best | Meeting Rooms II |
| **Two-pointer Greedy** | Process from both ends | Assign Cookies |
| **Multi-pass Greedy** | Multiple passes, each greedy | Candy problem |
| **Greedy + Binary Search** | Search for answer, check greedily | Koko Eating Bananas |

---

## ‚ö†Ô∏è Common Mistakes

1. **Assuming greedy works without proof**
   - ‚ùå "It seems like picking the biggest first should work"
   - ‚úÖ Try to find a counterexample or prove correctness

2. **Wrong sorting criteria**
   - ‚ùå Activity selection: sort by start time
   - ‚úÖ Activity selection: sort by END time

3. **Not handling ties**
   - ‚ùå Ignoring what happens when values are equal
   - ‚úÖ Define tie-breaking rules explicitly

4. **Forgetting edge cases**
   - ‚ùå Empty input, single element, all overlapping
   - ‚úÖ Handle edge cases before main logic

---

## üìù Practice Problems

### Easy (Learn the concept)
- [ ] [Assign Cookies](https://leetcode.com/problems/assign-cookies/) - Sort both, match greedily
- [ ] [Lemonade Change](https://leetcode.com/problems/lemonade-change/) - Greedy change-making
- [ ] [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/) - Sum all profits

### Medium (Apply patterns)
- [ ] [Jump Game](https://leetcode.com/problems/jump-game/) - Track max reachable
- [ ] [Merge Intervals](https://leetcode.com/problems/merge-intervals/) - Sort by start
- [ ] [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/) - Sort by end

### Hard (Edge cases)
- [ ] [Candy](https://leetcode.com/problems/candy/) - Two-pass greedy
- [ ] [IPO](https://leetcode.com/problems/ipo/) - Two heaps

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

After learning this concept:
- **Day 1:** Implement activity selection from scratch
- **Day 3:** Solve 2 easy greedy problems
- **Day 7:** Identify greedy vs DP for 5 random problems
- **Day 14:** Explain greedy choice property to someone
- **Day 30:** Review and solve a new medium problem

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Discuss Greedy in Interviews</strong></summary>

**The 4-Step Greedy Communication:**

1. **Recognize Pattern** (30 sec)
   - "This looks like an optimization problem where we make sequential choices"
   - "I'm thinking greedy might work here"

2. **State Greedy Strategy** (1 min)
   - "My greedy approach is to [sort by X] and [take items that satisfy Y]"
   - "The key insight is that choosing [locally optimal] leads to [globally optimal]"

3. **Justify or Check** (1 min)
   - "Let me verify this with an example..."
   - "Can I think of a counterexample where this fails?"
   - If unsure: "If greedy doesn't work, we might need DP"

4. **Implement** (5-10 min)
   - Write clean code with comments
   - Handle edge cases

**Company Focus:**
| Company | Greedy Frequency | Common Types |
|---------|-----------------|--------------|
| Amazon | ‚≠ê‚≠ê‚≠ê | Intervals, scheduling |
| Meta | ‚≠ê‚≠ê‚≠ê | Intervals, arrays |
| Google | ‚≠ê‚≠ê | Often mixed with DP |
| Microsoft | ‚≠ê‚≠ê | Classic problems |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 30 min | First exposure |
| Implement first example | 20 min | Activity selection |
| Solve Easy problem | 15 min | With hints |
| Solve Medium problem | 25 min | Interview target |
| Master recognition | 2-3 hours | Multiple problems |

---

> **üí° Key Insight:** Greedy works when making the locally optimal choice at each step doesn't cut off the globally optimal solution. The hard part is proving this is true‚Äîor finding a counterexample that proves it's false.

> **üîó Related:** [When Greedy Works](./1.2-When-Greedy-Works.md) | [Greedy vs DP](./1.3-Greedy-vs-DP.md) | [Proof Techniques](./2.1-Greedy-Stays-Ahead.md)
