# 5.3 - Binary Tree Maximum Path Sum (LC 124)

> **Grokking Pattern:** #11 Tree DFS (Global Variable Pattern - Advanced)
>
> **Difficulty:** Hard | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very Common (Famous!)

---

## Problem Statement

A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.

The **path sum** of a path is the sum of the node's values in the path.

Given the `root` of a binary tree, return the **maximum path sum** of any **non-empty** path.

```
Input: root = [-10,9,20,null,null,15,7]
       -10
       /  \
      9    20
          /  \
         15   7

Output: 42 (path: 15 ‚Üí 20 ‚Üí 7)
```

```
Input: root = [1,2,3]
      1
     / \
    2   3

Output: 6 (path: 2 ‚Üí 1 ‚Üí 3)
```

[LeetCode 124 - Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Maximum path sum" in tree
- Path can start/end anywhere
- Path doesn't need to go through root

**Key insight:**
This is like [Diameter of Binary Tree](../04-Tree-Properties/4.3-Diameter-of-Tree.md) but with values instead of edges.

At each node, we consider:
1. The path sum **through** this node (left + node + right)
2. But we can only **return** one branch to parent (path can't fork)

Uses **global variable pattern** to track maximum across all nodes.

</details>

---

## ‚úÖ When to Use

- Maximum path value in tree
- Path can be any node sequence
- Need to consider all possible paths

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Root-to-leaf paths only | Different constraint | Path Sum problems |
| Find the actual path | Just need value | Path tracking |
| All values positive | Same algo works | Same solution |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Diameter of Binary Tree](../04-Tree-Properties/4.3-Diameter-of-Tree.md) - Same pattern, simpler
- [Maximum Depth](../04-Tree-Properties/4.1-Maximum-Depth.md) - Postorder basics

**After mastering this:**
- [Longest Univalue Path](https://leetcode.com/problems/longest-univalue-path/)
- [House Robber III](https://leetcode.com/problems/house-robber-iii/)

**Similar pattern:**
- Any "maximize across all nodes" problem

</details>

---

## üìê How It Works

### Two Values at Each Node

For each node, we calculate:

1. **Max path through this node** (for global answer):
   ```
   path_through = max(0, left_gain) + node.val + max(0, right_gain)
   ```
   This can use BOTH branches.

2. **Max gain to return to parent** (for continuing path):
   ```
   gain_to_parent = node.val + max(0, max(left_gain, right_gain))
   ```
   Can only use ONE branch (path can't fork at parent).

### Why max(0, gain)?

If a branch has negative sum, don't include it! We can just "cut" that branch.

### Visualization

```
       -10                path_through(-10) = 9 + (-10) + 42 = 41
       /  \               gain_to_parent(-10) = -10 + max(9, 42) = 32
      9    20
          /  \            path_through(20) = 15 + 20 + 7 = 42 ‚Üê max!
         15   7           gain_to_parent(20) = 20 + max(15, 7) = 35

At each node:
- Update global max with path_through
- Return gain_to_parent for parent to use
```

---

## üíª Code Implementation

### Solution 1: Global Variable Pattern

**Python:**
```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def max_path_sum(root: Optional[TreeNode]) -> int:
    """
    Maximum path sum in binary tree.
    
    At each node:
    - Update global max with path through this node
    - Return max gain to parent (can only take one branch)
    
    Time: O(n), Space: O(h)
    """
    max_sum = float('-inf')  # Global maximum
    
    def max_gain(node):
        """Return max gain from this subtree to parent."""
        nonlocal max_sum
        
        if not node:
            return 0
        
        # Get max gain from each subtree (ignore negative gains)
        left_gain = max(0, max_gain(node.left))
        right_gain = max(0, max_gain(node.right))
        
        # Path through this node (using both branches)
        path_through = left_gain + node.val + right_gain
        
        # Update global maximum
        max_sum = max(max_sum, path_through)
        
        # Return max gain to parent (can only take one branch)
        return node.val + max(left_gain, right_gain)
    
    max_gain(root)
    return max_sum
```

**JavaScript:**
```javascript
function maxPathSum(root) {
    let maxSum = -Infinity;
    
    function maxGain(node) {
        if (!node) return 0;
        
        // Ignore negative gains
        const leftGain = Math.max(0, maxGain(node.left));
        const rightGain = Math.max(0, maxGain(node.right));
        
        // Path through this node
        const pathThrough = leftGain + node.val + rightGain;
        
        // Update global max
        maxSum = Math.max(maxSum, pathThrough);
        
        // Return gain to parent (one branch only)
        return node.val + Math.max(leftGain, rightGain);
    }
    
    maxGain(root);
    return maxSum;
}
```

### Solution 2: Return Tuple (No Global)

**Python:**
```python
def max_path_sum_tuple(root: Optional[TreeNode]) -> int:
    """
    Alternative: Return (max_gain, max_path) tuple.
    Avoids global variable.
    """
    def dfs(node):
        """Returns (max_gain_to_parent, max_path_in_subtree)"""
        if not node:
            return (0, float('-inf'))
        
        left_gain, left_max = dfs(node.left)
        right_gain, right_max = dfs(node.right)
        
        # Ignore negative gains
        left_gain = max(0, left_gain)
        right_gain = max(0, right_gain)
        
        # Path through this node
        path_through = left_gain + node.val + right_gain
        
        # Max path in subtree
        max_path = max(path_through, left_max, right_max)
        
        # Gain to parent
        gain = node.val + max(left_gain, right_gain)
        
        return (gain, max_path)
    
    _, result = dfs(root)
    return result
```

### Solution 3: Class-Based (Common LeetCode Style)

**Python:**
```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        self.max_sum = float('-inf')
        
        def max_gain(node):
            if not node:
                return 0
            
            left = max(0, max_gain(node.left))
            right = max(0, max_gain(node.right))
            
            self.max_sum = max(self.max_sum, left + node.val + right)
            
            return node.val + max(left, right)
        
        max_gain(root)
        return self.max_sum
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Global Variable |" O(n) "| O(h) | Single traversal |
| Tuple Return |" O(n) "| O(h) | Same complexity |

**Why O(n)?**
- Visit each node exactly once
- O(1) work at each node

---

## üîÑ Variations

| Variation | Difference | LeetCode |
|-----------|------------|----------|
| Diameter of Tree | Count edges, not values | LC 543 |
| Longest Univalue Path | Same value constraint | LC 687 |
| House Robber III | Can't take adjacent nodes | LC 337 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Ignoring Negative Gains

```python
# ‚ùå WRONG: Always including branches
left_gain = max_gain(node.left)
right_gain = max_gain(node.right)
path_through = left_gain + node.val + right_gain

# If left is -100, we're making path worse!

# ‚úÖ CORRECT: Ignore negative branches
left_gain = max(0, max_gain(node.left))
right_gain = max(0, max_gain(node.right))
```

### 2. Returning Path Through (Both Branches) to Parent

```python
# ‚ùå WRONG: Returning path that uses both branches
return left_gain + node.val + right_gain
# Parent can't use a path that already forks!

# ‚úÖ CORRECT: Return one branch only
return node.val + max(left_gain, right_gain)
```

### 3. Wrong Initial Value for Max

```python
# ‚ùå WRONG: Starting with 0
max_sum = 0  # All nodes could be negative!

# ‚úÖ CORRECT: Start with negative infinity
max_sum = float('-inf')
```

### 4. Confusing What to Track vs Return

```python
# At each node:
# TRACK (for global answer): path_through = left + node + right (uses both)
# RETURN (to parent): gain = node + max(left, right) (uses one)

# These are DIFFERENT! Don't mix them up.
```

---

## üìù Practice Problems

### This Problem
- [ ] [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/) - LC 124

### Similar Pattern
- [ ] [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) - LC 543 (Easier)
- [ ] [Longest Univalue Path](https://leetcode.com/problems/longest-univalue-path/) - LC 687
- [ ] [House Robber III](https://leetcode.com/problems/house-robber-iii/) - LC 337

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Understand the two values (path_through vs gain)
**Day 3:** Implement from scratch
**Day 7:** Solve Diameter first, then this
**Day 14:** Explain why we return one branch

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Explaining the insight:**
> "At each node, I need to track two things: the max path that goes THROUGH this node (using both branches), and the max gain I can offer to my PARENT (using only one branch, since paths can't fork)."

**Why two different values:**
> "A path through me can use both left and right. But if my parent wants to include me in their path, they can only continue in one direction - so I return my best single-branch gain."

**Handling negatives:**
> "If a branch contributes negative sum, I just don't take it - that's why I use max(0, branch_gain). A path of just the current node is valid."

**Comparing to Diameter:**
> "This is like Diameter but with values. Diameter returns depth and tracks edges; this returns gain and tracks sums. Same pattern of 'update global, return to parent.'"

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Favorite hard problem |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Classic interview |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Often asked |
| Apple | ‚≠ê‚≠ê‚≠ê‚≠ê | Common question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 3-5 min | Path definitions |
| Implement solution | 15-20 min | Hard problem |
| Explain approach | 5 min | Two values concept |

---

> **üí° Key Insight:** The core insight is distinguishing between "path through this node" (can use both branches, for global answer) and "gain to parent" (can only use one branch, for continuing the path). This pattern - tracking a global maximum while returning something different - appears in many tree problems.

---

## üîó Related

- [Diameter of Binary Tree](../04-Tree-Properties/4.3-Diameter-of-Tree.md)
- [Path Sum](./5.1-Path-Sum.md)
- [DFS - Global Variable Pattern](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
