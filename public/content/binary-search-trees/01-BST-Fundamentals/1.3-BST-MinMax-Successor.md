# 1.3 BST Min/Max and Successor/Predecessor

## Overview

Understanding how to navigate to minimum, maximum, successor, and predecessor in a BST is fundamental. These operations form the building blocks for more complex BST algorithms like deletion, range queries, and iterators.

```
Example BST:
              20
            /    \
          10      30
         /  \    /  \
        5   15  25   35
           /  \
          12  17

Min: 5 (leftmost)
Max: 35 (rightmost)
Successor of 15: 17 (smallest value > 15)
Predecessor of 25: 20 (largest value < 25)
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Successor/Predecessor Problems</strong></summary>

**Look for these signals:**
- "Find the next larger/smaller element"
- "In-order successor/predecessor"
- "Delete a node from BST" (needs successor for replacement)
- "Closest values to target"
- "Iterator with next() operation"

**Keywords in problem statement:**
- "successor", "predecessor"
- "next greater", "next smaller"
- "closest", "nearest"
- "delete node" (successor needed)

</details>

---

## ‚úÖ When to Use

| Operation | Use Case |
|-----------|----------|
| Find Min/Max | Priority queue operations, range endpoints |
| Inorder Successor | BST deletion, iterator implementation |
| Inorder Predecessor | Reverse iterator, floor queries |
| Both together | Closest value problems, median tracking |

## ‚ùå When NOT to Use

| Scenario | Why Not | Better Approach |
|----------|---------|-----------------|
| Need k-th smallest |" Successor loop is O(k¬∑h) "| Inorder traversal or augmented BST |
| Unsorted tree | These only work for BSTs | General tree traversal |
| Frequent successor calls |" O(h) each time "| Morris traversal or threaded BST |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Definition](./1.1-BST-Definition.md) - Core BST property
- [BST Properties](./1.2-BST-Properties.md) - Min at leftmost, max at rightmost

**After mastering this:**
- [BST Delete](../02-BST-Operations/2.3-BST-Delete-LC450.md) - Uses successor for replacement
- [BST Iterator](../04-Inorder-Property/4.2-BST-Iterator-LC173.md) - Controlled successor calls
- [Inorder Successor (LC 285)](../02-BST-Operations/2.4-Inorder-Successor-LC285.md)

**Combines with:**
- Parent pointers for O(h) successor without root
- Stack-based iteration for memory-efficient successor

</details>

---

## üìê How It Works

### Finding Minimum (Leftmost Node)

```
        20
       /
      10        ‚Üê Go left
     /
    5           ‚Üê No left child = MINIMUM
```

**Algorithm:** Start at root, keep going left until null.

### Finding Maximum (Rightmost Node)

```
        20
          \
           30      ‚Üê Go right
             \
              35   ‚Üê No right child = MAXIMUM
```

**Algorithm:** Start at root, keep going right until null.

### Inorder Successor (Next Larger Value)

**Case 1: Node has right subtree ‚Üí Successor is leftmost in right subtree**

```
Finding successor of 10:
              20
            /    \
          10      30     10 has right subtree
         /  \
        5   15           Go to right child (15)
           /             Then go leftmost
          12             12 is successor of 10!
```

**Case 2: Node has no right subtree ‚Üí Successor is first ancestor where node is in left subtree**

```
Finding successor of 17:
              20     ‚Üê Successor! (17 is in left subtree of 20)
            /
          10
            \
             15
               \
                17   ‚Üê Start here, no right child
                
Walk up: 17‚Üí15 (17 is right child, keep going)
        15‚Üí10 (15 is right child, keep going)
        10‚Üí20 (10 is left child, FOUND!)
```

### Inorder Predecessor (Next Smaller Value)

**Case 1: Node has left subtree ‚Üí Predecessor is rightmost in left subtree**

```
Finding predecessor of 20:
              20         20 has left subtree
            /    \
          10      30     Go to left child (10)
         /  \            Then go rightmost
        5   15
              \
               17        17 is predecessor of 20!
```

**Case 2: Node has no left subtree ‚Üí Predecessor is first ancestor where node is in right subtree**

```
Finding predecessor of 25:
              20     ‚Üê Predecessor! (25 is in right subtree of 20)
                \
                 30
                /
               25    ‚Üê Start here, no left child
```

---

## üíª Code Implementation

### Find Min and Max

**Python:**
```python
def find_min(root: TreeNode) -> TreeNode:
    """Find node with minimum value in BST.
    
    Time: O(h), Space: O(1)
    Returns the node, not just the value.
    """
    if not root:
        return None
    
    while root.left:
        root = root.left
    return root

def find_max(root: TreeNode) -> TreeNode:
    """Find node with maximum value in BST.
    
    Time: O(h), Space: O(1)
    """
    if not root:
        return None
    
    while root.right:
        root = root.right
    return root
```

**JavaScript:**
```javascript
function findMin(root) {
    // Find node with minimum value - O(h) time
    if (!root) return null;
    
    while (root.left) {
        root = root.left;
    }
    return root;
}

function findMax(root) {
    // Find node with maximum value - O(h) time
    if (!root) return null;
    
    while (root.right) {
        root = root.right;
    }
    return root;
}
```

### Inorder Successor (Without Parent Pointer)

**Python:**
```python
def inorder_successor(root: TreeNode, target: TreeNode) -> TreeNode:
    """Find inorder successor of target node.
    
    Approach: Search from root, track potential successor.
    Time: O(h), Space: O(1)
    
    Key insight: Successor is either:
    1. Leftmost node in right subtree (if right exists)
    2. Lowest ancestor for which target is in left subtree
    """
    successor = None
    current = root
    
    while current:
        if target.val < current.val:
            # Current could be successor, go left to find smaller
            successor = current
            current = current.left
        else:
            # Target >= current, successor must be in right subtree
            current = current.right
    
    return successor

# Alternative: If you have the target node directly
def successor_from_node(root: TreeNode, target: TreeNode) -> TreeNode:
    """Find successor when you have direct reference to target."""
    # Case 1: Right subtree exists ‚Üí leftmost in right
    if target.right:
        return find_min(target.right)
    
    # Case 2: No right subtree ‚Üí search from root
    successor = None
    current = root
    
    while current:
        if target.val < current.val:
            successor = current
            current = current.left
        elif target.val > current.val:
            current = current.right
        else:
            # Found target, successor is already tracked
            break
    
    return successor
```

**JavaScript:**
```javascript
function inorderSuccessor(root, target) {
    // Find inorder successor of target node
    // Time: O(h), Space: O(1)
    let successor = null;
    let current = root;
    
    while (current) {
        if (target.val < current.val) {
            // Current could be successor
            successor = current;
            current = current.left;
        } else {
            // Target >= current, go right
            current = current.right;
        }
    }
    
    return successor;
}

function successorFromNode(root, target) {
    // Case 1: Right subtree exists
    if (target.right) {
        return findMin(target.right);
    }
    
    // Case 2: Search from root
    let successor = null;
    let current = root;
    
    while (current) {
        if (target.val < current.val) {
            successor = current;
            current = current.left;
        } else if (target.val > current.val) {
            current = current.right;
        } else {
            break;  // Found target
        }
    }
    
    return successor;
}
```

### Inorder Predecessor

**Python:**
```python
def inorder_predecessor(root: TreeNode, target: TreeNode) -> TreeNode:
    """Find inorder predecessor of target node.
    
    Mirror logic of successor:
    1. If left subtree exists ‚Üí rightmost in left
    2. Otherwise ‚Üí lowest ancestor where target is in right subtree
    
    Time: O(h), Space: O(1)
    """
    predecessor = None
    current = root
    
    while current:
        if target.val > current.val:
            # Current could be predecessor, go right to find larger
            predecessor = current
            current = current.right
        else:
            # Target <= current, predecessor must be in left subtree
            current = current.left
    
    return predecessor

def predecessor_from_node(root: TreeNode, target: TreeNode) -> TreeNode:
    """Find predecessor when you have direct reference to target."""
    # Case 1: Left subtree exists ‚Üí rightmost in left
    if target.left:
        return find_max(target.left)
    
    # Case 2: No left subtree ‚Üí search from root
    predecessor = None
    current = root
    
    while current:
        if target.val > current.val:
            predecessor = current
            current = current.right
        elif target.val < current.val:
            current = current.left
        else:
            break
    
    return predecessor
```

**JavaScript:**
```javascript
function inorderPredecessor(root, target) {
    // Find inorder predecessor - mirror of successor
    let predecessor = null;
    let current = root;
    
    while (current) {
        if (target.val > current.val) {
            predecessor = current;
            current = current.right;
        } else {
            current = current.left;
        }
    }
    
    return predecessor;
}

function predecessorFromNode(root, target) {
    // Case 1: Left subtree exists
    if (target.left) {
        return findMax(target.left);
    }
    
    // Case 2: Search from root
    let predecessor = null;
    let current = root;
    
    while (current) {
        if (target.val > current.val) {
            predecessor = current;
            current = current.right;
        } else if (target.val < current.val) {
            current = current.left;
        } else {
            break;
        }
    }
    
    return predecessor;
}
```

### With Parent Pointer (Simpler for Successor)

**Python:**
```python
def successor_with_parent(node: TreeNode) -> TreeNode:
    """Find successor when nodes have parent pointers.
    
    Assumes node.parent exists.
    Time: O(h), Space: O(1)
    """
    # Case 1: Right subtree exists
    if node.right:
        return find_min(node.right)
    
    # Case 2: Walk up until we're a left child
    parent = node.parent
    while parent and node == parent.right:
        node = parent
        parent = parent.parent
    
    return parent  # Could be None if node was max
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Find Min |" O(h) "| O(1) | Follow left pointers |
| Find Max |" O(h) "| O(1) | Follow right pointers |
| Successor |" O(h) "| O(1) | At most 2 traversals |
| Predecessor |" O(h) "| O(1) | Mirror of successor |
| With parent ptr |" O(h) "| O(1) | May need to walk up |

**Height Considerations:**

| Tree Shape | Height h | Operations |
|------------|----------|------------|
| Balanced |" O(log n) "| All operations O(log n) |
| Skewed |" O(n) "| All operations O(n) |
| Random |" O(log n) expected "| Average case good |

---

## üîÑ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| **K successors** | Find next k elements | Range iteration |
| **Closest to target** | Both predecessor & successor | Nearest neighbor |
| **Floor/Ceiling** | Largest ‚â§ target, Smallest ‚â• target | Approximate search |
| **With parent pointer** |" O(h) without root access "| Iterator implementation |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting Edge Cases for Successor

```python
# ‚ùå Wrong: Not handling when target is maximum
def successor(root, target):
    # ... search logic
    return successor  # Could be None!

# ‚úÖ Correct: Explicitly handle None case
def successor(root, target):
    result = search_successor(root, target)
    if result is None:
        print("Target is the maximum value")
    return result
```

### 2. Confusing the Two Cases

```python
# ‚ùå Wrong: Always looking in right subtree
def successor(root, target):
    return find_min(target.right)  # Fails if no right subtree!

# ‚úÖ Correct: Handle both cases
def successor(root, target):
    if target.right:
        return find_min(target.right)
    else:
        return search_ancestor(root, target)
```

### 3. Off-by-One in Comparison

```python
# ‚ùå Wrong: Using <= instead of <
while current:
    if target.val <= current.val:  # Includes equal!
        successor = current
        current = current.left

# ‚úÖ Correct: Strict less than
while current:
    if target.val < current.val:  # Successor must be strictly greater
        successor = current
        current = current.left
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)
- [ ] [Search in BST (LC 700)](https://leetcode.com/problems/search-in-a-binary-search-tree/) - Basic navigation
- [ ] [Minimum Distance Between BST Nodes (LC 783)](https://leetcode.com/problems/minimum-distance-between-bst-nodes/) - Adjacent values

### Medium (Apply variations)
- [ ] [Inorder Successor in BST (LC 285)](https://leetcode.com/problems/inorder-successor-in-bst/) - Core concept
- [ ] [Delete Node in BST (LC 450)](https://leetcode.com/problems/delete-node-in-a-bst/) - Uses successor
- [ ] [BST Iterator (LC 173)](https://leetcode.com/problems/binary-search-tree-iterator/) - Controlled next()
- [ ] [Closest BST Value (LC 270)](https://leetcode.com/problems/closest-binary-search-tree-value/) - Predecessor + successor

### Hard (Master edge cases)
- [ ] [Closest BST Value II (LC 272)](https://leetcode.com/problems/closest-binary-search-tree-value-ii/) - K closest using both

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

After learning successor/predecessor:
- **Day 1:** Draw the two cases on paper
- **Day 3:** Implement successor without looking
- **Day 7:** Solve LC 285 (Inorder Successor)
- **Day 14:** Implement BST delete (uses successor)
- **Day 30:** Solve LC 173 (BST Iterator)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**When explaining:**
- "To find the successor, there are two cases: with or without a right subtree"
- "If there's a right subtree, successor is the leftmost node in that subtree"
- "Otherwise, I walk up to find the first ancestor where the node is in the left subtree"

**Common interview questions:**
- "Why is successor useful?" ‚Üí BST deletion, iterators
- "What's the time complexity?" ‚Üí O(h), mention balanced vs skewed
- "Can you do it without root access?" ‚Üí Need parent pointers

**Red flags to avoid:**
- ‚ùå Doing inorder traversal to find successor (O(n) instead of O(h))
- ‚ùå Forgetting the "no right subtree" case
- ‚ùå Not handling edge cases (max element has no successor)

</details>

**Company Focus:**

| Company | Frequency | Focus |
|---------|-----------|-------|
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | LC 285 is common |
| Amazon | ‚≠ê‚≠ê‚≠ê | BST deletion |
| Google | ‚≠ê‚≠ê‚≠ê | Iterator pattern |
| Meta | ‚≠ê‚≠ê | Combined with other patterns |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand min/max | 10 min | Simple concept |
| Understand successor cases | 20-25 min | Draw both cases |
| Implement successor | 15-20 min | First time |
| Solve LC 285 | 20-25 min | After understanding |
| Master pattern | 1-2 hours | Multiple problems |

---

## üí° Key Insight

> **Successor and predecessor are the "next" and "previous" in sorted order.** Since BST encodes sorted order spatially, finding next/previous is just navigating the tree structure ‚Äî either into a subtree or up to an ancestor.

---

## üîó Related

- **Previous:** [1.2 BST Properties](./1.2-BST-Properties.md)
- **Next:** [1.4 BST vs Binary Tree Comparison](./1.4-BST-vs-Trees.md)
- **Apply:** [LC 285 Inorder Successor](../02-BST-Operations/2.4-Inorder-Successor-LC285.md)
- **Apply:** [LC 450 Delete Node](../02-BST-Operations/2.3-BST-Delete-LC450.md)
