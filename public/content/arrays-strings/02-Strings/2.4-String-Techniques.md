# 2.4 String Techniques

> **Apply array patterns to strings with character-specific optimizations**  
> **Key patterns:** Two Pointers, Sliding Window, Frequency Counting

---

## Overview

Strings are essentially character arrays. Most array techniques apply directly, but strings have unique properties (immutability, character set constraints) that enable specific optimizations.

---

## üéØ Pattern Recognition for Strings

```mermaid
flowchart TD
    A[String Problem?] --> B{What are we looking for?}
    B -->|Palindrome/Reverse| C[Two Pointers]
    B -->|Substring with property| D[Sliding Window]
    B -->|Anagram/Frequency| E[Hash Map / Array[26]]
    B -->|Pattern in text| F[Pattern Matching KMP/etc]
    B -->|Comparison| G[Sort or Hash]
    
    style C fill:#90EE90
    style D fill:#87CEEB
    style E fill:#FFD700
```

---

## üîÑ Two Pointers on Strings

### Palindrome Check

```python
def is_palindrome(s: str) -> bool:
    """Check if string is palindrome (alphanumeric only).
    
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(s) - 1
    
    while left < right:
        # Skip non-alphanumeric
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True


# Examples
print(is_palindrome("A man, a plan, a canal: Panama"))  # True
print(is_palindrome("race a car"))  # False
```

```javascript
function isPalindrome(s) {
    let left = 0, right = s.length - 1;
    
    while (left < right) {
        while (left < right && !isAlphanumeric(s[left])) left++;
        while (left < right && !isAlphanumeric(s[right])) right--;
        
        if (s[left].toLowerCase() !== s[right].toLowerCase()) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

function isAlphanumeric(char) {
    return /[a-zA-Z0-9]/.test(char);
}
```

### String Reversal (In-Place for Char Array)

```python
def reverse_string(s: list[str]) -> None:
    """Reverse string in-place.
    
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(s) - 1
    
    while left < right:
        s[left], s[right] = s[right], s[left]
        left += 1
        right -= 1


# For immutable strings, create list first
s = "hello"
chars = list(s)
reverse_string(chars)
result = ''.join(chars)  # "olleh"
```

### Reverse Words in String

```python
def reverse_words(s: str) -> str:
    """Reverse words in string.
    
    Input:  "the sky is blue"
    Output: "blue is sky the"
    
    Time: O(n), Space: O(n)
    """
    # Split, reverse, join
    words = s.split()
    return ' '.join(reversed(words))


# In-place approach (for char array)
def reverse_words_inplace(s: list[str]) -> None:
    """
    1. Reverse entire string
    2. Reverse each word
    """
    def reverse(arr, left, right):
        while left < right:
            arr[left], arr[right] = arr[right], arr[left]
            left += 1
            right -= 1
    
    # Remove extra spaces and convert
    n = len(s)
    
    # Reverse entire string
    reverse(s, 0, n - 1)
    
    # Reverse each word
    start = 0
    for i in range(n + 1):
        if i == n or s[i] == ' ':
            reverse(s, start, i - 1)
            start = i + 1
```

---

## üìä Sliding Window on Strings

### Longest Substring Without Repeating Characters

```python
def length_of_longest_substring(s: str) -> int:
    """Find length of longest substring without repeating chars.
    
    Time: O(n), Space: O(min(n, 26)) = O(1) for lowercase
    """
    char_index = {}  # char ‚Üí last seen index
    max_length = 0
    left = 0
    
    for right, char in enumerate(s):
        # If char seen and within current window
        if char in char_index and char_index[char] >= left:
            left = char_index[char] + 1  # Shrink window
        
        char_index[char] = right
        max_length = max(max_length, right - left + 1)
    
    return max_length


# Examples
print(length_of_longest_substring("abcabcbb"))  # 3 ("abc")
print(length_of_longest_substring("bbbbb"))     # 1 ("b")
print(length_of_longest_substring("pwwkew"))    # 3 ("wke")
```

```javascript
function lengthOfLongestSubstring(s) {
    const charIndex = new Map();
    let maxLength = 0;
    let left = 0;
    
    for (let right = 0; right < s.length; right++) {
        const char = s[right];
        
        if (charIndex.has(char) && charIndex.get(char) >= left) {
            left = charIndex.get(char) + 1;
        }
        
        charIndex.set(char, right);
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}
```

### Find All Anagrams in String

```python
def find_anagrams(s: str, p: str) -> list[int]:
    """Find all start indices of p's anagrams in s.
    
    Time: O(n), Space: O(1) - only 26 letters
    """
    if len(p) > len(s):
        return []
    
    from collections import Counter
    
    p_count = Counter(p)
    window_count = Counter(s[:len(p)])
    
    result = []
    if window_count == p_count:
        result.append(0)
    
    # Slide window
    for i in range(len(p), len(s)):
        # Add new char
        window_count[s[i]] += 1
        
        # Remove old char
        old_char = s[i - len(p)]
        window_count[old_char] -= 1
        if window_count[old_char] == 0:
            del window_count[old_char]
        
        # Check if anagram
        if window_count == p_count:
            result.append(i - len(p) + 1)
    
    return result


# Example
print(find_anagrams("cbaebabacd", "abc"))  # [0, 6]
```

### Minimum Window Substring

```python
def min_window(s: str, t: str) -> str:
    """Find minimum window in s containing all chars of t.
    
    Time: O(n), Space: O(m) where m = unique chars in t
    """
    if not s or not t:
        return ""
    
    from collections import Counter
    
    t_count = Counter(t)
    required = len(t_count)  # Unique chars needed
    
    left = 0
    formed = 0  # Unique chars in window with desired count
    window_count = {}
    
    min_len = float('inf')
    min_left = 0
    
    for right, char in enumerate(s):
        # Add char to window
        window_count[char] = window_count.get(char, 0) + 1
        
        # Check if char satisfies requirement
        if char in t_count and window_count[char] == t_count[char]:
            formed += 1
        
        # Try to shrink window
        while formed == required:
            # Update minimum
            if right - left + 1 < min_len:
                min_len = right - left + 1
                min_left = left
            
            # Remove left char
            left_char = s[left]
            window_count[left_char] -= 1
            if left_char in t_count and window_count[left_char] < t_count[left_char]:
                formed -= 1
            left += 1
    
    return s[min_left:min_left + min_len] if min_len != float('inf') else ""


# Example
print(min_window("ADOBECODEBANC", "ABC"))  # "BANC"
```

---

## üî¢ Frequency Counting

### Using Array[26] (Lowercase Letters Only)

More efficient than hash map when only dealing with lowercase letters.

```python
def is_anagram(s: str, t: str) -> bool:
    """Check if t is anagram of s using fixed array.
    
    Time: O(n), Space: O(1) - always 26 slots
    """
    if len(s) != len(t):
        return False
    
    count = [0] * 26
    
    for i in range(len(s)):
        count[ord(s[i]) - ord('a')] += 1
        count[ord(t[i]) - ord('a')] -= 1
    
    return all(c == 0 for c in count)


# Example
print(is_anagram("anagram", "nagaram"))  # True
print(is_anagram("rat", "car"))          # False
```

```javascript
function isAnagram(s, t) {
    if (s.length !== t.length) return false;
    
    const count = new Array(26).fill(0);
    const aCode = 'a'.charCodeAt(0);
    
    for (let i = 0; i < s.length; i++) {
        count[s.charCodeAt(i) - aCode]++;
        count[t.charCodeAt(i) - aCode]--;
    }
    
    return count.every(c => c === 0);
}
```

### Group Anagrams

```python
def group_anagrams(strs: list[str]) -> list[list[str]]:
    """Group strings that are anagrams of each other.
    
    Time: O(n * k log k) with sorting, O(n * k) with counting
    Space: O(n * k)
    """
    from collections import defaultdict
    
    groups = defaultdict(list)
    
    for s in strs:
        # Option 1: Sorted string as key
        key = tuple(sorted(s))
        
        # Option 2: Character count as key (faster for long strings)
        # count = [0] * 26
        # for c in s:
        #     count[ord(c) - ord('a')] += 1
        # key = tuple(count)
        
        groups[key].append(s)
    
    return list(groups.values())


# Example
print(group_anagrams(["eat", "tea", "tan", "ate", "nat", "bat"]))
# [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]
```

### First Unique Character

```python
def first_uniq_char(s: str) -> int:
    """Find index of first non-repeating character.
    
    Time: O(n), Space: O(1)
    """
    count = [0] * 26
    
    # Count frequencies
    for c in s:
        count[ord(c) - ord('a')] += 1
    
    # Find first with count 1
    for i, c in enumerate(s):
        if count[ord(c) - ord('a')] == 1:
            return i
    
    return -1


# Example
print(first_uniq_char("leetcode"))  # 0 ('l')
print(first_uniq_char("loveleetcode"))  # 2 ('v')
```

---

## ‚úÇÔ∏è String Building Efficiently

### Avoid String Concatenation in Loops

```python
# ‚ùå SLOW: O(n¬≤) - creates new string each iteration
result = ""
for char in chars:
    result += char

# ‚úÖ FAST: O(n) - single join at end
result = ''.join(chars)

# ‚úÖ FAST: Build list, then join
parts = []
for char in chars:
    parts.append(char)
result = ''.join(parts)
```

```javascript
// ‚ùå SLOW in some engines
let result = "";
for (const char of chars) {
    result += char;
}

// ‚úÖ FAST: Use array join
const parts = [];
for (const char of chars) {
    parts.push(char);
}
const result = parts.join('');
```

### StringBuilder Pattern (for complex building)

```python
class StringBuilder:
    """Efficient string building for Python."""
    
    def __init__(self):
        self.parts = []
    
    def append(self, s: str) -> 'StringBuilder':
        self.parts.append(s)
        return self
    
    def __str__(self) -> str:
        return ''.join(self.parts)


# Usage
sb = StringBuilder()
sb.append("Hello").append(" ").append("World")
result = str(sb)  # "Hello World"
```

---

## üî† Case Conversion and Character Checks

```python
# Character checks
char.isalpha()    # Letter?
char.isdigit()    # Digit?
char.isalnum()    # Letter or digit?
char.isspace()    # Whitespace?
char.isupper()    # Uppercase?
char.islower()    # Lowercase?

# Case conversion
char.upper()      # To uppercase
char.lower()      # To lowercase

# ASCII manipulation
ord('A')          # 65
chr(65)           # 'A'

# Convert case manually
def to_lower(c):
    if 'A' <= c <= 'Z':
        return chr(ord(c) + 32)
    return c

def to_upper(c):
    if 'a' <= c <= 'z':
        return chr(ord(c) - 32)
    return c
```

```javascript
// Character checks
/[a-zA-Z]/.test(char)   // Letter?
/[0-9]/.test(char)      // Digit?
/[a-zA-Z0-9]/.test(char) // Alphanumeric?
/\s/.test(char)         // Whitespace?

// Case conversion
char.toUpperCase()
char.toLowerCase()

// ASCII
char.charCodeAt(0)      // Get code
String.fromCharCode(65) // 'A'
```

---

## ‚úÖ When to Use String Techniques

- **Palindrome checking** ‚Üí Two Pointers from both ends
- **Substring with constraint** ‚Üí Sliding Window
- **Anagram/frequency problems** ‚Üí Hash Map or Array[26]
- **In-place reversal** ‚Üí Two Pointers with char array
- **Character set tracking** ‚Üí Sliding Window + Hash Map

## ‚ùå When NOT to Use

| Situation | Why | Use Instead |
|-----------|-----|-------------|
| Pattern matching | Need exact substring location | KMP, Rabin-Karp |
| Prefix-based search | Many strings with common prefix | Trie |
| Edit distance | Need similarity metric | Dynamic Programming |
| Regular expressions | Complex patterns | Regex library |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [String Basics](./2.1-String-Basics.md) - Immutability, indexing
- [Two Pointers](../01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md) - Core pattern
- [Sliding Window](../01-Arrays/1.4-Common-Techniques/02-Sliding-Window.md) - Core pattern

**After mastering this:**
- [Pattern Matching](./2.5-Pattern-Matching.md) - KMP, Rabin-Karp
- [Tries](../../13-Tries.md) - Prefix-based problems

**Combines with:**
- **Hash Maps** - For frequency counting
- **Arrays** - For O(1) space with fixed alphabet

</details>

---

## üîÑ Variations

| Technique | Variation | Example |
|-----------|-----------|---------|
| Two Pointers | Expand from center | Longest Palindromic Substring |
| Two Pointers | Skip non-alphanum | Valid Palindrome II |
| Sliding Window | Fixed size | Find Anagrams |
| Sliding Window | Variable size | Longest Substring |
| Frequency | Array[26] | Lowercase only |
| Frequency | Array[128] | ASCII characters |
| Frequency | Hash Map | Unicode/any char |

---

## ‚ö° Complexity Summary

| Technique | Time | Space | Use Case |
|-----------|------|-------|----------|
| Two Pointers |" O(n) "| O(1) | Palindrome, reverse |
| Sliding Window (fixed) |" O(n) "| O(k) | Anagrams, fixed substring |
| Sliding Window (variable) |" O(n) "| O(k) | Longest substring |
| Frequency Array[26] |" O(n) "| O(1) | Lowercase only |
| Frequency HashMap |" O(n) "| O(k) | Any character set |
| String Join |" O(n) "| O(n) | Building strings |

---

## ‚ö†Ô∏è Common Mistakes

### 1. String Concatenation in Loop

‚ùå **Wrong - O(n¬≤):**
```python
result = ""
for char in chars:
    result += char  # Creates new string each time!
```

‚úÖ **Correct - O(n):**
```python
result = ''.join(chars)
```

### 2. Forgetting Immutability

‚ùå **Wrong:**
```python
s[0] = 'X'  # TypeError!
```

‚úÖ **Correct:**
```python
s = 'X' + s[1:]  # Create new string
# Or use list
chars = list(s)
chars[0] = 'X'
s = ''.join(chars)
```

### 3. Wrong Character Comparison

‚ùå **Wrong:**
```python
if s[i] == s[j]:  # Case sensitive!
```

‚úÖ **Correct:**
```python
if s[i].lower() == s[j].lower():
```

---

## üìù Practice Problems

| Problem | Difficulty | Technique | LeetCode |
|---------|------------|-----------|----------|
| Valid Palindrome | Easy | Two Pointers | [LC 125](https://leetcode.com/problems/valid-palindrome/) |
| Reverse String | Easy | Two Pointers | [LC 344](https://leetcode.com/problems/reverse-string/) |
| Valid Anagram | Easy | Frequency Count | [LC 242](https://leetcode.com/problems/valid-anagram/) |
| First Unique Character | Easy | Frequency Count | [LC 387](https://leetcode.com/problems/first-unique-character-in-a-string/) |
| Longest Substring Without Repeating | Medium | Sliding Window | [LC 3](https://leetcode.com/problems/longest-substring-without-repeating-characters/) |
| Find All Anagrams | Medium | Sliding Window | [LC 438](https://leetcode.com/problems/find-all-anagrams-in-a-string/) |
| Group Anagrams | Medium | Hash Map | [LC 49](https://leetcode.com/problems/group-anagrams/) |
| Longest Palindromic Substring | Medium | Two Pointers (expand) | [LC 5](https://leetcode.com/problems/longest-palindromic-substring/) |
| Minimum Window Substring | Hard | Sliding Window | [LC 76](https://leetcode.com/problems/minimum-window-substring/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

After learning string techniques:
- **Day 1:** Solve Valid Palindrome and Valid Anagram
- **Day 3:** Solve Longest Substring Without Repeating
- **Day 7:** Solve Find All Anagrams without hints
- **Day 14:** Solve Minimum Window Substring
- **Day 30:** Explain all techniques to someone

</details>

---

## üé§ Interview Context

<details>
<summary><strong>What Interviewers Expect</strong></summary>

**Must-know patterns:**
- Two Pointers for palindrome
- Sliding Window for substring
- Frequency counting with Array[26]

**Common follow-ups:**
- "Can you do it in O(1) space?" ‚Üí Use Array[26] instead of Hash Map
- "What if Unicode characters?" ‚Üí Use Hash Map
- "What about case sensitivity?" ‚Üí Normalize with lower()

**Company focus:**
| Company | String Focus |
|---------|--------------|
| Amazon | Anagrams, frequency counting |
| Google | Substring problems, edge cases |
| Meta | Clean code, optimization |
| Microsoft | Fundamentals, clear logic |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn techniques | 45 min | Two Pointers + Sliding Window on strings |
| Easy problems | 10-15 min each | Build foundation |
| Medium problems | 20-25 min each | Interview standard |
| Master pattern | 6-8 problems | Until automatic |

---

## üîó Related

- [Two Pointers](../01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md)
- [Sliding Window](../01-Arrays/1.4-Common-Techniques/02-Sliding-Window.md)
- [Hash Maps](../03-Hashing/3.1-Hash-Maps.md)
- [Pattern Matching](./2.5-Pattern-Matching.md)

---

> **üí° Key Insight:** Strings are character arrays with immutability in most languages. Use `array[26]` for O(1) space when dealing with lowercase letters. Always use `.join()` instead of `+=` for string building.
