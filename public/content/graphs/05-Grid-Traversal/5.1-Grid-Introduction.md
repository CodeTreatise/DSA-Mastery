# 5.1 Grid Traversal Introduction

> **Grids are graphs in disguise - master the translation and patterns**
>
> üéØ **Interview Impact:** ~20% of all graph problems are grid-based | **Frequency:** Very High

---

## Overview

A 2D grid is just a graph where:
- **Each cell** is a node
- **Adjacent cells** (up, down, left, right) are connected edges
- **Grid values** represent node properties (land/water, colors, obstacles)

```
Grid:               Graph View:
1 0 1               (0,0)----(0,1)----(0,2)
1 1 0                 |         |         |
                    (1,0)----(1,1)----(1,2)

Nodes: m √ó n cells
Edges: ~4 √ó m √ó n (each cell has up to 4 neighbors)
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>When is a Problem Actually a Grid Graph Problem?</strong></summary>

**Strong signals:**
- 2D matrix/grid input
- Words like "adjacent", "connected", "path"
- "Flood fill", "islands", "regions", "enclosed"
- Find shortest path in maze
- Count connected components

**Keywords mapping:**
| Keyword | Pattern |
|---------|---------|
| "Count islands" | Connected components (DFS/BFS) |
| "Shortest path" | BFS |
| "All paths" | DFS/Backtracking |
| "Surrounded regions" | Boundary DFS |
| "Flood fill" | DFS/BFS from source |

</details>

---

## üìê Grid-to-Graph Translation

### Core Concepts

```python
# Grid dimensions
rows, cols = len(grid), len(grid[0])

# 4-directional movement (most common)
directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # R, L, D, U

# 8-directional movement (includes diagonals)
directions = [
    (0, 1), (0, -1), (1, 0), (-1, 0),    # Cardinal
    (1, 1), (1, -1), (-1, 1), (-1, -1)   # Diagonal
]

# Get valid neighbors
def get_neighbors(r, c):
    neighbors = []
    for dr, dc in directions:
        nr, nc = r + dr, c + dc
        if 0 <= nr < rows and 0 <= nc < cols:
            if grid[nr][nc] == valid_value:  # Optional condition
                neighbors.append((nr, nc))
    return neighbors
```

### Bounds Checking

```python
# Method 1: Explicit check
def is_valid(r, c):
    return 0 <= r < rows and 0 <= c < cols

# Method 2: In-loop check
for dr, dc in directions:
    nr, nc = r + dr, c + dc
    if not (0 <= nr < rows and 0 <= nc < cols):
        continue
    # Process valid neighbor

# Method 3: Base case in recursive function
def dfs(r, c):
    if r < 0 or r >= rows or c < 0 or c >= cols:
        return  # Out of bounds
```

---

## üíª Grid Traversal Templates

### DFS on Grid

```python
def grid_dfs(grid: list[list[int]]) -> int:
    """DFS template for grid traversal."""
    if not grid or not grid[0]:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    
    def dfs(r, c):
        # Base cases
        if r < 0 or r >= rows or c < 0 or c >= cols:
            return
        if grid[r][c] != target_value:
            return
        
        # Mark visited (modify in-place)
        grid[r][c] = visited_marker
        
        # Explore all directions
        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
            dfs(r + dr, c + dc)
    
    # Main logic
    result = 0
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == target_value:
                result += 1
                dfs(r, c)
    
    return result
```

### BFS on Grid

```python
from collections import deque

def grid_bfs(grid: list[list[int]], start: tuple) -> int:
    """BFS template for grid - useful for shortest path."""
    rows, cols = len(grid), len(grid[0])
    
    queue = deque([(*start, 0)])  # (row, col, distance)
    visited = {start}
    
    while queue:
        r, c, dist = queue.popleft()
        
        # Check if target reached
        if grid[r][c] == target:
            return dist
        
        # Explore neighbors
        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < rows and 0 <= nc < cols:
                if (nr, nc) not in visited and grid[nr][nc] != obstacle:
                    visited.add((nr, nc))
                    queue.append((nr, nc, dist + 1))
    
    return -1  # Target not reachable
```

**JavaScript:**
```javascript
function gridDFS(grid) {
    if (!grid || !grid[0]) return 0;
    
    const rows = grid.length, cols = grid[0].length;
    const directions = [[0,1], [0,-1], [1,0], [-1,0]];
    
    function dfs(r, c) {
        if (r < 0 || r >= rows || c < 0 || c >= cols) return;
        if (grid[r][c] !== 1) return;
        
        grid[r][c] = 0;  // Mark visited
        
        for (const [dr, dc] of directions) {
            dfs(r + dr, c + dc);
        }
    }
    
    let count = 0;
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (grid[r][c] === 1) {
                count++;
                dfs(r, c);
            }
        }
    }
    
    return count;
}

function gridBFS(grid, start) {
    const rows = grid.length, cols = grid[0].length;
    const directions = [[0,1], [0,-1], [1,0], [-1,0]];
    
    const queue = [[...start, 0]];  // [row, col, dist]
    const visited = new Set([`${start[0]},${start[1]}`]);
    
    while (queue.length > 0) {
        const [r, c, dist] = queue.shift();
        
        if (grid[r][c] === target) return dist;
        
        for (const [dr, dc] of directions) {
            const nr = r + dr, nc = c + dc;
            const key = `${nr},${nc}`;
            
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                if (!visited.has(key) && grid[nr][nc] !== obstacle) {
                    visited.add(key);
                    queue.push([nr, nc, dist + 1]);
                }
            }
        }
    }
    
    return -1;
}
```

---

## üîÑ Grid Problem Categories

| Category | Examples | Pattern |
|----------|----------|---------|
| **Connected Components** | Number of Islands, Friend Circles | DFS/BFS count starts |
| **Flood Fill** | Paint fill, Surrounded Regions | DFS/BFS from source |
| **Shortest Path** | Shortest Bridge, 01 Matrix | BFS |
| **Boundary Problems** | Pacific Atlantic, Surrounded | Reverse thinking |
| **Area/Perimeter** | Max Area Island, Perimeter | DFS with counting |
| **Multi-source** | Rotting Oranges, 01 Matrix | Multi-source BFS |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Mark Visited

```python
# ‚ùå Wrong: Infinite loop
def dfs(r, c):
    for dr, dc in directions:
        nr, nc = r + dr, c + dc
        if is_valid(nr, nc) and grid[nr][nc] == 1:
            dfs(nr, nc)  # Never marked visited!

# ‚úÖ Correct: Mark before recursing
def dfs(r, c):
    grid[r][c] = 0  # Mark visited FIRST
    for dr, dc in directions:
        nr, nc = r + dr, c + dc
        if is_valid(nr, nc) and grid[nr][nc] == 1:
            dfs(nr, nc)
```

### 2. Wrong Direction Array

```python
# ‚ùå Wrong: Missing directions or duplicates
directions = [(1, 1), (1, 0), (0, 1)]  # Only 3 directions + diagonal

# ‚úÖ Correct: All 4 cardinal directions
directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # R, L, D, U
```

### 3. Modifying Grid When Shouldn't

```python
# ‚ùå If problem says "don't modify input"
grid[r][c] = 0  # Modifies original

# ‚úÖ Use separate visited set
visited = set()
visited.add((r, c))
```

---

## ‚ö° Complexity Analysis

| Traversal | Time | Space |
|-----------|------|-------|
| DFS | O(m √ó n) | O(m √ó n) stack |
| BFS | O(m √ó n) | O(min(m, n)) queue |

**Why BFS space is O(min(m, n))?**
- BFS explores level by level
- Maximum queue size = diagonal of grid
- For rectangle: O(min(m, n))

**Why DFS space is O(m √ó n)?**
- Worst case: snake-shaped path visiting all cells
- Recursion depth = m √ó n

---

## ‚úÖ When to Use Which

| Situation | Use |
|-----------|-----|
| Shortest path (unweighted) | **BFS** |
| Count/find all components | DFS or BFS |
| Path exists? | DFS or BFS |
| Need path itself | DFS with backtracking |
| Memory constrained | BFS (usually smaller) |
| Simpler code | DFS (recursion) |

---

## üìù Classic Grid Problems

| Problem | Pattern | Difficulty |
|---------|---------|------------|
| Number of Islands | DFS/BFS components | Easy-Medium |
| Flood Fill | DFS/BFS from source | Easy |
| Rotting Oranges | Multi-source BFS | Medium |
| 01 Matrix | Multi-source BFS | Medium |
| Shortest Bridge | BFS + DFS combo | Medium |
| Pacific Atlantic | Boundary reverse BFS/DFS | Medium |
| Surrounded Regions | Boundary DFS | Medium |

---

> **üí° Key Insight:** A grid is just a graph with `m √ó n` nodes and `~4mn` edges. Every grid problem translates to a graph algorithm: connected components, shortest path, or flood fill.

---

**Next:** [Island Pattern ‚Üí](./5.2-Island-Pattern.md)
