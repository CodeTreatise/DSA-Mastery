# Ordered Set (TreeSet/TreeMap)

> **Self-balancing BST-based containers providing O(log n) ordered operations.**
>
> Essential for problems requiring sorted order with dynamic updates.

---

## ðŸŽ¯ When to Use

| Scenario | Why Ordered Set |
|----------|-----------------|
| Need sorted elements with insert/delete | Hash sets don't maintain order |
| Find predecessor/successor | TreeSet has floor/ceiling |
| Range queries | All elements in [a, b] |
| kth smallest with updates | Augmented BST |

---

## ðŸ“ Available Operations

### Standard Operations (O(log n))

| Operation | Java | C++ | Python |
|-----------|------|-----|--------|
| Insert | `add(x)` | `insert(x)` | `sortedcontainers.SortedList` |
| Delete | `remove(x)` | `erase(x)` | `remove(x)` |
| Contains | `contains(x)` | `count(x)` | `x in sl` |
| Floor (â‰¤ x) | `floor(x)` | `*--upper_bound(x)` | `bisect_right` |
| Ceiling (â‰¥ x) | `ceiling(x)` | `*lower_bound(x)` | `bisect_left` |
| Min | `first()` | `*begin()` | `sl[0]` |
| Max | `last()` | `*rbegin()` | `sl[-1]` |

---

## ðŸ’» Python Implementation Options

### Option 1: sortedcontainers (Recommended)

```python
from sortedcontainers import SortedList, SortedDict, SortedSet

# SortedList - allows duplicates
sl = SortedList([5, 1, 3, 2, 4])
print(sl)  # SortedList([1, 2, 3, 4, 5])

sl.add(3)      # O(log n) insert
sl.remove(2)   # O(log n) delete
print(sl[0])   # O(log n) - min element: 1
print(sl[-1])  # O(log n) - max element: 5
print(sl[2])   # O(log n) - 3rd smallest

# Binary search
idx = sl.bisect_left(3)   # First index >= 3
idx = sl.bisect_right(3)  # First index > 3

# Range queries
print(list(sl.irange(2, 4)))  # Elements in [2, 4]


# SortedSet - no duplicates
ss = SortedSet([3, 1, 2, 3])  # {1, 2, 3}


# SortedDict - ordered by keys
sd = SortedDict({'c': 3, 'a': 1, 'b': 2})
print(list(sd.keys()))  # ['a', 'b', 'c']
```

### Option 2: bisect Module (Built-in, but less efficient)

```python
import bisect

# Maintain sorted list manually
arr = []

# Insert maintaining order - O(n) due to shift
bisect.insort(arr, 5)
bisect.insort(arr, 2)
bisect.insort(arr, 8)
# arr = [2, 5, 8]

# Find insertion point - O(log n)
idx = bisect.bisect_left(arr, 5)   # 1 (first index >= 5)
idx = bisect.bisect_right(arr, 5)  # 2 (first index > 5)

# Delete - O(n)
arr.remove(5)
```

**Warning:** `bisect.insort` is O(n) due to list shifting. Only use for small data or few operations.

---

## ðŸ“Š Java/C++ Equivalents

**Java TreeSet:**
```java
TreeSet<Integer> set = new TreeSet<>();
set.add(5);
set.add(3);
set.add(8);

System.out.println(set.floor(4));    // 3 (largest â‰¤ 4)
System.out.println(set.ceiling(4));  // 5 (smallest â‰¥ 4)
System.out.println(set.first());     // 3 (min)
System.out.println(set.last());      // 8 (max)
System.out.println(set.subSet(3, 8)); // [3, 5] (range [3, 8))
```

**C++ set:**
```cpp
set<int> s;
s.insert(5);
s.insert(3);
s.insert(8);

// lower_bound: first >= x
auto it = s.lower_bound(4);  // points to 5

// upper_bound: first > x
it = s.upper_bound(4);  // points to 5

// Floor (largest <= x)
it = s.upper_bound(4);
if (it != s.begin()) {
    --it;  // points to 3
}
```

---

## ðŸ“ Common Interview Patterns

### Pattern 1: Sliding Window with Ordered Operations

```python
from sortedcontainers import SortedList

def containsNearbyAlmostDuplicate(nums, k, t):
    """
    LC 220: Check if there are indices i, j where:
    - |i - j| <= k
    - |nums[i] - nums[j]| <= t
    """
    sl = SortedList()
    
    for i, num in enumerate(nums):
        # Find closest element to num
        idx = sl.bisect_left(num)
        
        # Check neighbors within t
        if idx < len(sl) and sl[idx] - num <= t:
            return True
        if idx > 0 and num - sl[idx - 1] <= t:
            return True
        
        sl.add(num)
        
        # Maintain window size k
        if i >= k:
            sl.remove(nums[i - k])
    
    return False
```

### Pattern 2: Data Stream Median (LC 295)

```python
from sortedcontainers import SortedList

class MedianFinder:
    def __init__(self):
        self.sl = SortedList()
    
    def addNum(self, num):
        self.sl.add(num)
    
    def findMedian(self):
        n = len(self.sl)
        if n % 2 == 1:
            return self.sl[n // 2]
        return (self.sl[n // 2 - 1] + self.sl[n // 2]) / 2
```

### Pattern 3: Range Sum with Updates

```python
from sortedcontainers import SortedDict

class CountIntervals:
    """LC 2276: Count Intervals"""
    def __init__(self):
        self.intervals = SortedDict()  # start -> end
        self.count = 0
    
    def add(self, left, right):
        # Find overlapping intervals and merge
        # ... (complex merging logic)
        pass
    
    def count(self):
        return self.count
```

---

## âš¡ Complexity Comparison

| Operation | SortedList | list + bisect | set/dict |
|-----------|------------|---------------|----------|
| Insert | O(log n) | O(n) | O(1) avg |
| Delete | O(log n) | O(n) | O(1) avg |
| Contains | O(log n) | O(log n) | O(1) avg |
| Index access | O(log n) | O(1) | N/A |
| Min/Max | O(log n) | O(1) | O(n) |
| Floor/Ceiling | O(log n) | O(log n) | N/A |

---

## âš ï¸ Interview Tips

1. **Python lacks built-in TreeSet:** Mention `sortedcontainers` or implement with BST
2. **Know Java/C++ equivalents:** Interviewers may expect TreeSet/set knowledge
3. **Time-space tradeoff:** SortedList uses O(n) space

---

## ðŸ“ Practice Problems

| Problem | Difficulty | Key Technique |
|---------|------------|---------------|
| [Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/) | Hard | Sliding window + SortedList |
| [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/) | Hard | Two heaps or SortedList |
| [My Calendar I](https://leetcode.com/problems/my-calendar-i/) | Medium | SortedDict for intervals |
| [Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/) | Hard | Merge sort or SortedList |

---

> **ðŸ’¡ Key Insight:** Ordered sets fill the gap between arrays (O(1) access, O(n) insert) and hash sets (O(1) insert, no order). Use when you need both efficient updates AND order-based queries.

> **ðŸ”— Related:** [Bloom Filter â†’](./5.5-Bloom-Filter.md)
