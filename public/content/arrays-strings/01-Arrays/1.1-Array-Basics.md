# 1.1 Array Basics

> **Foundation for all array-based algorithms**  
> **Prerequisite for:** Two Pointers, Sliding Window, Binary Search

---

## What is an Array?

An **array** is a collection of elements stored at **contiguous memory locations**. Each element can be accessed directly using an **index** (position number).

> üí° *Arrays are the most fundamental data structure. Almost every coding interview starts with array problems.*

---

## üìê Memory Representation

```
Memory Address:   1000    1004    1008    1012    1016
                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
Array [5]:       ‚îÇ  10   ‚îÇ  20   ‚îÇ  30   ‚îÇ  40   ‚îÇ  50   ‚îÇ
                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Index:              0       1       2       3       4
```

**Key Properties:**
- **Contiguous:** Elements are stored next to each other in memory
- **Fixed size:** In most languages, array size is determined at creation
- **Homogeneous:** All elements are the same type (in typed languages)
- **Random access:** Any element accessible in O(1) via index calculation

**Address calculation:**
```
address(arr[i]) = base_address + (i * element_size)
```

---

## üî¢ Indexing

### 0-Based Indexing (Most Languages)

```
Array:    [A, B, C, D, E]
Index:     0  1  2  3  4
Length:   5 elements
Last:     arr[length - 1] = arr[4] = E
```

**Languages:** Python, JavaScript, C, C++, Java, Go, Rust

### 1-Based Indexing (Some Languages)

```
Array:    [A, B, C, D, E]
Index:     1  2  3  4  5
Length:   5 elements
Last:     arr[length] = arr[5] = E
```

**Languages:** MATLAB, Lua, R, Fortran

> ‚ö†Ô∏è **Interview Note:** Always assume 0-based indexing unless told otherwise.

---

## üìä Static vs Dynamic Arrays

| Feature | Static Array | Dynamic Array |
|---------|-------------|---------------|
| **Size** | Fixed at creation | Can grow/shrink |
| **Memory** | Stack (usually) | Heap |
| **Resize** | Not possible | Automatic |
| **Examples** | C arrays, Java primitive arrays | Python list, Java ArrayList, JS Array |

### Dynamic Array Growth Strategy

When a dynamic array runs out of space:
1. Allocate new array (typically 2* size)
2. Copy all elements to new array
3. Delete old array

```
Capacity: 4 ‚Üí 8 ‚Üí 16 ‚Üí 32 ‚Üí 64 ‚Üí ...

Operation:  [1, 2, 3, 4] + append(5)
            ‚Üì
Result:     [1, 2, 3, 4, 5, _, _, _]  (capacity = 8)
```

**Amortized O(1) insertion:** While individual resize is O(n), averaged over many insertions it's O(1).

---

## üíª Declaration & Initialization

### Python

```python
# List (dynamic array)
arr = []                      # Empty
arr = [1, 2, 3, 4, 5]        # With values
arr = [0] * 10               # 10 zeros
arr = [i for i in range(5)]  # [0, 1, 2, 3, 4]

# 2D array (list of lists)
matrix = [[0] * 3 for _ in range(4)]  # 4x3 matrix

# Important: WRONG way for 2D
wrong = [[0] * 3] * 4  # All rows reference same list!
```

### JavaScript

```javascript
// Array (dynamic)
let arr = [];                       // Empty
let arr = [1, 2, 3, 4, 5];         // With values
let arr = new Array(10).fill(0);   // 10 zeros
let arr = Array.from({length: 5}, (_, i) => i);  // [0,1,2,3,4]

// 2D array
let matrix = Array.from({length: 4}, () => new Array(3).fill(0));

// Important: WRONG way for 2D
let wrong = new Array(4).fill(new Array(3).fill(0)); // Same reference!
```

### Java

```java
// Primitive array (static)
int[] arr = new int[5];           // 5 zeros
int[] arr = {1, 2, 3, 4, 5};      // With values

// ArrayList (dynamic)
ArrayList<Integer> list = new ArrayList<>();
list.add(1);

// 2D array
int[][] matrix = new int[4][3];   // 4x3 matrix
```

### C++

```cpp
// Static array
int arr[5] = {1, 2, 3, 4, 5};
int arr[5] = {};  // All zeros

// Dynamic array (vector)
vector<int> vec;
vector<int> vec(10, 0);  // 10 zeros
vector<int> vec = {1, 2, 3, 4, 5};

// 2D vector
vector<vector<int>> matrix(4, vector<int>(3, 0));  // 4x3
```

---

## ‚ö° Time Complexity

| Operation | Time | Notes |
|-----------|------|-------|
| **Access by index** |" O(1) "| Direct calculation |
| **Search (unsorted)** |" O(n) "| Must check each element |
| **Search (sorted)** |" O(log n) "| Binary search |
| **Insert at end** |" O(1)* "| Amortized for dynamic arrays |
| **Insert at beginning** |" O(n) "| Shift all elements right |
| **Insert at middle** |" O(n) "| Shift elements right |
| **Delete at end** |" O(1) "| No shifting needed |
| **Delete at beginning** |" O(n) "| Shift all elements left |
| **Delete at middle** |" O(n) "| Shift elements left |
| **Update** |" O(1) "| Direct access |

> **Note:** * means amortized time complexity (averaged over many operations)

---

## üîÑ Array Traversal Patterns

### Forward Traversal

```python
# By index
for i in range(len(arr)):
    print(arr[i])

# By element (when index not needed)
for element in arr:
    print(element)

# With both index and element
for i, element in enumerate(arr):
    print(f"Index {i}: {element}")
```

### Backward Traversal

```python
# By index
for i in range(len(arr) - 1, -1, -1):
    print(arr[i])

# Using reversed()
for element in reversed(arr):
    print(element)

# Using negative indexing
for i in range(-1, -len(arr) - 1, -1):
    print(arr[i])
```

### When to Use Each

| Pattern | Use Case |
|---------|----------|
| Forward by index | Need to modify array, access adjacent elements |
| Forward by element | Read-only, simple iteration |
| Forward with enumerate | Need both index and value |
| Backward | Stack simulation, finding last occurrence |

---

## üéØ Common Operations

### Python Examples

```python
arr = [1, 2, 3, 4, 5]

# Length
len(arr)              # 5

# Access
arr[0]                # 1 (first)
arr[-1]               # 5 (last)
arr[1:3]              # [2, 3] (slice)

# Modify
arr[0] = 10           # [10, 2, 3, 4, 5]
arr.append(6)         # [10, 2, 3, 4, 5, 6]
arr.pop()             # removes and returns 6
arr.insert(1, 99)     # [10, 99, 2, 3, 4, 5]

# Search
3 in arr              # True
arr.index(3)          # 2 (first occurrence)

# Sort
arr.sort()            # In-place, ascending
sorted(arr)           # Returns new sorted array
arr.sort(reverse=True)  # Descending

# Reverse
arr.reverse()         # In-place
arr[::-1]             # Returns new reversed array
```

### JavaScript Examples

```javascript
let arr = [1, 2, 3, 4, 5];

// Length
arr.length;            // 5

// Access
arr[0];                // 1
arr[arr.length - 1];   // 5
arr.slice(1, 3);       // [2, 3]

// Modify
arr[0] = 10;
arr.push(6);           // Add to end
arr.pop();             // Remove from end
arr.unshift(0);        // Add to beginning
arr.shift();           // Remove from beginning
arr.splice(1, 0, 99);  // Insert at index 1

// Search
arr.includes(3);       // true
arr.indexOf(3);        // 2

// Sort
arr.sort((a, b) => a - b);  // Ascending (MUST use comparator!)
arr.sort((a, b) => b - a);  // Descending

// Reverse
arr.reverse();         // In-place
[...arr].reverse();    // Returns new
```

---

## üìù Quick Reference

| Operation | Python | JavaScript | Time |
|-----------|--------|------------|------|
| Length | `len(arr)` | `arr.length` |" O(1) "|
| Access | `arr[i]` | `arr[i]` |" O(1) "|
| Last element | `arr[-1]` | `arr[arr.length-1]` |" O(1) "|
| Add to end | `arr.append(x)` | `arr.push(x)` |" O(1)* "|
| Remove from end | `arr.pop()` | `arr.pop()` |" O(1) "|
| Add to start | `arr.insert(0, x)` | `arr.unshift(x)` |" O(n) "|
| Remove from start | `arr.pop(0)` | `arr.shift()` |" O(n) "|
| Check contains | `x in arr` | `arr.includes(x)` |" O(n) "|
| Find index | `arr.index(x)` | `arr.indexOf(x)` |" O(n) "|
| Slice | `arr[a:b]` | `arr.slice(a, b)` |" O(k) "|
| Sort | `arr.sort()` | `arr.sort((a,b)=>a-b)` |" O(n log n) "|
| Reverse | `arr.reverse()` | `arr.reverse()` |" O(n) "|

---

## üéØ Pattern Recognition

<details>
<summary><strong>When Array Is The Right Choice</strong></summary>

**Use arrays when you see:**
- "Given an array of integers..."
- Need O(1) random access by index
- Data size is known or bounded
- Sequential iteration required
- Need to sort or binary search

**Keywords signaling array problems:**
- "contiguous", "subarray", "consecutive"
- "in-place", "rearrange", "partition"
- "sorted array", "two sum", "target"

</details>

---

## ‚úÖ When to Use Arrays

- **Random access needed** - O(1) access by index
- **Known/bounded size** - memory can be pre-allocated
- **Sequential processing** - iterating through elements
- **Sorting/searching** - many algorithms require arrays
- **Cache efficiency** - contiguous memory is CPU-friendly

## ‚ùå When NOT to Use Arrays

| Situation | Why | Use Instead |
|-----------|-----|-------------|
| Frequent insertions/deletions in middle |" O(n) shifting "| Linked List |
| Unknown/unbounded size | Resizing overhead | Linked List / Deque |
| Need key-value pairs | Arrays only have index | Hash Map |
| Need ordered unique elements | Duplicates allowed | Set / TreeSet |
| Hierarchical data | Flat structure | Tree |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- Basic programming syntax
- Variables and data types
- Loops (for, while)

**After mastering this:**
- [Basic Operations](./1.2-Basic-Operations.md) - CRUD complexity
- [Array Traversal](./1.3-Array-Traversal.md) - Iteration patterns
- [Two Pointers](./1.4-Common-Techniques/01-Two-Pointers.md) - O(n) pair finding
- [Sliding Window](./1.4-Common-Techniques/02-Sliding-Window.md) - Subarray problems
- [Prefix Sum](./1.4-Common-Techniques/03-Prefix-Sum.md) - Range queries

**Related data structures:**
- **Linked List** - O(1) insert/delete, O(n) access
- **Hash Map** - O(1) key-based lookup
- **Stack/Queue** - Restricted access patterns

</details>

---

## üîÑ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| Static Array | Fixed size at creation | Known bounds, performance critical |
| Dynamic Array | Auto-resizing | Unknown size, Python list, JS Array |
| Typed Array | Homogeneous types | Numeric processing, memory efficiency |
| Sparse Array | Most elements are default | Large arrays with few values |
| Circular Array | Wraps around | Queue implementation, buffers |
| 2D Array | Matrix/grid | Games, image processing, DP |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Off-by-One Errors

‚ùå **Wrong:**
```python
for i in range(len(arr) + 1):  # IndexError!
    print(arr[i])
```

‚úÖ **Correct:**
```python
for i in range(len(arr)):
    print(arr[i])
```

### 2. Modifying While Iterating

‚ùå **Wrong:**
```python
for i, val in enumerate(arr):
    if val < 0:
        arr.remove(val)  # Skips elements!
```

‚úÖ **Correct:**
```python
arr = [x for x in arr if x >= 0]  # Create new list
```

### 3. JavaScript Sort Gotcha

‚ùå **Wrong:**
```javascript
[10, 2, 5].sort()  // [10, 2, 5] - lexicographic!
```

‚úÖ **Correct:**
```javascript
[10, 2, 5].sort((a, b) => a - b)  // [2, 5, 10]
```

### 4. Mutation Side Effects

‚ùå **Wrong:**
```javascript
const sorted = arr.sort();  // MUTATES arr!
```

‚úÖ **Correct:**
```javascript
const sorted = [...arr].sort((a, b) => a - b);  // Copy first
```

---

## üìù Practice Problems

| Problem | Difficulty | Focus | LeetCode |
|---------|------------|-------|----------|
| Running Sum of 1d Array | Easy | Prefix sum basics | [LC 1480](https://leetcode.com/problems/running-sum-of-1d-array/) |
| Shuffle the Array | Easy | Index manipulation | [LC 1470](https://leetcode.com/problems/shuffle-the-array/) |
| Concatenation of Array | Easy | Array creation | [LC 1929](https://leetcode.com/problems/concatenation-of-array/) |
| Build Array from Permutation | Easy | Index mapping | [LC 1920](https://leetcode.com/problems/build-array-from-permutation/) |
| Richest Customer Wealth | Easy | 2D array sum | [LC 1672](https://leetcode.com/problems/richest-customer-wealth/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

After learning array basics:
- **Day 1:** Implement array operations from scratch
- **Day 3:** Solve 2 easy problems without hints
- **Day 7:** Explain indexing and complexity to someone
- **Day 14:** Review 2D array initialization pitfalls
- **Day 30:** Quick reference table from memory

</details>

---

## üé§ Interview Context

<details>
<summary><strong>What Interviewers Expect</strong></summary>

**Foundation knowledge (expected):**
- O(1) access, O(n) search in unsorted array
- Difference between static and dynamic arrays
- 0-based indexing
- Array vs ArrayList/List distinction

**Common follow-up questions:**
- "Why is array access O(1)?" ‚Üí Address calculation
- "Why is insert at beginning O(n)?" ‚Üí Element shifting
- "How does dynamic array grow?" ‚Üí Amortized analysis

**Company focus:**
| Company | Array Basics Importance |
|---------|------------------------|
| All | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Expected knowledge |
| FAANG | Rarely asked directly, assumed |
| Startups | May test fundamentals |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn array basics | 30 min | First exposure |
| Memorize operations table | 15 min | Reference sheet |
| Solve Easy problems | 10-15 min each | Build confidence |
| Master 2D arrays | 45 min | Common pitfall area |

---

> **üí° Key Insight:** Arrays provide O(1) random access because elements are stored contiguously. Address calculation `base + (index * size)` is simple arithmetic - no traversal needed. This enables many efficient algorithms that wouldn't work with linked structures.

---

## üîó Related

- [Basic Operations](./1.2-Basic-Operations.md) - Deep dive on CRUD
- [Array Traversal](./1.3-Array-Traversal.md) - Iteration patterns
- [Strings](../02-Strings/2.1-String-Basics.md) - Character arrays
