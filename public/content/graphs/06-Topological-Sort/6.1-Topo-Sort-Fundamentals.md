# 6.1 Topological Sort Fundamentals (Grokking Pattern #29)

> **Order tasks with dependencies - essential for scheduling problems**
>
> üéØ **Interview Impact:** ~10% of graph problems | **Frequency:** High (Google, Amazon, Meta)

---

## Overview

**Topological Sort** produces a linear ordering of vertices in a **Directed Acyclic Graph (DAG)** such that for every directed edge `u ‚Üí v`, vertex `u` comes before vertex `v` in the ordering.

```
Graph:              One Topological Order:
  5 ‚Üí 0 ‚Üê 4         5, 4, 2, 3, 1, 0
  ‚Üì       ‚Üì         
  2 ‚Üí 3 ‚Üí 1         (or: 4, 5, 2, 3, 1, 0 - multiple valid orders)

For edge 5‚Üí0: 5 appears before 0 ‚úì
For edge 2‚Üí3: 2 appears before 3 ‚úì
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Topological Sort Problems</strong></summary>

**Strong signals:**
1. Tasks/courses with **prerequisites**
2. **Dependencies** between items
3. Need to find a valid **order/sequence**
4. "Can this be completed?" (cycle detection)

**Keywords:**
- "Prerequisites", "dependencies"
- "Order of tasks/courses"
- "Build order", "compilation order"
- "Schedule", "sequence"

**Anti-signals (NOT topological sort):**
- Undirected graph (no direction)
- Graph has cycles (impossible)
- Need shortest path (use BFS/Dijkstra)

</details>

---

## ‚úÖ When to Use

- Course scheduling with prerequisites
- Build systems (compile order)
- Task scheduling with dependencies
- Package installation order
- Spreadsheet cell evaluation order

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Undirected graph | No direction concept | Connected components |
| Graph has cycles | Impossible to order | Detect cycle, report error |
| Need shortest path | Different problem | BFS or Dijkstra |
| Need all orderings | Exponentially many | Backtracking |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Connections</strong></summary>

**Before this, you should know:**
- [DFS Fundamentals](../04-DFS-Pattern/4.1-DFS-Fundamentals.md)
- [BFS Fundamentals](../03-BFS-Pattern/3.1-BFS-Fundamentals.md)
- Graph representation basics

**Connects to:**
- Cycle Detection (topological sort only works if no cycles)
- Strongly Connected Components (extension for cycles)
- Course Schedule problems (direct application)

</details>

---

## üìê How It Works

### The Core Insight

```
In a DAG, there's always at least one vertex with no incoming edges (in-degree 0).
This vertex can be "first" in the topological order.

Remove it, and the remaining graph is still a DAG.
Repeat until all vertices are ordered.
```

### Two Approaches

| Approach | Algorithm | Best For |
|----------|-----------|----------|
| **Kahn's (BFS)** | Process nodes with in-degree 0 | Easier to understand, detect cycles |
| **DFS-based** | Post-order traversal, reverse | Shorter code, natural recursion |

---

### Approach 1: Kahn's Algorithm (BFS)

```
1. Calculate in-degree for all vertices
2. Add all vertices with in-degree 0 to queue
3. While queue not empty:
   a. Remove vertex v from queue ‚Üí add to result
   b. For each neighbor of v:
      - Decrease neighbor's in-degree by 1
      - If neighbor's in-degree becomes 0, add to queue
4. If result contains all vertices ‚Üí valid order
   Otherwise ‚Üí graph has a cycle
```

**Visualization:**
```
Initial:        Remove 5:       Remove 4:       Remove 2:
  5 ‚Üí 0 ‚Üê 4     . ‚Üí 0 ‚Üê 4       . ‚Üí 0 ‚Üê .       . ‚Üí 0 ‚Üê .
  ‚Üì       ‚Üì         ‚Üì       ‚Üì       . ‚Üì     ‚Üì       . .     ‚Üì
  2 ‚Üí 3 ‚Üí 1       2 ‚Üí 3 ‚Üí 1       2 ‚Üí 3 ‚Üí 1       . ‚Üí 3 ‚Üí 1
In-deg:         In-deg:         In-deg:         In-deg:
5:0,4:0,2:1     2:0,0:1,3:1     2:0,0:0,3:1     3:0,0:0,1:1
0:2,3:1,1:1

Queue: [5,4]    Queue: [4,2]    Queue: [2,0]    Queue: [0,3]
Result: []      Result: [5]     Result: [5,4]   Result: [5,4,2]
```

### Approach 2: DFS-Based

```
1. Run DFS from each unvisited vertex
2. After exploring all neighbors, add vertex to stack
3. Reverse the stack ‚Üí topological order

Key insight: A vertex is added AFTER all its dependencies are added.
So reversing gives correct order.
```

---

## üíª Code Implementation

### Kahn's Algorithm (BFS)

**Python:**
```python
from collections import deque, defaultdict
from typing import List

def topological_sort_kahn(num_nodes: int, edges: List[List[int]]) -> List[int]:
    """
    Kahn's Algorithm for topological sort.
    
    Args:
        num_nodes: Number of vertices (0 to n-1)
        edges: List of [from, to] edges
        
    Returns:
        Topological order, or empty list if cycle exists
        
    Time: O(V + E)
    Space: O(V + E)
    """
    # Build adjacency list and calculate in-degrees
    graph = defaultdict(list)
    in_degree = [0] * num_nodes
    
    for src, dst in edges:
        graph[src].append(dst)
        in_degree[dst] += 1
    
    # Start with nodes having no prerequisites
    queue = deque([i for i in range(num_nodes) if in_degree[i] == 0])
    result = []
    
    while queue:
        node = queue.popleft()
        result.append(node)
        
        # Process all neighbors
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Check if all nodes were processed (no cycle)
    if len(result) == num_nodes:
        return result
    else:
        return []  # Cycle detected


# Example usage
edges = [[5,0], [5,2], [4,0], [4,1], [2,3], [3,1]]
print(topological_sort_kahn(6, edges))  # [4, 5, 0, 2, 3, 1] or similar
```

### DFS-Based Approach

**Python:**
```python
from typing import List
from collections import defaultdict

def topological_sort_dfs(num_nodes: int, edges: List[List[int]]) -> List[int]:
    """
    DFS-based topological sort.
    
    Returns topological order, or empty list if cycle exists.
    
    Time: O(V + E)
    Space: O(V + E)
    """
    # Build adjacency list
    graph = defaultdict(list)
    for src, dst in edges:
        graph[src].append(dst)
    
    # States: 0 = unvisited, 1 = in current path, 2 = completed
    WHITE, GRAY, BLACK = 0, 1, 2
    state = [WHITE] * num_nodes
    result = []
    has_cycle = False
    
    def dfs(node: int) -> None:
        nonlocal has_cycle
        
        if has_cycle:
            return
        
        state[node] = GRAY  # Mark as in current DFS path
        
        for neighbor in graph[node]:
            if state[neighbor] == GRAY:
                # Back edge found ‚Üí cycle!
                has_cycle = True
                return
            if state[neighbor] == WHITE:
                dfs(neighbor)
        
        state[node] = BLACK  # Mark as completed
        result.append(node)  # Add to result in post-order
    
    # Run DFS from each unvisited node
    for node in range(num_nodes):
        if state[node] == WHITE:
            dfs(node)
            if has_cycle:
                return []
    
    # Reverse to get topological order
    return result[::-1]


# Example
edges = [[5,0], [5,2], [4,0], [4,1], [2,3], [3,1]]
print(topological_sort_dfs(6, edges))  # [5, 4, 2, 3, 1, 0] or similar
```

**JavaScript:**
```javascript
// Kahn's Algorithm
function topologicalSortKahn(numNodes, edges) {
    const graph = new Map();
    const inDegree = new Array(numNodes).fill(0);
    
    // Initialize graph
    for (let i = 0; i < numNodes; i++) {
        graph.set(i, []);
    }
    
    // Build graph and calculate in-degrees
    for (const [src, dst] of edges) {
        graph.get(src).push(dst);
        inDegree[dst]++;
    }
    
    // Start with nodes having in-degree 0
    const queue = [];
    for (let i = 0; i < numNodes; i++) {
        if (inDegree[i] === 0) queue.push(i);
    }
    
    const result = [];
    
    while (queue.length > 0) {
        const node = queue.shift();
        result.push(node);
        
        for (const neighbor of (graph.get(node) || [])) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] === 0) {
                queue.push(neighbor);
            }
        }
    }
    
    return result.length === numNodes ? result : [];
}

// DFS-based
function topologicalSortDFS(numNodes, edges) {
    const graph = new Map();
    for (let i = 0; i < numNodes; i++) graph.set(i, []);
    for (const [src, dst] of edges) graph.get(src).push(dst);
    
    const WHITE = 0, GRAY = 1, BLACK = 2;
    const state = new Array(numNodes).fill(WHITE);
    const result = [];
    let hasCycle = false;
    
    function dfs(node) {
        if (hasCycle) return;
        
        state[node] = GRAY;
        
        for (const neighbor of (graph.get(node) || [])) {
            if (state[neighbor] === GRAY) {
                hasCycle = true;
                return;
            }
            if (state[neighbor] === WHITE) {
                dfs(neighbor);
            }
        }
        
        state[node] = BLACK;
        result.push(node);
    }
    
    for (let i = 0; i < numNodes; i++) {
        if (state[i] === WHITE) {
            dfs(i);
            if (hasCycle) return [];
        }
    }
    
    return result.reverse();
}
```

---

## ‚ö° Complexity Analysis

| Algorithm | Time | Space | Notes |
|-----------|------|-------|-------|
| Kahn's (BFS) | O(V + E) | O(V + E) | Process each vertex and edge once |
| DFS-based | O(V + E) | O(V + E) | DFS visits each vertex and edge once |

---

## üîÑ Comparison

| Aspect | Kahn's (BFS) | DFS-based |
|--------|--------------|-----------|
| **Intuition** | Remove nodes with no deps | Post-order traversal |
| **Cycle detection** | Easy (count processed) | Need extra state |
| **Implementation** | More setup (in-degree) | Cleaner recursion |
| **Memory** | Queue + in-degree array | Recursion stack |
| **Parallelism** | Naturally parallel | Sequential |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Handle Disconnected Graph

```python
# ‚ùå Wrong: Only start DFS from node 0
dfs(0)

# ‚úÖ Correct: Start from ALL unvisited nodes
for node in range(num_nodes):
    if state[node] == WHITE:
        dfs(node)
```

### 2. Wrong Cycle Detection in DFS

```python
# ‚ùå Wrong: Using visited set (can't detect back edges)
if node in visited:
    return  # This doesn't mean cycle!

# ‚úÖ Correct: Use three states
if state[neighbor] == GRAY:  # In current path = cycle
    has_cycle = True
```

### 3. Forgetting to Reverse DFS Result

```python
# ‚ùå Wrong: Return result as-is
return result  # This is reverse topological order!

# ‚úÖ Correct: Reverse the result
return result[::-1]
```

---

## üìù Practice Problems (Progressive)

### Easy/Medium (Learn the pattern)
- [ ] [Course Schedule](https://leetcode.com/problems/course-schedule/) - LC 207
- [ ] [Course Schedule II](https://leetcode.com/problems/course-schedule-ii/) - LC 210

### Medium (Apply variations)
- [ ] [Alien Dictionary](https://leetcode.com/problems/alien-dictionary/) - LC 269
- [ ] [Minimum Height Trees](https://leetcode.com/problems/minimum-height-trees/) - LC 310
- [ ] [Parallel Courses](https://leetcode.com/problems/parallel-courses/) - LC 1136

### Hard (Master edge cases)
- [ ] [Course Schedule III](https://leetcode.com/problems/course-schedule-iii/) - LC 630
- [ ] [Sequence Reconstruction](https://leetcode.com/problems/sequence-reconstruction/) - LC 444

---

## üé§ Interview Context

<details>
<summary><strong>Communication Tips</strong></summary>

**Opening statement:**
> "This is a dependency ordering problem, which maps to topological sort on a directed graph."

**Key points:**
1. First check for cycles (if cycle, impossible)
2. Mention both approaches (Kahn's and DFS)
3. Choose one and explain why

**If asked about trade-offs:**
> "Kahn's is more intuitive and naturally detects cycles. DFS is more concise but needs careful state management."

</details>

**Company Focus:**

| Company | Frequency | Focus |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Complex variations, parallel courses |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Build order, task scheduling |
| Meta | ‚≠ê‚≠ê‚≠ê | Course schedule problems |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Standard implementations |

---

> **üí° Key Insight:** Topological sort answers "in what order should I do things given dependencies?" If there's a cycle, no valid order exists. Think of it as repeatedly removing items with no remaining prerequisites.

---

**Next:** [DFS Approach ‚Üí](./6.2-DFS-Approach.md) | [Kahn's Algorithm ‚Üí](./6.3-Kahns-BFS.md)
