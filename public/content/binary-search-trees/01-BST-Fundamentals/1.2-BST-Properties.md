# 1.2 BST Properties

## Core Properties of Binary Search Trees

Beyond the fundamental ordering property, BSTs have several important characteristics that directly influence algorithm design and interview problems.

```
Example BST for reference:
              15
            /    \
          10      20
         /  \    /  \
        5   12  17   25
       /      \
      3       13

Height: 4
Nodes: 9
Min: 3 (leftmost)
Max: 25 (rightmost)
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Property-Based Problems</strong></summary>

**Look for these signals:**
- "Find minimum/maximum value"
- "Find height/depth of BST"
- "Count nodes in range"
- "Find floor/ceiling of a value"
- "Is the tree balanced?"

**Keywords in problem statement:**
- "minimum", "maximum", "range"
- "height", "depth", "balanced"
- "predecessor", "successor"
- "closest value", "floor", "ceiling"

</details>

---

## ‚úÖ When to Use BST Properties

| Property | When It Helps |
|----------|---------------|
| Minimum at leftmost |" O(log n) min finding without full traversal "|
| Maximum at rightmost |" O(log n) max finding "|
| Inorder = sorted | When sorted sequence needed from dynamic data |
| Subtree validity | Validation problems, range problems |
| Height-based | Balancing checks, complexity analysis |

## ‚ùå When NOT to Use BST Properties

| Scenario | Why Not | Better Approach |
|----------|---------|-----------------|
| Need median | BST doesn't track median efficiently | Augmented BST or two heaps |
| Frequent rebalancing needed | Standard BST doesn't rebalance | AVL or Red-Black Tree |
| Order statistics (k-th element) |" O(n) without augmentation "| Augmented BST with subtree sizes |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Definition](./1.1-BST-Definition.md) - Core BST property
- [Tree Height/Depth](../../06-Trees/01-Tree-Fundamentals/1.1-Tree-Terminology.md)

**After mastering this:**
- [Min/Max/Successor](./1.3-BST-MinMax-Successor.md) - Detailed algorithms
- [BST Validation](../03-BST-Validation/) - Using properties to validate
- [Range Problems](../05-BST-Range-Problems/) - Exploiting subtree ranges

**Combines with:**
- DFS for traversal-based properties
- Binary search for closest value problems
- Two pointers (via inorder) for pair finding

</details>

---

## üìê How It Works

### Property 1: Minimum is Leftmost Node

```
Starting at root, go left until you can't:

        15
       /
      10
     /
    5
   /
  3  ‚Üê MINIMUM (no left child)

Algorithm: while node.left exists, go left
```

### Property 2: Maximum is Rightmost Node

```
Starting at root, go right until you can't:

        15
          \
           20
             \
              25  ‚Üê MAXIMUM (no right child)

Algorithm: while node.right exists, go right
```

### Property 3: Inorder Traversal Yields Sorted Order

```
Inorder of BST:
        15
       /  \
      10   20
     /  \
    5   12

Inorder: 5 ‚Üí 10 ‚Üí 12 ‚Üí 15 ‚Üí 20  (sorted!)

This is NOT true for arbitrary binary trees!
```

### Property 4: Every Subtree is Also a BST

```
        15
       /  \
      10   20    ‚Üê Both subtrees are valid BSTs
     /  \    \
    5   12   25

Left subtree rooted at 10: All values < 15 ‚úì
Right subtree rooted at 20: All values > 15 ‚úì
```

### Property 5: Value Ranges in Subtrees

```
At node 15 with range (-‚àû, +‚àû):
‚îú‚îÄ‚îÄ Left subtree (10): range (-‚àû, 15)
‚îÇ   ‚îú‚îÄ‚îÄ Left (5): range (-‚àû, 10)
‚îÇ   ‚îî‚îÄ‚îÄ Right (12): range (10, 15)
‚îî‚îÄ‚îÄ Right subtree (20): range (15, +‚àû)
    ‚îî‚îÄ‚îÄ Right (25): range (20, +‚àû)

Each node "narrows" the valid range for its children.
```

---

## üíª Code Implementation

### Finding Minimum and Maximum

**Python:**
```python
def find_min(root: TreeNode) -> int:
    """Find minimum value in BST.
    
    Time: O(h) where h is height
    Space: O(1) iterative
    """
    if root is None:
        raise ValueError("Empty tree has no minimum")
    
    current = root
    while current.left:
        current = current.left
    return current.val

def find_max(root: TreeNode) -> int:
    """Find maximum value in BST.
    
    Time: O(h) where h is height
    Space: O(1) iterative
    """
    if root is None:
        raise ValueError("Empty tree has no maximum")
    
    current = root
    while current.right:
        current = current.right
    return current.val
```

**JavaScript:**
```javascript
function findMin(root) {
    // Find minimum value in BST - O(h) time
    if (root === null) {
        throw new Error("Empty tree has no minimum");
    }
    
    let current = root;
    while (current.left) {
        current = current.left;
    }
    return current.val;
}

function findMax(root) {
    // Find maximum value in BST - O(h) time
    if (root === null) {
        throw new Error("Empty tree has no maximum");
    }
    
    let current = root;
    while (current.right) {
        current = current.right;
    }
    return current.val;
}
```

### Checking Height Balance

**Python:**
```python
def is_height_balanced(root: TreeNode) -> bool:
    """Check if BST is height-balanced (AVL property).
    
    A tree is balanced if for every node, the height
    difference between left and right subtrees is ‚â§ 1.
    
    Time: O(n) - visit each node once
    Space: O(h) - recursion stack
    """
    def check(node: TreeNode) -> tuple[bool, int]:
        """Returns (is_balanced, height)."""
        if node is None:
            return True, 0
        
        left_balanced, left_height = check(node.left)
        if not left_balanced:
            return False, 0  # Early termination
        
        right_balanced, right_height = check(node.right)
        if not right_balanced:
            return False, 0
        
        # Check balance at current node
        balanced = abs(left_height - right_height) <= 1
        height = 1 + max(left_height, right_height)
        
        return balanced, height
    
    return check(root)[0]
```

**JavaScript:**
```javascript
function isHeightBalanced(root) {
    // Check if BST is height-balanced (AVL property)
    function check(node) {
        // Returns [isBalanced, height]
        if (node === null) return [true, 0];
        
        const [leftBalanced, leftHeight] = check(node.left);
        if (!leftBalanced) return [false, 0];  // Early exit
        
        const [rightBalanced, rightHeight] = check(node.right);
        if (!rightBalanced) return [false, 0];
        
        const balanced = Math.abs(leftHeight - rightHeight) <= 1;
        const height = 1 + Math.max(leftHeight, rightHeight);
        
        return [balanced, height];
    }
    
    return check(root)[0];
}
```

### Counting Nodes in Range

**Python:**
```python
def count_in_range(root: TreeNode, low: int, high: int) -> int:
    """Count nodes with values in [low, high] range.
    
    Uses BST property to prune subtrees outside range.
    Time: O(h + k) where k = nodes in range
    Space: O(h) recursion stack
    """
    if root is None:
        return 0
    
    # If current value is below range, only right subtree can have values
    if root.val < low:
        return count_in_range(root.right, low, high)
    
    # If current value is above range, only left subtree can have values
    if root.val > high:
        return count_in_range(root.left, low, high)
    
    # Current value is in range
    left_count = count_in_range(root.left, low, high)
    right_count = count_in_range(root.right, low, high)
    return 1 + left_count + right_count

# Example
# BST: 15 -> [10, 20] -> [5, 12, 17, 25]
# count_in_range(root, 10, 20) = 4 (10, 12, 15, 17, 20)
```

**JavaScript:**
```javascript
function countInRange(root, low, high) {
    // Count nodes with values in [low, high] range
    if (root === null) return 0;
    
    // If current value is below range, check right subtree only
    if (root.val < low) {
        return countInRange(root.right, low, high);
    }
    
    // If current value is above range, check left subtree only
    if (root.val > high) {
        return countInRange(root.left, low, high);
    }
    
    // Current value is in range - count it + recurse both
    return 1 + countInRange(root.left, low, high) 
             + countInRange(root.right, low, high);
}
```

---

## ‚ö° Complexity Analysis

| Property Operation | Time | Space | Notes |
|-------------------|------|-------|-------|
| Find min/max |" O(h) "| O(1) | Follow one path |
| Get height |" O(n) "| O(h) | Must visit all nodes |
| Check balanced |" O(n) "| O(h) | Bottom-up approach |
| Count in range |" O(h + k) "| O(h) | k = nodes in range |
| Inorder traversal |" O(n) "| O(h) | Visits all nodes |

**Height Analysis:**

| Tree Type | Height | Why |
|-----------|--------|-----|
| Balanced |" O(log n) "| Each level doubles capacity |
| Random insertions |" O(log n) expected "| Probabilistic balancing |
| Skewed (sorted input) |" O(n) "| Becomes linked list |

---

## üîÑ Variations

| Property Variation | Description | Use Case |
|-------------------|-------------|----------|
| **Augmented size** | Each node stores subtree size |" O(log n) k-th element "|
| **Augmented height** | Each node stores height |" O(1) balance check "|
| **Threaded BST** | Null pointers point to successor |" O(1) inorder successor "|
| **Order-statistic tree** | Augmented with rank | Selection, ranking |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Assuming Height is Always O(log n)

```python
# ‚ùå Wrong: Assuming balanced
def operation(root):
    # "This is O(log n) because BST"
    ...

# ‚úÖ Correct: State the assumption
def operation(root):
    """
    Time: O(h) where h is height
    - O(log n) if balanced
    - O(n) worst case (skewed tree)
    """
    ...
```

### 2. Confusing Height and Depth

```
        15        ‚Üê depth 0, height of this subtree = 3
       /  \
      10   20     ‚Üê depth 1
     /
    5             ‚Üê depth 2, height of this subtree = 1
   /
  3               ‚Üê depth 3, height of this subtree = 0

Height = max depth = 3
Node 15's height = 3 (longest path to leaf)
Node 3's depth = 3 (path from root)
```

### 3. Not Using BST Property for Optimization

```python
# ‚ùå Slow: Full traversal to find min
def find_min_slow(root):
    if not root:
        return float('inf')
    left = find_min_slow(root.left)
    right = find_min_slow(root.right)
    return min(root.val, left, right)  # O(n)!

# ‚úÖ Fast: Use BST property
def find_min_fast(root):
    while root and root.left:
        root = root.left
    return root.val if root else None  # O(h)
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn properties)
- [ ] [Minimum Absolute Difference in BST (LC 530)](https://leetcode.com/problems/minimum-absolute-difference-in-bst/) - Inorder property
- [ ] [Range Sum of BST (LC 938)](https://leetcode.com/problems/range-sum-of-bst/) - Range pruning

### Medium (Apply properties)
- [ ] [Validate BST (LC 98)](https://leetcode.com/problems/validate-binary-search-tree/) - Range property
- [ ] [Closest BST Value (LC 270)](https://leetcode.com/problems/closest-binary-search-tree-value/) - Binary search property
- [ ] [Balance a BST (LC 1382)](https://leetcode.com/problems/balance-a-binary-search-tree/) - Inorder + construction

### Hard (Master edge cases)
- [ ] [Count of Smaller Numbers After Self (LC 315)](https://leetcode.com/problems/count-of-smaller-numbers-after-self/) - Augmented BST

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

After learning BST properties:
- **Day 1:** Trace min/max finding on paper
- **Day 3:** Implement countInRange from scratch
- **Day 7:** Solve LC 938 (Range Sum)
- **Day 14:** Explain why inorder = sorted
- **Day 30:** Apply properties to a new problem

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Discuss BST Properties in Interviews</strong></summary>

**When analyzing:**
- "The minimum is at the leftmost node, so finding it is O(h)"
- "Since inorder traversal gives sorted order, I can use that to..."
- "I'll use the range property to prune subtrees outside the target range"

**Questions to expect:**
- "What's the time complexity?" ‚Üí State O(h), then clarify balanced vs skewed
- "Can you optimize this?" ‚Üí Use BST properties to prune
- "What if the tree is skewed?" ‚Üí Discuss O(n) worst case

</details>

**Company Focus:**

| Company | Property Emphasis | Example |
|---------|-------------------|---------|
| Amazon | Range queries | LC 938 |
| Google | Optimization via pruning | Closest value |
| Microsoft | Balance checks | Height-balanced BST |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand properties | 20-25 min | Draw examples |
| Implement min/max | 10 min | Simple while loop |
| Range problems | 20-25 min | LC 938 |
| Balance checking | 25-30 min | LC 110 variant |

---

## üí° Key Insight

> **Every BST property comes from the recursive definition:** left < node < right. The min being leftmost, max being rightmost, inorder being sorted ‚Äî all are consequences of this single invariant applied recursively.

---

## üîó Related

- **Previous:** [1.1 BST Definition](./1.1-BST-Definition.md)
- **Next:** [1.3 Min/Max/Successor](./1.3-BST-MinMax-Successor.md)
- **Problems:** [Range Sum BST](../05-BST-Range-Problems/5.2-Range-Sum-BST-LC938.md)
