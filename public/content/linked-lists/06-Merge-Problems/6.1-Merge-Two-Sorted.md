# 6.1 Merge Two Sorted Lists (LC 21)

> **Grokking Pattern:** Two Pointers on Linked Lists
>
> **Difficulty:** Easy | **Frequency:** â­â­â­â­â­ Very High

---

## Problem Statement

Merge two sorted linked lists and return it as a **sorted** list. The list should be made by splicing together the nodes of the first two lists.

```
Input:  list1 = 1 â†’ 2 â†’ 4
        list2 = 1 â†’ 3 â†’ 4

Output: 1 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 4
```

[LeetCode 21 - Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- Two sorted sequences to combine
- Need to maintain sorted order
- Can't use extra array (in-place merge)

**Keywords in problem statement:**
- "merge", "sorted", "combine two lists"

**Similar to:**
- Merge step in Merge Sort
- Merge Intervals (different pattern)
- Intersection of sorted arrays

</details>

---

## âœ… When to Use This Approach

- Merging two sorted linked lists
- Merge step of merge sort on lists
- Combining sorted streams of data
- Any two-pointer comparison on sorted data

---

## âŒ When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Unsorted lists | Pattern requires sorted input | Sort first or use hash |
| Need to preserve original lists | We modify next pointers | Create new nodes |
| Arrays instead of lists | Different optimization | Two pointer on arrays |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Linked List Basics](../01-Singly-LL/1.1-Basics.md)
- [Two Pointers concept](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md)

**After mastering this:**
- [Merge K Sorted Lists](./6.2-Merge-K-Sorted.md) - Extension with heap
- Sort List (LC 148) - Merge sort on linked list

**Combines with:**
- Divide and Conquer for merge sort
- Heap for k-way merge

</details>

---

## ğŸ“ How It Works

### Core Idea

Use a **dummy head** and compare nodes from both lists one at a time:

1. Compare heads of both lists
2. Attach smaller one to result
3. Advance that list's pointer
4. Repeat until one list is exhausted
5. Attach remaining nodes

### Visualization

```
list1: 1 â†’ 2 â†’ 4
       â†‘
list2: 1 â†’ 3 â†’ 4
       â†‘
result: dummy â†’

Step 1: Compare 1 vs 1, pick list1's 1
list1: 1 â†’ 2 â†’ 4
           â†‘
list2: 1 â†’ 3 â†’ 4
       â†‘
result: dummy â†’ 1

Step 2: Compare 2 vs 1, pick list2's 1
list1: 1 â†’ 2 â†’ 4
           â†‘
list2: 1 â†’ 3 â†’ 4
           â†‘
result: dummy â†’ 1 â†’ 1

Step 3: Compare 2 vs 3, pick 2
result: dummy â†’ 1 â†’ 1 â†’ 2

Step 4: Compare 4 vs 3, pick 3
result: dummy â†’ 1 â†’ 1 â†’ 2 â†’ 3

Step 5: Compare 4 vs 4, pick first 4
result: dummy â†’ 1 â†’ 1 â†’ 2 â†’ 3 â†’ 4

Step 6: list1 exhausted, attach remaining (4)
result: dummy â†’ 1 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 4
```

---

## ğŸ’» Code Implementation

### Iterative Solution (Recommended)

**Python:**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def merge_two_lists(list1: ListNode, list2: ListNode) -> ListNode:
    """
    Merge two sorted linked lists.
    
    Pattern: Two Pointers with Dummy Head
    Time: O(n + m), Space: O(1)
    """
    # Dummy head simplifies edge cases
    dummy = ListNode(-1)
    current = dummy
    
    # Compare and attach smaller node
    while list1 and list2:
        if list1.val <= list2.val:
            current.next = list1
            list1 = list1.next
        else:
            current.next = list2
            list2 = list2.next
        current = current.next
    
    # Attach remaining nodes (one list might not be exhausted)
    current.next = list1 if list1 else list2
    
    return dummy.next  # Skip dummy head
```

**JavaScript:**

```javascript
function mergeTwoLists(list1, list2) {
    // Dummy head simplifies edge cases
    const dummy = new ListNode(-1);
    let current = dummy;
    
    while (list1 && list2) {
        if (list1.val <= list2.val) {
            current.next = list1;
            list1 = list1.next;
        } else {
            current.next = list2;
            list2 = list2.next;
        }
        current = current.next;
    }
    
    // Attach remaining
    current.next = list1 || list2;
    
    return dummy.next;
}
```

### Recursive Solution

**Python:**

```python
def merge_two_lists_recursive(list1: ListNode, list2: ListNode) -> ListNode:
    """
    Recursive merge - elegant but O(n+m) stack space.
    
    Time: O(n + m), Space: O(n + m) for recursion stack
    """
    # Base cases
    if not list1:
        return list2
    if not list2:
        return list1
    
    # Recursive case: smaller node becomes head
    if list1.val <= list2.val:
        list1.next = merge_two_lists_recursive(list1.next, list2)
        return list1
    else:
        list2.next = merge_two_lists_recursive(list1, list2.next)
        return list2
```

**JavaScript:**

```javascript
function mergeTwoListsRecursive(list1, list2) {
    if (!list1) return list2;
    if (!list2) return list1;
    
    if (list1.val <= list2.val) {
        list1.next = mergeTwoListsRecursive(list1.next, list2);
        return list1;
    } else {
        list2.next = mergeTwoListsRecursive(list1, list2.next);
        return list2;
    }
}
```

---

## âš¡ Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Iterative |" O(n + m) "| O(1) | Recommended |
| Recursive |" O(n + m) "| O(n + m) | Stack space |

**Why O(n + m) time:**
- Each node is visited exactly once
- Each comparison and pointer update is O(1)

**Why O(1) space (iterative):**
- Only a few pointers used
- We reuse existing nodes, not creating new ones

---

## ğŸ”„ Variations

| Variation | Difference | Approach |
|-----------|------------|----------|
| Merge K lists | More than 2 lists | Heap or divide & conquer |
| Merge arrays | Array instead of LL |" Two pointers, O(n) extra space "|
| Keep duplicates | Same as above | Default behavior |
| Remove duplicates | Skip equal values | Add condition in comparison |

---

## âš ï¸ Common Mistakes

### 1. Forgetting Dummy Head

```python
# âŒ Without dummy - many edge cases
def merge_bad(list1, list2):
    if not list1:
        return list2
    if not list2:
        return list1
    
    if list1.val < list2.val:
        head = list1
        list1 = list1.next
    else:
        head = list2
        list2 = list2.next
    
    current = head
    # ... more code needed

# âœ… With dummy - clean and simple
def merge_good(list1, list2):
    dummy = ListNode(-1)
    current = dummy
    # ... rest is straightforward
```

### 2. Not Handling Remaining Nodes

```python
# âŒ Wrong - forgets remaining nodes
while list1 and list2:
    # ... merge logic
# list1 or list2 might still have nodes!

# âœ… Correct - attach remaining
while list1 and list2:
    # ... merge logic
current.next = list1 if list1 else list2
```

### 3. Returning Wrong Node

```python
# âŒ Wrong - returns dummy itself
return dummy

# âœ… Correct - skip dummy
return dummy.next
```

### 4. Modifying Original Lists

```python
# Note: The standard solution modifies the original lists
# If you need to preserve them, create new nodes:
def merge_preserve_original(list1, list2):
    dummy = ListNode(-1)
    current = dummy
    
    while list1 and list2:
        if list1.val <= list2.val:
            current.next = ListNode(list1.val)  # New node!
            list1 = list1.next
        else:
            current.next = ListNode(list2.val)
            list2 = list2.next
        current = current.next
    
    # Copy remaining
    while list1:
        current.next = ListNode(list1.val)
        list1 = list1.next
        current = current.next
    while list2:
        current.next = ListNode(list2.val)
        list2 = list2.next
        current = current.next
    
    return dummy.next
```

---

## ğŸ“ Practice Problems (Progressive)

### Easy (This problem)
- [ ] [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) - LC 21 â­

### Medium (Extensions)
- [ ] [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) - LC 23
- [ ] [Sort List](https://leetcode.com/problems/sort-list/) - LC 148
- [ ] [Merge In Between Linked Lists](https://leetcode.com/problems/merge-in-between-linked-lists/) - LC 1669

### Related
- [ ] [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/) - LC 2
- [ ] [Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/) - LC 160

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement iterative solution from scratch
- **Day 3:** Implement recursive solution, compare approaches
- **Day 7:** Solve without looking at notes
- **Day 14:** Extend to Merge K Lists
- **Day 30:** Review all merge variations

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
> "Since both lists are sorted, I'll use a two-pointer approach - comparing heads and building the result incrementally."

**Mention the dummy head:**
> "I'll use a dummy head to simplify handling the first node and empty list cases."

**Explain the time complexity:**
> "Each node is processed once, so time is O(n + m). Space is O(1) since we're just rearranging pointers."

**Common follow-ups:**
- "What if lists have different lengths?" â†’ Handled by final `current.next = list1 or list2`
- "Can you do it recursively?" â†’ Yes, but O(n+m) stack space
- "What about K lists?" â†’ Use a min-heap (leads to LC 23)

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | â­â­â­â­â­ | Very common, warm-up question |
| Meta | â­â­â­â­ | May ask as part of larger problem |
| Google | â­â­â­ | Often leads to Merge K |
| Microsoft | â­â­â­â­ | Classic interview question |

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Simple to grasp |
| Iterative solution | 5-10 min | Main approach |
| Recursive solution | 5-7 min | Alternative |
| Handle edge cases | 2-3 min | Empty lists, single node |
| Interview target | 10-15 min | Including explanation |

---

> **ğŸ’¡ Key Insight:** The dummy head pattern eliminates edge cases for the first node. Always consider using it when building a new list node by node.

---

## ğŸ”— Related

- [Merge K Sorted Lists](./6.2-Merge-K-Sorted.md) - Harder extension
- [Two Pointers Pattern](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md) - General technique
- [Linked List Basics](../01-Singly-LL/1.1-Basics.md) - Foundation
