# Cache Practice Problems

> **Practice problems for mastering cache design patterns.**
>
> From basic LRU to advanced design challenges.

---

## ðŸ“Š Problem Overview

| Problem | Difficulty | Core Concept |
|---------|------------|--------------|
| LRU Cache | Medium | HashMap + DLL |
| LFU Cache | Hard | Triple HashMap + min tracking |
| Design HashMap | Easy | Bucket array + chaining |
| All O'one Data Structure | Hard | Count tracking + DLL |

---

## ðŸŸ¡ LRU Cache (LC 146)

**Link:** [LeetCode 146](https://leetcode.com/problems/lru-cache/)

**Time Target:** 25-30 min

### Problem Summary

Design a cache with O(1) get/put and LRU eviction.

### Key Implementation Points

```python
class LRUCache:
    def __init__(self, capacity):
        self.cap = capacity
        self.cache = {}          # key â†’ Node
        self.head = ListNode()   # Dummy head (MRU side)
        self.tail = ListNode()   # Dummy tail (LRU side)
        self.head.next = self.tail
        self.tail.prev = self.head
    
    # Helper: Remove node from DLL
    # Helper: Add node right after head
    # get: lookup + move to front
    # put: update or add + evict if needed
```

### Common Bugs

1. Forgetting to store key in node (needed for eviction)
2. Wrong pointer order when inserting/removing
3. Not moving to front on put (update case)

---

## ðŸ”´ LFU Cache (LC 460)

**Link:** [LeetCode 460](https://leetcode.com/problems/lfu-cache/)

**Time Target:** 40-45 min

### Problem Summary

Design a cache with O(1) get/put and LFU eviction (tie-break by LRU).

### Key Implementation Points

```python
class LFUCache:
    def __init__(self, capacity):
        self.cap = capacity
        self.key_to_val = {}           # key â†’ value
        self.key_to_count = {}         # key â†’ frequency
        self.count_to_keys = defaultdict(OrderedDict)  # count â†’ {keys}
        self.min_count = 0
    
    # _update_count: increment and handle min_count
    # get: return value + update count
    # put: update or add + evict if over capacity
```

### Common Bugs

1. Not updating min_count when count group empties
2. Not resetting min_count to 1 on new insert
3. Wrong tie-breaking (should be LRU)

---

## ðŸŸ¢ Design HashMap (LC 706)

**Link:** [LeetCode 706](https://leetcode.com/problems/design-hashmap/)

**Time Target:** 15-20 min

### Problem Summary

Implement a HashMap without using built-in hash table libraries.

### Key Implementation Points

```python
class MyHashMap:
    def __init__(self):
        self.size = 1000
        self.buckets = [[] for _ in range(self.size)]
    
    def _hash(self, key):
        return key % self.size
    
    def put(self, key, value):
        bucket = self.buckets[self._hash(key)]
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        bucket.append((key, value))
    
    def get(self, key):
        bucket = self.buckets[self._hash(key)]
        for k, v in bucket:
            if k == key:
                return v
        return -1
    
    def remove(self, key):
        bucket = self.buckets[self._hash(key)]
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket.pop(i)
                return
```

### Variations

- Use linked list for chaining instead of array
- Implement resizing for better performance
- Handle different key types (strings, objects)

---

## ðŸ”´ All O'one Data Structure (LC 432)

**Link:** [LeetCode 432](https://leetcode.com/problems/all-oone-data-structure/)

**Time Target:** 45 min

### Problem Summary

Design a structure that supports:
- `inc(key)`: Increment count of key
- `dec(key)`: Decrement count of key
- `getMaxKey()`: Return a key with max count
- `getMinKey()`: Return a key with min count

All in O(1).

### Key Insight

Use a DLL where each node represents a count value and contains all keys with that count.

```python
class Node:
    def __init__(self, count):
        self.count = count
        self.keys = set()
        self.prev = None
        self.next = None

class AllOne:
    def __init__(self):
        self.key_to_node = {}
        self.head = Node(0)   # Dummy head (min side)
        self.tail = Node(0)   # Dummy tail (max side)
        self.head.next = self.tail
        self.tail.prev = self.head
```

---

## ðŸ“‹ Study Plan

### Week 1: Fundamentals

| Day | Problem | Focus |
|-----|---------|-------|
| 1-2 | Design HashMap | Hashing basics |
| 3-4 | LRU Cache | HashMap + DLL pattern |
| 5 | Review | Solidify understanding |

### Week 2: Advanced

| Day | Problem | Focus |
|-----|---------|-------|
| 6-7 | LFU Cache | Triple HashMap |
| 8-9 | All O'one | Count-based DLL |
| 10 | Mock interview | Time practice |

---

## ðŸŽ¯ Interview Tips

### Opening Statement

> "For O(1) operations with ordering requirements, I'll use a HashMap combined with a doubly linked list. The HashMap gives O(1) access, and the DLL allows O(1) reordering."

### Key Points to Mention

1. **Why DLL not SLL?** Need O(1) removal, which requires access to prev node
2. **Why dummy nodes?** Simplifies edge cases (empty list, single element)
3. **Why store key in node?** Need to delete from HashMap during eviction

### Common Follow-ups

| Question | Answer |
|----------|--------|
| "What about thread safety?" | Use locks or concurrent data structures |
| "How would you distribute this?" | Consistent hashing, partition by key |
| "What if we need TTL?" | Additional timestamp field + lazy expiration |

---

## â±ï¸ Target Times

| Problem | Coding | Explanation | Total |
|---------|--------|-------------|-------|
| Design HashMap | 10 min | 5 min | 15 min |
| LRU Cache | 20 min | 10 min | 30 min |
| LFU Cache | 30 min | 10 min | 40 min |
| All O'one | 35 min | 10 min | 45 min |

---

## ðŸ§  Spaced Repetition

| Day | Activity |
|-----|----------|
| Day 1 | Solve with reference |
| Day 2 | Solve from memory |
| Day 4 | Explain approach |
| Day 7 | Solve variation |
| Day 14 | Full re-solve |

---

## ðŸ“ Template Code

### LRU Cache Template

```python
class ListNode:
    def __init__(self, key=0, val=0):
        self.key, self.val = key, val
        self.prev = self.next = None

class LRUCache:
    def __init__(self, capacity):
        self.cap = capacity
        self.cache = {}
        self.head, self.tail = ListNode(), ListNode()
        self.head.next, self.tail.prev = self.tail, self.head
    
    def _remove(self, node):
        node.prev.next, node.next.prev = node.next, node.prev
    
    def _add_front(self, node):
        node.prev, node.next = self.head, self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def get(self, key):
        if key not in self.cache: return -1
        node = self.cache[key]
        self._remove(node)
        self._add_front(node)
        return node.val
    
    def put(self, key, val):
        if key in self.cache:
            self._remove(self.cache[key])
        node = ListNode(key, val)
        self.cache[key] = node
        self._add_front(node)
        if len(self.cache) > self.cap:
            lru = self.tail.prev
            self._remove(lru)
            del self.cache[lru.key]
```

---

> **ðŸ’¡ Key Insight:** Cache problems test your ability to combine data structures. The pattern is almost always: HashMap for O(1) lookup + some structure for ordering (DLL, OrderedDict, or count tracking).

> **ðŸ”— Related:** [Cache Fundamentals](./2.1-Cache-Fundamentals.md) | [LRU Implementation](./2.2-LRU-Implementation.md) | [LFU Cache](./2.3-LFU-Cache.md)
