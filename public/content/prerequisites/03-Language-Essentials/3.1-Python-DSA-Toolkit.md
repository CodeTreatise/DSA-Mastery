# 3.1 Python DSA Toolkit

> **The modules and techniques that separate "I know Python" from "I can solve LeetCode in Python."**
>
> ‚è±Ô∏è *Estimated reading: 30 minutes*

---

## üéØ Why This Matters

You can know Python syntax perfectly and still fail medium-difficulty LeetCode problems because you don't know these modules exist. Every competitive Python DSA solver uses these daily:

| Module | Without It | With It |
|--------|-----------|---------|
| `collections.deque` | BFS is O(n¬≤) per pop | BFS is O(n) ‚úÖ |
| `heapq` | Can't solve Top K problems | O(n log k) solutions |
| `collections.Counter` | Manual frequency counting | One-line frequency maps |
| `bisect` | Write binary search from scratch | One-line sorted insertion |
| `functools.lru_cache` | Manual memoization dicts | One decorator = DP |

---

## üì¶ 1. `collections.Counter` ‚Äî Frequency Counting

### What It Does

Creates a dictionary that counts occurrences of each element.

### Code

```python
from collections import Counter

# Basic usage
nums = [1, 2, 2, 3, 3, 3]
count = Counter(nums)
# Counter({3: 3, 2: 2, 1: 1})

# Most common elements
count.most_common(2)    # [(3, 3), (2, 2)]

# Access count of specific element
count[3]                # 3
count[99]               # 0 (not KeyError!)

# Subtract counts
a = Counter("aabbc")
b = Counter("abc")
a - b                   # Counter({'a': 1, 'b': 1})

# Check if one is subset of another
a = Counter("aab")
b = Counter("aabb")
a & b == a              # True ‚Äî a is subset of b
```

### DSA Use Cases

| Problem | How Counter Helps |
|---------|------------------|
| **Valid Anagram** (LC 242) | `Counter(s) == Counter(t)` ‚Äî one line |
| **Group Anagrams** (LC 49) | `tuple(sorted(word))` as key, Counter for verification |
| **Find All Anagrams** (LC 438) | Sliding window + Counter comparison |
| **Top K Frequent Elements** (LC 347) | `Counter(nums).most_common(k)` |
| **First Unique Character** (LC 387) | `Counter(s)`, find first with count 1 |

### ‚ö†Ô∏è Pitfalls

```python
# ‚úÖ Counter returns 0 for missing keys (no KeyError)
c = Counter([1, 2, 3])
c[99]  # 0 ‚Äî safe!

# ‚ùå Regular dict raises KeyError
d = {1: 1, 2: 1}
d[99]  # KeyError!

# ‚ö†Ô∏è Counter keeps zero/negative counts after subtraction
c = Counter(a=3, b=1)
c.subtract(Counter(a=5))
c  # Counter({'b': 1, 'a': -2}) ‚Äî negative values exist!
# Use c = +c to remove zero/negative entries
```

---

## üì¶ 2. `collections.defaultdict` ‚Äî Auto-Initializing Dictionary

### What It Does

A dict that creates default values for missing keys automatically.

### Code

```python
from collections import defaultdict

# List as default ‚Äî perfect for adjacency lists
graph = defaultdict(list)
graph[1].append(2)    # No need to check if key exists
graph[1].append(3)
graph[2].append(1)
# {1: [2, 3], 2: [1]}

# Int as default ‚Äî counting
freq = defaultdict(int)
for char in "hello":
    freq[char] += 1   # No KeyError, starts at 0
# {'h': 1, 'e': 1, 'l': 2, 'o': 1}

# Set as default ‚Äî unique grouping
groups = defaultdict(set)
groups["fruit"].add("apple")
groups["fruit"].add("apple")  # Ignored (set)
groups["fruit"].add("banana")
# {'fruit': {'apple', 'banana'}}
```

### DSA Use Cases

| Problem | How defaultdict Helps |
|---------|----------------------|
| **Graph adjacency list** | `graph = defaultdict(list)` ‚Äî THE standard way |
| **Group Anagrams** (LC 49) | `groups = defaultdict(list); groups[key].append(word)` |
| **Word Ladder** (LC 127) | Build pattern‚Üíwords mapping |
| **Course Schedule** (LC 207) | `prereqs = defaultdict(list)` for dependency graph |

### vs Regular `dict`

```python
# ‚ùå Without defaultdict ‚Äî ugly and error-prone
graph = {}
for u, v in edges:
    if u not in graph:
        graph[u] = []
    graph[u].append(v)

# ‚úÖ With defaultdict ‚Äî clean
graph = defaultdict(list)
for u, v in edges:
    graph[u].append(v)
```

---

## üì¶ 3. `collections.deque` ‚Äî Double-Ended Queue

### What It Does

O(1) append and pop from BOTH ends. Lists only have O(1) at the right end.

### Code

```python
from collections import deque

# Create
q = deque([1, 2, 3])

# O(1) operations on BOTH ends
q.append(4)        # Right: [1, 2, 3, 4]
q.appendleft(0)    # Left:  [0, 1, 2, 3, 4]
q.pop()             # Right: returns 4, deque is [0, 1, 2, 3]
q.popleft()         # Left:  returns 0, deque is [1, 2, 3]

# Maxlen ‚Äî automatic eviction (sliding window!)
window = deque(maxlen=3)
for i in range(5):
    window.append(i)
    print(list(window))
# [0]
# [0, 1]
# [0, 1, 2]
# [1, 2, 3]    ‚Üê 0 auto-evicted
# [2, 3, 4]    ‚Üê 1 auto-evicted
```

### üî¥ THE Critical Pitfall

```python
# ‚ùå NEVER use list for BFS ‚Äî pop(0) is O(n)!
queue = [start]
while queue:
    node = queue.pop(0)    # O(n) ‚Äî shifts entire array!
    # ... This makes BFS O(n¬≤) total

# ‚úÖ ALWAYS use deque for BFS ‚Äî popleft() is O(1)
queue = deque([start])
while queue:
    node = queue.popleft()  # O(1) ‚Äî proper BFS is O(n)
    # ...
```

**Why it matters:** With n = 100,000 nodes, `list.pop(0)` does ~5 billion shifts total. `deque.popleft()` does 100,000 operations. That's the difference between TLE and AC.

### DSA Use Cases

| Problem | How deque Helps |
|---------|----------------|
| **All BFS problems** | `deque` is REQUIRED for O(V+E) BFS |
| **Level Order Traversal** (LC 102) | `queue = deque([(root, 0)])` |
| **Sliding Window Maximum** (LC 239) | Monotonic deque pattern |
| **Number of Islands** (LC 200) | BFS with deque |
| **Rotting Oranges** (LC 994) | Multi-source BFS |

---

## üì¶ 4. `collections.OrderedDict` ‚Äî Insertion-Order Dict

### What It Does

Dict that remembers insertion order AND supports `move_to_end()` and `popitem()`.

> **Note:** Since Python 3.7, regular `dict` also preserves insertion order. But OrderedDict has `move_to_end()` which is essential for LRU Cache.

### Code

```python
from collections import OrderedDict

od = OrderedDict()
od['a'] = 1
od['b'] = 2
od['c'] = 3

# Move to end (most recently used)
od.move_to_end('a')  # Now: b‚Üí2, c‚Üí3, a‚Üí1

# Pop least recently used (first item)
od.popitem(last=False)  # Removes 'b', returns ('b', 2)
```

### THE Classic Use Case: LRU Cache (LC 146)

```python
class LRUCache:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.cap = capacity

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)  # Mark as recently used
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.cap:
            self.cache.popitem(last=False)  # Evict LRU
```

---

## üì¶ 5. `heapq` ‚Äî Min-Heap (Priority Queue)

### What It Does

Maintains a min-heap: smallest element is always at index 0.

### Code

```python
import heapq

# Create a heap from a list
nums = [5, 1, 3, 7, 2]
heapq.heapify(nums)       # In-place, O(n)
# nums is now [1, 2, 3, 7, 5] (heap property, not sorted)

# Push
heapq.heappush(nums, 0)   # O(log n)

# Pop smallest
smallest = heapq.heappop(nums)  # O(log n), returns 0

# Peek (don't pop)
peek = nums[0]             # O(1), always the minimum

# Push and pop in one step (more efficient)
result = heapq.heappushpop(nums, 4)  # Push 4, pop smallest

# Top K largest
top_3 = heapq.nlargest(3, [5, 1, 8, 3, 9])   # [9, 8, 5]

# Top K smallest
bot_3 = heapq.nsmallest(3, [5, 1, 8, 3, 9])  # [1, 3, 5]
```

### ‚ö†Ô∏è Max-Heap Trick (Python Only Has Min-Heap!)

```python
# Python has NO max-heap. Use negative values:
import heapq

# Max-heap via negation
max_heap = []
heapq.heappush(max_heap, -5)   # Store negative
heapq.heappush(max_heap, -1)
heapq.heappush(max_heap, -8)

largest = -heapq.heappop(max_heap)  # -(-8) = 8 ‚úÖ
```

### Heap with Custom Priority (Tuples)

```python
# Heap compares tuples element by element
tasks = []
heapq.heappush(tasks, (1, "high priority"))
heapq.heappush(tasks, (3, "low priority"))
heapq.heappush(tasks, (2, "medium"))

heapq.heappop(tasks)  # (1, "high priority") ‚Äî lowest first

# ‚ö†Ô∏è If first elements tie, Python compares second elements
# This crashes if second elements aren't comparable!
# Fix: use a counter as tiebreaker
counter = 0
heapq.heappush(tasks, (priority, counter, task_object))
counter += 1
```

### DSA Use Cases

| Problem | Pattern |
|---------|---------|
| **Kth Largest Element** (LC 215) | Min-heap of size k |
| **Top K Frequent Elements** (LC 347) | Counter + heap |
| **Merge K Sorted Lists** (LC 23) | Min-heap of list heads |
| **Find Median from Data Stream** (LC 295) | Two heaps (max + min) |
| **Network Delay Time** (LC 743) | Dijkstra = BFS + min-heap |
| **Task Scheduler** (LC 621) | Max-heap + cooldown queue |

---

## üì¶ 6. `bisect` ‚Äî Binary Search on Sorted Lists

### What It Does

Binary search insertion point in a sorted list. O(log n) lookup.

### Code

```python
import bisect

sorted_list = [1, 3, 5, 7, 9]

# Find insertion point (left)
bisect.bisect_left(sorted_list, 5)    # 2 (index OF the element)
bisect.bisect_left(sorted_list, 4)    # 2 (where 4 WOULD go)

# Find insertion point (right)
bisect.bisect_right(sorted_list, 5)   # 3 (after existing 5s)

# Insert while maintaining sort order
bisect.insort(sorted_list, 4)         # [1, 3, 4, 5, 7, 9]

# Count elements less than x
count_less = bisect.bisect_left(sorted_list, 5)  # 3

# Count elements in range [lo, hi]
lo_idx = bisect.bisect_left(sorted_list, 3)
hi_idx = bisect.bisect_right(sorted_list, 7)
count_in_range = hi_idx - lo_idx  # 4 (elements: 3, 4, 5, 7)
```

### DSA Use Cases

| Problem | How bisect Helps |
|---------|-----------------|
| **Longest Increasing Subsequence** (LC 300) | O(n log n) patience sorting with `bisect_left` |
| **Russian Doll Envelopes** (LC 354) | Sort + LIS with `bisect_left` |
| **Search Insert Position** (LC 35) | `bisect_left(nums, target)` ‚Äî literally the answer |
| **Count of Smaller Numbers** (LC 315) | Maintain sorted list, use `bisect_left` |

### LIS with bisect ‚Äî The O(n log n) Solution

```python
import bisect

def length_of_LIS(nums):
    """LC 300 ‚Äî O(n log n) with patience sorting."""
    tails = []  # tails[i] = smallest tail of increasing subseq of length i+1
    for num in nums:
        pos = bisect.bisect_left(tails, num)
        if pos == len(tails):
            tails.append(num)
        else:
            tails[pos] = num
    return len(tails)
```

---

## üì¶ 7. `functools.lru_cache` ‚Äî Memoization Decorator

### What It Does

Caches function results. Turns recursive brute force into dynamic programming with ONE line.

### Code

```python
from functools import lru_cache

# Basic usage
@lru_cache(maxsize=None)  # None = unlimited cache
def fib(n):
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)

fib(100)  # Instant! Without cache: would take billions of years

# Clear cache when needed
fib.cache_clear()

# Check cache stats
fib.cache_info()  # CacheInfo(hits=98, misses=101, maxsize=None, currsize=101)
```

### The Magic: Brute Force ‚Üí DP in One Line

```python
# ‚ùå Without memoization ‚Äî O(2^n), TLE on LC
def coinChange(coins, amount):
    def dp(remaining):
        if remaining == 0: return 0
        if remaining < 0: return float('inf')
        return min(dp(remaining - c) for c in coins) + 1
    result = dp(amount)
    return result if result != float('inf') else -1

# ‚úÖ With lru_cache ‚Äî O(n * amount), AC on LC
from functools import lru_cache

def coinChange(coins, amount):
    @lru_cache(maxsize=None)
    def dp(remaining):
        if remaining == 0: return 0
        if remaining < 0: return float('inf')
        return min(dp(remaining - c) for c in coins) + 1
    result = dp(amount)
    return result if result != float('inf') else -1
```

### ‚ö†Ô∏è Pitfalls

```python
# ‚ö†Ô∏è Arguments must be HASHABLE (no lists!)
@lru_cache(None)
def bad(arr):         # ‚ùå list is not hashable
    pass

@lru_cache(None)
def good(arr):        # ‚úÖ convert to tuple
    pass
good(tuple([1, 2, 3]))

# ‚ö†Ô∏è Cache persists across test cases on LeetCode
# If your function is inside a class method, cache is shared!
# Fix: use cache inside the method scope, or clear it
```

### DSA Use Cases

| Problem | Without Cache | With Cache |
|---------|-------------|-----------|
| **Climbing Stairs** (LC 70) | O(2‚Åø) | O(n) |
| **Coin Change** (LC 322) | O(amount^n) | O(n √ó amount) |
| **House Robber** (LC 198) | O(2‚Åø) | O(n) |
| **Word Break** (LC 139) | O(2‚Åø) | O(n¬≤ √ó m) |
| **Unique Paths** (LC 62) | O(2^(m+n)) | O(m √ó n) |

---

## üì¶ 8. `math` Module ‚Äî Mathematical Utilities

### Essential Functions

```python
import math

# Infinity (for initializing min/max)
math.inf            # Positive infinity
-math.inf           # Negative infinity
# Alternative: float('inf'), float('-inf')

# Rounding
math.ceil(3.2)      # 4 (round up)
math.floor(3.8)     # 3 (round down)

# Square root
math.sqrt(16)       # 4.0
math.isqrt(16)      # 4 (integer square root, Python 3.8+)

# Logarithms
math.log2(1024)     # 10.0
math.log10(1000)    # 3.0
math.log(8, 2)      # 3.0 (log base 2 of 8)

# GCD (greatest common divisor)
math.gcd(12, 8)     # 4
math.gcd(12, 8, 6)  # 2 (Python 3.9+ supports multiple args)

# Factorial
math.factorial(5)   # 120

# Combinations
math.comb(5, 2)     # 10 (Python 3.8+)
math.perm(5, 2)     # 20 (Python 3.8+)
```

### DSA Usage

```python
# Initialize minimum tracker
min_val = math.inf
for num in nums:
    min_val = min(min_val, num)

# Integer division rounding UP (common in binary search)
# ‚ùå math.ceil(a / b) ‚Äî float division issues
# ‚úÖ (a + b - 1) // b ‚Äî integer arithmetic
pages = (total_items + page_size - 1) // page_size
```

---

## üì¶ 9. `sorted()` with Custom Key

### Code

```python
# Sort by absolute value
sorted([-3, 1, -2, 4], key=abs)         # [1, -2, -3, 4]

# Sort strings by length
sorted(["hi", "hello", "a"], key=len)    # ["a", "hi", "hello"]

# Sort tuples by second element
sorted([(1, 3), (2, 1), (3, 2)], key=lambda x: x[1])  # [(2,1), (3,2), (1,3)]

# Sort by multiple criteria (first by length, then alphabetically)
sorted(["banana", "apple", "cherry", "date"], key=lambda x: (len(x), x))

# Reverse sort
sorted(nums, reverse=True)              # Descending

# Sort intervals by end time (Greedy pattern)
intervals = [[1, 3], [2, 6], [5, 7], [8, 10]]
intervals.sort(key=lambda x: x[1])      # Sort by end time
```

### DSA Use Cases

| Problem | Sort Strategy |
|---------|--------------|
| **Merge Intervals** (LC 56) | `intervals.sort(key=lambda x: x[0])` ‚Äî by start |
| **Non-overlapping Intervals** (LC 435) | Sort by end time (greedy) |
| **Largest Number** (LC 179) | Custom comparator with `functools.cmp_to_key` |
| **Meeting Rooms** (LC 252) | Sort by start time |
| **Custom Sort String** (LC 791) | `key=lambda c: order.index(c)` |

### Advanced: `cmp_to_key` for Complex Comparisons

```python
from functools import cmp_to_key

# LC 179: Largest Number
def largestNumber(nums):
    def compare(a, b):
        # Compare "ab" vs "ba" as strings
        if a + b > b + a:
            return -1  # a comes first
        elif a + b < b + a:
            return 1   # b comes first
        return 0

    nums = [str(n) for n in nums]
    nums.sort(key=cmp_to_key(compare))
    result = ''.join(nums)
    return '0' if result[0] == '0' else result
```

---

## üì¶ 10. Essential Patterns & Idioms

### Tuple Unpacking & Swap

```python
# Swap without temp variable
a, b = b, a

# Multiple assignment
x, y, z = 1, 2, 3

# Unpacking in loops
pairs = [(1, 'a'), (2, 'b'), (3, 'c')]
for num, letter in pairs:
    print(num, letter)

# Star unpacking
first, *rest = [1, 2, 3, 4, 5]
# first = 1, rest = [2, 3, 4, 5]
```

### Infinity for Min/Max Tracking

```python
# Initialize trackers
min_val = float('inf')
max_val = float('-inf')

# sys.maxsize for integer contexts
import sys
max_int = sys.maxsize       # 2^63 - 1 on 64-bit
min_int = -sys.maxsize - 1  # -(2^63)
```

### Enumerate & Zip

```python
# Enumerate ‚Äî get index + value
for i, val in enumerate(arr):
    print(f"Index {i}: {val}")

# Enumerate with start index
for i, val in enumerate(arr, start=1):
    pass

# Zip ‚Äî iterate two lists in parallel
for a, b in zip(list1, list2):
    print(a, b)

# Zip for creating dict from two lists
keys = ['a', 'b', 'c']
values = [1, 2, 3]
d = dict(zip(keys, values))  # {'a': 1, 'b': 2, 'c': 3}
```

### List Comprehension Patterns

```python
# Basic
squares = [x**2 for x in range(10)]

# With filter
evens = [x for x in nums if x % 2 == 0]

# 2D grid initialization
grid = [[0] * cols for _ in range(rows)]
# ‚ö†Ô∏è NEVER: grid = [[0] * cols] * rows ‚Äî all rows share same reference!

# Flatten 2D list
flat = [x for row in grid for x in row]

# Dict comprehension
freq = {c: s.count(c) for c in set(s)}
```

---

## ‚è±Ô∏è Complexity Reference

| Module/Operation | Time | Space | Notes |
|-----------------|------|-------|-------|
| `Counter(iterable)` | O(n) | O(k) | k = unique elements |
| `Counter.most_common(k)` | O(n log k) | O(k) | Uses heap internally |
| `defaultdict[key]` | O(1) | O(1) | Same as regular dict |
| `deque.append/popleft` | O(1) | O(1) | WHY you use deque for BFS |
| `list.pop(0)` | O(n) | O(1) | ‚ùå DON'T use for BFS |
| `heapq.heappush/pop` | O(log n) | O(1) | Heap operations |
| `heapq.heapify` | O(n) | O(1) | In-place |
| `bisect.bisect_left` | O(log n) | O(1) | Binary search |
| `bisect.insort` | O(n) | O(1) | O(log n) search + O(n) insert |
| `lru_cache` lookup | O(1) | O(cache size) | Hash-based |
| `sorted(key=...)` | O(n log n) | O(n) | Timsort |

---

## üìù Practice Checklist

Work through these problems using the modules above:

| Problem | Module to Practice | Difficulty |
|---------|-------------------|------------|
| [Valid Anagram (LC 242)](https://leetcode.com/problems/valid-anagram/) | Counter | Easy |
| [Top K Frequent (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/) | Counter + heapq | Medium |
| [Group Anagrams (LC 49)](https://leetcode.com/problems/group-anagrams/) | defaultdict | Medium |
| [Number of Islands (LC 200)](https://leetcode.com/problems/number-of-islands/) | deque (BFS) | Medium |
| [LRU Cache (LC 146)](https://leetcode.com/problems/lru-cache/) | OrderedDict | Medium |
| [Kth Largest (LC 215)](https://leetcode.com/problems/kth-largest-element-in-an-array/) | heapq | Medium |
| [Merge K Lists (LC 23)](https://leetcode.com/problems/merge-k-sorted-lists/) | heapq | Hard |
| [LIS (LC 300)](https://leetcode.com/problems/longest-increasing-subsequence/) | bisect | Medium |
| [Coin Change (LC 322)](https://leetcode.com/problems/coin-change/) | lru_cache | Medium |
| [Merge Intervals (LC 56)](https://leetcode.com/problems/merge-intervals/) | sorted(key=) | Medium |

---

> **üí° Key Insight:** Knowing these 10 modules is the difference between spending 30 minutes fighting Python's stdlib and spending 30 minutes actually solving the problem. Learn them BEFORE you start grinding LeetCode.

---

**Next:** [3.2 JavaScript DSA Toolkit](./3.2-JavaScript-DSA-Toolkit.md) ‚Üí
