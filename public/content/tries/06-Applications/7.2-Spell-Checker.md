# Spell Checker with Trie

> **Build a spell checker that suggests corrections for misspelled words using Trie + edit distance techniques.**

---

## üìã Problem Statement

Design a spell checker that:
1. Checks if a word exists in the dictionary
2. Suggests corrections for misspelled words
3. Handles common typos efficiently

**Example:**
```
Dictionary: ["hello", "help", "world", "word"]

check("hello") ‚Üí True (exists)
check("helo")  ‚Üí False, suggestions: ["hello"]
check("wrld")  ‚Üí False, suggestions: ["world"]
```

---

## üéØ Pattern Recognition

**Patterns Combined:**
- **Trie** for dictionary storage and prefix lookup
- **Edit Distance** for finding similar words
- **DFS/BFS** for exploring corrections

**Key insight:** Use Trie to efficiently search for words within edit distance k of the input.

---

## üìê Approaches

### Approach 1: Trie + Levenshtein Distance

For each query:
1. If exact match exists, return True
2. Otherwise, DFS through Trie allowing edit operations

### Approach 2: Generate-and-Check

Generate all strings within edit distance 1:
- Deletions: remove one character
- Insertions: add one character at each position
- Substitutions: replace one character
- Transpositions: swap adjacent characters

Check each against Trie.

---

## üíª Implementation

### Solution 1: Trie with Fuzzy Search

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False
        self.word = None  # Store the actual word


class SpellChecker:
    """
    Spell checker with Trie-based fuzzy matching.
    
    Exact check: O(m)
    Suggestions: O(26^k √ó m) where k is edit distance
    """
    
    def __init__(self, dictionary: list[str]):
        self.root = TrieNode()
        for word in dictionary:
            self._insert(word)
    
    def _insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
        node.word = word
    
    def check(self, word: str) -> bool:
        """Check if exact word exists."""
        node = self._traverse(word)
        return node is not None and node.is_end
    
    def _traverse(self, word: str):
        node = self.root
        for char in word:
            if char not in node.children:
                return None
            node = node.children[char]
        return node
    
    def suggest(self, word: str, max_distance: int = 1) -> list[str]:
        """
        Find words within edit distance max_distance.
        Uses DFS with early pruning.
        """
        suggestions = []
        self._search_with_distance(
            node=self.root,
            word=word,
            pos=0,
            distance=0,
            max_distance=max_distance,
            suggestions=suggestions
        )
        return suggestions
    
    def _search_with_distance(
        self, 
        node: TrieNode, 
        word: str, 
        pos: int, 
        distance: int, 
        max_distance: int,
        suggestions: list
    ) -> None:
        """DFS through Trie with edit distance budget."""
        
        # Pruning: too many edits already
        if distance > max_distance:
            return
        
        # Reached end of input word
        if pos == len(word):
            if node.is_end:
                suggestions.append(node.word)
            # Can still delete remaining Trie characters
            if distance < max_distance:
                for char, child in node.children.items():
                    self._search_with_distance(
                        child, word, pos, distance + 1, 
                        max_distance, suggestions
                    )
            return
        
        current_char = word[pos]
        
        # Option 1: Match (no edit)
        if current_char in node.children:
            self._search_with_distance(
                node.children[current_char], word, pos + 1, 
                distance, max_distance, suggestions
            )
        
        if distance < max_distance:
            # Option 2: Substitution (replace current_char)
            for char, child in node.children.items():
                if char != current_char:
                    self._search_with_distance(
                        child, word, pos + 1, 
                        distance + 1, max_distance, suggestions
                    )
            
            # Option 3: Deletion (skip current input char)
            self._search_with_distance(
                node, word, pos + 1, 
                distance + 1, max_distance, suggestions
            )
            
            # Option 4: Insertion (use Trie char without consuming input)
            for char, child in node.children.items():
                self._search_with_distance(
                    child, word, pos, 
                    distance + 1, max_distance, suggestions
                )


# Usage
checker = SpellChecker(["hello", "help", "world", "word", "held"])
print(checker.check("hello"))    # True
print(checker.check("helo"))     # False
print(checker.suggest("helo"))   # ["hello", "help", "held"]
print(checker.suggest("wrld"))   # ["world"]
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = new Map();
        this.isEnd = false;
        this.word = null;
    }
}

class SpellChecker {
    constructor(dictionary) {
        this.root = new TrieNode();
        for (const word of dictionary) {
            this._insert(word);
        }
    }
    
    _insert(word) {
        let node = this.root;
        for (const char of word) {
            if (!node.children.has(char)) {
                node.children.set(char, new TrieNode());
            }
            node = node.children.get(char);
        }
        node.isEnd = true;
        node.word = word;
    }
    
    check(word) {
        let node = this.root;
        for (const char of word) {
            if (!node.children.has(char)) return false;
            node = node.children.get(char);
        }
        return node.isEnd;
    }
    
    suggest(word, maxDistance = 1) {
        const suggestions = [];
        this._searchWithDistance(
            this.root, word, 0, 0, maxDistance, suggestions
        );
        return suggestions;
    }
    
    _searchWithDistance(node, word, pos, distance, maxDistance, suggestions) {
        if (distance > maxDistance) return;
        
        if (pos === word.length) {
            if (node.isEnd) {
                suggestions.push(node.word);
            }
            if (distance < maxDistance) {
                for (const [char, child] of node.children) {
                    this._searchWithDistance(
                        child, word, pos, distance + 1, 
                        maxDistance, suggestions
                    );
                }
            }
            return;
        }
        
        const currentChar = word[pos];
        
        // Match
        if (node.children.has(currentChar)) {
            this._searchWithDistance(
                node.children.get(currentChar), word, pos + 1,
                distance, maxDistance, suggestions
            );
        }
        
        if (distance < maxDistance) {
            // Substitution
            for (const [char, child] of node.children) {
                if (char !== currentChar) {
                    this._searchWithDistance(
                        child, word, pos + 1,
                        distance + 1, maxDistance, suggestions
                    );
                }
            }
            
            // Deletion
            this._searchWithDistance(
                node, word, pos + 1,
                distance + 1, maxDistance, suggestions
            );
            
            // Insertion
            for (const [char, child] of node.children) {
                this._searchWithDistance(
                    child, word, pos,
                    distance + 1, maxDistance, suggestions
                );
            }
        }
    }
}
```

---

### Solution 2: Generate-and-Check (Simpler)

**Python:**
```python
class SimpleSpellChecker:
    """
    Generate all edit-distance-1 variants and check against Trie.
    Simpler but may generate more candidates.
    """
    
    def __init__(self, dictionary: list[str]):
        self.words = set(dictionary)
        self.root = TrieNode()
        for word in dictionary:
            self._insert(word)
    
    def _insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def check(self, word: str) -> bool:
        return word in self.words
    
    def suggest(self, word: str) -> list[str]:
        """Generate all edits and filter valid words."""
        if word in self.words:
            return [word]
        
        edits = self._edits1(word)
        # Filter to valid words
        return [w for w in edits if w in self.words]
    
    def _edits1(self, word: str) -> set:
        """All words within edit distance 1."""
        letters = 'abcdefghijklmnopqrstuvwxyz'
        splits = [(word[:i], word[i:]) for i in range(len(word) + 1)]
        
        # Deletions: remove one letter
        deletes = [L + R[1:] for L, R in splits if R]
        
        # Transpositions: swap adjacent letters
        transposes = [L + R[1] + R[0] + R[2:] for L, R in splits if len(R) > 1]
        
        # Substitutions: replace one letter
        replaces = [L + c + R[1:] for L, R in splits if R for c in letters]
        
        # Insertions: add one letter
        inserts = [L + c + R for L, R in splits for c in letters]
        
        return set(deletes + transposes + replaces + inserts)
    
    def suggest_distance_2(self, word: str) -> list[str]:
        """Words within edit distance 2."""
        if word in self.words:
            return [word]
        
        # Distance 1
        edits1 = self._edits1(word)
        known1 = [w for w in edits1 if w in self.words]
        if known1:
            return known1
        
        # Distance 2
        edits2 = set(e2 for e1 in edits1 for e2 in self._edits1(e1))
        return [w for w in edits2 if w in self.words]


# Usage
checker = SimpleSpellChecker(["hello", "help", "world", "word"])
print(checker.suggest("helo"))   # ["hello"]
print(checker.suggest("wrld"))   # ["world"]
```

---

## ‚ö° Complexity Analysis

### Trie + DFS Approach

| Operation | Time | Space |
|-----------|------|-------|
| Build dictionary | O(n √ó m) | O(n √ó m) |
| Exact check | O(m) | O(1) |
| Suggest (k=1) | O(26 √ó m) | O(m) recursion |
| Suggest (k=2) | O(26¬≤ √ó m) | O(m) |

### Generate-and-Check Approach

| Operation | Time | Space |
|-----------|------|-------|
| Edits distance 1 | O(26 √ó m) | O(26 √ó m) |
| Edits distance 2 | O(26¬≤ √ó m¬≤) | O(26¬≤ √ó m¬≤) |
| Filter valid | O(edits) | O(1) per check |

**Trade-off:** Generate-and-check is simpler but creates many invalid candidates. Trie+DFS prunes invalid paths early.

---

## üîÑ Advanced Features

### Ranking Suggestions

```python
def suggest_ranked(self, word: str) -> list[str]:
    """Rank by frequency and edit distance."""
    suggestions = []
    
    # Collect with distance
    for dist in [1, 2]:
        found = self._find_within_distance(word, dist)
        for w in found:
            suggestions.append((w, dist, self.frequency.get(w, 0)))
    
    # Sort by distance first, then by frequency (descending)
    suggestions.sort(key=lambda x: (x[1], -x[2]))
    
    return [w for w, _, _ in suggestions[:5]]
```

### Common Typo Patterns

```python
# Keyboard proximity substitutions
KEYBOARD_NEIGHBORS = {
    'a': 'qwsz', 'b': 'vghn', 'c': 'xdfv',
    # ... full keyboard mapping
}

def weighted_edits(self, word: str) -> dict:
    """Weight edits by likelihood."""
    edits = {}
    
    for i, char in enumerate(word):
        # Adjacent key typo (more likely)
        for neighbor in KEYBOARD_NEIGHBORS.get(char, ''):
            edit = word[:i] + neighbor + word[i+1:]
            edits[edit] = 0.8  # High probability
        
        # Random substitution (less likely)
        for c in 'abcdefghijklmnopqrstuvwxyz':
            edit = word[:i] + c + word[i+1:]
            if edit not in edits:
                edits[edit] = 0.2
    
    return edits
```

---

## ‚ö†Ô∏è Edge Cases

| Case | Handling |
|------|----------|
| Empty word | Return False, no suggestions |
| Very long word | May timeout on large k |
| All caps/mixed case | Normalize before check |
| Word equals suggestion | Don't include self |

---

## üé§ Interview Tips

**Opening statement:**
"I'll build a Trie for the dictionary. For spell checking, I'll use DFS with an edit distance budget, allowing substitution, insertion, and deletion at each step."

**Trade-offs to discuss:**
1. "Trie+DFS prunes early vs generate-and-check creates many candidates"
2. "Edit distance 1 catches most typos; 2 is rarely needed"
3. "Can rank by word frequency for better suggestions"

**Follow-ups:**
- "How to handle proper nouns?" ‚Üí Separate dictionary or skip check
- "Scale to millions of words?" ‚Üí Compress Trie, limit distance
- "Real-time as-you-type?" ‚Üí Cache prefix suggestions

---

## üìù Practice Checklist

- [ ] Implement basic Trie spell checker
- [ ] Add fuzzy search with edit distance
- [ ] Handle all edit types (substitute, insert, delete)
- [ ] Rank suggestions by relevance
- [ ] Optimize for performance

<details>
<summary><strong>üß† Spaced Repetition</strong></summary>

- **Day 1:** Implement exact check with Trie
- **Day 3:** Add fuzzy search (distance 1)
- **Day 7:** Implement generate-and-check alternative
- **Day 14:** Add ranking and keyboard proximity

</details>

---

> **üí° Key Insight:** The Trie structure lets us prune the search space early - if a prefix doesn't exist, we don't explore further, unlike generate-and-check which creates all candidates first.

> **üîó Related:** [Search Operation](../02-Trie-Operations/3.2-Search-Operation.md) | [Autocomplete](7.1-Autocomplete-System.md)
