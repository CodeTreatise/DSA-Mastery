# Rolling Hash Overview

> A technique for computing hash values incrementally as a window slides over data, enabling O(n) string matching instead of O(n*m).

Rolling hash is the foundation for efficient string searching algorithms like Rabin-Karp. It allows recomputing a hash in O(1) by "rolling" out the old character and "rolling" in the new one.

---

## üéØ Pattern Recognition

<details>
<summary><strong>Problem Signals</strong></summary>

**Keywords indicating rolling hash:**
- "Find pattern in string"
- "Substring matching"
- "Repeated DNA sequences"
- "Longest duplicate substring"
- "Compare multiple substrings efficiently"

**When rolling hash shines:**
```
Naive: Check each position ‚Üí O(n √ó m) comparisons
       Each comparison is O(m) for m-length pattern

Rolling: Compute hash incrementally ‚Üí O(n + m)
         Each new position is O(1) hash update
```

**Problem Classification:**
```
Category: String Matching
Key Insight: Reuse previous hash computation
Time Complexity: O(n) for n-length string
Space Complexity: O(1) for hash value
```

</details>

---

## ‚úÖ When to Use Rolling Hash

- Finding pattern occurrences in text
- Detecting repeated substrings
- Comparing multiple substrings efficiently
- Plagiarism detection / document fingerprinting
- Longest common substring problems

---

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|-------------------|
| Single exact match | KMP, Boyer-Moore |
| Pattern with wildcards | Dynamic programming |
| Regex matching | Regex engine |
| Edit distance | DP approach |
| Need exact match guarantee | KMP (no false positives) |

**Important:** Rolling hash can have false positives (hash collision). Always verify matches!

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Related Concepts</strong></summary>

**Before this, understand:**
- [Hash Functions](../01-Hash-Fundamentals/1.2-Hash-Functions.md) - Polynomial hash basics
- [Modular Arithmetic](../../16-Math-Number-Theory/modular.md) - For avoiding overflow
- String basics

**After mastering this:**
- [Rabin-Karp Algorithm](./9.2-Rabin-Karp.md) - Pattern matching
- Longest Duplicate Substring (LC 1044)
- Rolling hash for trees/graphs

**Combines with:**
- Binary Search (for longest substring problems)
- Sliding Window (window movement)

</details>

---

## üìê How It Works

### The Core Idea

Instead of recomputing hash from scratch for each window position, we:
1. **Remove** the leftmost character's contribution
2. **Shift** the remaining hash
3. **Add** the new rightmost character

### Polynomial Hash Representation

For string `s` of length `m`, hash is computed as:
```
hash(s) = s[0] √ó base^(m-1) + s[1] √ó base^(m-2) + ... + s[m-1] √ó base^0
```

Where:
- `base` = prime number (commonly 26, 31, or 131)
- Characters are converted to numbers (a=1, b=2, ... or ASCII values)

### Rolling Update Formula

When sliding window from position `i` to `i+1`:

```
Old window: s[i : i+m]
New window: s[i+1 : i+m+1]

hash_new = (hash_old - s[i] √ó base^(m-1)) √ó base + s[i+m]
```

### Visual Walkthrough

```
String: "abcdef"    Pattern length: 3    Base: 26

Position 0: "abc"
‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ a ‚îÇ b ‚îÇ c ‚îÇ d   e   f
‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
hash = a√ó26¬≤ + b√ó26¬π + c√ó26‚Å∞
     = 1√ó676 + 2√ó26 + 3√ó1
     = 676 + 52 + 3 = 731

Position 1: "bcd"
    ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  a ‚îÇ b ‚îÇ c ‚îÇ d ‚îÇ e   f
    ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Rolling update:
1. Remove 'a': 731 - 1√ó676 = 55
2. Shift left (√ó26): 55 √ó 26 = 1430
3. Add 'd': 1430 + 4 = 1434

hash = 1434 = b√ó26¬≤ + c√ó26¬π + d√ó26‚Å∞
            = 2√ó676 + 3√ó26 + 4√ó1 ‚úì
```

### Modular Arithmetic (Avoiding Overflow)

For long patterns, use modulo to prevent overflow:

```
hash = (hash √ó base + char) % MOD
```

Common MOD values: `10^9 + 7`, large primes like `1000000007`

---

## üíª Code Implementation

### Python - Basic Rolling Hash

```python
class RollingHash:
    """
    Rolling hash for string windows.
    
    Uses polynomial hash with base and modulo.
    hash(s) = s[0] * base^(m-1) + ... + s[m-1] * base^0 (mod MOD)
    
    Time: O(m) initial, O(1) per roll
    Space: O(1)
    """
    
    def __init__(self, base: int = 31, mod: int = 10**9 + 7):
        self.base = base
        self.mod = mod
    
    def hash_string(self, s: str) -> int:
        """
        Compute hash of entire string.
        Time: O(n)
        """
        h = 0
        for char in s:
            h = (h * self.base + ord(char)) % self.mod
        return h
    
    def compute_initial(self, s: str, length: int) -> tuple[int, int]:
        """
        Compute hash of first window and power for rolling.
        Returns (hash, base^(length-1))
        """
        h = 0
        for i in range(length):
            h = (h * self.base + ord(s[i])) % self.mod
        
        # Precompute base^(length-1) for removal
        power = pow(self.base, length - 1, self.mod)
        
        return h, power
    
    def roll(self, old_hash: int, old_char: str, new_char: str, 
             power: int) -> int:
        """
        Roll hash from one window to next.
        
        Removes old_char (leftmost), adds new_char (rightmost).
        Time: O(1)
        """
        # Remove old character contribution
        h = old_hash - ord(old_char) * power
        
        # Handle negative modulo
        h = (h % self.mod + self.mod) % self.mod
        
        # Shift left and add new character
        h = (h * self.base + ord(new_char)) % self.mod
        
        return h


# Example usage for pattern matching:
def find_pattern_with_rolling_hash(text: str, pattern: str) -> list[int]:
    """
    Find all occurrences of pattern in text using rolling hash.
    Returns list of starting indices.
    """
    if len(pattern) > len(text):
        return []
    
    rh = RollingHash()
    m = len(pattern)
    n = len(text)
    
    # Hash the pattern
    pattern_hash = rh.hash_string(pattern)
    
    # Hash first window
    text_hash, power = rh.compute_initial(text, m)
    
    result = []
    
    # Check first window
    if text_hash == pattern_hash:
        # Verify to handle hash collision
        if text[:m] == pattern:
            result.append(0)
    
    # Roll through remaining windows
    for i in range(1, n - m + 1):
        text_hash = rh.roll(text_hash, text[i - 1], text[i + m - 1], power)
        
        if text_hash == pattern_hash:
            # Verify match
            if text[i:i + m] == pattern:
                result.append(i)
    
    return result


# Trace example:
# text = "abcabc", pattern = "abc"
# pattern_hash = hash("abc") = 1√ó31¬≤ + 2√ó31¬π + 3√ó31‚Å∞ = 961 + 62 + 3 = 1026
#
# i=0: window "abc", hash = 1026 == 1026 ‚úì, verify ‚Üí match at 0
# i=1: window "bca", roll ‚Üí different hash, skip
# i=2: window "cab", roll ‚Üí different hash, skip
# i=3: window "abc", roll ‚Üí 1026 == 1026 ‚úì, verify ‚Üí match at 3
#
# Result: [0, 3]
```

### Python - Double Hash (Reduce False Positives)

```python
class DoubleRollingHash:
    """
    Use two different hash functions to minimize collision probability.
    
    Probability of collision: 1/MOD1 √ó 1/MOD2 ‚âà 10^-18
    """
    
    def __init__(self):
        self.base1, self.mod1 = 31, 10**9 + 7
        self.base2, self.mod2 = 37, 10**9 + 9
    
    def hash_string(self, s: str) -> tuple[int, int]:
        """Return (hash1, hash2)"""
        h1, h2 = 0, 0
        for c in s:
            h1 = (h1 * self.base1 + ord(c)) % self.mod1
            h2 = (h2 * self.base2 + ord(c)) % self.mod2
        return (h1, h2)
    
    def compute_initial(self, s: str, length: int):
        """Return ((h1, h2), (pow1, pow2))"""
        h1, h2 = 0, 0
        for i in range(length):
            h1 = (h1 * self.base1 + ord(s[i])) % self.mod1
            h2 = (h2 * self.base2 + ord(s[i])) % self.mod2
        
        pow1 = pow(self.base1, length - 1, self.mod1)
        pow2 = pow(self.base2, length - 1, self.mod2)
        
        return (h1, h2), (pow1, pow2)
    
    def roll(self, hashes, old_char, new_char, powers):
        """Roll both hashes simultaneously."""
        h1, h2 = hashes
        pow1, pow2 = powers
        
        h1 = ((h1 - ord(old_char) * pow1) % self.mod1 + self.mod1) % self.mod1
        h1 = (h1 * self.base1 + ord(new_char)) % self.mod1
        
        h2 = ((h2 - ord(old_char) * pow2) % self.mod2 + self.mod2) % self.mod2
        h2 = (h2 * self.base2 + ord(new_char)) % self.mod2
        
        return (h1, h2)
```

### JavaScript - Rolling Hash

```javascript
class RollingHash {
    /**
     * Rolling hash for string windows.
     * @param {number} base - Hash base (default 31)
     * @param {number} mod - Modulo value (default 1e9 + 7)
     */
    constructor(base = 31, mod = 1e9 + 7) {
        this.base = base;
        this.mod = mod;
    }
    
    /**
     * Hash entire string.
     * @param {string} s
     * @return {number}
     */
    hashString(s) {
        let h = 0;
        for (const char of s) {
            h = (h * this.base + char.charCodeAt(0)) % this.mod;
        }
        return h;
    }
    
    /**
     * Compute initial window hash and power.
     * @param {string} s
     * @param {number} length
     * @return {{hash: number, power: number}}
     */
    computeInitial(s, length) {
        let h = 0;
        for (let i = 0; i < length; i++) {
            h = (h * this.base + s.charCodeAt(i)) % this.mod;
        }
        
        // Compute base^(length-1) mod
        let power = 1;
        for (let i = 0; i < length - 1; i++) {
            power = (power * this.base) % this.mod;
        }
        
        return { hash: h, power };
    }
    
    /**
     * Roll hash to next window.
     * @param {number} oldHash
     * @param {string} oldChar
     * @param {string} newChar
     * @param {number} power
     * @return {number}
     */
    roll(oldHash, oldChar, newChar, power) {
        // Remove old character
        let h = oldHash - oldChar.charCodeAt(0) * power;
        
        // Handle negative mod
        h = ((h % this.mod) + this.mod) % this.mod;
        
        // Shift and add new character
        h = (h * this.base + newChar.charCodeAt(0)) % this.mod;
        
        return h;
    }
}

/**
 * Find pattern in text using rolling hash.
 * @param {string} text
 * @param {string} pattern
 * @return {number[]} Starting indices
 */
function findPattern(text, pattern) {
    if (pattern.length > text.length) return [];
    
    const rh = new RollingHash();
    const m = pattern.length;
    const n = text.length;
    
    const patternHash = rh.hashString(pattern);
    let { hash: textHash, power } = rh.computeInitial(text, m);
    
    const result = [];
    
    // Check first window
    if (textHash === patternHash && text.slice(0, m) === pattern) {
        result.push(0);
    }
    
    // Roll through rest
    for (let i = 1; i <= n - m; i++) {
        textHash = rh.roll(textHash, text[i - 1], text[i + m - 1], power);
        
        if (textHash === patternHash && text.slice(i, i + m) === pattern) {
            result.push(i);
        }
    }
    
    return result;
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| Initial hash (length m) | O(m) | O(1) |
| Single roll | O(1) | O(1) |
| Pattern matching (n text, m pattern) | O(n + m) | O(1) |
| With verification | O(n + m) average | O(1) |

**Worst case:** O(n √ó m) if many hash collisions (rare with good primes)

---

## üîÑ Variations

| Variation | Use Case | Difference |
|-----------|----------|------------|
| Single hash | Basic matching | Faster, more collisions |
| Double hash | Critical applications | Two independent hashes |
| Polynomial hash | Standard | Uses powers of base |
| Cyclic polynomial | Memory | Uses XOR, rotation |
| Rabin fingerprint | Binary data | Polynomial over GF(2) |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Handle Negative Modulo

```python
# ‚ùå WRONG: Negative result possible
h = (old_hash - ord(old_char) * power) % mod
# If subtraction goes negative, Python handles it, but...

# In some languages like C++/Java:
h = (old_hash - ord(old_char) * power) % mod
# Can give negative result!

# ‚úÖ CORRECT: Ensure positive
h = ((old_hash - ord(old_char) * power) % mod + mod) % mod
```

### 2. Integer Overflow

```python
# ‚ùå WRONG: May overflow for long patterns
power = base ** (length - 1)  # Huge number!

# ‚úÖ CORRECT: Use modular exponentiation
power = pow(base, length - 1, mod)
```

### 3. Not Verifying Matches

```python
# ‚ùå WRONG: Hash collision can cause false positive
if text_hash == pattern_hash:
    result.append(i)  # Might not actually match!

# ‚úÖ CORRECT: Always verify
if text_hash == pattern_hash:
    if text[i:i+m] == pattern:  # Verify actual match
        result.append(i)
```

### 4. Off-by-One in Power Calculation

```python
# ‚ùå WRONG: Power for removal
power = pow(base, length, mod)  # Should be length-1!

# ‚úÖ CORRECT: Power is base^(length-1)
power = pow(base, length - 1, mod)

# Because: hash = char[0] √ó base^(m-1) + ... + char[m-1] √ó base^0
# To remove char[0], multiply by base^(m-1)
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Key Concept |
|---------|------------|-------------|
| Implement strStr() | üü¢ Easy | Basic pattern matching |
| Repeated DNA Sequences | üü° Medium | 10-char rolling hash |
| Longest Duplicate Substring | üî¥ Hard | Binary search + rolling hash |
| Distinct Echo Substrings | üî¥ Hard | Double hash |

**LeetCode Links:**
- [28. Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/)
- [187. Repeated DNA Sequences](https://leetcode.com/problems/repeated-dna-sequences/)
- [1044. Longest Duplicate Substring](https://leetcode.com/problems/longest-duplicate-substring/)
- [1316. Distinct Echo Substrings](https://leetcode.com/problems/distinct-echo-substrings/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand polynomial hash formula
- **Day 3:** Implement rolling update from scratch
- **Day 7:** Solve LC 187 (Repeated DNA)
- **Day 14:** Handle the power/modulo correctly
- **Day 30:** Solve LC 1044 (Binary search + rolling hash)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Communication Tips</strong></summary>

**Explain the intuition:**
> "Instead of recomputing the hash for each window position, I can 'roll' it by removing the old character's contribution and adding the new character's. This turns O(m) per position into O(1)."

**Address hash collisions:**
> "Hash collisions can cause false positives, so I verify actual matches when hashes are equal. With a large prime modulo, collisions are rare."

**Trade-offs to mention:**
- Rolling hash is simpler than KMP but has potential false positives
- Good for multiple pattern search or approximate matching
- Base and modulo choice affects collision probability

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Rabin-Karp variants |
| Amazon | ‚≠ê‚≠ê‚≠ê | Pattern matching |
| Meta | ‚≠ê‚≠ê‚≠ê | String problems |
| Competitive | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand concept | 20 min |
| Implement basic rolling hash | 15 min |
| Handle edge cases (negative mod) | 10 min |
| Solve pattern matching problem | 20 min |
| Master double hash | 30 min |

---

> **üí° Key Insight:** Rolling hash trades mathematical elegance for simplicity. By representing strings as numbers (polynomial hash), we can compare substrings in O(1) by comparing their hash values. The "rolling" update removes the old character and adds the new in O(1), enabling O(n) string matching.

> **üîó Related:** [Rabin-Karp Algorithm](./9.2-Rabin-Karp.md) | [Hash Functions](../01-Hash-Fundamentals/1.2-Hash-Functions.md) | [Sliding Window](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/02-Sliding-Window.md)
