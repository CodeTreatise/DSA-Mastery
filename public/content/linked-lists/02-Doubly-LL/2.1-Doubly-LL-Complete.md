# 2.1 Doubly Linked List - Complete Guide

> **Grokking Pattern:** Foundation for LRU Cache, Browser History, Deques
>
> ‚è±Ô∏è Estimated Learning Time: 45-60 minutes

---

## Overview

A **Doubly Linked List (DLL)** is a linked list where each node contains a pointer to both the next node AND the previous node. This bidirectional navigation enables O(1) deletion when you have a reference to the node.

```
null ‚Üê [1] ‚áÑ [2] ‚áÑ [3] ‚áÑ [4] ‚Üí null
       head                tail
```

**Key Advantage:** If you have a reference to any node, you can delete it in O(1) time without needing to traverse from head.

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Choose DLL Over Singly LL</strong></summary>

| Signal | Why DLL? | Example |
|--------|----------|---------|
| Need backward traversal | Can go prev | Browser history |
|" O(1) deletion with node reference "| Have prev pointer | LRU Cache |
| Frequent inserts/deletes at both ends | No tail finding needed | Deque |
| Need to remove from middle often | Direct access to neighbors | Text editor cursor |
| Undo/Redo functionality | Navigate both directions | Editor operations |

</details>

---

## ‚úÖ When to Use Doubly Linked List

- **LRU Cache** - Need O(1) move to front when accessed
- **Browser history** - Navigate forward and backward
- **Deque implementation** - Efficient both-end operations
- **Text editors** - Cursor movement both directions
- **Undo/Redo systems** - Bidirectional operation history
- **Music playlists** - Next/previous song

---

## ‚ùå When NOT to Use

| Use Case | Why Not DLL | Use Instead |
|----------|-------------|-------------|
| Memory constrained | 2x pointers per node | Singly LL |
| Only forward traversal | Extra pointer wasted | Singly LL |
| Simple queue/stack | Simpler is better | Singly LL |
| Large datasets | Higher memory overhead | Arrays or Singly LL |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Singly Linked List Basics](../01-Singly-LL/1.1-Basics.md)
- [Basic Operations](../01-Singly-LL/1.2-Operations.md)

**After mastering this:**
- [LRU Cache](../08-Advanced-Problems/8.1-LRU-Cache.md) - Classic DLL application
- Implement a Deque from scratch
- Browser history implementation

**Combines with:**
- Hash Map for O(1) lookup + O(1) operations (LRU Cache)
- Stack operations for undo/redo

</details>

---

## üìê Node Structure

### Visualization

```
           prev pointer
               ‚Üì
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   null ‚Üê‚îÇ prev | data | next ‚îÇ‚Üí next node
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚Üë
          next pointer
```

### Python Implementation

```python
class DoublyListNode:
    """Node for Doubly Linked List."""
    
    def __init__(self, val=0, prev=None, next=None):
        self.val = val
        self.prev = prev   # Pointer to previous node
        self.next = next   # Pointer to next node


class DoublyLinkedList:
    """
    Doubly Linked List with head and tail pointers.
    
    Using sentinel nodes (dummy head/tail) simplifies edge cases.
    """
    
    def __init__(self):
        # Sentinel nodes - they don't hold real data
        self.head = DoublyListNode()  # Dummy head
        self.tail = DoublyListNode()  # Dummy tail
        
        # Connect dummy nodes
        self.head.next = self.tail
        self.tail.prev = self.head
        
        self.size = 0
    
    def __len__(self):
        return self.size
    
    def is_empty(self):
        return self.size == 0
```

### JavaScript Implementation

```javascript
class DoublyListNode {
    constructor(val = 0, prev = null, next = null) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}

class DoublyLinkedList {
    constructor() {
        // Sentinel nodes
        this.head = new DoublyListNode();
        this.tail = new DoublyListNode();
        
        // Connect dummy nodes
        this.head.next = this.tail;
        this.tail.prev = this.head;
        
        this.size = 0;
    }
    
    isEmpty() {
        return this.size === 0;
    }
}
```

---

## üíª Core Operations

### Why Sentinel Nodes?

```
Without sentinels - many edge cases:
- Insert at empty list: check if head is null
- Delete last node: update head to null
- Insert at head: update head pointer

With sentinels - uniform operations:
- Always have prev and next nodes
- No null checks for neighbors
- Same code for all positions
```

```
Sentinel structure:
[dummy_head] ‚áÑ [real nodes...] ‚áÑ [dummy_tail]
     ‚Üë                              ‚Üë
    head                           tail
```

---

### Insert Operations

#### Insert After a Node (Core Operation)

```python
def _insert_after(self, node: DoublyListNode, val) -> DoublyListNode:
    """
    Insert new node after given node.
    Time: O(1)
    
    This is the core insertion - all other inserts use this.
    """
    new_node = DoublyListNode(val)
    next_node = node.next
    
    # Connect new node
    new_node.prev = node
    new_node.next = next_node
    
    # Update neighbors
    node.next = new_node
    next_node.prev = new_node
    
    self.size += 1
    return new_node
```

```
Before: [node] ‚áÑ [next_node]
After:  [node] ‚áÑ [new] ‚áÑ [next_node]

Steps:
1. new.prev = node
2. new.next = next_node  
3. node.next = new
4. next_node.prev = new
```

#### Insert at Head (After Dummy Head)

```python
def insert_at_head(self, val) -> DoublyListNode:
    """Insert at the beginning (after dummy head)."""
    return self._insert_after(self.head, val)
```

#### Insert at Tail (Before Dummy Tail)

```python
def insert_at_tail(self, val) -> DoublyListNode:
    """Insert at the end (before dummy tail)."""
    return self._insert_after(self.tail.prev, val)
```

**JavaScript:**

```javascript
_insertAfter(node, val) {
    const newNode = new DoublyListNode(val);
    const nextNode = node.next;
    
    newNode.prev = node;
    newNode.next = nextNode;
    node.next = newNode;
    nextNode.prev = newNode;
    
    this.size++;
    return newNode;
}

insertAtHead(val) {
    return this._insertAfter(this.head, val);
}

insertAtTail(val) {
    return this._insertAfter(this.tail.prev, val);
}
```

---

### Delete Operations

#### Remove a Node (Core Operation)

```python
def _remove(self, node: DoublyListNode):
    """
    Remove a node from the list.
    Time: O(1)
    
    This is why DLL shines - no need to find predecessor!
    """
    prev_node = node.prev
    next_node = node.next
    
    # Bypass the node
    prev_node.next = next_node
    next_node.prev = prev_node
    
    self.size -= 1
    return node.val
```

```
Before: [prev] ‚áÑ [node] ‚áÑ [next]
After:  [prev] ‚áÑ [next]

Steps:
1. prev.next = next
2. next.prev = prev
(node is now orphaned - garbage collected)
```

#### Remove from Head/Tail

```python
def remove_from_head(self):
    """Remove and return first real node."""
    if self.is_empty():
        raise IndexError("List is empty")
    return self._remove(self.head.next)

def remove_from_tail(self):
    """Remove and return last real node."""
    if self.is_empty():
        raise IndexError("List is empty")
    return self._remove(self.tail.prev)
```

**JavaScript:**

```javascript
_remove(node) {
    const prevNode = node.prev;
    const nextNode = node.next;
    
    prevNode.next = nextNode;
    nextNode.prev = prevNode;
    
    this.size--;
    return node.val;
}

removeFromHead() {
    if (this.isEmpty()) throw new Error("List is empty");
    return this._remove(this.head.next);
}

removeFromTail() {
    if (this.isEmpty()) throw new Error("List is empty");
    return this._remove(this.tail.prev);
}
```

---

### Move to Front (Key for LRU Cache)

```python
def move_to_front(self, node: DoublyListNode):
    """
    Move existing node to front of list.
    Time: O(1)
    
    Key operation for LRU Cache - recently accessed items go to front.
    """
    # Remove from current position
    self._remove(node)
    self.size += 1  # Compensate for remove's decrement
    
    # Insert at front (without creating new node)
    node.prev = self.head
    node.next = self.head.next
    self.head.next.prev = node
    self.head.next = node
```

**JavaScript:**

```javascript
moveToFront(node) {
    // Remove from current position
    this._remove(node);
    this.size++;  // Compensate
    
    // Insert at front
    node.prev = this.head;
    node.next = this.head.next;
    this.head.next.prev = node;
    this.head.next = node;
}
```

---

### Traversal Operations

```python
def traverse_forward(self):
    """Iterate from head to tail."""
    result = []
    current = self.head.next  # Skip dummy head
    while current != self.tail:  # Stop before dummy tail
        result.append(current.val)
        current = current.next
    return result

def traverse_backward(self):
    """Iterate from tail to head."""
    result = []
    current = self.tail.prev  # Skip dummy tail
    while current != self.head:  # Stop before dummy head
        result.append(current.val)
        current = current.prev
    return result
```

**JavaScript:**

```javascript
traverseForward() {
    const result = [];
    let current = this.head.next;
    while (current !== this.tail) {
        result.push(current.val);
        current = current.next;
    }
    return result;
}

traverseBackward() {
    const result = [];
    let current = this.tail.prev;
    while (current !== this.head) {
        result.push(current.val);
        current = current.prev;
    }
    return result;
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Insert at head/tail |" O(1) "| O(1) | With sentinel nodes |
| Insert after node |" O(1) "| O(1) | Given node reference |
| Delete head/tail |" O(1) "| O(1) | With sentinel nodes |
| Delete given node |" O(1) "| O(1) | **DLL advantage!** |
| Search by value |" O(n) "| O(1) | Must traverse |
| Access by index |" O(n) "| O(1) | Must traverse |
| Move to front |" O(1) "| O(1) | Key for LRU |

**Memory per node:**
- Singly LL: 1 pointer + data
- Doubly LL: 2 pointers + data (~1.5-2x memory)

---

## üîÑ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| With sentinels | Dummy head/tail nodes | Cleaner code, fewer edge cases |
| Without sentinels | Real head/tail | Memory constrained |
| Circular DLL | Tail connects to head | Round-robin scheduling |
| XOR Linked List | Uses XOR for both pointers | Memory optimization (rare) |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Update Both Pointers

```python
# ‚ùå Wrong - only updated next
def bad_insert(self, node, val):
    new_node = DoublyListNode(val)
    new_node.next = node.next
    node.next = new_node
    # Forgot: new_node.prev = node
    # Forgot: node.next.prev = new_node

# ‚úÖ Correct - update all 4 connections
def good_insert(self, node, val):
    new_node = DoublyListNode(val)
    next_node = node.next
    
    new_node.prev = node
    new_node.next = next_node
    node.next = new_node
    next_node.prev = new_node
```

### 2. Order of Operations Matters

```python
# ‚ùå Wrong order - loses reference
def bad_delete(self, node):
    node.prev.next = node.next
    node.next.prev = node.prev  # ‚úì But what if we did this first?
    
# If we wrote: node.next = something_else BEFORE using it,
# we'd lose the original reference!

# ‚úÖ Correct - save references first
def good_delete(self, node):
    prev_node = node.prev  # Save first
    next_node = node.next  # Save first
    prev_node.next = next_node
    next_node.prev = prev_node
```

### 3. Not Handling Empty List

```python
# ‚ùå Without sentinels - many null checks
def insert_bad(self, val):
    if self.head is None:
        self.head = self.tail = DoublyListNode(val)
    else:
        new_node = DoublyListNode(val)
        new_node.next = self.head
        self.head.prev = new_node
        self.head = new_node

# ‚úÖ With sentinels - no special cases
def insert_good(self, val):
    self._insert_after(self.head, val)  # Works even if empty!
```

---

## üìù Practice Problems

### Easy (Learn the structure)
- [ ] Design a DLL with basic operations
- [ ] [Design Browser History](https://leetcode.com/problems/design-browser-history/) - LC 1472

### Medium (Apply to real problems)
- [ ] [LRU Cache](https://leetcode.com/problems/lru-cache/) - LC 146 ‚≠ê‚≠ê‚≠ê Classic!
- [ ] [Flatten a Multilevel Doubly Linked List](https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/) - LC 430

### Hard
- [ ] [LFU Cache](https://leetcode.com/problems/lfu-cache/) - LC 460

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement DLL from scratch with all operations
- **Day 3:** Solve LRU Cache (the classic DLL problem)
- **Day 7:** Re-implement without reference
- **Day 14:** Add Browser History problem
- **Day 30:** Review LRU Cache edge cases

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Interview Tips for DLL Problems</strong></summary>

**When to mention DLL:**
- "I need O(1) deletion with a node reference ‚Üí DLL"
- "I need to move nodes frequently ‚Üí DLL with hash map"
- "I need bidirectional traversal ‚Üí DLL"

**LRU Cache is THE DLL interview problem:**
1. Explain: "I'll use DLL for O(1) move-to-front + O(1) remove-from-tail"
2. Explain: "Hash map gives O(1) lookup of nodes"
3. Show you understand sentinel nodes simplify edge cases

**Common follow-ups:**
- "Why not just use an array?" ‚Üí O(n) to move elements
- "Why DLL over singly?" ‚Üí Need O(1) remove without predecessor

</details>

**Company Focus:**

| Company | Problem | Frequency |
|---------|---------|-----------|
| Amazon | LRU Cache | ‚≠ê‚≠ê‚≠ê‚≠ê Very High |
| Meta | LRU Cache | ‚≠ê‚≠ê‚≠ê‚≠ê Very High |
| Google | LRU/LFU Cache | ‚≠ê‚≠ê‚≠ê High |
| Microsoft | LRU Cache | ‚≠ê‚≠ê‚≠ê High |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn DLL structure | 15-20 min | Node with two pointers |
| Implement basic ops | 20-30 min | Insert, delete, traverse |
| Understand sentinels | 10-15 min | Why they simplify code |
| Solve LRU Cache | 30-45 min | Classic application |
| Master DLL | 2-3 hours | Multiple problems |

---

## üíª Complete Implementation

```python
class DoublyLinkedList:
    """Complete Doubly Linked List with sentinel nodes."""
    
    def __init__(self):
        self.head = DoublyListNode()  # Dummy head
        self.tail = DoublyListNode()  # Dummy tail
        self.head.next = self.tail
        self.tail.prev = self.head
        self.size = 0
    
    def __len__(self):
        return self.size
    
    def is_empty(self):
        return self.size == 0
    
    def _insert_after(self, node, val):
        new_node = DoublyListNode(val)
        next_node = node.next
        new_node.prev = node
        new_node.next = next_node
        node.next = new_node
        next_node.prev = new_node
        self.size += 1
        return new_node
    
    def insert_at_head(self, val):
        return self._insert_after(self.head, val)
    
    def insert_at_tail(self, val):
        return self._insert_after(self.tail.prev, val)
    
    def _remove(self, node):
        prev_node = node.prev
        next_node = node.next
        prev_node.next = next_node
        next_node.prev = prev_node
        self.size -= 1
        return node.val
    
    def remove_from_head(self):
        if self.is_empty():
            raise IndexError("List is empty")
        return self._remove(self.head.next)
    
    def remove_from_tail(self):
        if self.is_empty():
            raise IndexError("List is empty")
        return self._remove(self.tail.prev)
    
    def move_to_front(self, node):
        self._remove(node)
        self.size += 1
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def to_list(self):
        result = []
        current = self.head.next
        while current != self.tail:
            result.append(current.val)
            current = current.next
        return result
```

---

> **üí° Key Insight:** The power of DLL comes from having access to both neighbors. Combined with a hash map for O(1) node lookup, you get O(1) for all operations - this is exactly what LRU Cache needs!

---

## üîó Related

- [Singly Linked List](../01-Singly-LL/1.1-Basics.md) - Simpler alternative
- [LRU Cache](../08-Advanced-Problems/8.1-LRU-Cache.md) - Classic DLL application
- [Circular Linked List](../03-Circular-LL/3.1-Circular-LL-Complete.md) - Circular variant
