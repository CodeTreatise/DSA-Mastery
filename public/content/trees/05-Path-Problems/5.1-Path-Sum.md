# 5.1 - Path Sum (LC 112)

> **Grokking Pattern:** #11 Tree DFS (Path Tracking)
>
> **Difficulty:** Easy | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very Common

---

## Problem Statement

Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf path** such that adding up all the values along the path equals `targetSum`.

A **leaf** is a node with no children.

```
Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1

Output: true (path 5 ‚Üí 4 ‚Üí 11 ‚Üí 2 = 22)
```

[LeetCode 112 - Path Sum](https://leetcode.com/problems/path-sum/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Root-to-leaf path"
- "Sum equals target"
- Path must end at a LEAF

**Key insight:**
DFS traversal, subtracting node values from target. When reaching a leaf, check if remaining target is 0.

</details>

---

## ‚úÖ When to Use

- Checking if path with specific sum exists
- Root-to-leaf path problems
- Path validation

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Need all paths | Just checking existence | Path Sum II |
| Any path (not root-to-leaf) | Different constraint | Path Sum III |
| Maximum path sum | Not target sum | Max Path Sum |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [DFS Concept](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
- Basic tree traversal

**After mastering this:**
- [Path Sum II](./5.2-Path-Sum-II.md) - Find all paths
- [Path Sum III](https://leetcode.com/problems/path-sum-iii/) - Any path
- [Sum Root to Leaf Numbers](./5.4-Sum-Root-to-Leaf.md)

</details>

---

## üìê How It Works

### Subtract as You Go

```
Target = 22
              5          remaining = 22 - 5 = 17
             / \
            4   8        remaining = 17 - 4 = 13
           /
          11             remaining = 13 - 11 = 2
         /  \
        7    2           At leaf 2: remaining = 2 - 2 = 0 ‚úì

Instead of adding values, subtract from target.
At leaf: if remaining == 0, path found!
```

### Why Check at Leaf

```
              5
             /
            4       ‚Üê NOT a leaf (has child)
           /
          2         ‚Üê IS a leaf (no children)

Path sum 5 + 4 = 9 ends at 4? NO!
4 is not a leaf, so this doesn't count.
```

---

## üíª Code Implementation

### Solution 1: Recursive DFS

**Python:**
```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def has_path_sum(root: Optional[TreeNode], target_sum: int) -> bool:
    """
    Check if root-to-leaf path with target sum exists.
    
    Subtract node values from target.
    At leaf, check if remaining is 0.
    Time: O(n), Space: O(h)
    """
    if not root:
        return False
    
    # Subtract current node's value
    remaining = target_sum - root.val
    
    # Check if leaf
    if not root.left and not root.right:
        return remaining == 0
    
    # Check left or right subtree
    return (has_path_sum(root.left, remaining) or 
            has_path_sum(root.right, remaining))
```

**JavaScript:**
```javascript
function hasPathSum(root, targetSum) {
    if (!root) return false;
    
    const remaining = targetSum - root.val;
    
    // Check if leaf
    if (!root.left && !root.right) {
        return remaining === 0;
    }
    
    // Check either subtree
    return hasPathSum(root.left, remaining) || 
           hasPathSum(root.right, remaining);
}
```

### Solution 2: Iterative with Stack

**Python:**
```python
def has_path_sum_iterative(root: Optional[TreeNode], target_sum: int) -> bool:
    """
    Iterative DFS with stack.
    
    Store (node, remaining_sum) pairs.
    Time: O(n), Space: O(h)
    """
    if not root:
        return False
    
    stack = [(root, target_sum - root.val)]
    
    while stack:
        node, remaining = stack.pop()
        
        # Check if leaf with sum satisfied
        if not node.left and not node.right:
            if remaining == 0:
                return True
            continue
        
        # Add children with updated remaining
        if node.right:
            stack.append((node.right, remaining - node.right.val))
        if node.left:
            stack.append((node.left, remaining - node.left.val))
    
    return False
```

### Solution 3: BFS (Level Order)

**Python:**
```python
from collections import deque

def has_path_sum_bfs(root: Optional[TreeNode], target_sum: int) -> bool:
    """
    BFS approach - less common but valid.
    
    Track cumulative sum to each node.
    """
    if not root:
        return False
    
    queue = deque([(root, root.val)])
    
    while queue:
        node, current_sum = queue.popleft()
        
        # Check if leaf
        if not node.left and not node.right:
            if current_sum == target_sum:
                return True
            continue
        
        if node.left:
            queue.append((node.left, current_sum + node.left.val))
        if node.right:
            queue.append((node.right, current_sum + node.right.val))
    
    return False
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Recursive |" O(n) "| O(h) | h = height |
| Iterative |" O(n) "| O(h) | Stack size |
| BFS |" O(n) "| O(w) | Queue width |

---

## üîÑ Variations

| Variation | Difference | LeetCode |
|-----------|------------|----------|
| Path Sum II | Return all paths | LC 113 |
| Path Sum III | Any path, not just root-to-leaf | LC 437 |
| Sum Root to Leaf | All paths as numbers | LC 129 |
| Maximum Path Sum | Max sum, any path | LC 124 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Checking for Leaf

```python
# ‚ùå WRONG: Checking remaining at any node
def has_path_sum(root, target_sum):
    if not root:
        return target_sum == 0  # Wrong! Null is not a leaf

# ‚úÖ CORRECT: Only check at actual leaves
def has_path_sum(root, target_sum):
    if not root:
        return False
    
    remaining = target_sum - root.val
    
    # Check ONLY if it's a leaf
    if not root.left and not root.right:
        return remaining == 0
```

### 2. Checking Before Subtracting

```python
# ‚ùå WRONG: Checking before subtracting current value
def has_path_sum(root, target_sum):
    if not root.left and not root.right:
        return target_sum == 0  # Didn't subtract root.val!

# ‚úÖ CORRECT: Subtract first, then check
remaining = target_sum - root.val
if not root.left and not root.right:
    return remaining == 0
```

### 3. Handling Negative Values

```python
# Note: Tree can have negative values!
# Don't add early termination like:
if remaining < 0:  # WRONG! Negative values can bring it back
    return False

# Just continue the traversal
```

---

## üìù Practice Problems

### This Problem
- [ ] [Path Sum](https://leetcode.com/problems/path-sum/) - LC 112

### Path Sum Series
- [ ] [Path Sum II](https://leetcode.com/problems/path-sum-ii/) - LC 113
- [ ] [Path Sum III](https://leetcode.com/problems/path-sum-iii/) - LC 437
- [ ] [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/) - LC 124

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Basic Path Sum (this problem)
**Day 3:** Path Sum II (return all paths)
**Day 7:** Path Sum III (any path)
**Day 14:** Maximum Path Sum (hardest)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Clarifying the problem:**
> "Just to confirm - we need a root-to-leaf path, meaning the path must end at a node with no children, correct?"

**Explaining approach:**
> "I'll use DFS, subtracting each node's value from the target. When I reach a leaf, I check if the remaining sum is zero."

**Why subtract instead of add:**
> "Subtracting is cleaner - I don't need to track the cumulative sum. At each call, I just pass the remaining target."

**Follow-up - Find all paths:**
> "For Path Sum II, I'd track the current path and when I find a valid leaf, add a copy of the path to my results."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Often leads to Path Sum II |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask variations |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Classic question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Recursive solution | 5-7 min | Should be quick |
| Iterative solution | 7-10 min | If asked |
| Explain leaf check | 2 min | Important distinction |

---

> **üí° Key Insight:** The critical part is checking at LEAF nodes only. A null node is NOT a leaf. A node with no children IS a leaf. Subtracting from target is cleaner than accumulating sum - at each leaf, just check if remaining equals 0.

---

## üîó Related

- [Path Sum II](./5.2-Path-Sum-II.md)
- [Maximum Path Sum](./5.3-Maximum-Path-Sum.md)
- [DFS Concept](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
