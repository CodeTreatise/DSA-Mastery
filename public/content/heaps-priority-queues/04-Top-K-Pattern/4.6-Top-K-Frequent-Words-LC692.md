# 4.6 Top K Frequent Words (LC 692)

## Problem Statement

Given an array of strings `words` and an integer `k`, return the **k most frequent strings**. Return the answer **sorted by frequency from highest to lowest**. If two words have the same frequency, sort them by **lexicographical order** (alphabetically).

**Example:**
```
Input: words = ["i","love","leetcode","i","love","coding"], k = 2
Output: ["i","love"]
Explanation: "i" and "love" appear twice, "leetcode" and "coding" once.
"i" comes before "love" lexicographically.

Input: words = ["the","day","is","sunny","the","the","the","sunny","is","is"], k = 4
Output: ["the","is","sunny","day"]
Explanation: "the" (4), "is" (3), "sunny" (2), "day" (1)
```

**LeetCode:** [692. Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>Pattern: Top K with Custom Comparator</strong></summary>

**Key signals:**
- "Top K" + frequency
- Secondary sort criterion (lexicographical)
- Need ordered output

**This extends basic Top K because:**
```
Basic Top K (LC 347):
  - Just find K most frequent
  - Order among K doesn't matter

Top K Words (LC 692):
  - Find K most frequent
  - Sort by frequency (descending)
  - Tie-break by word (ascending/lexicographical)
```

**The challenge:**
- Heap needs custom comparison
- Higher frequency = higher priority
- Same frequency: alphabetically earlier = higher priority

</details>

---

## ‚úÖ When to Use This Pattern

| Scenario | Approach |
|----------|----------|
| Top K with tie-breaking | Custom comparator |
| Need sorted output | Max-heap or sort result |
| Lexicographic tie-break | Negate comparison |

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|---------------------|
| No tie-breaking needed | Simple LC 347 approach |
| Very small dataset | Just sort |
| Need all words sorted | Full sort |

---

## üìê Solution Approaches

### Approach 1: Min-Heap with Custom Comparator

```
Strategy: Keep min-heap of size K

Challenge: Min-heap pops "smallest" - we want smallest to be:
  - Lowest frequency (so we keep highest)
  - Alphabetically LAST for ties (so we keep earliest)

Custom comparison for min-heap:
  - Compare frequency: lower frequency = smaller
  - If tie: alphabetically later = smaller (reverse!)

After heap: We have K best, but in min-heap order
  - Pop all and reverse, OR
  - Use max-heap and pop in order
```

### Approach 2: Max-Heap (Simpler Logic)

```
Strategy: Use max-heap of ALL elements

Max-heap comparison:
  - Higher frequency = higher priority
  - Alphabetically earlier = higher priority

Pop K times to get result
```

### Approach 3: Bucket Sort

```
Strategy: Group by frequency, then sort within buckets

Buckets:
  freq=4: ["the"]
  freq=3: ["is"]  
  freq=2: ["sunny"]
  freq=1: ["coding", "day", ...]

Iterate from highest frequency, sort each bucket
Collect until K words
```

---

## üíª Code Implementation

### Approach 1: Min-Heap of Size K (Optimal)

**Python:**
```python
import heapq
from collections import Counter

def topKFrequent(words: list[str], k: int) -> list[str]:
    """
    LC 692: Top K Frequent Words
    
    Min-heap of size K with custom comparison:
    - Lower frequency = smaller (gets popped first)
    - For same frequency: later word = smaller (gets popped first)
    
    Time: O(n log K)
    Space: O(n) for counter
    """
    # Count frequencies
    count = Counter(words)
    
    # Min-heap: (frequency, word)
    # Python heapq is min-heap, so we need:
    # - Smaller frequency pops first (correct - keep larger)
    # - For ties: We want earlier word to stay
    #   So later word should be "smaller" and pop first
    #   We can negate the word comparison by wrapping
    
    # Use wrapper class for custom comparison
    class WordFreq:
        def __init__(self, word, freq):
            self.word = word
            self.freq = freq
        
        def __lt__(self, other):
            # For min-heap to pop "worst" first:
            # Worst = lower frequency
            # If tie: worst = alphabetically LATER
            if self.freq != other.freq:
                return self.freq < other.freq
            return self.word > other.word  # Later word is "smaller"
    
    heap = []
    
    for word, freq in count.items():
        heapq.heappush(heap, WordFreq(word, freq))
        if len(heap) > k:
            heapq.heappop(heap)  # Remove worst
    
    # Extract and reverse (heap is min-heap)
    result = []
    while heap:
        result.append(heapq.heappop(heap).word)
    
    return result[::-1]  # Reverse to get best first


# Alternative using tuples (trickier)
def topKFrequent_tuple(words: list[str], k: int) -> list[str]:
    """
    Using tuples with negation trick.
    
    Tuple: (-freq, word)
    - Negate frequency for max-heap behavior
    - Word comparison is natural (earlier = smaller)
    """
    count = Counter(words)
    
    # For this approach, use max-heap (negate freq)
    heap = [(-freq, word) for word, freq in count.items()]
    heapq.heapify(heap)  # O(n)
    
    return [heapq.heappop(heap)[1] for _ in range(k)]


# Example
words = ["i", "love", "leetcode", "i", "love", "coding"]
print(topKFrequent(words, 2))  # ["i", "love"]
```

### Approach 2: Sorting with Custom Key

**Python:**
```python
from collections import Counter

def topKFrequent_sort(words: list[str], k: int) -> list[str]:
    """
    Simple sorting approach.
    
    Sort by: (-frequency, word)
    - Negated frequency: higher frequency comes first
    - Word: alphabetically earlier comes first
    
    Time: O(n log n)
    Space: O(n)
    """
    count = Counter(words)
    
    # Sort by (-frequency, word)
    sorted_words = sorted(count.keys(), key=lambda w: (-count[w], w))
    
    return sorted_words[:k]


# Example
words = ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"]
print(topKFrequent_sort(words, 4))  # ["the", "is", "sunny", "day"]
```

### Approach 3: Bucket Sort (Linear for Small Frequencies)

**Python:**
```python
from collections import Counter, defaultdict

def topKFrequent_bucket(words: list[str], k: int) -> list[str]:
    """
    Bucket sort approach.
    
    Time: O(n + k log k) - can be faster if k << n
    Space: O(n)
    """
    count = Counter(words)
    
    # Group words by frequency
    buckets = defaultdict(list)
    max_freq = 0
    for word, freq in count.items():
        buckets[freq].append(word)
        max_freq = max(max_freq, freq)
    
    # Collect k words from highest frequency buckets
    result = []
    for freq in range(max_freq, 0, -1):
        if freq in buckets:
            # Sort bucket lexicographically
            bucket = sorted(buckets[freq])
            for word in bucket:
                result.append(word)
                if len(result) == k:
                    return result
    
    return result
```

### JavaScript Solution

**JavaScript:**
```javascript
function topKFrequent(words, k) {
    // Count frequencies
    const count = new Map();
    for (const word of words) {
        count.set(word, (count.get(word) || 0) + 1);
    }
    
    // Convert to array and sort
    const entries = [...count.entries()];
    
    // Sort by: frequency descending, then word ascending
    entries.sort((a, b) => {
        if (b[1] !== a[1]) return b[1] - a[1];  // Higher freq first
        return a[0].localeCompare(b[0]);        // Earlier word first
    });
    
    // Take first k
    return entries.slice(0, k).map(entry => entry[0]);
}

// Example
console.log(topKFrequent(
    ["i", "love", "leetcode", "i", "love", "coding"], 2
));  // ["i", "love"]
```

### JavaScript with Custom Heap

**JavaScript:**
```javascript
class MinHeapWords {
    constructor() {
        this.heap = [];
    }
    
    size() { return this.heap.length; }
    
    // Compare: return true if a should come before b (a is "smaller")
    // Smaller = lower priority = gets popped first
    compare(a, b) {
        if (a.freq !== b.freq) return a.freq < b.freq;  // Lower freq = smaller
        return a.word > b.word;  // Later word = smaller
    }
    
    push(word, freq) {
        this.heap.push({ word, freq });
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return min;
    }
    
    peek() { return this.heap[0]; }
    
    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (!this.compare(this.heap[i], this.heap[parent])) break;
            [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
            i = parent;
        }
    }
    
    _bubbleDown(i) {
        const n = this.heap.length;
        while (true) {
            let smallest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;
            if (left < n && this.compare(this.heap[left], this.heap[smallest])) {
                smallest = left;
            }
            if (right < n && this.compare(this.heap[right], this.heap[smallest])) {
                smallest = right;
            }
            if (smallest === i) break;
            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
            i = smallest;
        }
    }
}


function topKFrequentHeap(words, k) {
    const count = new Map();
    for (const word of words) {
        count.set(word, (count.get(word) || 0) + 1);
    }
    
    const heap = new MinHeapWords();
    
    for (const [word, freq] of count.entries()) {
        heap.push(word, freq);
        if (heap.size() > k) {
            heap.pop();
        }
    }
    
    // Extract and reverse
    const result = [];
    while (heap.size() > 0) {
        result.push(heap.pop().word);
    }
    
    return result.reverse();
}
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Min-Heap Size K |" O(n log K) "| O(n) | Optimal for K << n |
| Max-Heap (all) |" O(n + K log n) "| O(n) | heapify + K pops |
| Sorting |" O(n log n) "| O(n) | Simple but slower |
| Bucket Sort |" O(n + k log k) "| O(n) | Best if max freq small |

**When to use which:**
- K << n: Min-heap of size K
- K ‚âà n: Sorting or max-heap
- Very high frequencies: Bucket sort

---

## üîÑ Variations

| Variation | Difference | Example |
|-----------|------------|---------|
| Most frequent (no tie-break) | LC 347 | Simpler |
| Least frequent | Use max-heap | Keep smallest freq |
| With removal | Indexed PQ | Harder |
| Top K in window | Sliding window + heap | Advanced |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Tie-Breaking Order

```python
# ‚ùå Wrong: Alphabetically later first
sorted_words = sorted(count.keys(), key=lambda w: (-count[w], w), reverse=True)

# ‚úÖ Correct: Alphabetically earlier first
sorted_words = sorted(count.keys(), key=lambda w: (-count[w], w))
```

### 2. Wrong Min-Heap Comparison for Ties

```python
# ‚ùå Wrong: Earlier word pops first (should stay!)
def __lt__(self, other):
    if self.freq != other.freq:
        return self.freq < other.freq
    return self.word < other.word  # Wrong for min-heap!

# ‚úÖ Correct: Later word pops first (we keep earlier)
def __lt__(self, other):
    if self.freq != other.freq:
        return self.freq < other.freq
    return self.word > other.word  # Later word is "worse"
```

### 3. Not Reversing Final Result

```python
# ‚ùå Wrong: Returning min-heap order (worst first)
result = []
while heap:
    result.append(heapq.heappop(heap).word)
return result  # Reversed order!

# ‚úÖ Correct: Reverse to get best first
return result[::-1]
```

### 4. Using Wrong Data Structure

```python
# ‚ùå Wrong: Using just tuple without wrapper
# (-freq, word) works for max-heap but not for custom min-heap logic

# For min-heap of size K with tie-breaking:
# Use wrapper class or careful tuple negation
```

---

## üìù Related Practice Problems

### Similar (Top K variants)
- [ ] [Top K Frequent Elements (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/) - No tie-break
- [ ] [Sort Characters By Frequency (LC 451)](https://leetcode.com/problems/sort-characters-by-frequency/) - All characters

### Harder
- [ ] [Top K Frequent Words (Follow-up)](https://leetcode.com/problems/top-k-frequent-words/) - O(n log K) strict
- [ ] [Design Twitter (LC 355)](https://leetcode.com/problems/design-twitter/) - Custom comparison

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve with sorting approach
- **Day 3:** Implement with min-heap + wrapper class
- **Day 7:** Compare with LC 347 (no tie-break)
- **Day 14:** Implement O(n log K) strictly
- **Day 30:** Teach the tie-breaking logic

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This Solution</strong></summary>

**Opening:**
"This is a Top K Frequent problem with tie-breaking. I'll use a min-heap of size K, but with custom comparison. The heap should pop the 'worst' candidates first, where worst means lower frequency, or if tied, alphabetically later."

**Explaining comparison:**
"For the min-heap, I define the comparison so that lower frequency elements are 'smaller' and get popped first. For equal frequencies, I treat alphabetically later words as 'smaller' so they get popped and we keep the earlier ones."

**Follow-up - O(n log K):**
"The sorting approach is O(n log n). For strict O(n log K), I use a min-heap of size K. Each of the n elements does at most O(log K) work, giving O(n log K) total."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Follow-up on complexity |
| Google | ‚≠ê‚≠ê‚≠ê | May ask variations |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Standard question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 3-5 min | Note tie-breaking! |
| Design solution | 5-7 min | Decide approach |
| Implement (sorting) | 8-10 min | Simpler |
| Implement (heap) | 12-15 min | Custom comparator |
| Test | 3-5 min | Check tie-break cases |

**Interview target:** 25-30 minutes

---

## üí° Key Insight

> **For Top K with tie-breaking, the min-heap comparison must be reversed for the secondary criterion.** We want to keep alphabetically earlier words, so alphabetically later words should be "smaller" in the min-heap comparison - they get popped first, leaving the better candidates.

---

## üîó Related

- **Previous:** [K Closest Points (LC 973)](./4.5-K-Closest-Points-LC973.md)
- **Pattern:** [Top K Overview](./4.1-Top-K-Overview.md)
- **Simpler:** [Top K Frequent Elements (LC 347)](./4.4-Top-K-Frequent-LC347.md)
