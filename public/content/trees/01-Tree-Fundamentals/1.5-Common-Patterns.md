# 1.5 - Common Tree Patterns

> **Foundation:** Recognizing patterns that appear across tree problems
>
> **Priority:** Learn these patterns to solve problems faster

---

## Overview

Tree problems fall into recognizable patterns. Learning these patterns allows you to map new problems to familiar solutions, which is the most valuable interview skill.

> "The ability to map a new problem to an already known problem is the most important skill."
> ‚Äî Grokking the Coding Interview

---

## üéØ The 7 Major Tree Patterns

| Pattern | Description | % of Problems |
|---------|-------------|---------------|
| **1. Traversal** | Visit all nodes in specific order | ~15% |
| **2. Properties** | Calculate/verify tree attributes | ~20% |
| **3. Path** | Find/process paths in tree | ~20% |
| **4. Ancestor/Descendant** | Relationship between nodes | ~15% |
| **5. Construction** | Build tree from data | ~10% |
| **6. Transformation** | Modify tree structure | ~10% |
| **7. BST-specific** | Leverage BST ordering | ~10% |

---

## üìê Pattern 1: Traversal Problems

### Recognition Signals
- "Return all nodes in [order]"
- "Print/collect tree values"
- "Visit each node"

### Template

```python
def traverse(node):
    if not node:
        return []
    
    # Adjust order for pre/in/post
    result = []
    result.extend(traverse(node.left))
    result.append(node.val)  # Move for different order
    result.extend(traverse(node.right))
    
    return result
```

### Key Problems
- LC 94, 144, 145 - Basic traversals
- LC 102, 103 - Level order variations
- LC 987 - Vertical order

---

## üìê Pattern 2: Tree Properties

### Recognition Signals
- "Calculate [height/depth/size/diameter]"
- "Check if tree is [balanced/symmetric/same]"
- "Count [nodes/leaves/levels]"

### Template

```python
def calculate_property(node):
    if not node:
        return base_value  # 0 for height, True for checks
    
    left = calculate_property(node.left)
    right = calculate_property(node.right)
    
    return combine(node.val, left, right)
```

### Common Properties

| Property | Base Case | Combine |
|----------|-----------|---------|
| Height | 0 | 1 + max(left, right) |
| Size | 0 | 1 + left + right |
| Sum | 0 | node.val + left + right |
| Balanced | True | abs(left-right) <= 1 and both balanced |

### Key Problems
- LC 104, 111 - Depth problems
- LC 543 - Diameter (global variable pattern)
- LC 100, 101 - Same/symmetric tree
- LC 110 - Balanced tree

---

## üìê Pattern 3: Path Problems

### Recognition Signals
- "Find path from root to [leaf/target]"
- "Path sum equals [target]"
- "Maximum/minimum path"
- "All paths" or "any path"

### Template (Root to Leaf)

```python
def path_problem(node, target):
    if not node:
        return False  # or default
    
    # Leaf check
    if not node.left and not node.right:
        return node.val == target
    
    # Continue path to children
    new_target = target - node.val
    return path_problem(node.left, new_target) or \
           path_problem(node.right, new_target)
```

### Template (Track Path)

```python
def find_paths(node, target, path, all_paths):
    if not node:
        return
    
    path.append(node.val)
    
    if not node.left and not node.right and target == node.val:
        all_paths.append(path[:])  # Copy!
    else:
        find_paths(node.left, target - node.val, path, all_paths)
        find_paths(node.right, target - node.val, path, all_paths)
    
    path.pop()  # Backtrack!
```

### Key Problems
- LC 112, 113 - Path sum series
- LC 124 - Maximum path sum (any path)
- LC 257 - All root-to-leaf paths
- LC 129 - Root to leaf numbers

---

## üìê Pattern 4: Ancestor/Descendant

### Recognition Signals
- "Lowest common ancestor"
- "Distance between nodes"
- "Path between two nodes"
- "Ancestors of a node"

### Template (LCA)

```python
def lca(node, p, q):
    if not node or node == p or node == q:
        return node
    
    left = lca(node.left, p, q)
    right = lca(node.right, p, q)
    
    if left and right:
        return node  # Found split point
    
    return left or right
```

### Key Problems
- LC 236 - LCA of binary tree
- LC 235 - LCA of BST
- LC 1123 - LCA of deepest leaves

---

## üìê Pattern 5: Construction

### Recognition Signals
- "Construct tree from [traversals]"
- "Build/create tree"
- "Serialize/deserialize"

### Template (From Traversals)

```python
def build_tree(preorder, inorder):
    if not preorder:
        return None
    
    root = TreeNode(preorder[0])
    mid = inorder.index(preorder[0])
    
    root.left = build_tree(preorder[1:mid+1], inorder[:mid])
    root.right = build_tree(preorder[mid+1:], inorder[mid+1:])
    
    return root
```

### Key Problems
- LC 105, 106 - From traversals
- LC 297 - Serialize/deserialize
- LC 1008 - BST from preorder

---

## üìê Pattern 6: Transformation

### Recognition Signals
- "Invert/mirror tree"
- "Flatten tree"
- "Convert to [linked list/another structure]"

### Template

```python
def transform(node):
    if not node:
        return None
    
    # Transform children
    left = transform(node.left)
    right = transform(node.right)
    
    # Apply transformation
    node.left = right  # Example: invert
    node.right = left
    
    return node
```

### Key Problems
- LC 226 - Invert binary tree
- LC 114 - Flatten to linked list
- LC 116, 117 - Populate next pointers

---

## üìê Pattern 7: BST-Specific

### Recognition Signals
- "Binary search tree"
- "Sorted order"
- "kth smallest/largest"
- "Validate BST"

### BST Properties
- Inorder traversal gives sorted order
- For each node: left < node < right
- Search is O(log n) for balanced BST

### Template (Inorder for Sorted)

```python
def kth_smallest(node, k):
    stack = []
    current = node
    count = 0
    
    while stack or current:
        while current:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        count += 1
        if count == k:
            return current.val
        
        current = current.right
```

### Key Problems
- LC 98 - Validate BST
- LC 230 - Kth smallest
- LC 235 - LCA in BST
- LC 700 - Search in BST

---

## üîÑ Pattern Decision Flowchart

```
What does the problem ask for?
‚îÇ
‚îú‚îÄ Visit all nodes?
‚îÇ  ‚îî‚îÄ Traversal Pattern
‚îÇ
‚îú‚îÄ Calculate tree attribute?
‚îÇ  ‚îî‚îÄ Properties Pattern
‚îÇ
‚îú‚îÄ Find/process paths?
‚îÇ  ‚îî‚îÄ Path Pattern
‚îÇ
‚îú‚îÄ Relationship between nodes?
‚îÇ  ‚îî‚îÄ Ancestor/Descendant Pattern
‚îÇ
‚îú‚îÄ Build or serialize tree?
‚îÇ  ‚îî‚îÄ Construction Pattern
‚îÇ
‚îú‚îÄ Modify tree structure?
‚îÇ  ‚îî‚îÄ Transformation Pattern
‚îÇ
‚îî‚îÄ BST with ordering needed?
   ‚îî‚îÄ BST-Specific Pattern
```

---

## üí° Pattern Combinations

Many problems combine patterns:

| Problem | Patterns Combined |
|---------|------------------|
| Maximum Path Sum (LC 124) | Path + Properties (global variable) |
| LCA of Deepest Leaves (LC 1123) | Ancestor + Properties (depth) |
| Serialize Tree (LC 297) | Construction + Traversal |
| Validate BST (LC 98) | BST + Properties (bounds passing) |

---

## ‚ö° DFS vs BFS Decision

| Use DFS (Recursion) | Use BFS (Queue) |
|--------------------|-----------------|
| Path problems | Level-by-level processing |
| Properties (height, balance) | Width/level calculations |
| Ancestor problems | Right/left side view |
| Most tree problems | Shortest path (unweighted) |

---

## üìù Pattern Practice Order

### Week 1: Core Patterns
1. Traversals (LC 94, 144, 145, 102)
2. Properties (LC 104, 100, 101, 226)

### Week 2: Path & Ancestor
3. Path Sum Series (LC 112, 113, 124)
4. LCA (LC 236, 235)

### Week 3: Construction & BST
5. Construction (LC 105, 106, 297)
6. BST Problems (LC 98, 230, 700)

---

## üé§ Interview Context

<details>
<summary><strong>How to Quickly Identify Patterns</strong></summary>

**Ask yourself:**
1. Do I need to visit all nodes? ‚Üí Traversal
2. Am I calculating something about the tree? ‚Üí Properties
3. Am I looking for paths? ‚Üí Path pattern
4. Am I finding relationships? ‚Üí Ancestor/Descendant
5. Am I building a tree? ‚Üí Construction
6. Am I changing the tree? ‚Üí Transformation
7. Is BST ordering helpful? ‚Üí BST pattern

**Then verbalize:**
> "This looks like a [pattern] problem because [key signal]. I'll use [template approach]."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn all patterns | 60-90 min | Conceptual |
| Practice 1 problem per pattern | 2-3 hours | Application |
| Master pattern recognition | 1-2 weeks | Many problems |

---

> **üí° Key Insight:** You don't need to memorize 100 tree problems. Learn these 7 patterns deeply, and you can solve most tree problems by mapping them to a known pattern. The key is recognizing the signals that tell you which pattern to apply.

---

## üîó Related

- [DFS Traversals](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
- [BFS Traversals](../03-Tree-Traversals/3.2-BFS-Traversals/00-BFS-Concept.md)
- [Path Problems](../05-Path-Problems/)
- [Tree Properties](../04-Tree-Properties/)
