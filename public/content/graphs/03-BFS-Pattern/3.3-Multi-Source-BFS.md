# 3.3 Multi-Source BFS

> **BFS from multiple starting points simultaneously - spreading in parallel**
>
> â±ï¸ **Time:** 35-45 min | ğŸ“Š **Difficulty:** Medium | ğŸ¯ **Interview Frequency:** â­â­â­â­â­ (Classic pattern)

---

## Overview

**Multi-Source BFS** starts from multiple sources at the same time, spreading outward in parallel. This is the key technique for "spreading" problems like rotting oranges or finding nearest distances from multiple points.

```
Regular BFS:                Multi-Source BFS:
Start from ONE point        Start from MULTIPLE points

    [S]                         [S1]     [S2]
     â”‚                           â”‚         â”‚
     â–¼                           â–¼         â–¼
   Level 1                    Level 1   Level 1
     â”‚                           â”‚         â”‚
     â–¼                           â–¼         â–¼
   Level 2                    Level 2   Level 2
                                    â•²     â•±
                                     Level 3 (they meet!)

Key: All sources start at distance 0
     They spread simultaneously
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>How to Identify Multi-Source BFS Problems</strong></summary>

**Look for these signals:**
- "All X start spreading simultaneously"
- "Find minimum distance TO any X"
- "All X start at the same time"
- "Fire/water/infection spreads from multiple points"
- "Distance from nearest X"

**Keywords in problem statement:**
- "simultaneously"
- "at the same time"
- "nearest distance to any"
- "spreading from all"
- "minimum time for all to be affected"

**Classic problems:**
- Rotting Oranges (rotten oranges spread simultaneously)
- 01 Matrix (distance to nearest 0)
- Walls and Gates (distance to nearest gate)
- Shortest Bridge (grow both islands simultaneously)

</details>

---

## âœ… When to Use Multi-Source BFS

| Scenario | Example |
|----------|---------|
| Spreading from multiple sources | Rotting Oranges - infection spreads |
| Distance to nearest target | 01 Matrix - distance to nearest 0 |
| Multiple starting points, any goal | Escape fire from any exit |
| Simultaneous processes | Multiple fires spreading |
| Shortest path involving multiple endpoints | Shortest Bridge |

---

## âŒ When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Distance from single source | Simpler single-source BFS | Standard BFS |
| Need path, not just distance | Track parent per source | Modified BFS |
| Weighted edges | BFS ignores weights | Dijkstra |
| Different "speeds" per source | All sources must spread equally | Custom algorithm |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BFS Fundamentals](./3.1-BFS-Fundamentals.md)
- [BFS Template](./3.2-BFS-Template.md)

**After mastering this:**
- [Grid Traversal](../05-Grid-Traversal/5.1-Grid-Introduction.md)
- [Island Pattern](../05-Grid-Traversal/5.2-Island-Pattern.md)
- [Shortest Bridge](../05-Grid-Traversal/5.3-Grid-Practice/03-Shortest-Bridge-LC934.md)

**Related patterns:**
- Dijkstra from multiple sources (weighted version)
- Bidirectional BFS (special case with 2 sources)

</details>

---

## ğŸ“ How It Works

### Core Insight

Instead of starting with ONE node in the queue, we start with ALL source nodes:

```python
# Single-source BFS
queue = deque([source])
visited = {source}

# Multi-source BFS
queue = deque(sources)  # ALL sources at once
visited = set(sources)  # ALL marked visited
```

### Step-by-Step Visualization

```
Problem: Find distance from each cell to nearest 0

Grid:            Step 0 (initialize):    Step 1 (spread):
 _______          Queue = [(0,0), (2,2)]   Queue = [(0,1), (1,0), (1,2), (2,1)]
|0|1|1|          Distance:               Distance:
|1|1|1|          |0|?|?|                  |0|1|?|
|1|1|0|          |?|?|?|                  |1|?|1|
                 |?|?|0|                  |?|1|0|

Step 2:                Step 3 (final):
Queue = [(1,1)]        Queue = []
Distance:              Distance:
|0|1|2|                |0|1|2|
|1|2|1|                |1|2|1|
|2|1|0|                |2|1|0|

All 0s spread simultaneously â†’ Each cell gets distance to NEAREST 0!
```

### Why It Works

When sources spread simultaneously:
- Each cell is first reached by its NEAREST source
- Distance recorded = distance to nearest source
- No need to run BFS from each source separately!

### Complexity Advantage

```
N sources, M cells:

Naive approach: Run BFS from each source
Time: O(N Ã— M) = O(N Ã— M)

Multi-source BFS: One BFS with all sources
Time: O(M) - each cell visited ONCE!
                â†‘
        Massive improvement!
```

---

## ğŸ’» Code Implementation

### Template: Multi-Source BFS

**Python:**
```python
from collections import deque

def multi_source_bfs(grid, sources):
    """
    Multi-Source BFS Template.
    
    Key difference from regular BFS:
    - Initialize queue with ALL sources
    - All sources start at distance 0
    - First reach to any cell = distance from NEAREST source
    
    Time: O(rows Ã— cols)
    Space: O(rows Ã— cols)
    """
    if not grid or not grid[0] or not sources:
        return grid
    
    rows, cols = len(grid), len(grid[0])
    DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # KEY: Initialize with ALL sources
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    visited = set()
    queue = deque()
    
    # Add ALL sources to queue at distance 0
    for r, c in sources:
        visited.add((r, c))
        queue.append((r, c, 0))  # (row, col, distance)
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # BFS Loop (same as regular BFS)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    max_distance = 0
    distance_grid = [[float('inf')] * cols for _ in range(rows)]
    
    # Set source distances to 0
    for r, c in sources:
        distance_grid[r][c] = 0
    
    while queue:
        row, col, dist = queue.popleft()
        
        for dr, dc in DIRECTIONS:
            new_row, new_col = row + dr, col + dc
            
            if (0 <= new_row < rows and 
                0 <= new_col < cols and 
                (new_row, new_col) not in visited):
                
                visited.add((new_row, new_col))
                new_dist = dist + 1
                distance_grid[new_row][new_col] = new_dist
                max_distance = max(max_distance, new_dist)
                queue.append((new_row, new_col, new_dist))
    
    return distance_grid, max_distance
```

### Classic Problem: 01 Matrix (LC 542)

**Python:**
```python
from collections import deque

def updateMatrix(mat):
    """
    LeetCode 542: 01 Matrix
    
    Find distance from each cell to nearest 0.
    
    Key insight: Start BFS from ALL 0s simultaneously!
    Then each 1 gets distance to its nearest 0.
    
    Time: O(m Ã— n)
    Space: O(m Ã— n)
    """
    rows, cols = len(mat), len(mat[0])
    DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    # Result matrix (will be updated with distances)
    result = [[float('inf')] * cols for _ in range(rows)]
    
    # Multi-source BFS: start from ALL 0s
    queue = deque()
    
    for r in range(rows):
        for c in range(cols):
            if mat[r][c] == 0:
                result[r][c] = 0
                queue.append((r, c))  # All 0s are sources
    
    # BFS - spread from all 0s simultaneously
    while queue:
        row, col = queue.popleft()
        
        for dr, dc in DIRECTIONS:
            new_row, new_col = row + dr, col + dc
            
            if (0 <= new_row < rows and 
                0 <= new_col < cols and 
                result[new_row][new_col] > result[row][col] + 1):
                
                result[new_row][new_col] = result[row][col] + 1
                queue.append((new_row, new_col))
    
    return result


# Test
mat = [
    [0, 0, 0],
    [0, 1, 0],
    [1, 1, 1]
]
print(updateMatrix(mat))
# Output: [[0,0,0], [0,1,0], [1,2,1]]
```

### Classic Problem: Rotting Oranges (LC 994)

**Python:**
```python
from collections import deque

def orangesRotting(grid):
    """
    LeetCode 994: Rotting Oranges
    
    2 = rotten (source), 1 = fresh, 0 = empty
    Rotten oranges rot adjacent fresh ones each minute.
    Find minimum time for all to rot, or -1 if impossible.
    
    Key insight: Multi-source BFS from all rotten oranges!
    
    Time: O(m Ã— n)
    Space: O(m Ã— n)
    """
    rows, cols = len(grid), len(grid[0])
    DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    queue = deque()
    fresh_count = 0
    
    # Find all rotten oranges (sources) and count fresh
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c, 0))  # (row, col, time)
            elif grid[r][c] == 1:
                fresh_count += 1
    
    # Edge case: no fresh oranges
    if fresh_count == 0:
        return 0
    
    max_time = 0
    
    # Multi-source BFS - all rotten spread simultaneously
    while queue:
        row, col, time = queue.popleft()
        
        for dr, dc in DIRECTIONS:
            new_row, new_col = row + dr, col + dc
            
            # Check bounds and if fresh orange
            if (0 <= new_row < rows and 
                0 <= new_col < cols and 
                grid[new_row][new_col] == 1):
                
                grid[new_row][new_col] = 2  # Mark as rotten
                fresh_count -= 1
                max_time = max(max_time, time + 1)
                queue.append((new_row, new_col, time + 1))
    
    # Return -1 if some oranges couldn't be rotted
    return max_time if fresh_count == 0 else -1


# Test
grid = [
    [2, 1, 1],
    [1, 1, 0],
    [0, 1, 1]
]
print(orangesRotting(grid))  # 4
```

### Classic Problem: Walls and Gates (LC 286)

**Python:**
```python
from collections import deque

def wallsAndGates(rooms):
    """
    LeetCode 286: Walls and Gates
    
    INF = empty, -1 = wall, 0 = gate
    Fill each empty room with distance to nearest gate.
    
    Key insight: Multi-source BFS from all gates!
    
    Time: O(m Ã— n)
    Space: O(m Ã— n)
    """
    if not rooms or not rooms[0]:
        return
    
    rows, cols = len(rooms), len(rooms[0])
    DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    INF = 2147483647
    
    # Find all gates (sources)
    queue = deque()
    for r in range(rows):
        for c in range(cols):
            if rooms[r][c] == 0:  # Gate
                queue.append((r, c))
    
    # BFS from all gates
    while queue:
        row, col = queue.popleft()
        
        for dr, dc in DIRECTIONS:
            new_row, new_col = row + dr, col + dc
            
            # Only update if empty room (INF) - not wall, not visited
            if (0 <= new_row < rows and 
                0 <= new_col < cols and 
                rooms[new_row][new_col] == INF):
                
                rooms[new_row][new_col] = rooms[row][col] + 1
                queue.append((new_row, new_col))
    
    return rooms


# Test
INF = 2147483647
rooms = [
    [INF, -1, 0, INF],
    [INF, INF, INF, -1],
    [INF, -1, INF, -1],
    [0, -1, INF, INF]
]
print(wallsAndGates(rooms))
# [[3,-1,0,1], [2,2,1,-1], [1,-1,2,-1], [0,-1,3,4]]
```

**JavaScript:**
```javascript
// Multi-Source BFS Template
function multiSourceBFS(grid, sources) {
    const rows = grid.length, cols = grid[0].length;
    const DIRECTIONS = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    
    const visited = new Set();
    const queue = [];
    
    // Initialize with ALL sources
    for (const [r, c] of sources) {
        visited.add(`${r},${c}`);
        queue.push([r, c, 0]);
    }
    
    let maxDist = 0;
    const result = Array(rows).fill(null).map(() => Array(cols).fill(Infinity));
    
    for (const [r, c] of sources) {
        result[r][c] = 0;
    }
    
    while (queue.length > 0) {
        const [row, col, dist] = queue.shift();
        
        for (const [dr, dc] of DIRECTIONS) {
            const newRow = row + dr;
            const newCol = col + dc;
            const key = `${newRow},${newCol}`;
            
            if (newRow >= 0 && newRow < rows &&
                newCol >= 0 && newCol < cols &&
                !visited.has(key)) {
                
                visited.add(key);
                const newDist = dist + 1;
                result[newRow][newCol] = newDist;
                maxDist = Math.max(maxDist, newDist);
                queue.push([newRow, newCol, newDist]);
            }
        }
    }
    
    return { result, maxDist };
}

// Rotting Oranges
function orangesRotting(grid) {
    const rows = grid.length, cols = grid[0].length;
    const DIRECTIONS = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    
    const queue = [];
    let freshCount = 0;
    
    // Find all rotten oranges and count fresh
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (grid[r][c] === 2) {
                queue.push([r, c, 0]);
            } else if (grid[r][c] === 1) {
                freshCount++;
            }
        }
    }
    
    if (freshCount === 0) return 0;
    
    let maxTime = 0;
    
    while (queue.length > 0) {
        const [row, col, time] = queue.shift();
        
        for (const [dr, dc] of DIRECTIONS) {
            const newRow = row + dr;
            const newCol = col + dc;
            
            if (newRow >= 0 && newRow < rows &&
                newCol >= 0 && newCol < cols &&
                grid[newRow][newCol] === 1) {
                
                grid[newRow][newCol] = 2;
                freshCount--;
                maxTime = Math.max(maxTime, time + 1);
                queue.push([newRow, newCol, time + 1]);
            }
        }
    }
    
    return freshCount === 0 ? maxTime : -1;
}
```

---

## âš¡ Complexity Analysis

| Aspect | Complexity | Notes |
|--------|------------|-------|
| **Time** | O(m Ã— n) | Each cell visited once |
| **Space** | O(m Ã— n) | Queue + visited/result |

### Why O(m Ã— n)?

```
Multi-source BFS still visits each cell exactly ONCE:

- Adding N sources: O(N)
- Processing queue: O(m Ã— n) total
  - Each cell enters queue once
  - Each cell dequeued once
- Total: O(m Ã— n)

Key insight: Number of sources doesn't multiply time!
It just changes which cells are visited first.
```

---

## ğŸ”„ Variations

| Variation | Description | Example |
|-----------|-------------|---------|
| Distance to nearest | All targets are sources | 01 Matrix |
| Spreading simulation | Sources "infect" neighbors | Rotting Oranges |
| Fill from boundary | Edges are sources | Surrounded Regions |
| Two groups meeting | Both groups are sources | Shortest Bridge |

---

## âš ï¸ Common Mistakes

### 1. Running Separate BFS for Each Source

```python
# âŒ Wrong: O(sources Ã— m Ã— n)
for source in sources:
    bfs(source)  # Repeats work!

# âœ… Correct: O(m Ã— n)
queue = deque(sources)  # All sources together
bfs_from_queue(queue)
```

### 2. Forgetting to Track Fresh/Unreachable

```python
# âŒ Wrong: Doesn't check if all oranges rotted
def orangesRotting(grid):
    # BFS...
    return max_time  # Might return time even if some can't rot

# âœ… Correct: Check if all reachable
def orangesRotting(grid):
    fresh_count = count_fresh(grid)
    # BFS that decrements fresh_count...
    return max_time if fresh_count == 0 else -1
```

### 3. Not Handling Edge Cases

```python
# âŒ Wrong: Crashes on empty grid
def bfs(grid):
    queue = deque()
    for r in range(len(grid)):
        for c in range(len(grid[0])):  # IndexError if grid is empty
            # ...

# âœ… Correct: Check for empty
def bfs(grid):
    if not grid or not grid[0]:
        return []
    # ...
```

---

## ğŸ“ Practice Problems (Progressive)

### Easy
| Problem | Focus | Link |
|---------|-------|------|
| Flood Fill | Single-source warmup | [LC 733](https://leetcode.com/problems/flood-fill/) |

### Medium (Core Multi-Source)
| Problem | Focus | Link |
|---------|-------|------|
| 01 Matrix | Distance to nearest 0 | [LC 542](https://leetcode.com/problems/01-matrix/) |
| Rotting Oranges | Spreading + counting | [LC 994](https://leetcode.com/problems/rotting-oranges/) |
| Walls and Gates | Fill with distances | [LC 286](https://leetcode.com/problems/walls-and-gates/) |
| As Far from Land as Possible | Distance from land | [LC 1162](https://leetcode.com/problems/as-far-from-land-as-possible/) |
| Shortest Bridge | Two island sources | [LC 934](https://leetcode.com/problems/shortest-bridge/) |

### Hard
| Problem | Focus | Link |
|---------|-------|------|
| Pacific Atlantic Water Flow | Two sets of sources | [LC 417](https://leetcode.com/problems/pacific-atlantic-water-flow/) |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve 01 Matrix and Rotting Oranges
- **Day 3:** Re-solve without looking, add Walls and Gates
- **Day 7:** Identify multi-source pattern in new problem
- **Day 14:** Solve Shortest Bridge (combines patterns)

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate Multi-Source BFS</strong></summary>

**When you identify the pattern:**
> "I notice all the rotten oranges start spreading at the same time. Instead of running BFS from each one separately, I can use multi-source BFS - starting with all rotten oranges in my queue. This way, each fresh orange will be reached by its nearest rotten neighbor first."

**Explaining the optimization:**
> "The naive approach would run BFS from each source, giving O(sources Ã— cells). But with multi-source BFS, I process all sources simultaneously in O(cells) total, because each cell is visited exactly once."

**Complexity discussion:**
> "Time is O(m Ã— n) because each cell is processed once. Space is also O(m Ã— n) for the queue in the worst case."

</details>

**Company Focus:**
| Company | Frequency | Favorite Problems |
|---------|-----------|-------------------|
| Meta | â­â­â­â­â­ | Rotting Oranges |
| Amazon | â­â­â­â­â­ | 01 Matrix, Walls and Gates |
| Google | â­â­â­â­ | Complex grid problems |
| Microsoft | â­â­â­â­ | Spreading simulations |

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Understand concept | 15-20 min |
| Implement template | 10-15 min |
| Solve 01 Matrix | 15-20 min |
| Solve Rotting Oranges | 15-20 min |
| **Master multi-source** | **1.5-2 hours** |

---

> **ğŸ’¡ Key Insight:** When you need distance FROM multiple sources (or TO multiple targets), flip the perspective: start BFS from all targets simultaneously. Each cell will be reached first by its nearest target, giving you the answer in one pass!

> **ğŸ”— Related:** [BFS Fundamentals](./3.1-BFS-Fundamentals.md) | [Grid Traversal](../05-Grid-Traversal/5.1-Grid-Introduction.md) | [Island Pattern](../05-Grid-Traversal/5.2-Island-Pattern.md)

---

**Previous:** [â† 3.2 BFS Template](./3.2-BFS-Template.md)  
**Next:** [Rotting Oranges Practice â†’](./3.4-BFS-Practice/01-Rotting-Oranges-LC994.md)
