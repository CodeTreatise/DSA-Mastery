# 12.1 Advanced Graph Topics Overview

> **SCCs, Bridges, Articulation Points - Deeper graph analysis**
>
> ‚è±Ô∏è **Study Time:** 45 min | üìä **Priority:** Low-Medium | üéØ **Interview Frequency:** Rare but impressive

---

## Overview

These advanced topics appear less frequently in interviews but demonstrate deep graph understanding:

```
Advanced Topics:
‚îú‚îÄ‚îÄ Strongly Connected Components (SCCs)
‚îÇ   ‚îî‚îÄ‚îÄ Maximal groups where every node can reach every other
‚îú‚îÄ‚îÄ Bridges (Cut Edges)
‚îÇ   ‚îî‚îÄ‚îÄ Edges whose removal disconnects the graph
‚îú‚îÄ‚îÄ Articulation Points (Cut Vertices)
‚îÇ   ‚îî‚îÄ‚îÄ Vertices whose removal disconnects the graph
‚îú‚îÄ‚îÄ Euler Path/Circuit
‚îÇ   ‚îî‚îÄ‚îÄ Path visiting every edge exactly once
‚îî‚îÄ‚îÄ Hamiltonian Path/Circuit
    ‚îî‚îÄ‚îÄ Path visiting every vertex exactly once (NP-complete)
```

---

## üéØ When You'll Encounter These

| Topic | Interview Frequency | Companies | When to Know |
|-------|-------------------|-----------|--------------|
| **SCCs** | Rare | Google, competitive | Advanced roles |
| **Bridges** | Low | Network companies | System design |
| **Articulation Points** | Low | Infrastructure | Reliability analysis |
| **Euler Path** | Very Rare | - | Mostly academic |
| **Hamiltonian** | Rare | - | Know it's NP-complete |

---

## Strongly Connected Components (SCCs)

A **strongly connected component** is a maximal set of vertices where every vertex can reach every other vertex (in a **directed** graph).

```
Graph:                  SCCs:
1 ‚Üí 2 ‚Üí 3               SCC1: {1, 2, 5}
‚Üë   ‚Üì   ‚Üì               SCC2: {3, 4}
5 ‚Üê 4 ‚Üê 6               SCC3: {6}
    ‚Üì
    7                   SCC4: {7}

In SCC1: 1‚Üí2, 2‚Üí5, 5‚Üí1 (cycle connects all)
```

### Kosaraju's Algorithm

```python
from collections import defaultdict
from typing import List

def kosaraju_scc(n: int, edges: List[List[int]]) -> List[List[int]]:
    """
    Find SCCs using Kosaraju's algorithm.
    
    Steps:
    1. DFS on original graph, record finish order
    2. Reverse all edges
    3. DFS on reversed graph in reverse finish order
    
    Time: O(V + E)
    """
    # Build graph and reverse graph
    graph = defaultdict(list)
    reverse_graph = defaultdict(list)
    
    for u, v in edges:
        graph[u].append(v)
        reverse_graph[v].append(u)
    
    # Step 1: DFS to get finish order
    visited = [False] * n
    finish_order = []
    
    def dfs1(node):
        visited[node] = True
        for neighbor in graph[node]:
            if not visited[neighbor]:
                dfs1(neighbor)
        finish_order.append(node)
    
    for i in range(n):
        if not visited[i]:
            dfs1(i)
    
    # Step 2 & 3: DFS on reverse graph in reverse finish order
    visited = [False] * n
    sccs = []
    
    def dfs2(node, component):
        visited[node] = True
        component.append(node)
        for neighbor in reverse_graph[node]:
            if not visited[neighbor]:
                dfs2(neighbor, component)
    
    for node in reversed(finish_order):
        if not visited[node]:
            component = []
            dfs2(node, component)
            sccs.append(component)
    
    return sccs


# Example
edges = [[0, 1], [1, 2], [2, 0], [1, 3], [3, 4], [4, 3]]
print(kosaraju_scc(5, edges))  # [[0, 2, 1], [3, 4]] - two SCCs
```

### Tarjan's Algorithm (Single DFS)

```python
def tarjan_scc(n: int, graph: dict) -> List[List[int]]:
    """
    Find SCCs using Tarjan's algorithm.
    Uses single DFS with discovery times.
    
    Time: O(V + E)
    """
    disc = [-1] * n  # Discovery time
    low = [0] * n    # Lowest reachable discovery time
    on_stack = [False] * n
    stack = []
    sccs = []
    time = [0]  # Mutable for nested function
    
    def dfs(node):
        disc[node] = low[node] = time[0]
        time[0] += 1
        stack.append(node)
        on_stack[node] = True
        
        for neighbor in graph.get(node, []):
            if disc[neighbor] == -1:
                dfs(neighbor)
                low[node] = min(low[node], low[neighbor])
            elif on_stack[neighbor]:
                low[node] = min(low[node], disc[neighbor])
        
        # If node is root of SCC
        if low[node] == disc[node]:
            component = []
            while True:
                v = stack.pop()
                on_stack[v] = False
                component.append(v)
                if v == node:
                    break
            sccs.append(component)
    
    for i in range(n):
        if disc[i] == -1:
            dfs(i)
    
    return sccs
```

---

## Bridges (Critical Connections)

A **bridge** is an edge whose removal disconnects the graph.

```
Graph:              Bridges: (1,3)
1 ‚îÄ‚îÄ‚îÄ 2             
‚îÇ     ‚îÇ             Removing (1,3) disconnects
3     ‚îÇ             left part from right
‚îÇ     ‚îÇ             
4 ‚îÄ‚îÄ‚îÄ 5             Non-bridges: all others
                    (removing them doesn't disconnect)
```

### Finding Bridges (LC 1192)

```python
def criticalConnections(n: int, connections: List[List[int]]) -> List[List[int]]:
    """
    Find all bridges using Tarjan's algorithm.
    
    Key insight: Edge (u,v) is a bridge if there's no back edge
    from v's subtree that reaches u or above.
    
    Time: O(V + E)
    """
    graph = defaultdict(list)
    for u, v in connections:
        graph[u].append(v)
        graph[v].append(u)
    
    disc = [-1] * n
    low = [0] * n
    bridges = []
    time = [0]
    
    def dfs(node, parent):
        disc[node] = low[node] = time[0]
        time[0] += 1
        
        for neighbor in graph[node]:
            if neighbor == parent:
                continue
            
            if disc[neighbor] == -1:
                dfs(neighbor, node)
                low[node] = min(low[node], low[neighbor])
                
                # If no back edge from neighbor's subtree to node or above
                if low[neighbor] > disc[node]:
                    bridges.append([node, neighbor])
            else:
                low[node] = min(low[node], disc[neighbor])
    
    dfs(0, -1)
    return bridges


# Example
print(criticalConnections(4, [[0,1],[1,2],[2,0],[1,3]]))
# [[1, 3]] - only bridge
```

---

## Articulation Points (Cut Vertices)

An **articulation point** is a vertex whose removal disconnects the graph.

```
Graph:              Articulation Points: {1}
0 ‚îÄ‚îÄ‚îÄ 1 ‚îÄ‚îÄ‚îÄ 2       
      ‚îÇ             Removing vertex 1 disconnects
      3             0 from {2, 3}
```

### Finding Articulation Points

```python
def findArticulationPoints(n: int, edges: List[List[int]]) -> List[int]:
    """
    Find all articulation points.
    
    A vertex u is an articulation point if:
    1. u is root of DFS tree and has 2+ children, OR
    2. u is not root and has a child v where no vertex in 
       v's subtree has a back edge to an ancestor of u
    
    Time: O(V + E)
    """
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    disc = [-1] * n
    low = [0] * n
    parent = [-1] * n
    articulation_points = set()
    time = [0]
    
    def dfs(node):
        children = 0
        disc[node] = low[node] = time[0]
        time[0] += 1
        
        for neighbor in graph[node]:
            if disc[neighbor] == -1:
                children += 1
                parent[neighbor] = node
                dfs(neighbor)
                low[node] = min(low[node], low[neighbor])
                
                # Case 1: Root with 2+ children
                if parent[node] == -1 and children > 1:
                    articulation_points.add(node)
                
                # Case 2: Non-root and no back edge from subtree
                if parent[node] != -1 and low[neighbor] >= disc[node]:
                    articulation_points.add(node)
            
            elif neighbor != parent[node]:
                low[node] = min(low[node], disc[neighbor])
    
    for i in range(n):
        if disc[i] == -1:
            dfs(i)
    
    return list(articulation_points)
```

---

## Euler Path and Circuit

**Euler Path:** Visit every **edge** exactly once
**Euler Circuit:** Euler path that starts and ends at same vertex

**Conditions:**
```
Undirected Graph:
- Euler Circuit: All vertices have even degree
- Euler Path: Exactly 0 or 2 vertices have odd degree

Directed Graph:
- Euler Circuit: Every vertex has in-degree == out-degree
- Euler Path: At most one vertex with out-degree = in-degree + 1
              At most one vertex with in-degree = out-degree + 1
```

### Hierholzer's Algorithm

```python
def findEulerPath(n: int, edges: List[List[int]]) -> List[int]:
    """
    Find Euler path using Hierholzer's algorithm.
    
    Time: O(E)
    """
    from collections import defaultdict, deque
    
    graph = defaultdict(deque)
    in_degree = [0] * n
    out_degree = [0] * n
    
    for u, v in edges:
        graph[u].append(v)
        out_degree[u] += 1
        in_degree[v] += 1
    
    # Find start node
    start = 0
    for i in range(n):
        if out_degree[i] - in_degree[i] == 1:
            start = i
            break
    
    # Hierholzer's algorithm
    path = []
    stack = [start]
    
    while stack:
        node = stack[-1]
        if graph[node]:
            next_node = graph[node].popleft()
            stack.append(next_node)
        else:
            path.append(stack.pop())
    
    return path[::-1]
```

---

## Quick Reference Table

| Algorithm | Problem | Time | Key Structure |
|-----------|---------|------|---------------|
| **Kosaraju** | SCCs | O(V+E) | Two DFS + reverse |
| **Tarjan (SCC)** | SCCs | O(V+E) | Single DFS + stack |
| **Tarjan (Bridges)** | Bridges | O(V+E) | disc/low arrays |
| **Tarjan (AP)** | Articulation Points | O(V+E) | disc/low + parent |
| **Hierholzer** | Euler Path | O(E) | Stack + edge removal |

---

## üìù Practice Problems

### Bridges/Articulation Points
- [ ] [Critical Connections](https://leetcode.com/problems/critical-connections-in-a-network/) - Find bridges

### Euler Path
- [ ] [Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/) - Euler path in airports
- [ ] [Valid Arrangement of Pairs](https://leetcode.com/problems/valid-arrangement-of-pairs/) - Euler path

### SCCs (Rare in interviews)
- [ ] SCC problems are more common in competitive programming

---

## üé§ Interview Context

<details>
<summary><strong>When to Mention These</strong></summary>

**For Bridges/Critical Connections:**
> "I'll use Tarjan's algorithm with discovery and low-link values. An edge is a bridge if there's no back edge from its subtree to earlier nodes."

**For SCCs:**
> "I'd use Kosaraju's: DFS to get finish order, reverse graph, DFS in reverse order. Each tree in second DFS is an SCC."

**Generally:**
> These are impressive to know but rarely required. Mention them if relevant, don't force them.

</details>

---

> **üí° Key Insight:** Most advanced graph algorithms use the same DFS framework with `disc` (discovery time) and `low` (lowest reachable) values. Master this framework and you can derive bridges, articulation points, and SCCs.

---

**Back:** [‚Üê MST Algorithms](../11-MST/11.1-MST-Introduction.md)
