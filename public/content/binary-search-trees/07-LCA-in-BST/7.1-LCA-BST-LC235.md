# 7.1 Lowest Common Ancestor of BST (LC 235)

## Problem Statement

[LeetCode 235 - Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

Given a BST and two nodes `p` and `q`, find their Lowest Common Ancestor (LCA). The LCA is the deepest node that is an ancestor of both p and q (a node can be its own ancestor).

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8

        6
       / \
      2   8
     / \ / \
    0  4 7  9
      / \
     3   5

Output: 6

Explanation: 6 is the LCA because:
- 2 is in left subtree (2 < 6)
- 8 is in right subtree (8 > 6)
- So they diverge at 6
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a BST Navigation problem:**
- Find where paths to p and q diverge
- BST property determines direction
- The split point is the LCA

**Keywords:**
- "lowest common ancestor"
- "BST" + "find ancestor"
- "common parent"

**Pattern:** Navigate using BST property until split point.

**Key Insight:**
- If both p and q are smaller than current ‚Üí go left
- If both p and q are larger than current ‚Üí go right
- Otherwise ‚Üí current is the LCA (split point)

</details>

---

## ‚úÖ When to Use

- LCA problems on BST
- When BST property can guide navigation
- Finding divergence point of two paths

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| General tree | No ordering | LC 236 approach |
| Nodes might not exist | Need validation | Check first |
| Multiple queries |" O(h) each time "| Binary lifting |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
- [BST Search](../02-BST-Operations/2.1-BST-Search-LC700.md)
- [LCA Binary Tree (LC 236)](../../06-Trees/) - General version

**After mastering this:**
- LCA with parent pointers
- LCA in directed graph

**Combines with:**
- BST navigation
- Path tracing

</details>

---

## üìê How It Works

### The Key Insight

```
In a BST, the LCA is the first node where p and q "split":
- If both are smaller ‚Üí both in left subtree ‚Üí go left
- If both are larger ‚Üí both in right subtree ‚Üí go right
- If one is smaller, one is larger ‚Üí they split here ‚Üí LCA found!
- If current equals p or q ‚Üí current is LCA (ancestor of itself)

        6           p=2, q=8
       / \
      2   8
     
At 6: 2 < 6 < 8, they split! LCA = 6
```

### Visualization

```
Finding LCA of p=2 and q=4:

        6
       / \
      2   8
     / \
    0   4

Step 1: At 6
        p=2 < 6, q=4 < 6
        Both smaller ‚Üí go left

Step 2: At 2
        p=2 == 2 (current node)
        q=4 > 2
        Split! (or current is p/q)
        LCA = 2

---

Finding LCA of p=3 and q=5:

        6
       / \
      2   8
     / \
    0   4
       / \
      3   5

Step 1: At 6 ‚Üí both < 6 ‚Üí go left
Step 2: At 2 ‚Üí both > 2 ‚Üí go right
Step 3: At 4 ‚Üí 3 < 4 < 5 ‚Üí split! LCA = 4
```

---

## üíª Code Implementation

### Recursive (Clean)

**Python:**
```python
def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    """
    Find LCA in BST using BST property.
    
    Time: O(h) - follow one path down
    Space: O(h) - recursion stack (O(1) for iterative)
    
    Pattern: Navigate until split point
    """
    # Both in left subtree
    if p.val < root.val and q.val < root.val:
        return self.lowestCommonAncestor(root.left, p, q)
    
    # Both in right subtree
    if p.val > root.val and q.val > root.val:
        return self.lowestCommonAncestor(root.right, p, q)
    
    # Split point: one left, one right (or current is p or q)
    return root
```

**JavaScript:**
```javascript
var lowestCommonAncestor = function(root, p, q) {
    // Navigate using BST property
    
    // Both in left subtree
    if (p.val < root.val && q.val < root.val) {
        return lowestCommonAncestor(root.left, p, q);
    }
    
    // Both in right subtree
    if (p.val > root.val && q.val > root.val) {
        return lowestCommonAncestor(root.right, p, q);
    }
    
    // Split point
    return root;
};
```

### Iterative (Optimal Space)

**Python:**
```python
def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    """
    Iterative version - O(1) space.
    
    Time: O(h), Space: O(1)
    """
    current = root
    
    while current:
        if p.val < current.val and q.val < current.val:
            current = current.left
        elif p.val > current.val and q.val > current.val:
            current = current.right
        else:
            return current
    
    return None  # Should never reach if p, q exist in tree
```

**JavaScript:**
```javascript
var lowestCommonAncestor = function(root, p, q) {
    // Iterative - O(1) space
    let current = root;
    
    while (current) {
        if (p.val < current.val && q.val < current.val) {
            current = current.left;
        } else if (p.val > current.val && q.val > current.val) {
            current = current.right;
        } else {
            return current;
        }
    }
    
    return null;
};
```

### One-Liner (Clever but less readable)

**Python:**
```python
def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    while (root.val - p.val) * (root.val - q.val) > 0:
        root = root.left if p.val < root.val else root.right
    return root
```

**Explanation:** `(root.val - p.val) * (root.val - q.val) > 0` is true only when both p and q are on the same side of root.

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Recursive |" O(h) "| O(h) | Recursion stack |
| Iterative |" O(h) "| O(1) | No extra space |

**Why O(h) time:**
- We follow a single path from root to LCA
- Never backtrack or visit siblings
- Height h = O(log n) for balanced, O(n) for skewed

**Comparison with General Tree LCA (LC 236):**
| Tree Type | Time | Space | Approach |
|-----------|------|-------|----------|
| BST (this) |" O(h) "| O(1) | Navigate by value |
| General Tree |" O(n) "| O(n) | Full DFS |

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **General Tree LCA** | No ordering | LC 236 |
| **LCA with parent pointers** | Follow parents up | Two-pointer approach |
| **LCA of multiple nodes** | Find common prefix | Extension |
| **Distance between nodes** | LCA + path lengths | Uses LCA as intermediate |

### LCA in General Tree (LC 236)

```python
def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """General tree - must search both subtrees."""
    if not root or root == p or root == q:
        return root
    
    left = lowestCommonAncestor(root.left, p, q)
    right = lowestCommonAncestor(root.right, p, q)
    
    if left and right:
        return root  # Split point
    
    return left if left else right
```

### Distance Between Two Nodes

```python
def distanceBetweenNodes(root: TreeNode, p: TreeNode, q: TreeNode) -> int:
    """Find distance = dist(root, p) + dist(root, q) - 2*dist(root, LCA)"""
    lca = lowestCommonAncestor(root, p, q)
    
    def depth(node, target, d):
        if not node:
            return -1
        if node == target:
            return d
        left = depth(node.left, target, d + 1)
        if left != -1:
            return left
        return depth(node.right, target, d + 1)
    
    return depth(lca, p, 0) + depth(lca, q, 0)
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Handling When Current Node is p or q

```python
# ‚ùå Wrong: Only checks for split, not equality
if p.val < root.val and q.val < root.val:
    return self.LCA(root.left, p, q)
if p.val > root.val and q.val > root.val:
    return self.LCA(root.right, p, q)
# Missing: what if root == p or root == q?

# ‚úÖ Correct: The else case handles it
# When root == p, q is either equal or on one side
# Either way, the else case returns root correctly
```

### 2. Checking Only One Node

```python
# ‚ùå Wrong: Only checks p
if p.val < root.val:  # What about q?
    return self.LCA(root.left, p, q)

# ‚úÖ Correct: Check BOTH p AND q
if p.val < root.val and q.val < root.val:
    return self.LCA(root.left, p, q)
```

### 3. Wrong Comparison Direction

```python
# ‚ùå Wrong: Inverted condition
if p.val < root.val and q.val < root.val:
    return self.LCA(root.right, p, q)  # Should go LEFT!

# ‚úÖ Correct: Smaller values are in LEFT subtree
if p.val < root.val and q.val < root.val:
    return self.LCA(root.left, p, q)
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn pattern)
- [ ] [LCA of BST (LC 235)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) - This problem

### Medium (Apply pattern)
- [ ] [LCA of Binary Tree (LC 236)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) - General tree
- [ ] [LCA with Parent (LC 1650)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/) - With parent pointers

### Hard (Master)
- [ ] [LCA of Deepest Leaves (LC 1123)](https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/)
- [ ] [LCA Binary Tree IV (LC 1676)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/) - Multiple nodes

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement recursive solution
- **Day 3:** Implement iterative solution
- **Day 7:** Compare with LC 236 (general tree)
- **Day 14:** Explain why BST version is more efficient
- **Day 30:** Solve distance between nodes problem

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"Since this is a BST, I can use the ordering property. The LCA is the first node where p and q diverge ‚Äî where one goes left and one goes right. I'll navigate down: if both are smaller, go left; if both are larger, go right; otherwise, I've found the LCA."

**Key points:**
1. "BST property enables O(h) instead of O(n)"
2. "LCA is the split point of paths to p and q"
3. "Iterative version uses O(1) space"

**Follow-up: What about general trees?**
"Without BST property, I'd need to search both subtrees. I'd recursively check if p or q is in each subtree. When I find both in different subtrees, that's the LCA."

**Follow-up: What if nodes might not exist?**
"I'd first validate that both p and q exist in the tree, then find LCA."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Frequently asked |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Often with follow-ups |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Clear concept |
| Explain approach | 2-3 min | Split point logic |
| Code solution | 5-7 min | Short code |
| Discuss BST vs general | 3-5 min | Optimization insight |
| Total interview time | 15-20 min | Easy difficulty |

---

## üí° Key Insight

> **LCA in BST is the first "fork in the road."** As we walk down from the root, p and q travel together (both go left or both go right) until they must split. The node where they split is the LCA. BST ordering tells us exactly when this split happens.

---

## üîó Related

- **Comparison:** [LCA Binary Tree (LC 236)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) - General version
- **Uses:** [BST Navigation](../02-BST-Operations/2.1-BST-Search-LC700.md)
- **Pattern:** BST navigation with value-based decisions
- **Foundation:** [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
