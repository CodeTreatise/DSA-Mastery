# 4.1 - Maximum Depth of Binary Tree (LC 104)

> **Grokking Pattern:** #11 Tree DFS (Postorder Application)
>
> **Difficulty:** Easy | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very Common

---

## Problem Statement

Given the `root` of a binary tree, return its **maximum depth**.

The **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.

```
Input: root = [3,9,20,null,null,15,7]
        3
       / \
      9   20
         /  \
        15   7

Output: 3 (path: 3 ‚Üí 20 ‚Üí 15 or 3 ‚Üí 20 ‚Üí 7)
```

[LeetCode 104 - Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Maximum depth" or "height"
- "Longest path from root to leaf"
- Need to compare left and right subtrees

**Key insight:**
This is a **postorder** problem - we need to know the heights of children before computing the parent's height.

```
height(node) = 1 + max(height(left), height(right))
```

</details>

---

## ‚úÖ When to Use

- Finding tree height/depth
- Comparing subtree properties
- Any "bottom-up" aggregation

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Shortest path to leaf | Different problem | [Minimum Depth](./4.2-Minimum-Depth.md) |
| Path between any nodes | Not root-to-leaf | Diameter/LCA |
| Level-order needed | DFS not ideal | BFS |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [DFS Concept](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
- [Postorder Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/03-Postorder-Traversal.md)

**After mastering this:**
- [Minimum Depth](./4.2-Minimum-Depth.md) - Similar but tricky edge case
- [Balanced Tree](./4.4-Balanced-Tree.md) - Uses height comparison
- [Diameter of Tree](./4.3-Diameter-of-Tree.md) - Extends this concept

**Combines with:**
- BFS (alternative approach)
- Level order traversal

</details>

---

## üìê How It Works

### Core Intuition

```
Max depth = 1 (current node) + max(left depth, right depth)

Base case: null node has depth 0
```

### Visualization

```
        3           depth = 1 + max(1, 2) = 3
       / \
      9   20        depth(9)=1, depth(20)=1+max(1,1)=2
         /  \
        15   7      depth(15)=1, depth(7)=1

Postorder computation:
1. depth(9) = 1 + max(0, 0) = 1
2. depth(15) = 1 + max(0, 0) = 1
3. depth(7) = 1 + max(0, 0) = 1
4. depth(20) = 1 + max(1, 1) = 2
5. depth(3) = 1 + max(1, 2) = 3
```

---

## üíª Code Implementation

### Solution 1: Recursive DFS (Postorder)

**Python:**
```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def max_depth(root: Optional[TreeNode]) -> int:
    """
    Maximum depth using postorder DFS.
    
    Pattern: Return value from children
    Time: O(n), Space: O(h)
    """
    if not root:
        return 0
    
    left_depth = max_depth(root.left)
    right_depth = max_depth(root.right)
    
    return 1 + max(left_depth, right_depth)
```

**JavaScript:**
```javascript
function maxDepth(root) {
    if (!root) return 0;
    
    const leftDepth = maxDepth(root.left);
    const rightDepth = maxDepth(root.right);
    
    return 1 + Math.max(leftDepth, rightDepth);
}
```

### Solution 2: BFS (Level Order)

**Python:**
```python
from collections import deque

def max_depth_bfs(root: Optional[TreeNode]) -> int:
    """
    Maximum depth using BFS.
    
    Count the number of levels.
    Time: O(n), Space: O(w) where w = max width
    """
    if not root:
        return 0
    
    queue = deque([root])
    depth = 0
    
    while queue:
        # Process all nodes at current level
        level_size = len(queue)
        for _ in range(level_size):
            node = queue.popleft()
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        depth += 1
    
    return depth
```

**JavaScript:**
```javascript
function maxDepthBFS(root) {
    if (!root) return 0;
    
    const queue = [root];
    let depth = 0;
    
    while (queue.length > 0) {
        const levelSize = queue.length;
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        depth++;
    }
    
    return depth;
}
```

### Solution 3: Iterative DFS with Stack

**Python:**
```python
def max_depth_iterative(root: Optional[TreeNode]) -> int:
    """
    Iterative DFS with explicit stack.
    
    Store (node, depth) pairs.
    Time: O(n), Space: O(h)
    """
    if not root:
        return 0
    
    stack = [(root, 1)]
    max_depth = 0
    
    while stack:
        node, depth = stack.pop()
        max_depth = max(max_depth, depth)
        
        if node.right:
            stack.append((node.right, depth + 1))
        if node.left:
            stack.append((node.left, depth + 1))
    
    return max_depth
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Recursive DFS |" O(n) "| O(h) |" h = height, worst O(n) "|
| BFS |" O(n) "| O(w) | w = max width |
| Iterative DFS |" O(n) "| O(h) | Explicit stack |

**Space Comparison:**
- Balanced tree: DFS = O(log n), BFS = O(n/2) = O(n)
- Skewed tree: DFS = O(n), BFS = O(1)

---

## üîÑ Variations

| Variation | Difference | LeetCode |
|-----------|------------|----------|
| Minimum Depth | Shortest root-to-leaf | LC 111 |
| Maximum Depth of N-ary | Multiple children | LC 559 |
| Depth at specific node | Target node depth | - |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Confusing Max and Min Depth

```python
# ‚ùå WRONG: This is max depth logic
def min_depth(root):
    if not root:
        return 0
    return 1 + min(min_depth(root.left), min_depth(root.right))
# Problem: min(0, something) = 0, which is wrong for min depth!

# ‚úÖ For max depth, this is correct
def max_depth(root):
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))
```

### 2. Off-by-One Error

```python
# ‚ùå WRONG: Returning height instead of depth
def max_depth(root):
    if not root:
        return -1  # Height uses -1 for null
    return 1 + max(...)

# ‚úÖ CORRECT: Depth uses 0 for null
def max_depth(root):
    if not root:
        return 0
    return 1 + max(...)
```

### 3. BFS: Forgetting Level Size

```python
# ‚ùå WRONG: Counting nodes, not levels
while queue:
    node = queue.popleft()
    depth += 1  # This counts nodes!

# ‚úÖ CORRECT: Process entire level
while queue:
    level_size = len(queue)
    for _ in range(level_size):
        node = queue.popleft()
        # Add children
    depth += 1  # Count levels
```

---

## üìù Practice Problems

### This Problem
- [ ] [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) - LC 104

### Related Problems
- [ ] [Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/) - LC 111
- [ ] [Maximum Depth of N-ary Tree](https://leetcode.com/problems/maximum-depth-of-n-ary-tree/) - LC 559
- [ ] [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/) - LC 110

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Recursive DFS solution
**Day 3:** BFS approach + compare space
**Day 7:** Minimum depth (note the difference!)
**Day 14:** Balanced tree (uses height)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Starting the explanation:**
> "Maximum depth is the longest path from root to any leaf. I'll use DFS with postorder - computing children's depths first, then taking the max."

**Discussing approaches:**
> "DFS uses O(h) space for recursion. BFS uses O(w) space for the queue. For a balanced tree, DFS is better. For a very skewed tree, BFS might use less space."

**Follow-up questions:**
- "Can you do it iteratively?" ‚Üí Yes, with explicit stack
- "What about BFS?" ‚Üí Count levels instead

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common warm-up |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Often follow with min depth |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May extend to balanced check |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Classic interview question |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Recognize pattern | 1 min | Immediate |
| Recursive solution | 3-5 min | Should be quick |
| BFS alternative | 5-7 min | If asked |

---

> **üí° Key Insight:** Maximum depth is a classic postorder problem - you need children's information first. The formula `1 + max(left, right)` captures the essence of bottom-up tree computation.

---

## üîó Related

- [Minimum Depth](./4.2-Minimum-Depth.md)
- [Balanced Binary Tree](./4.4-Balanced-Tree.md)
- [Diameter of Binary Tree](./4.3-Diameter-of-Tree.md)
