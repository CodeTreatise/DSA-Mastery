# 2.2 OOP Basics for DSA

> **You don't need to master OOP to solve LeetCode â€” but you DO need to know enough to define a `ListNode`, build a `TreeNode`, and write a class-based solution without fumbling.**
>
> â±ï¸ *Estimated reading: 15 minutes*

---

## ğŸ¯ Why This Matters

LeetCode gives you class definitions. You need to understand them instantly:

```python
# You'll see this in EVERY linked list problem
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

```javascript
// And this in every tree problem
class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

If you can't read this fluently, you'll waste precious interview minutes on syntax instead of algorithms.

---

## ğŸ“ Class Syntax: Python vs JavaScript

### Basic Class

```python
# Python
class Point:
    def __init__(self, x, y):     # Constructor
        self.x = x                 # Instance variable
        self.y = y
    
    def distance_to(self, other):  # Method
        return ((self.x - other.x)**2 + (self.y - other.y)**2) ** 0.5
    
    def __repr__(self):            # String representation
        return f"Point({self.x}, {self.y})"

# Usage
p1 = Point(0, 0)
p2 = Point(3, 4)
print(p1.distance_to(p2))  # 5.0
```

```javascript
// JavaScript
class Point {
    constructor(x, y) {           // Constructor
        this.x = x;               // Instance variable
        this.y = y;
    }
    
    distanceTo(other) {           // Method
        return Math.sqrt((this.x - other.x)**2 + (this.y - other.y)**2);
    }
    
    toString() {                  // String representation
        return `Point(${this.x}, ${this.y})`;
    }
}

// Usage
const p1 = new Point(0, 0);      // 'new' keyword required!
const p2 = new Point(3, 4);
console.log(p1.distanceTo(p2));   // 5
```

### Key Differences

| Feature | Python | JavaScript |
|---------|--------|------------|
| Constructor | `__init__(self, ...)` | `constructor(...)` |
| Self reference | `self` (explicit, first param) | `this` (implicit) |
| Instantiation | `Point(1, 2)` | `new Point(1, 2)` |
| Method definition | `def method(self, ...)` | `method(...)` |
| String repr | `__repr__` / `__str__` | `toString()` |

---

## ğŸ’» The 3 Classes You MUST Know

### 1. ListNode (Linked Lists)

Every linked list problem on LeetCode uses this:

```python
# Python â€” LC standard definition
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# Create linked list: 1 â†’ 2 â†’ 3
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)

# Helper: create from array (useful for testing)
def create_list(arr):
    dummy = ListNode(0)
    current = dummy
    for val in arr:
        current.next = ListNode(val)
        current = current.next
    return dummy.next

# Helper: print linked list
def print_list(head):
    vals = []
    while head:
        vals.append(str(head.val))
        head = head.next
    print(" â†’ ".join(vals))

head = create_list([1, 2, 3, 4, 5])
print_list(head)  # 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
```

```javascript
// JavaScript â€” LC standard definition
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

// Create linked list: 1 â†’ 2 â†’ 3
const head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);

// Helper: create from array
function createList(arr) {
    const dummy = new ListNode(0);
    let current = dummy;
    for (const val of arr) {
        current.next = new ListNode(val);
        current = current.next;
    }
    return dummy.next;
}
```

### 2. TreeNode (Binary Trees)

```python
# Python â€” LC standard definition
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# Create a tree:
#       1
#      / \
#     2   3
#    / \
#   4   5
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

# Quick creation with constructor chaining
root = TreeNode(1,
    TreeNode(2, TreeNode(4), TreeNode(5)),
    TreeNode(3)
)
```

```javascript
// JavaScript â€” LC standard definition
class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

// Quick creation
const root = new TreeNode(1,
    new TreeNode(2, new TreeNode(4), new TreeNode(5)),
    new TreeNode(3)
);
```

### 3. GraphNode (Graphs â€” Adjacency List)

Graphs usually don't use a class â€” they use an adjacency list:

```python
# Python â€” adjacency list (most common representation)
from collections import defaultdict

# Undirected graph
graph = defaultdict(list)
edges = [[0,1], [0,2], [1,3], [2,3]]
for u, v in edges:
    graph[u].append(v)
    graph[v].append(u)

# Directed graph
graph = defaultdict(list)
for u, v in edges:
    graph[u].append(v)  # Only one direction

# Weighted graph
graph = defaultdict(list)
weighted_edges = [[0,1,5], [0,2,3], [1,3,2]]  # [from, to, weight]
for u, v, w in weighted_edges:
    graph[u].append((v, w))
```

```javascript
// JavaScript â€” adjacency list
const graph = new Map();

// Build undirected graph
const edges = [[0,1], [0,2], [1,3], [2,3]];
for (const [u, v] of edges) {
    if (!graph.has(u)) graph.set(u, []);
    if (!graph.has(v)) graph.set(v, []);
    graph.get(u).push(v);
    graph.get(v).push(u);
}
```

> **ğŸ’¡ When LC gives you a Node class for graphs (like LC 133 Clone Graph), it looks like this:**

```python
class Node:
    def __init__(self, val=0, neighbors=None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
```

---

## ğŸ“ `self` (Python) vs `this` (JavaScript)

### Python: `self` is Explicit

```python
class Counter:
    def __init__(self):
        self.count = 0       # Must use self to access instance vars
    
    def increment(self):
        self.count += 1      # self required everywhere
    
    def get(self):
        return self.count    # Can't just say 'count'
```

### JavaScript: `this` is Implicit (and Tricky)

```javascript
class Counter {
    constructor() {
        this.count = 0;
    }
    
    increment() {
        this.count++;        // 'this' refers to the instance
    }
    
    get() {
        return this.count;
    }
}

// âš ï¸ 'this' gotcha: losing context in callbacks
const counter = new Counter();
const fn = counter.increment;
fn();  // TypeError! 'this' is undefined in strict mode

// âœ… Fix: bind, or use arrow functions
const fn2 = counter.increment.bind(counter);
fn2();  // Works âœ…
```

> **For LeetCode:** You rarely hit `this` issues because LC problems don't use callbacks. Just know `this.` accesses instance variables in methods.

---

## ğŸ“ Design Problems: Class-Based Solutions

Some LC problems require you to design a class:

### LC 146: LRU Cache

```python
class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}     # Instance state
    
    def get(self, key: int) -> int:
        # Method that accesses self.cache
        pass
    
    def put(self, key: int, value: int) -> None:
        # Method that modifies self.cache
        pass
```

### LC 155: Min Stack

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []
    
    def push(self, val: int) -> None:
        self.stack.append(val)
        # ...
    
    def pop(self) -> None:
        self.stack.pop()
        # ...
    
    def top(self) -> int:
        return self.stack[-1]
    
    def getMin(self) -> int:
        return self.min_stack[-1]
```

### Common Design Problems

| Problem | What You Design |
|---------|----------------|
| [LRU Cache (LC 146)](https://leetcode.com/problems/lru-cache/) | Cache with O(1) get/put + eviction |
| [Min Stack (LC 155)](https://leetcode.com/problems/min-stack/) | Stack with O(1) getMin |
| [Implement Queue using Stacks (LC 232)](https://leetcode.com/problems/implement-queue-using-stacks/) | Queue from two stacks |
| [Design HashMap (LC 706)](https://leetcode.com/problems/design-hashmap/) | Hash map with chaining |
| [Trie (LC 208)](https://leetcode.com/problems/implement-trie-prefix-tree/) | Prefix tree |
| [MedianFinder (LC 295)](https://leetcode.com/problems/find-median-from-data-stream/) | Two-heap median tracker |

---

## âš ï¸ Common OOP Mistakes in Interviews

| Mistake | Language | Impact |
|---------|----------|--------|
| Forgetting `self.` before instance variables | Python | `NameError` |
| Forgetting `new` before class instantiation | JavaScript | TypeError or wrong behavior |
| Forgetting `self` as first parameter in methods | Python | `TypeError: takes 0 positional arguments` |
| Using `this` in arrow functions expecting class context | JavaScript | `this` not bound correctly |
| Not initializing variables in `__init__`/`constructor` | Both | `AttributeError`/`undefined` |

---

## ğŸ“ Quick Reference

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                 OOP FOR DSA CHEAT SHEET                â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                        â•‘
â•‘  PYTHON:                                               â•‘
â•‘    class Foo:                                          â•‘
â•‘        def __init__(self, x):                          â•‘
â•‘            self.x = x                                  â•‘
â•‘        def method(self):                               â•‘
â•‘            return self.x                               â•‘
â•‘    obj = Foo(5)                                        â•‘
â•‘                                                        â•‘
â•‘  JAVASCRIPT:                                           â•‘
â•‘    class Foo {                                         â•‘
â•‘        constructor(x) {                                â•‘
â•‘            this.x = x;                                 â•‘
â•‘        }                                               â•‘
â•‘        method() {                                      â•‘
â•‘            return this.x;                              â•‘
â•‘        }                                               â•‘
â•‘    }                                                   â•‘
â•‘    const obj = new Foo(5);                             â•‘
â•‘                                                        â•‘
â•‘  3 ESSENTIAL NODE TYPES:                               â•‘
â•‘    ListNode(val, next)                                 â•‘
â•‘    TreeNode(val, left, right)                          â•‘
â•‘    Graph â†’ defaultdict(list) / new Map()               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

> **ğŸ’¡ Key Insight:** For DSA interviews, you need exactly 3 OOP skills: (1) read LeetCode's class definitions, (2) write class-based solutions for Design problems, (3) create `ListNode`/`TreeNode` from memory. That's it â€” no inheritance, no polymorphism, no design patterns needed.

---

â† [2.1 Reference Semantics](./2.1-Reference-Semantics-Mutability.md) | **Back to:** [Prerequisites Index](../00-Prerequisites.md)
