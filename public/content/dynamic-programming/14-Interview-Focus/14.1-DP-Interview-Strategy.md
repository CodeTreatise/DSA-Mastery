# DP Interview Strategy

> **How to recognize, approach, and communicate DP problems in interviews.** This guide combines pattern recognition, systematic problem-solving, and communication strategies for acing DP questions.

---

## ðŸ“‹ The DP Recognition Framework

### Step 1: Is It DP?

Ask yourself these questions:

| Signal | Example |
|--------|---------|
| **Optimization?** | "minimum", "maximum", "longest", "shortest" |
| **Counting?** | "how many ways", "count the number" |
| **Yes/No feasibility?** | "can you", "is it possible" |
| **Overlapping subproblems?** | Same computation needed multiple times |
| **Optimal substructure?** | Optimal solution uses optimal sub-solutions |

**Quick Test:** Can you express the answer in terms of smaller instances of the same problem?

### Step 2: Which DP Pattern?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PROBLEM TYPE                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sequence/Array?                                            â”‚
â”‚   â”œâ”€ One sequence â†’ Fibonacci/Linear DP                    â”‚
â”‚   â”œâ”€ Two sequences â†’ LCS/Edit Distance                     â”‚
â”‚   â””â”€ Subarray/substring â†’ Sliding Window or Prefix Sum     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Grid/Matrix?                                               â”‚
â”‚   â””â”€ Path problems â†’ Grid DP                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Selection with constraint?                                 â”‚
â”‚   â”œâ”€ Each item once â†’ 0/1 Knapsack                         â”‚
â”‚   â””â”€ Unlimited items â†’ Unbounded Knapsack                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ States and transitions?                                    â”‚
â”‚   â””â”€ Multiple states â†’ State Machine DP                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Range/interval optimization?                               â”‚
â”‚   â””â”€ Merge/split ranges â†’ Interval DP                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Tree structure?                                            â”‚
â”‚   â””â”€ Tree-based â†’ Tree DP                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Small set (n â‰¤ 20)?                                        â”‚
â”‚   â””â”€ Subset tracking â†’ Bitmask DP                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸŽ¯ The 5-Step DP Approach

### 1. State Definition (Most Important!)

**Ask:** "What information do I need to make a decision at each step?"

| Pattern | State | Example |
|---------|-------|---------|
| Fibonacci | `dp[i]` = answer for position i | Climbing Stairs |
| Grid | `dp[i][j]` = answer at cell (i,j) | Unique Paths |
| Knapsack | `dp[i][w]` = answer using items 0..i-1 with capacity w | 0/1 Knapsack |
| LCS | `dp[i][j]` = answer for prefixes s1[:i], s2[:j] | Edit Distance |
| Interval | `dp[i][j]` = answer for range [i, j] | Burst Balloons |

### 2. Recurrence Relation

**Ask:** "How does the answer for this state depend on smaller states?"

```python
# General form
dp[current_state] = optimal(
    dp[smaller_state_1] + contribution_1,
    dp[smaller_state_2] + contribution_2,
    ...
)
```

### 3. Base Cases

**Ask:** "What are the smallest subproblems with known answers?"

```python
# Examples
dp[0] = 0  # Empty sequence
dp[0][0] = True  # Empty prefix matches
dp[i][0] = 1  # Empty target can be formed 1 way
```

### 4. Fill Order

**Ask:** "In what order should I compute states so dependencies are met?"

| Pattern | Order |
|---------|-------|
| Linear DP | Left to right |
| Grid DP | Row by row, or column by column |
| Interval DP | By increasing length |
| Knapsack (1D) | Right to left (for 0/1), Left to right (for unbounded) |

### 5. Answer Extraction

**Ask:** "Where is the final answer stored?"

```python
# Examples
return dp[n]          # Last element
return dp[m][n]       # Bottom-right corner
return max(dp)        # Maximum across all states
return dp[0][n-1]     # Entire range
```

---

## ðŸ’¬ Communication Template

### Opening (1-2 minutes)

> "This looks like a [Pattern Name] problem because [signal].
> Let me define the state and work through the recurrence."

### State Definition

> "I'll define dp[i][j] as [meaning].
> This captures [what information] which is what I need to make decisions."

### Recurrence

> "For each state, I have [N] choices:
> - Choice 1: [description] â†’ dp[...] + [contribution]
> - Choice 2: [description] â†’ dp[...] + [contribution]
> I take the [max/min/sum] of these."

### Base Cases

> "The base cases are:
> - dp[0] = [value] because [reason]
> - dp[i][0] = [value] because [reason]"

### Complexity

> "Time: O([expression]) because [reason].
> Space: O([expression]), and I can optimize to O([smaller]) by [technique]."

### Before Coding

> "Let me verify with a small example... [trace through]
> Looks correct. I'll code it now."

---

## ðŸ“Š Pattern Quick Reference

### Fibonacci Family
```python
# Climbing Stairs, House Robber, Decode Ways
dp[i] = f(dp[i-1], dp[i-2], ...)
# Optimize: Keep only last 2-3 values
```

### Grid DP
```python
# Unique Paths, Min Path Sum, Triangle
dp[i][j] = f(dp[i-1][j], dp[i][j-1], grid[i][j])
# Optimize: Use 1D array, row by row
```

### 0/1 Knapsack
```python
# Subset Sum, Partition Equal
for item in items:
    for w in range(W, item-1, -1):  # RIGHT TO LEFT
        dp[w] = f(dp[w], dp[w-item])
```

### Unbounded Knapsack
```python
# Coin Change, Perfect Squares
for w in range(W+1):  # LEFT TO RIGHT
    for coin in coins:
        dp[w] = f(dp[w], dp[w-coin])
```

### LCS Family
```python
# LCS, Edit Distance, Longest Palindromic Subsequence
for i in range(1, m+1):
    for j in range(1, n+1):
        if match:
            dp[i][j] = dp[i-1][j-1] + 1
        else:
            dp[i][j] = f(dp[i-1][j], dp[i][j-1])
```

### Interval DP
```python
# Burst Balloons, Matrix Chain
for length in range(2, n+1):  # BY LENGTH
    for i in range(n-length+1):
        j = i + length - 1
        for k in range(i, j):  # Split point
            dp[i][j] = f(dp[i][k], dp[k+1][j], ...)
```

---

## âš ï¸ Common Interview Mistakes

### 1. Jumping to Code Too Fast

**âŒ Wrong:** "I know this pattern, let me code..."
**âœ… Right:** "Let me define the state clearly and verify with an example first."

### 2. Unclear State Definition

**âŒ Wrong:** "dp[i] is like... the answer somehow"
**âœ… Right:** "dp[i] represents the maximum profit using the first i items with capacity w"

### 3. Missing Edge Cases

- Empty input
- Single element
- All same values
- All zeros or negatives

### 4. Wrong Space Optimization

**âŒ Wrong:** Optimizing before getting the 2D solution right
**âœ… Right:** Get 2D working, then optimize to 1D if asked

### 5. Not Testing with Examples

- Always trace through at least one small example
- Verify base cases work
- Check that recurrence produces expected results

---

## ðŸ”¢ Complexity Cheat Sheet

| Pattern | Time | Space (2D) | Space (Optimized) |
|---------|------|------------|-------------------|
| Fibonacci/Linear | O(n) | O(n) | O(1) |
| Grid | O(mn) | O(mn) | O(n) |
| Knapsack | O(nW) | O(nW) | O(W) |
| LCS | O(mn) | O(mn) | O(n) |
| LIS | O(nÂ²) or O(n log n) | O(n) | O(n) |
| Interval | O(nÂ³) | O(nÂ²) | O(nÂ²) |
| Bitmask | O(n Ã— 2â¿) | O(2â¿) | O(2â¿) |

---

## ðŸŽ¤ Handling "I Don't Know" Moments

### If You Don't See the Pattern

> "Let me think about what information I need to track...
> At each step, I need to know [X] to make a decision.
> So my state should include [X]."

### If the Recurrence Isn't Clear

> "Let me consider the choices I have at step i:
> - I could [option 1], which would give me...
> - I could [option 2], which would give me...
> So dp[i] = [max/min] of these options."

### If You're Stuck

> "Let me try the brute force approach first and see where it recomputes...
> I notice we're solving the same subproblem multiple times, which suggests DP."

### If the Interviewer Gives a Hint

> "Ah, that makes sense. So if I track [hint], then I can...
> [Incorporate the hint and continue]"

---

## ðŸ“ Pre-Interview Checklist

### Patterns to Know Cold

- [ ] Fibonacci/Climbing Stairs
- [ ] Grid traversal (Unique Paths, Min Path Sum)
- [ ] 0/1 Knapsack and variants
- [ ] Unbounded Knapsack (Coin Change)
- [ ] LCS and Edit Distance
- [ ] LIS (both O(nÂ²) and O(n log n))
- [ ] Stock problems (I, II, III, with cooldown)

### Skills to Practice

- [ ] Defining states clearly in words
- [ ] Writing recurrences before code
- [ ] Tracing through small examples
- [ ] Space optimization techniques
- [ ] Time/space complexity analysis

### Common Gotchas

- [ ] 0-indexed vs 1-indexed in DP arrays
- [ ] Inclusive vs exclusive ranges
- [ ] Forward vs backward iteration for knapsack
- [ ] Handling empty/base cases

---

## ðŸ’¡ Final Tips

1. **State first, code last**: Most DP bugs come from unclear state definitions
2. **Draw the DP table**: Visualizing helps catch errors
3. **Think about dependencies**: Ensure you're filling in the right order
4. **Start simple**: Get 2D working before optimizing
5. **Communicate constantly**: Interviewers can't help if you're silent
6. **It's OK to be slow**: Correctness > speed in DP problems

---

> **ðŸ’¡ Key Insight:** DP is about breaking down problems into overlapping subproblems. The hardest part is defining the right state. Once you have that, the recurrence often becomes clear.

> **ðŸ”— Related:** [DP Fundamentals](../01-DP-Fundamentals/1.1-What-Is-DP.md) | [Problem-Solving Framework](../01-DP-Fundamentals/3.0-DP-Problem-Solving-Framework.md) | [When to Use DP](../01-DP-Fundamentals/1.2-When-To-Use-DP.md)
