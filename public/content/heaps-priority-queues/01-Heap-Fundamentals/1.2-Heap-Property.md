# 1.2 Heap Property Explained

## Definition

The **heap property** is the ordering constraint that makes a heap useful:

- **Max-Heap Property:** Every node is **greater than or equal to** its children
- **Min-Heap Property:** Every node is **less than or equal to** its children

This property applies **only to parent-child relationships**, not siblings.

```
Max-Heap Property:               Min-Heap Property:
   parent ‚â• children                parent ‚â§ children
   
        100                              1
       /    \                          /   \
      90      80                      5     3
     /  \    /  \                    / \   / \
    70  60  50  40                  10  8  7   9
    
100 ‚â• 90 ‚úì  100 ‚â• 80 ‚úì           1 ‚â§ 5 ‚úì   1 ‚â§ 3 ‚úì
90 ‚â• 70 ‚úì   90 ‚â• 60 ‚úì            5 ‚â§ 10 ‚úì  5 ‚â§ 8 ‚úì
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>Understanding the Heap Property</strong></summary>

**Key insight:**
- Heap property is **local** (parent vs children only)
- NOT a full sort (siblings can be in any order)
- Guarantees extreme element at root

**What it gives us:**
- O(1) access to min/max (always at root)
- O(log n) to restore after modification
- Partial ordering (enough for priority queue)

**What it does NOT give:**
- Elements in sorted order
- Fast search by value
- Comparison between siblings

</details>

---

## ‚úÖ Why This Property Matters

| Benefit | Explanation |
|---------|-------------|
|" O(1) extreme "| Root always has min/max |
|" O(log n) updates "| Only fix path from change to root |
| Simple structure | Only track parent-child, not siblings |
| Array storage | Complete tree + property = efficient array |

## ‚ùå Common Misconceptions

| Wrong Assumption | Reality |
|-----------------|---------|
| "Heap is sorted" | Only parent > children, siblings unordered |
| "Left child < right child" | No such constraint |
| "Can binary search" | No, heap isn't sorted |
|" "Can find Kth in O(1)" "| Only root (1st) is O(1) |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Heap](./1.1-What-Is-Heap.md)
- Binary tree basics
- Parent-child relationships

**After mastering this:**
- [Complete Binary Tree](./1.3-Complete-Binary-Tree.md)
- [Heap Operations](../02-Heap-Operations/2.1-Insert.md)

**Related concepts:**
- BST property (left < parent < right)
- AVL balance property

</details>

---

## üìê How It Works

### Heap Property vs BST Property

```
HEAP PROPERTY (Min-Heap):           BST PROPERTY:
   Parent ‚â§ Children                Left < Parent < Right
   
        1                                  5
       / \                               /   \
      5   3                             2     8
     / \                               / \   / \
    10  8                             1   4 6   9

In heap [5,3]:                      In BST:
  5 and 3 are siblings              Left subtree < Root < Right subtree
  No ordering between them!         Full ordering maintained

Heap: "Parent smallest in subtree"  BST: "Fully ordered for searching"
```

### Verifying Heap Property

```
Is this a valid Min-Heap?

        2
       / \
      8   4
     / \
    9   10

Check all parent-child pairs:
  2 ‚â§ 8 ‚úì   2 ‚â§ 4 ‚úì
  8 ‚â§ 9 ‚úì   8 ‚â§ 10 ‚úì
  
All pass ‚Üí Valid Min-Heap ‚úì

Note: 8 > 4 (sibling comparison) is IRRELEVANT
```

### Heap Property Violations

```
Invalid Min-Heap (violation at X):

        2
       / \
      5   1   ‚Üê VIOLATION: 2 > 1
     / \
    6   7

Fix: Swap 2 and 1, then continue checking

        1
       / \
      5   2   ‚Üê Now valid
     / \
    6   7
```

---

## üíª Code Implementation

### Checking Heap Property

**Python:**
```python
def is_min_heap(arr: list[int]) -> bool:
    """
    Check if array represents a valid min-heap.
    
    Time: O(n) - check all parent-child pairs
    Space: O(1)
    """
    n = len(arr)
    
    # Only need to check internal nodes (not leaves)
    # Internal nodes: indices 0 to (n//2 - 1)
    for i in range(n // 2):
        left = 2 * i + 1
        right = 2 * i + 2
        
        # Check left child
        if left < n and arr[i] > arr[left]:
            return False
        
        # Check right child
        if right < n and arr[i] > arr[right]:
            return False
    
    return True


def is_max_heap(arr: list[int]) -> bool:
    """Check if array represents a valid max-heap."""
    n = len(arr)
    
    for i in range(n // 2):
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[i] < arr[left]:
            return False
        if right < n and arr[i] < arr[right]:
            return False
    
    return True


# Examples:
print(is_min_heap([1, 3, 2, 7, 6, 4, 5]))  # True
print(is_min_heap([1, 2, 3, 4, 5, 6, 7]))  # True (sorted is valid min-heap)
print(is_min_heap([3, 1, 2]))              # False (3 > 1 violates)
```

**JavaScript:**
```javascript
function isMinHeap(arr) {
    const n = arr.length;
    
    // Check all internal nodes
    for (let i = 0; i < Math.floor(n / 2); i++) {
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        
        if (left < n && arr[i] > arr[left]) return false;
        if (right < n && arr[i] > arr[right]) return false;
    }
    
    return true;
}

function isMaxHeap(arr) {
    const n = arr.length;
    
    for (let i = 0; i < Math.floor(n / 2); i++) {
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        
        if (left < n && arr[i] < arr[left]) return false;
        if (right < n && arr[i] < arr[right]) return false;
    }
    
    return true;
}

// Examples:
console.log(isMinHeap([1, 3, 2, 7, 6, 4, 5]));  // true
console.log(isMaxHeap([9, 7, 8, 3, 4, 5, 2]));  // true
```

### Restoring Heap Property

**Python:**
```python
def bubble_up(arr: list[int], i: int) -> None:
    """
    Restore min-heap property by bubbling up from index i.
    Used after inserting at end of heap.
    
    Time: O(log n) - at most height of tree
    """
    while i > 0:
        parent = (i - 1) // 2
        if arr[parent] <= arr[i]:  # Property satisfied
            break
        arr[parent], arr[i] = arr[i], arr[parent]  # Swap
        i = parent


def bubble_down(arr: list[int], i: int, n: int) -> None:
    """
    Restore min-heap property by bubbling down from index i.
    Used after removing root.
    
    Time: O(log n) - at most height of tree
    """
    while True:
        smallest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[left] < arr[smallest]:
            smallest = left
        if right < n and arr[right] < arr[smallest]:
            smallest = right
        
        if smallest == i:  # Property satisfied
            break
        
        arr[i], arr[smallest] = arr[smallest], arr[i]
        i = smallest
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Notes |
|-----------|------|-------|
| Check property (one node) |" O(1) "| Compare with 2 children |
| Check entire heap |" O(n) "| Check all internal nodes |
| Bubble up |" O(log n) "| Height of tree |
| Bubble down |" O(log n) "| Height of tree |

**Why O(log n) for restoring?**
```
Tree height = log‚ÇÇ(n)

Bubble up:   Start at leaf, move toward root
             At most log(n) swaps

Bubble down: Start at root, move toward leaf
             At most log(n) swaps
```

---

## üîÑ Variations

| Variation | Property | Use Case |
|-----------|----------|----------|
| **Min-Heap** | Parent ‚â§ children | Priority queue (min first) |
| **Max-Heap** | Parent ‚â• children | Priority queue (max first) |
| **Min-Max Heap** | Alternating levels | Need both min and max |
| **Weak Heap** | Relaxed property | Fewer comparisons |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Checking Siblings Instead of Parent-Child

```python
# ‚ùå Wrong: Comparing siblings
def is_min_heap_wrong(arr):
    for i in range(len(arr) - 1):
        if arr[i] > arr[i + 1]:  # This checks adjacent, not parent-child!
            return False
    return True

# ‚úÖ Correct: Compare parent with its children
def is_min_heap(arr):
    for i in range(len(arr) // 2):
        left = 2 * i + 1
        right = 2 * i + 2
        if left < len(arr) and arr[i] > arr[left]:
            return False
        if right < len(arr) and arr[i] > arr[right]:
            return False
    return True
```

### 2. Wrong Index Formulas

```python
# ‚ùå Wrong: 1-indexed formulas with 0-indexed array
parent = i // 2              # Wrong for 0-indexed
left = 2 * i                 # Wrong for 0-indexed

# ‚úÖ Correct: 0-indexed formulas
parent = (i - 1) // 2
left = 2 * i + 1
right = 2 * i + 2
```

### 3. Forgetting to Check Bounds

```python
# ‚ùå Wrong: Accessing out of bounds
left = 2 * i + 1
if arr[i] > arr[left]:  # IndexError if left >= len(arr)!
    
# ‚úÖ Correct: Check bounds first
left = 2 * i + 1
if left < len(arr) and arr[i] > arr[left]:
    return False
```

### 4. Checking All Nodes Instead of Internal Only

```python
# ‚ùå Wrong: Checking leaf nodes too (wasteful)
for i in range(len(arr)):  # Includes leaves
    
# ‚úÖ Correct: Only check internal nodes (have children)
for i in range(len(arr) // 2):  # Excludes leaves
```

---

## üìù Practice Problems (Progressive)

### Easy (Understand property)
- [ ] Implement `is_min_heap()` function
- [ ] Implement `is_max_heap()` function
- [ ] Convert array to valid heap visualization

### Medium (Apply property)
- [ ] Implement bubble_up and bubble_down
- [ ] [Last Stone Weight (LC 1046)](https://leetcode.com/problems/last-stone-weight/) - Maintain max-heap

### Hard (Master property)
- [ ] [Find Median from Stream (LC 295)](https://leetcode.com/problems/find-median-from-data-stream/) - Maintain two heaps

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Write index formulas from memory
- **Day 3:** Implement is_heap() without reference
- **Day 7:** Implement bubble_up and bubble_down
- **Day 14:** Explain heap vs BST property to someone
- **Day 30:** Derive why heapify is O(n)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Explain This in Interviews</strong></summary>

**Explaining heap property:**
"In a min-heap, every parent is smaller than or equal to its children. This means the root is always the minimum. It's not fully sorted though - siblings can be in any order."

**Clarifying confusion:**
"Unlike a BST where left < parent < right, a heap only cares about parent vs children. So I can't binary search a heap, but I can always get the min/max in O(1)."

**When asked about violations:**
"If the heap property is violated after an insertion, I bubble up - swap with parent until property is restored. After a deletion, I bubble down - swap with the smaller child until property is restored."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand property | 10-15 min | Draw examples |
| Memorize index formulas | 5-10 min | Practice derivation |
| Implement is_heap() | 10-15 min | Edge cases |
| Implement bubble up/down | 15-20 min | Core operations |

---

## üí° Key Insight

> **The heap property is deliberately weaker than full sorting.** By only enforcing parent-child ordering (not sibling ordering), we achieve O(log n) updates instead of O(n). This "partial order" is exactly enough for priority queue operations: we always know the extreme element (root), and we can efficiently update when elements change.

---

## üîó Related

- **Previous:** [What Is a Heap](./1.1-What-Is-Heap.md)
- **Next:** [Complete Binary Tree](./1.3-Complete-Binary-Tree.md)
- **Operations:** [Insert](../02-Heap-Operations/2.1-Insert.md) | [Remove](../02-Heap-Operations/2.2-Extract.md)
