# 2.1 Search in BST (LC 700)

## Problem Statement

[LeetCode 700 - Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/)

Given the root of a BST and a value `val`, return the subtree rooted at the node with that value. If the node doesn't exist, return `null`.

```
Input: root = [4,2,7,1,3], val = 2
        4
       / \
      2   7
     / \
    1   3

Output: [2,1,3]  (subtree rooted at 2)
        2
       / \
      1   3
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a BST Navigation problem:**
- Need to find a specific value in BST
- Use ordering property to choose direction
- O(h) time instead of O(n)

**Keywords:**
- "search", "find", "locate" in BST
- "return the node" or "return subtree"
- Any BST operation that starts with finding a value

**Pattern:** At each node, compare target with current value:
- target < current ‚Üí go left
- target > current ‚Üí go right
- target == current ‚Üí found!

</details>

---

## ‚úÖ When to Use

- Finding a specific value in BST
- First step of insert/delete operations
- Checking if value exists in BST
- Any operation that requires locating a node

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| General binary tree | No ordering |" O(n) DFS "|
| Find all occurrences | Standard BST has unique values | Modified BST with counts |
| Need path to node | Just returns node | Track path during search |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Definition](../01-BST-Fundamentals/1.1-BST-Definition.md)
- [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)

**After mastering this:**
- [BST Insert (LC 701)](./2.2-BST-Insert-LC701.md) - Same navigation
- [BST Delete (LC 450)](./2.3-BST-Delete-LC450.md) - Search + restructure
- [Validate BST (LC 98)](../03-BST-Validation/3.1-Validate-BST-LC98.md)

**Combines with:**
- Range problems (search to find range endpoints)
- Closest value problems (track closest during search)

</details>

---

## üìê How It Works

### Visualization

```
Searching for 3 in BST:

        4           Step 1: 3 < 4, go LEFT
       / \
      2   7         Step 2: 3 > 2, go RIGHT
     / \
    1   3           Step 3: 3 == 3, FOUND!

Path: 4 ‚Üí 2 ‚Üí 3 (3 comparisons for 5 nodes)
```

### Algorithm Steps

1. **Start at root**
2. **Compare target with current node:**
   - If equal ‚Üí return current node
   - If target < current ‚Üí search left subtree
   - If target > current ‚Üí search right subtree
3. **If reach null ‚Üí value not found**

### Why O(h) Time?

```
Each comparison eliminates half the remaining tree:
         8
        / \
       4   12      If target=3: 3<8, eliminate right half (12,10,14)
      / \  / \
     2  6 10  14   Now only 3 nodes to search

At each level, we do O(1) work and go to ONE child.
Path length = height h = O(log n) for balanced tree.
```

---

## üíª Code Implementation

### Iterative (Preferred)

**Python:**
```python
def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    """
    Search for value in BST and return subtree rooted at that node.
    
    Time: O(h) - follow one path from root
    Space: O(1) - no extra space needed
    
    Pattern: BST Navigation
    """
    current = root
    
    while current:
        if val == current.val:
            return current
        elif val < current.val:
            current = current.left   # Target is smaller, go left
        else:
            current = current.right  # Target is larger, go right
    
    return None  # Value not found
```

**JavaScript:**
```javascript
var searchBST = function(root, val) {
    // BST Search - O(h) time, O(1) space
    let current = root;
    
    while (current) {
        if (val === current.val) {
            return current;
        } else if (val < current.val) {
            current = current.left;
        } else {
            current = current.right;
        }
    }
    
    return null;
};
```

### Recursive (Clean but O(h) space)

**Python:**
```python
def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    """
    Recursive BST search.
    
    Time: O(h)
    Space: O(h) - recursion stack
    """
    if not root:
        return None
    
    if val == root.val:
        return root
    elif val < root.val:
        return self.searchBST(root.left, val)
    else:
        return self.searchBST(root.right, val)
```

**JavaScript:**
```javascript
var searchBST = function(root, val) {
    // Recursive approach
    if (!root) return null;
    
    if (val === root.val) return root;
    if (val < root.val) return searchBST(root.left, val);
    return searchBST(root.right, val);
};
```

### One-Liner (Pythonic)

```python
def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    """Elegant one-liner using short-circuit evaluation."""
    return (
        root if not root or root.val == val 
        else self.searchBST(root.left if val < root.val else root.right, val)
    )
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space (Iterative) | Space (Recursive) |
|------|------|-------------------|-------------------|
| Best |" O(1) "| O(1) |" O(1) "|
| Average |" O(log n) "| O(1) |" O(log n) "|
| Worst |" O(n) "| O(1) |" O(n) "|

**Why these complexities:**

- **Time O(h):** We follow exactly one path from root to target (or leaf)
- **Space O(1) iterative:** Only use a single pointer variable
- **Space O(h) recursive:** Call stack grows with tree height

**Worst case example:**
```
Skewed tree (sorted insertions):
    1
     \
      2
       \
        3
         \
          4   ‚Üê Searching for 4 requires O(n) steps
```

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **Search with path** | Track nodes visited | Debugging, LCA |
| **Closest value** | Track closest during search | LC 270 |
| **Search with parent** | Return node and its parent | Delete preparation |
| **Range search** | Collect all values in [lo, hi] | LC 938 |

### Closest Value Variation

```python
def closestValue(root: TreeNode, target: float) -> int:
    """Find value closest to target - O(h) time."""
    closest = root.val
    
    while root:
        if abs(root.val - target) < abs(closest - target):
            closest = root.val
        
        if target < root.val:
            root = root.left
        elif target > root.val:
            root = root.right
        else:
            return root.val  # Exact match
    
    return closest
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting Null Check

```python
# ‚ùå Wrong: No null check
def searchBST(root, val):
    if val == root.val:  # Crashes if root is None!
        return root
    ...

# ‚úÖ Correct: Check for null first
def searchBST(root, val):
    if not root:
        return None
    if val == root.val:
        return root
    ...
```

### 2. Using Wrong Comparison

```python
# ‚ùå Wrong: Using <= instead of <
if val <= root.val:
    root = root.left

# ‚úÖ Correct: Strict comparison
if val < root.val:
    root = root.left
elif val > root.val:
    root = root.right
else:
    return root  # Equal case
```

### 3. Returning Wrong Thing

```python
# ‚ùå Wrong: Return True/False instead of node
def searchBST(root, val):
    while root:
        if val == root.val:
            return True  # Should return node!
        ...

# ‚úÖ Correct: Return the node
def searchBST(root, val):
    while root:
        if val == root.val:
            return root  # Return the subtree
        ...
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)
- [ ] [Search in BST (LC 700)](https://leetcode.com/problems/search-in-a-binary-search-tree/) - This problem
- [ ] [Two Sum IV - BST (LC 653)](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) - Search + hash

### Medium (Apply variations)
- [ ] [Closest BST Value (LC 270)](https://leetcode.com/problems/closest-binary-search-tree-value/) - Track closest
- [ ] [Insert into BST (LC 701)](https://leetcode.com/problems/insert-into-a-binary-search-tree/) - Search to find spot
- [ ] [Delete Node in BST (LC 450)](https://leetcode.com/problems/delete-node-in-a-bst/) - Search + restructure

### Hard (Master edge cases)
- [ ] [Closest BST Value II (LC 272)](https://leetcode.com/problems/closest-binary-search-tree-value-ii/) - K closest values

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement iterative search from scratch
- **Day 3:** Implement recursive version
- **Day 7:** Solve LC 270 (Closest Value)
- **Day 14:** Use search as part of LC 701 (Insert)
- **Day 30:** Chain search into LC 450 (Delete)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"Since this is a BST, I can use the ordering property. At each node, I compare the target with the current value and go left or right accordingly. This gives O(log n) average time."

**When coding:**
- Talk through the three cases (less, greater, equal)
- Mention iterative vs recursive trade-off
- State complexity before finishing

**Follow-up questions:**
- "What if the tree is skewed?" ‚Üí O(n) worst case
- "Recursive or iterative?" ‚Üí Iterative for O(1) space
- "What if value doesn't exist?" ‚Üí Return null

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| All companies | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Foundation for all BST problems |
| Amazon | High | Often as warm-up |
| Microsoft | High | Building block |
| Google | Medium | Usually combined with other ops |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Very straightforward |
| Code solution | 5-7 min | Simple implementation |
| Discuss complexity | 2-3 min |" O(h) time, O(1) space "|
| Total interview time | 10-15 min | Easy warm-up |

---

## üí° Key Insight

> **BST search is binary search on a tree structure.** Just as binary search on an array halves the search space with each comparison, BST search eliminates an entire subtree with each comparison. Same principle, different data structure.

---

## üîó Related

- **Foundation:** [BST Definition](../01-BST-Fundamentals/1.1-BST-Definition.md)
- **Next:** [BST Insert (LC 701)](./2.2-BST-Insert-LC701.md)
- **Uses this:** [BST Delete (LC 450)](./2.3-BST-Delete-LC450.md)
- **Variation:** [Closest BST Value (LC 270)](https://leetcode.com/problems/closest-binary-search-tree-value/)
