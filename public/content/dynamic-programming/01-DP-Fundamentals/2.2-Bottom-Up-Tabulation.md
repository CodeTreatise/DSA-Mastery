# 2.2 Bottom-Up Tabulation

> **Tabulation** is a DP implementation where you start from the smallest subproblems and iteratively build up to the final answer. It's called "bottom-up" because you start from the bottom (base cases) and work up to the main problem.

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Bottom-Up (Tabulation)</strong></summary>

**Choose tabulation when:**
- You need to solve ALL subproblems anyway
- Deep recursion could cause stack overflow
- You want to optimize space (rolling array)
- Performance is critical (no function call overhead)

**Signals in problems:**
- Clear iteration order (small ‚Üí large)
- All subproblems will be visited
- Space optimization is needed

</details>

---

## ‚úÖ When to Use

- All subproblems needed
- Large input sizes (avoid stack overflow)
- Need space optimization
- Performance-critical applications
- Clearer to reason about complexity

## ‚ùå When NOT to Use

| Situation | Why | Alternative |
|-----------|-----|-------------|
| Only some subproblems needed | Wastes computation | Memoization |
| Complex fill order | Hard to determine iteration | Memoization |
| Quick prototype needed | More code to write | Memoization |
| Recursion is more intuitive | Harder to derive | Memoization first |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Connections</strong></summary>

**Before this:**
- [What Is DP](./1.1-What-Is-DP.md)
- [Top-Down Memoization](./2.1-Top-Down-Memoization.md)

**After this:**
- [Space Optimization](./2.3-Space-Optimization.md)
- [DP Problem-Solving Framework](./3.0-DP-Problem-Solving-Framework.md)

**Key relationship:**
```
Memoization (Top-Down)
         ‚Üì Convert
Tabulation (Bottom-Up)
         ‚Üì Optimize
Space-Optimized DP
```

</details>

---

## üìê How It Works

### The 4-Step Tabulation Pattern

```
Step 1: Create dp table of appropriate size
Step 2: Initialize base cases in the table
Step 3: Iterate in correct order, filling the table
Step 4: Return the answer (usually dp[n] or dp[n-1])
```

**Template:**
```python
def solve(n):
    # Step 1: Create table
    dp = [0] * (n + 1)
    
    # Step 2: Base cases
    dp[0] = base_value_0
    dp[1] = base_value_1
    
    # Step 3: Fill table (small to large)
    for i in range(2, n + 1):
        dp[i] = recurrence(dp[i-1], dp[i-2], ...)
    
    # Step 4: Return answer
    return dp[n]
```

### Visual Comparison: Memoization vs Tabulation

**Fibonacci - Memoization (Top-Down):**
```
Start: fib(5)
       ‚Üì
     fib(4) ‚Üí fib(3) ‚Üí fib(2) ‚Üí fib(1) ‚Üí fib(0)
       ‚Üì         ‚Üì         ‚Üì
   (uses cached values going back up)

Order: 5 ‚Üí 4 ‚Üí 3 ‚Üí 2 ‚Üí 1 ‚Üí 0 (then back up)
```

**Fibonacci - Tabulation (Bottom-Up):**
```
Start: dp[0] = 0, dp[1] = 1

dp[2] = dp[1] + dp[0] = 1
dp[3] = dp[2] + dp[1] = 2
dp[4] = dp[3] + dp[2] = 3
dp[5] = dp[4] + dp[3] = 5 ‚Üê Answer!

Order: 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 (always forward)
```

**Table visualization:**
```
Index:    0   1   2   3   4   5
         ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
dp:      [0] [1] [1] [2] [3] [5]
              ‚Üë   ‚Üë   ‚Üë   ‚Üë   ‚Üë
              ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dp[4] + dp[3]
              ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ dp[3] + dp[2]
              ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ dp[2] + dp[1]
              ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ dp[1] + dp[0]
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ base case
```

---

## üíª Code Implementation

### Python - Tabulation Patterns

```python
from typing import List

# ==========================
# Pattern 1: 1D Tabulation
# ==========================
def fib_tabulation(n: int) -> int:
    """
    Classic bottom-up Fibonacci.
    Time: O(n), Space: O(n)
    """
    if n <= 1:
        return n
    
    # Step 1: Create table
    dp = [0] * (n + 1)
    
    # Step 2: Base cases
    dp[0] = 0
    dp[1] = 1
    
    # Step 3: Fill table
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    # Step 4: Return answer
    return dp[n]


# ==========================
# Pattern 2: 2D Tabulation (Grid)
# ==========================
def unique_paths(m: int, n: int) -> int:
    """
    Count paths in m√ón grid from top-left to bottom-right.
    Time: O(m*n), Space: O(m*n)
    """
    # Step 1: Create 2D table
    dp = [[0] * n for _ in range(m)]
    
    # Step 2: Base cases - first row and column
    for i in range(m):
        dp[i][0] = 1  # Only one way to reach first column
    for j in range(n):
        dp[0][j] = 1  # Only one way to reach first row
    
    # Step 3: Fill table
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]  # From top + from left
    
    # Step 4: Return answer
    return dp[m-1][n-1]


# ==========================
# Pattern 3: 2D Tabulation (Two Sequences)
# ==========================
def longest_common_subsequence(text1: str, text2: str) -> int:
    """
    LCS using bottom-up tabulation.
    Time: O(m*n), Space: O(m*n)
    """
    m, n = len(text1), len(text2)
    
    # dp[i][j] = LCS of text1[0:i] and text2[0:j]
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Base case: dp[0][j] = dp[i][0] = 0 (empty string)
    # Already initialized to 0
    
    # Fill table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]


# ==========================
# Pattern 4: 1D with Choices
# ==========================
def coin_change(coins: List[int], amount: int) -> int:
    """
    Minimum coins to make amount.
    Time: O(amount * len(coins)), Space: O(amount)
    """
    # dp[i] = minimum coins to make amount i
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Base case: 0 coins for amount 0
    
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i and dp[i - coin] != float('inf'):
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1


# ==========================
# Pattern 5: Boolean DP
# ==========================
def can_partition(nums: List[int]) -> bool:
    """
    Can we partition into two equal-sum subsets?
    Time: O(n * sum), Space: O(sum)
    """
    total = sum(nums)
    if total % 2 != 0:
        return False
    
    target = total // 2
    
    # dp[j] = can we make sum j?
    dp = [False] * (target + 1)
    dp[0] = True  # Sum 0 always achievable (empty subset)
    
    for num in nums:
        # Iterate backwards to avoid using same num twice
        for j in range(target, num - 1, -1):
            dp[j] = dp[j] or dp[j - num]
    
    return dp[target]
```

### JavaScript - Tabulation Patterns

```javascript
// ==========================
// Pattern 1: 1D Tabulation
// ==========================
function fibTabulation(n) {
    if (n <= 1) return n;
    
    const dp = new Array(n + 1).fill(0);
    dp[0] = 0;
    dp[1] = 1;
    
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}

// ==========================
// Pattern 2: 2D Tabulation (Grid)
// ==========================
function uniquePaths(m, n) {
    const dp = Array.from({ length: m }, () => 
        new Array(n).fill(0)
    );
    
    // Base cases
    for (let i = 0; i < m; i++) dp[i][0] = 1;
    for (let j = 0; j < n; j++) dp[0][j] = 1;
    
    // Fill table
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    
    return dp[m - 1][n - 1];
}

// ==========================
// Pattern 3: Two Sequences
// ==========================
function longestCommonSubsequence(text1, text2) {
    const m = text1.length, n = text2.length;
    const dp = Array.from({ length: m + 1 }, () => 
        new Array(n + 1).fill(0)
    );
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (text1[i - 1] === text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[m][n];
}

// ==========================
// Pattern 4: 1D with Choices
// ==========================
function coinChange(coins, amount) {
    const dp = new Array(amount + 1).fill(Infinity);
    dp[0] = 0;
    
    for (let i = 1; i <= amount; i++) {
        for (const coin of coins) {
            if (coin <= i && dp[i - coin] !== Infinity) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    
    return dp[amount] === Infinity ? -1 : dp[amount];
}
```

---

## ‚ö° Complexity Analysis

| Problem | Time | Space | Notes |
|---------|------|-------|-------|
| Fibonacci | O(n) | O(n) | Can optimize to O(1) |
| Unique Paths | O(m√ón) | O(m√ón) | Can optimize to O(n) |
| LCS | O(m√ón) | O(m√ón) | Can optimize to O(min(m,n)) |
| Coin Change | O(amount √ó coins) | O(amount) | Already 1D |

**Why tabulation can be faster:**
```
Memoization overhead:
- Function call stack
- Hash table lookups
- Cache miss costs

Tabulation:
- Simple array indexing O(1)
- No recursion overhead
- Better cache locality
```

---

## üîÑ Memoization ‚Üí Tabulation Conversion

### Step-by-Step Conversion

**1. Identify the state dimensions**
```python
# Memoization: memo[(i, j)] ‚Üí 2D state
# Tabulation:  dp[i][j]      ‚Üí 2D array
```

**2. Determine iteration order**
```python
# Look at dependencies:
# If dp[i][j] depends on dp[i-1][j-1], dp[i-1][j], dp[i][j-1]
# Then iterate i from 0 to m, j from 0 to n (increasing order)
```

**3. Initialize base cases**
```python
# Memoization base cases ‚Üí Initial values in dp table
```

**4. Replace recursive calls with table lookups**
```python
# solve(i-1, j) ‚Üí dp[i-1][j]
```

### Example: LCS Conversion

**Memoization:**
```python
def lcs_memo(s1, s2):
    memo = {}
    
    def dp(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        if i == len(s1) or j == len(s2):
            return 0
        
        if s1[i] == s2[j]:
            result = 1 + dp(i + 1, j + 1)
        else:
            result = max(dp(i + 1, j), dp(i, j + 1))
        
        memo[(i, j)] = result
        return result
    
    return dp(0, 0)
```

**Tabulation (Converted):**
```python
def lcs_tab(s1, s2):
    m, n = len(s1), len(s2)
    
    # 2D state ‚Üí 2D table (add 1 for base case row/col)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Base case: dp[m][*] = 0, dp[*][n] = 0 (already 0)
    
    # Iterate: we need dp[i+1], dp[j+1] before dp[i][j]
    # So go backwards from m-1 to 0, n-1 to 0
    for i in range(m - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            if s1[i] == s2[j]:
                dp[i][j] = 1 + dp[i + 1][j + 1]
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])
    
    return dp[0][0]
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Table Size

**‚ùå Wrong:**
```python
dp = [0] * n  # Off by one!
# Can't access dp[n]
```

**‚úÖ Correct:**
```python
dp = [0] * (n + 1)  # Size n+1 for indices 0 to n
```

### 2. Wrong Iteration Order

**‚ùå Wrong:**
```python
# dp[i][j] depends on dp[i+1][j+1]
# But iterating forward!
for i in range(m):
    for j in range(n):
        dp[i][j] = ... dp[i+1][j+1]  # Not computed yet!
```

**‚úÖ Correct:**
```python
# Iterate backwards when depending on larger indices
for i in range(m - 1, -1, -1):
    for j in range(n - 1, -1, -1):
        dp[i][j] = ... dp[i+1][j+1]  # Already computed!
```

### 3. Forgetting Base Cases

**‚ùå Wrong:**
```python
dp = [[0] * n for _ in range(m)]
# Directly start filling without proper base cases
for i in range(m):
    for j in range(n):
        dp[i][j] = dp[i-1][j] + dp[i][j-1]  # dp[-1][0]??
```

**‚úÖ Correct:**
```python
dp = [[0] * n for _ in range(m)]
# Initialize base cases first
for i in range(m):
    dp[i][0] = 1
for j in range(n):
    dp[0][j] = 1
# Then fill
for i in range(1, m):
    for j in range(1, n):
        dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

### 4. Using Uninitialized Values

**‚ùå Wrong:**
```python
dp = [0] * (amount + 1)
dp[0] = 0
for i in range(1, amount + 1):
    for coin in coins:
        dp[i] = min(dp[i], dp[i - coin] + 1)  # min(0, ...) always 0!
```

**‚úÖ Correct:**
```python
dp = [float('inf')] * (amount + 1)  # Initialize to infinity
dp[0] = 0
for i in range(1, amount + 1):
    for coin in coins:
        if coin <= i:
            dp[i] = min(dp[i], dp[i - coin] + 1)
```

---

## üìù Practice Problems (Progressive)

**Easy (1D Tabulation):**
- [ ] [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/) - Basic iteration
- [ ] [Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/) - With cost

**Medium (2D Tabulation):**
- [ ] [Unique Paths](https://leetcode.com/problems/unique-paths/) - Grid DP
- [ ] [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/) - Grid optimization
- [ ] [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/) - Two sequences

**Hard (Complex patterns):**
- [ ] [Edit Distance](https://leetcode.com/problems/edit-distance/) - 3 choices per cell
- [ ] [Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/) - Counting

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement Fibonacci tabulation from scratch
- **Day 3:** Convert memoized Climbing Stairs to tabulation
- **Day 7:** Solve Unique Paths with tabulation
- **Day 14:** Solve LCS and trace through the table
- **Day 30:** Derive tabulation for a new problem

</details>

---

## üé§ Interview Context

<details>
<summary><strong>When to Show Tabulation</strong></summary>

**Start with memoization, then offer to convert:**
> "Here's my memoized solution. I could also convert this to bottom-up tabulation, which would:
> 1. Avoid potential stack overflow for large inputs
> 2. Allow for space optimization
> Would you like me to show that?"

**If asked about trade-offs:**
> "Memoization is easier to derive from the recurrence, while tabulation is more efficient in practice due to better cache locality and no function call overhead."

**Company expectations:**
- Most interviewers accept either approach
- Google may ask for both to show understanding
- For follow-up "optimize space," tabulation is required

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 20-30 min | This document |
| Convert memo ‚Üí tab | 15-20 min | Mechanical process |
| Derive tabulation directly | 25-35 min | Requires practice |
| Master pattern | 5-7 problems | Until automatic |

---

> **üí° Key Insight:** Tabulation builds the solution from the ground up. Instead of asking "what do I need?" (top-down), you ask "what can I compute with what I have?" (bottom-up). This makes it easier to see space optimization opportunities.

> **üîó Related:** [Top-Down Memoization](./2.1-Top-Down-Memoization.md) | [Space Optimization](./2.3-Space-Optimization.md) | [Problem-Solving Framework](./3.0-DP-Problem-Solving-Framework.md)
