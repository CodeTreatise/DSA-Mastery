# 2.2 - String Operations

> **Foundation:** Core string manipulation operations in Python and JavaScript
>
> **Priority:** ‚≠ê‚≠ê‚≠ê‚≠ê HIGH - Essential knowledge for string problems

---

## Overview

Strings are sequences of characters. Understanding basic operations is essential before tackling string algorithm problems. This section covers the fundamental operations you'll use in nearly every string problem.

---

## üéØ Pattern Recognition

<details>
<summary><strong>When String Operations Apply</strong></summary>

**You need basic string operations when:**
- Building or modifying strings character by character
- Extracting substrings or comparing strings
- Converting between cases or formats
- Checking string properties (empty, length, etc.)

**Keywords in problem statement:**
- "reverse", "palindrome", "anagram"
- "substring", "prefix", "suffix"
- "concatenate", "compare"

</details>

---

## ‚úÖ When to Use

- Preprocessing strings before algorithm application
- Building result strings incrementally
- Validating input strings
- Comparing strings or substrings

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|-------------------|
| Frequent modifications | Use list/array of chars, join at end |
| Pattern matching | Use regex or KMP algorithm |
| Finding duplicates | Use hash map/set |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [2.1 String Basics](2.1-String-Basics.md) - What strings are, immutability

**After mastering this:**
- [2.3 String Methods](2.3-String-Methods.md) - Built-in methods
- [2.4 String Techniques](2.4-String-Techniques.md) - Algorithms

**Combines with:**
- Two Pointers for palindrome checking
- Hash Map for frequency counting

</details>

---

## üìê Core Operations

### 1. String Concatenation

**Joining strings together**

**Python:**
```python
# Using + operator (creates new string each time)
s1 = "Hello"
s2 = "World"
result = s1 + " " + s2  # "Hello World"

# Using f-strings (preferred for formatting)
name = "Alice"
age = 25
greeting = f"My name is {name} and I am {age} years old"

# Using join() (EFFICIENT for multiple strings)
words = ["Hello", "World", "!"]
result = " ".join(words)  # "Hello World !"

# ‚ö†Ô∏è INEFFICIENT: Concatenating in a loop
result = ""
for word in words:
    result += word  # Creates new string each time! O(n¬≤)

# ‚úÖ EFFICIENT: Build list, join at end
parts = []
for word in words:
    parts.append(word)
result = "".join(parts)  # O(n) total
```

**JavaScript:**
```javascript
// Using + operator
const s1 = "Hello";
const s2 = "World";
const result = s1 + " " + s2;  // "Hello World"

// Using template literals (preferred)
const name = "Alice";
const age = 25;
const greeting = `My name is ${name} and I am ${age} years old`;

// Using join() for arrays
const words = ["Hello", "World", "!"];
const result2 = words.join(" ");  // "Hello World !"

// Using concat()
const result3 = s1.concat(" ", s2);  // "Hello World"
```

---

### 2. String Comparison

**Comparing strings for equality or ordering**

**Python:**
```python
s1 = "apple"
s2 = "banana"
s3 = "apple"

# Equality check
s1 == s3  # True
s1 == s2  # False

# Case-insensitive comparison
"Apple".lower() == "apple"  # True
"APPLE".casefold() == "apple"  # True (handles unicode better)

# Lexicographic comparison (dictionary order)
s1 < s2   # True ("apple" comes before "banana")
s1 > s2   # False

# Check if identical object (rarely needed)
s1 is s3  # May be True due to string interning (don't rely on this!)
```

**JavaScript:**
```javascript
const s1 = "apple";
const s2 = "banana";
const s3 = "apple";

// Equality check
s1 === s3;  // true
s1 === s2;  // false

// Case-insensitive comparison
"Apple".toLowerCase() === "apple";  // true

// Lexicographic comparison
s1 < s2;   // true
s1 > s2;   // false

// Using localeCompare (for locale-aware comparison)
s1.localeCompare(s2);  // -1 (s1 comes before s2)
s2.localeCompare(s1);  // 1 (s2 comes after s1)
s1.localeCompare(s3);  // 0 (equal)
```

---

### 3. Substring Extraction

**Getting parts of a string**

**Python:**
```python
s = "Hello, World!"

# Slicing: s[start:end] (end is exclusive)
s[0:5]     # "Hello" (index 0-4)
s[7:12]    # "World" (index 7-11)

# From start
s[:5]      # "Hello" (same as s[0:5])

# To end
s[7:]      # "World!" (from index 7 to end)

# Negative indices (count from end)
s[-1]      # "!" (last character)
s[-6:-1]   # "World" (6th from end to 2nd from end)
s[-6:]     # "World!" (6th from end to end)

# Step (every nth character)
s[::2]     # "Hlo ol!" (every 2nd char)
s[::-1]    # "!dlroW ,olleH" (reversed)

# Get first/last n characters
first_3 = s[:3]   # "Hel"
last_3 = s[-3:]   # "ld!"
```

**JavaScript:**
```javascript
const s = "Hello, World!";

// substring(start, end) - end is exclusive
s.substring(0, 5);   // "Hello"
s.substring(7, 12);  // "World"

// slice(start, end) - supports negative indices
s.slice(0, 5);       // "Hello"
s.slice(-6, -1);     // "World"
s.slice(-6);         // "World!" (to end)

// substr(start, length) - deprecated but still works
s.substr(7, 5);      // "World" (5 chars from index 7)

// Get first/last n characters
const first3 = s.slice(0, 3);   // "Hel"
const last3 = s.slice(-3);      // "ld!"

// Reverse a string (no built-in method)
const reversed = s.split("").reverse().join("");  // "!dlroW ,olleH"
```

---

### 4. Character Access

**Accessing individual characters**

**Python:**
```python
s = "Hello"

# Index access
s[0]       # "H" (first)
s[4]       # "o" (fifth)
s[-1]      # "o" (last)
s[-2]      # "l" (second to last)

# ‚ö†Ô∏è Index out of range raises error
# s[10]    # IndexError!

# Iterate through characters
for char in s:
    print(char)  # H, e, l, l, o

# Iterate with index
for i, char in enumerate(s):
    print(f"{i}: {char}")  # 0: H, 1: e, etc.

# Check if character exists
'H' in s   # True
'z' in s   # False
```

**JavaScript:**
```javascript
const s = "Hello";

// Index access
s[0];         // "H"
s[4];         // "o"
s[s.length - 1];  // "o" (last)

// charAt() method (same result)
s.charAt(0);  // "H"

// ‚ö†Ô∏è Index out of range returns undefined
s[10];        // undefined (no error)

// Iterate through characters
for (const char of s) {
    console.log(char);  // H, e, l, l, o
}

// Iterate with index
for (let i = 0; i < s.length; i++) {
    console.log(`${i}: ${s[i]}`);
}

// Check if character exists
s.includes("H");  // true
s.includes("z");  // false
```

---

### 5. Case Conversion

**Changing between upper and lower case**

**Python:**
```python
s = "Hello World"

# Convert to uppercase
s.upper()      # "HELLO WORLD"

# Convert to lowercase
s.lower()      # "hello world"

# Capitalize first letter only
s.capitalize() # "Hello world"

# Title case (each word capitalized)
s.title()      # "Hello World"

# Swap case
s.swapcase()   # "hELLO wORLD"

# Case-insensitive comparison
"HELLO" == "hello"              # False
"HELLO".lower() == "hello"      # True
"HELLO".casefold() == "hello"   # True (better for unicode)
```

**JavaScript:**
```javascript
const s = "Hello World";

// Convert to uppercase
s.toUpperCase();  // "HELLO WORLD"

// Convert to lowercase
s.toLowerCase();  // "hello world"

// No built-in capitalize or title case
// Custom capitalize first letter:
const capitalize = str => str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
capitalize("hello");  // "Hello"

// Custom title case:
const titleCase = str => str.split(" ")
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(" ");
titleCase("hello world");  // "Hello World"
```

---

### 6. String Length

**Getting the number of characters**

**Python:**
```python
s = "Hello"

# Get length
len(s)  # 5

# Check if empty
len(s) == 0     # False
not s           # False (empty string is falsy)
s == ""         # False

# Empty string checks
empty = ""
len(empty) == 0  # True
not empty        # True
empty == ""      # True
if not empty:    # Preferred pythonic way
    print("Empty!")
```

**JavaScript:**
```javascript
const s = "Hello";

// Get length (property, not method!)
s.length;  // 5

// Check if empty
s.length === 0;  // false
s === "";        // false
!s;              // false (empty string is falsy)

// Empty string checks
const empty = "";
empty.length === 0;  // true
empty === "";        // true
!empty;              // true
if (!empty) {        // Preferred way
    console.log("Empty!");
}
```

---

## ‚ö° Complexity Analysis

| Operation | Python | JavaScript | Notes |
|-----------|--------|------------|-------|
| Concatenation (+) | O(n+m) | O(n+m) | Creates new string |
| Length | O(1) | O(1) | Stored property |
| Index access | O(1) | O(1) | Direct access |
| Slicing | O(k) | O(k) | k = slice length |
| in / includes | O(n) | O(n) | Linear search |
| Comparison (==) | O(n) | O(n) | Compare each char |
| upper/lower | O(n) | O(n) | Creates new string |

**‚ö†Ô∏è String Immutability Cost:**
```python
# ‚ùå BAD: O(n¬≤) due to creating new strings
result = ""
for i in range(n):
    result += str(i)  # Each += creates new string!

# ‚úÖ GOOD: O(n) using list
parts = []
for i in range(n):
    parts.append(str(i))
result = "".join(parts)
```

---

## ‚ö†Ô∏è Common Mistakes

1. **Modifying strings in place (they're immutable!)**
   - ‚ùå `s[0] = 'h'` - TypeError!
   - ‚úÖ `s = 'h' + s[1:]` - Create new string

2. **Using + in loops (quadratic time)**
   - ‚ùå `result += char` in loop
   - ‚úÖ `parts.append(char)` then `''.join(parts)`

3. **Off-by-one in slicing**
   - ‚ùå `s[0:5]` thinking it's 6 characters
   - ‚úÖ `s[0:5]` gives 5 characters (indices 0-4)

4. **Forgetting case sensitivity**
   - ‚ùå `s1 == s2` when comparing user input
   - ‚úÖ `s1.lower() == s2.lower()` for case-insensitive

5. **Index out of bounds**
   - ‚ùå Python: `s[len(s)]` raises IndexError
   - ‚ö†Ô∏è JavaScript: `s[s.length]` returns `undefined` (silent!)

---

## üìù Practice Problems (Progressive)

### Easy (Apply basics)
- [ ] [Reverse String](https://leetcode.com/problems/reverse-string/) - LC 344
- [ ] [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/) - LC 125
- [ ] [First Unique Character](https://leetcode.com/problems/first-unique-character-in-a-string/) - LC 387

### Medium (Combine operations)
- [ ] [Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/) - LC 14
- [ ] [String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/) - LC 8

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Practice string slicing in both languages
- **Day 3:** Convert between cases, compare strings
- **Day 7:** Build strings efficiently (list + join pattern)
- **Day 14:** Review all operations without reference

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**When explaining:**
1. "I'll use slicing to get the substring from index i to j"
2. "Since strings are immutable, I'll build in a list and join at the end"
3. "I'll convert to lowercase for case-insensitive comparison"

**What interviewers look for:**
- Awareness of string immutability and its O(n¬≤) trap
- Efficient string building with list + join
- Proper handling of edge cases (empty string, single char)

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn all operations | 20-30 min | Quick reference |
| Practice in REPL | 15-20 min | Try each operation |
| Solve Easy problems | 10-15 min each | Apply knowledge |

---

> **üí° Key Insight:** The most important thing to remember is that strings are **immutable**. Every "modification" creates a new string. For building strings in loops, always use a list and join at the end!

> **üîó Related:** [2.3 String Methods](2.3-String-Methods.md) | [2.4 String Techniques](2.4-String-Techniques.md)
