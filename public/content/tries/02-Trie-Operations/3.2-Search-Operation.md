# Trie Search Operation

> **Search checks if an exact word exists in the Trie - it must traverse all characters AND verify the end marker is set.**

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Search Patterns</strong></summary>

**Look for these signals:**
- "Check if word exists in dictionary"
- "Is this a valid word?"
- "Find exact match"
- Dictionary lookups, spell checking

**Key distinction:**
- **Search** = Exact match, word must END at that node
- **StartsWith** = Prefix match, word may continue beyond

</details>

---

## ‚úÖ When to Use

| Scenario | Details |
|----------|---------|
| **Dictionary lookup** | Is "apple" a word? |
| **Spell checking** | Verify word validity |
| **Word games** | Is player's word valid? |
| **Exact matching** | Distinguish from prefixes |

---

## ‚ùå Search vs StartsWith - Critical Difference

| Operation | Checks | Returns True For |
|-----------|--------|------------------|
| **search("app")** | Is "app" a complete word? | Only if "app" was inserted |
| **startsWith("app")** | Does any word start with "app"? | If "app", "apple", etc. exist |

**Example:**
```
Trie contains: ["apple"]

search("app")      ‚Üí False (no word "app" inserted)
search("apple")    ‚Üí True  (word exists)
startsWith("app")  ‚Üí True  (apple starts with app)
```

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Trie](../01-Trie-Fundamentals/1.1-What-Is-Trie.md) - Basic concept
- [TrieNode Structure](../01-Trie-Fundamentals/2.1-TrieNode-Structure.md) - Node design
- [Insert Operation](./3.1-Insert-Operation.md) - Building the trie

**After mastering this:**
- [StartsWith Operation](./3.3-StartsWith-Prefix.md) - Prefix checking
- [Wildcard Search](../03-Trie-Patterns/4.1-Wildcard-Search.md) - Pattern matching

**Search combines with:**
- Backtracking for Word Search
- DFS for finding all words

</details>

---

## üìê How It Works

### The Search Algorithm

```
FUNCTION search(word):
    1. Start at root node
    2. FOR each character in word:
        a. If child for character doesn't exist:
           ‚Üí Return False (word can't exist)
        b. Move to child node
    3. Return node.is_end (True if word ends here)
    END
```

### Step-by-Step Visualization

**Trie contains: ["app", "apple"]**

```
Trie structure:
    (root)
       ‚îÇ
       a
       ‚îÇ
       p
       ‚îÇ
       p ‚Üê is_end = True ("app")
       ‚îÇ
       l
       ‚îÇ
       e ‚Üê is_end = True ("apple")
```

**Search "app":**
```
Step 1: At root, look for 'a' ‚Üí Found, move down
Step 2: At 'a', look for 'p' ‚Üí Found, move down
Step 3: At 'p', look for 'p' ‚Üí Found, move down
Step 4: At 'p', no more chars, check is_end ‚Üí True ‚úì
Result: True
```

**Search "apple":**
```
Step 1-3: Same as above, reach 'p'
Step 4: At 'p', look for 'l' ‚Üí Found, move down
Step 5: At 'l', look for 'e' ‚Üí Found, move down
Step 6: At 'e', no more chars, check is_end ‚Üí True ‚úì
Result: True
```

**Search "appl":**
```
Step 1-4: Traverse to 'l' node
Step 5: At 'l', no more chars, check is_end ‚Üí False ‚úó
Result: False (reached 'l' but it's not marked as word end)
```

**Search "application":**
```
Step 1-5: Traverse to 'e' node
Step 6: At 'e', look for 'i' ‚Üí NOT FOUND ‚úó
Result: False (path doesn't exist)
```

---

## üíª Code Implementation

### Basic Search (HashMap)

**Python:**
```python
class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def search(self, word: str) -> bool:
        """
        Check if exact word exists in trie.
        
        Time: O(m) where m = len(word)
        Space: O(1) - no extra space
        
        Args:
            word: String to search for
            
        Returns:
            True if word exists, False otherwise
        """
        node = self.root
        
        for char in word:
            # If character path doesn't exist, word can't exist
            if char not in node.children:
                return False
            
            # Move to child node
            node = node.children[char]
        
        # Critical: Must check is_end, not just path existence
        return node.is_end
```

**JavaScript:**
```javascript
class Trie {
    constructor() {
        this.root = new TrieNode();
    }
    
    /**
     * Check if exact word exists in trie.
     * @param {string} word - Word to search for
     * @returns {boolean}
     */
    search(word) {
        let node = this.root;
        
        for (const char of word) {
            if (!node.children.has(char)) {
                return false;
            }
            node = node.children.get(char);
        }
        
        return node.isEnd;  // Must check end marker!
    }
}
```

---

### Optimized Search (Array[26])

**Python:**
```python
class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def search(self, word: str) -> bool:
        """
        Search with array-based children (lowercase only).
        
        Time: O(m) - guaranteed, no hash overhead
        Space: O(1)
        """
        node = self.root
        
        for char in word:
            index = ord(char) - ord('a')
            
            if node.children[index] is None:
                return False
            
            node = node.children[index]
        
        return node.is_end
```

**JavaScript:**
```javascript
class Trie {
    constructor() {
        this.root = new TrieNode();
    }
    
    search(word) {
        let node = this.root;
        
        for (const char of word) {
            const index = char.charCodeAt(0) - 'a'.charCodeAt(0);
            
            if (node.children[index] === null) {
                return false;
            }
            
            node = node.children[index];
        }
        
        return node.isEnd;
    }
}
```

---

### Search with Helper (Reusable Traverse)

**Python:**
```python
class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def _traverse(self, s: str) -> TrieNode:
        """
        Traverse trie following string s.
        Returns final node or None if path doesn't exist.
        
        This helper is reused by search() and startsWith().
        """
        node = self.root
        
        for char in s:
            if char not in node.children:
                return None
            node = node.children[char]
        
        return node
    
    def search(self, word: str) -> bool:
        """Check if exact word exists."""
        node = self._traverse(word)
        return node is not None and node.is_end
    
    def startsWith(self, prefix: str) -> bool:
        """Check if any word starts with prefix."""
        return self._traverse(prefix) is not None
```

**JavaScript:**
```javascript
class Trie {
    constructor() {
        this.root = new TrieNode();
    }
    
    _traverse(s) {
        let node = this.root;
        
        for (const char of s) {
            if (!node.children.has(char)) {
                return null;
            }
            node = node.children.get(char);
        }
        
        return node;
    }
    
    search(word) {
        const node = this._traverse(word);
        return node !== null && node.isEnd;
    }
    
    startsWith(prefix) {
        return this._traverse(prefix) !== null;
    }
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| **Search** | O(m) | O(1) | m = word length |
| **Best case** | O(1) | O(1) | First char doesn't exist |
| **Worst case** | O(m) | O(1) | Full traversal |

**Why O(m):**
- Visit at most m nodes (one per character)
- Each node visit is O(1) (hash lookup or array access)
- No recursion stack needed

**Comparison with alternatives:**

| Structure | Search Time | Notes |
|-----------|-------------|-------|
| Trie | O(m) | Length-based |
| HashSet | O(m) | For hashing string |
| Sorted Array | O(m log n) | Binary search + compare |
| Linked List | O(n √ó m) | Must check all |

---

## üîÑ Variations

| Variation | Difference | Use Case |
|-----------|------------|----------|
| **Basic search** | Just is_end check | Exact word lookup |
| **Get word count** | Return count instead | Frequency queries |
| **Case-insensitive** | Lowercase before search | User-friendly search |
| **With found word** | Return stored word | Prefix matching |

### Case-Insensitive Search

```python
def search(self, word: str) -> bool:
    """Case-insensitive search."""
    return self._search_helper(word.lower())
```

### Search with Count

```python
def search_count(self, word: str) -> int:
    """Return how many times word was inserted."""
    node = self._traverse(word)
    if node is None or not node.is_end:
        return 0
    return node.end_count  # Requires extended node
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Check is_end

**‚ùå Wrong:**
```python
def search(self, word):
    node = self._traverse(word)
    return node is not None  # Wrong! Prefix is not a word!
```

**‚úÖ Correct:**
```python
def search(self, word):
    node = self._traverse(word)
    return node is not None and node.is_end  # Must check is_end!
```

### 2. Confusing Search and StartsWith

**‚ùå Wrong understanding:**
```python
# Trie contains ["apple"]
trie.search("app")  # Returns False, NOT True!
```

**‚úÖ Correct understanding:**
```python
# Trie contains ["apple"]
trie.search("app")      # False - "app" is not a word
trie.startsWith("app")  # True - "apple" starts with "app"
```

### 3. Wrong Return Value for Empty String

**Consider:**
```python
def search(self, word):
    if not word:
        return ???  # What should this return?
```

**‚úÖ Correct:**
```python
def search(self, word):
    if not word:
        return self.root.is_end  # True only if empty string was inserted
```

---

## üìù Practice Problems

### Easy (Master basic search)
- [ ] [Implement Trie](https://leetcode.com/problems/implement-trie-prefix-tree/) - LC 208 ‚≠ê

### Medium (Search variations)
- [ ] [Design Add and Search Words](https://leetcode.com/problems/design-add-and-search-words-data-structure/) - LC 211
- [ ] [Longest Word in Dictionary](https://leetcode.com/problems/longest-word-in-dictionary/) - LC 720
- [ ] [Replace Words](https://leetcode.com/problems/replace-words/) - LC 648

### Hard (Complex search patterns)
- [ ] [Word Search II](https://leetcode.com/problems/word-search-ii/) - LC 212
- [ ] [Stream of Characters](https://leetcode.com/problems/stream-of-characters/) - LC 1032

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

For search operation mastery:
- **Day 1:** Implement search from scratch, test edge cases
- **Day 3:** Implement both search and startsWith, understand difference
- **Day 7:** Solve "Add and Search Words" with wildcard
- **Day 14:** Apply search in Word Search II
- **Day 30:** Explain search vs startsWith to someone

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Discuss Search in Interviews</strong></summary>

**Explaining the approach:**
> "For search, I traverse the trie character by character. If at any point the path doesn't exist, the word isn't there. If I reach the end of the word, I check if this node is marked as the end of a word - that's the key difference from prefix checking."

**When asked why check is_end:**
> "The path might exist as part of a longer word. For example, if we only have 'apple' in the trie, the path 'app' exists, but 'app' isn't a word. The is_end flag distinguishes complete words from just prefixes."

**Common interview follow-up:**
> Interviewer: "What if the search should be case-insensitive?"
> You: "I'd convert the query to lowercase before searching. The trie should also store words in lowercase, or we'd need to check both cases at each step."

</details>

**Interview Tips:**

| Situation | Advice |
|-----------|--------|
| Asked about search | Always mention the is_end check |
| Prefix vs exact | Clarify which is needed |
| Empty string | Ask about expected behavior |
| Case sensitivity | Clarify requirements |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand search | 10-15 min | This file |
| Implement basic search | 5 min | Simple traversal |
| Understand search vs startsWith | 5-10 min | Key distinction |
| Implement with helper | 10 min | Reusable code |
| Master pattern | 20-30 min | With practice problems |

---

> **üí° Key Insight:** Search = Traverse + Check is_end. The traversal ensures the path exists; the is_end check ensures it's a complete word, not just a prefix of something longer.

> **üîó Related:** [Insert Operation](./3.1-Insert-Operation.md) | [StartsWith Operation](./3.3-StartsWith-Prefix.md) | [Wildcard Search](../03-Trie-Patterns/4.1-Wildcard-Search.md)
