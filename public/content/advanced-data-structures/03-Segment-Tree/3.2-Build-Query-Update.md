# Segment Tree: Build, Query, Update

> **Deep dive into the three core operations of Segment Trees.**
>
> Understanding these operations thoroughly is key to implementing variants.

---

## ğŸ“ Build Operation

### Recursive Build

```python
def build(self, arr, node, start, end):
    """
    Build segment tree from array.
    
    Time: O(n) - visits each leaf once, each internal node once
    Space: O(log n) recursion stack
    """
    if start == end:
        # Leaf: store array element
        self.tree[node] = arr[start]
    else:
        mid = (start + end) // 2
        left = 2 * node
        right = 2 * node + 1
        
        # Build children first
        self.build(arr, left, start, mid)
        self.build(arr, right, mid + 1, end)
        
        # Then compute parent from children
        self.tree[node] = self.merge(self.tree[left], self.tree[right])
```

### Build Visualization

```
Array: [2, 1, 5, 3]

Step-by-step build (post-order traversal):

1. build(1, 0, 3)
   â”œâ”€â”€ build(2, 0, 1)
   â”‚   â”œâ”€â”€ build(4, 0, 0) â†’ tree[4] = 2
   â”‚   â”œâ”€â”€ build(5, 1, 1) â†’ tree[5] = 1
   â”‚   â””â”€â”€ tree[2] = 2 + 1 = 3
   â”œâ”€â”€ build(3, 2, 3)
   â”‚   â”œâ”€â”€ build(6, 2, 2) â†’ tree[6] = 5
   â”‚   â”œâ”€â”€ build(7, 3, 3) â†’ tree[7] = 3
   â”‚   â””â”€â”€ tree[3] = 5 + 3 = 8
   â””â”€â”€ tree[1] = 3 + 8 = 11

Final tree: [_, 11, 3, 8, 2, 1, 5, 3]
             0   1  2  3  4  5  6  7
```

### Iterative Build (Bottom-Up)

```python
def build_iterative(self, arr):
    """
    Bottom-up build - often faster in practice.
    
    For array of size n, leaves start at index n.
    """
    n = len(arr)
    self.tree = [0] * (2 * n)
    
    # Fill leaves
    for i in range(n):
        self.tree[n + i] = arr[i]
    
    # Build parents from bottom up
    for i in range(n - 1, 0, -1):
        self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]
```

---

## ğŸ” Query Operation

### Three Cases

When querying range [L, R] at node covering [start, end]:

```
Case 1: NO OVERLAP
   Query: [L, R]    Node: [start, end]
   
   [L----R]                    [start----end]
   
   Return identity (0 for sum, âˆ for min)


Case 2: COMPLETE OVERLAP
   Query: [L--------------------R]
   Node:        [start--end]
   
   Return tree[node] directly


Case 3: PARTIAL OVERLAP
   Query:    [L--------R]
   Node:  [start--------end]
   
   Recurse to both children, merge results
```

### Query Implementation

```python
def query(self, node, start, end, L, R):
    """
    Query sum of arr[L:R+1].
    
    Time: O(log n) - at most 2 nodes per level visited
    """
    # Case 1: No overlap
    if R < start or end < L:
        return 0  # Identity for sum
    
    # Case 2: Complete overlap
    if L <= start and end <= R:
        return self.tree[node]
    
    # Case 3: Partial overlap
    mid = (start + end) // 2
    left_sum = self.query(2 * node, start, mid, L, R)
    right_sum = self.query(2 * node + 1, mid + 1, end, L, R)
    return left_sum + right_sum
```

### Query Visualization

```
Array: [2, 1, 5, 3, 4, 6]
Query: sum(1, 4)

Tree:
               [0-5]: 21
              /        \
       [0-2]: 8         [3-5]: 13
       /     \           /      \
   [0-1]: 3  [2]: 5  [3-4]: 7   [5]: 6
   /    \            /     \
 [0]: 2 [1]: 1    [3]: 3  [4]: 4

Query(1, 4):
â”œâ”€â”€ At [0-5]: partial â†’ query both
â”œâ”€â”€ At [0-2]: partial â†’ query both
â”‚   â”œâ”€â”€ At [0-1]: partial â†’ query both
â”‚   â”‚   â”œâ”€â”€ At [0]: R=4 â‰¥ start=0, L=1 > end=0 â†’ NO OVERLAP â†’ 0
â”‚   â”‚   â””â”€â”€ At [1]: L=1 â‰¤ start=1, end=1 â‰¤ R=4 â†’ COMPLETE â†’ 1
â”‚   â””â”€â”€ At [2]: COMPLETE â†’ 5
â”œâ”€â”€ At [3-5]: partial â†’ query both
â”‚   â”œâ”€â”€ At [3-4]: COMPLETE â†’ 7
â”‚   â””â”€â”€ At [5]: L=1, R=4, start=5 â†’ NO OVERLAP â†’ 0

Result: 0 + 1 + 5 + 7 + 0 = 13 âœ“
```

### Iterative Query

```python
def query_iterative(self, L, R):
    """
    Bottom-up query using iterative approach.
    """
    n = self.n
    L += n
    R += n
    result = 0
    
    while L <= R:
        if L % 2 == 1:  # L is right child
            result += self.tree[L]
            L += 1
        if R % 2 == 0:  # R is left child
            result += self.tree[R]
            R -= 1
        L //= 2
        R //= 2
    
    return result
```

---

## ğŸ”„ Update Operation

### Point Update

Update a single element and propagate changes up.

```python
def update(self, node, start, end, idx, val):
    """
    Update arr[idx] = val.
    
    Time: O(log n) - follows single path to leaf
    """
    if start == end:
        # Leaf node
        self.tree[node] = val
    else:
        mid = (start + end) // 2
        
        if idx <= mid:
            # Go left
            self.update(2 * node, start, mid, idx, val)
        else:
            # Go right
            self.update(2 * node + 1, mid + 1, end, idx, val)
        
        # Recalculate after child update
        self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]
```

### Update Visualization

```
Array: [2, 1, 5, 3]
Update: arr[1] = 7

Before:
       [0-3]: 11
       /        \
   [0-1]: 3    [2-3]: 8
   /    \       /    \
 [0]: 2 [1]: 1 [2]: 5 [3]: 3

Update path: root â†’ left child â†’ right grandchild

After:
       [0-3]: 17      â† recalc: 9 + 8 = 17
       /        \
   [0-1]: 9      [2-3]: 8   â† recalc: 2 + 7 = 9
   /    \        /    \
 [0]: 2 [1]: 7  [2]: 5 [3]: 3  â† updated!
```

### Iterative Update

```python
def update_iterative(self, idx, val):
    """
    Bottom-up update.
    """
    n = self.n
    idx += n
    self.tree[idx] = val
    
    # Update parents
    while idx > 1:
        idx //= 2
        self.tree[idx] = self.tree[2 * idx] + self.tree[2 * idx + 1]
```

---

## ğŸ’» Complete Implementation

```python
class SegmentTree:
    """
    Complete Segment Tree with all operations.
    Supports any associative merge function.
    """
    
    def __init__(self, arr, merge_fn=lambda a, b: a + b, identity=0):
        self.n = len(arr)
        self.merge = merge_fn
        self.identity = identity
        self.tree = [identity] * (4 * self.n)
        if self.n > 0:
            self._build(arr, 1, 0, self.n - 1)
    
    def _build(self, arr, node, start, end):
        if start == end:
            self.tree[node] = arr[start]
        else:
            mid = (start + end) // 2
            self._build(arr, 2 * node, start, mid)
            self._build(arr, 2 * node + 1, mid + 1, end)
            self.tree[node] = self.merge(
                self.tree[2 * node], 
                self.tree[2 * node + 1]
            )
    
    def update(self, idx, val):
        self._update(1, 0, self.n - 1, idx, val)
    
    def _update(self, node, start, end, idx, val):
        if start == end:
            self.tree[node] = val
        else:
            mid = (start + end) // 2
            if idx <= mid:
                self._update(2 * node, start, mid, idx, val)
            else:
                self._update(2 * node + 1, mid + 1, end, idx, val)
            self.tree[node] = self.merge(
                self.tree[2 * node], 
                self.tree[2 * node + 1]
            )
    
    def query(self, L, R):
        return self._query(1, 0, self.n - 1, L, R)
    
    def _query(self, node, start, end, L, R):
        if R < start or end < L:
            return self.identity
        if L <= start and end <= R:
            return self.tree[node]
        mid = (start + end) // 2
        return self.merge(
            self._query(2 * node, start, mid, L, R),
            self._query(2 * node + 1, mid + 1, end, L, R)
        )


# Example: Sum queries
arr = [1, 3, 5, 7, 9, 11]
sum_tree = SegmentTree(arr)
print(sum_tree.query(1, 4))  # 3+5+7+9 = 24

# Example: Min queries
min_tree = SegmentTree(arr, merge_fn=min, identity=float('inf'))
print(min_tree.query(1, 4))  # min(3,5,7,9) = 3

# Example: Max queries
max_tree = SegmentTree(arr, merge_fn=max, identity=float('-inf'))
print(max_tree.query(1, 4))  # max(3,5,7,9) = 9
```

---

## âš ï¸ Common Mistakes

### 1. Wrong Mid Calculation

```python
# âŒ Wrong: Integer overflow in some languages
mid = (start + end) / 2  # Python float division!

# âœ… Correct
mid = (start + end) // 2  # Integer division
# Or safer:
mid = start + (end - start) // 2  # Avoids overflow
```

### 2. Wrong Child Indices

```python
# âŒ Wrong: Using 0-indexed children
left = 2 * node      # If node = 0, left = 0 (same!)
right = 2 * node + 1

# âœ… Correct: Start tree at index 1
# Node 1 â†’ children 2, 3
# Node 2 â†’ children 4, 5
# etc.
```

### 3. Forgetting to Update Parent

```python
# âŒ Wrong: Missing recalculation
def update(self, node, start, end, idx, val):
    if start == end:
        self.tree[node] = val
    else:
        mid = (start + end) // 2
        if idx <= mid:
            self.update(2 * node, start, mid, idx, val)
        else:
            self.update(2 * node + 1, mid + 1, end, idx, val)
        # Missing: self.tree[node] = ...

# âœ… Correct: Always recalculate parent after child update
self.tree[node] = self.merge(self.tree[2 * node], self.tree[2 * node + 1])
```

---

## ğŸ“Š Operation Comparison

| Implementation | Build | Query | Update | Code Complexity |
|----------------|-------|-------|--------|-----------------|
| Recursive | O(n) | O(log n) | O(log n) | Medium |
| Iterative | O(n) | O(log n) | O(log n) | Lower (but trickier) |

---

## ğŸ¤ Interview Tips

**When explaining build:**
> "I build bottom-up, starting with leaves (array elements), then computing each parent as the merge of its children."

**When explaining query:**
> "I check three cases: no overlap (return identity), complete overlap (return stored value), partial overlap (recurse to both children and merge)."

**When explaining update:**
> "I traverse down to the leaf, update it, then on the way back up, recalculate each ancestor."

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Implement build | 10 min |
| Implement query | 10 min |
| Implement update | 10 min |
| Debug edge cases | 10 min |
| Total (from scratch) | 40 min |

---

> **ğŸ’¡ Key Insight:** The magic of segment trees is that any range can be decomposed into O(log n) pre-computed segments. Build precomputes all possible segments, query finds the right decomposition, update maintains the invariant.

> **ğŸ”— Related:** [Fundamentals](./3.1-Segment-Tree-Fundamentals.md) | [Lazy Propagation â†’](./3.3-Lazy-Propagation.md)

---

**Next:** [Lazy Propagation â†’](./3.3-Lazy-Propagation.md)
