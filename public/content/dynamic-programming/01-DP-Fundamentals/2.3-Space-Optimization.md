# 2.3 Space Optimization in DP

> **Space optimization** reduces memory usage by observing that most DP recurrences only depend on a limited number of previous states. Instead of storing the entire table, we keep only what's needed.

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>When to Optimize Space</strong></summary>

**Optimize when:**
- Current state only depends on **previous row/column**
- Current state only depends on **last few elements**
- Memory is a constraint (large inputs)
- Interview follow-up: "Can you reduce space?"

**Look for these dependencies:**
```
dp[i] depends on dp[i-1], dp[i-2]     â†’ O(1) space possible
dp[i][j] depends on dp[i-1][j], dp[i][j-1] â†’ O(n) space possible
dp[i][j] depends on dp[i-2][j], dp[i][j-2] â†’ O(2n) space possible
```

</details>

---

## âœ… When to Use

- Large input sizes (memory constraints)
- Interview follow-up optimization
- Dependencies are localized
- When asked "can you do better?"

## âŒ When NOT to Use

| Situation | Why | Keep Full Table |
|-----------|-----|-----------------|
| Need to reconstruct path | Can't backtrack without table | Yes |
| Complex dependencies | Hard to track with few variables | Yes |
| Debugging/learning | Full table easier to visualize | Yes |
| Small input sizes | Premature optimization | Optional |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Optimization Hierarchy</strong></summary>

```
Full Table O(nÃ—m)
     â†“ Optimize row dependency
Two Rows O(2Ã—m) = O(m)
     â†“ Optimize to single row
Single Row O(m)
     â†“ Optimize to variables
Few Variables O(1)
```

</details>

---

## ğŸ“ Optimization Techniques

### Technique 1: 1D â†’ O(1) (Rolling Variables)

**Pattern:** When `dp[i]` only depends on `dp[i-1]` and `dp[i-2]`

```python
# BEFORE: O(n) space
def fib_table(n):
    if n <= 1:
        return n
    dp = [0] * (n + 1)
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

# AFTER: O(1) space
def fib_optimized(n):
    if n <= 1:
        return n
    prev2, prev1 = 0, 1  # dp[i-2], dp[i-1]
    for i in range(2, n + 1):
        curr = prev1 + prev2
        prev2 = prev1
        prev1 = curr
    return prev1
```

**Visualization:**
```
Full table:
[0, 1, 1, 2, 3, 5, 8, 13, ...]
 â†‘  â†‘  â†‘
     Only need these two to compute next

Rolling variables:
Step 0: prev2=0, prev1=1
Step 1: curr=1, prev2=1, prev1=1
Step 2: curr=2, prev2=1, prev1=2
Step 3: curr=3, prev2=2, prev1=3
...
```

### Technique 2: 2D â†’ O(n) (Single Row)

**Pattern:** When `dp[i][j]` only depends on row `i-1` and current row `i`

```python
# BEFORE: O(mÃ—n) space
def unique_paths_2d(m, n):
    dp = [[0] * n for _ in range(m)]
    for i in range(m):
        dp[i][0] = 1
    for j in range(n):
        dp[0][j] = 1
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[m-1][n-1]

# AFTER: O(n) space
def unique_paths_1d(m, n):
    # Single row, updated in-place
    dp = [1] * n  # Initialize with first row
    
    for i in range(1, m):
        for j in range(1, n):
            # dp[j] is "dp[i-1][j]" (above) before update
            # dp[j-1] is "dp[i][j-1]" (left) already updated
            dp[j] = dp[j] + dp[j-1]
    
    return dp[n-1]
```

**Visualization:**
```
2D Table:                  1D Rolling:
[1, 1, 1, 1]              Start: [1, 1, 1, 1]
[1, 2, 3, 4]              After row 1: [1, 2, 3, 4]
[1, 3, 6, 10]             After row 2: [1, 3, 6, 10]

In 1D version:
- dp[j] starts as value from previous row (above)
- dp[j-1] already has current row's value (left)
- Update: dp[j] = dp[j] (old=above) + dp[j-1] (new=left)
```

### Technique 3: 2D â†’ O(n) with Careful Iteration

**Pattern:** LCS/Edit Distance - depends on `dp[i-1][j-1]`, `dp[i-1][j]`, `dp[i][j-1]`

```python
# BEFORE: O(mÃ—n) space
def lcs_2d(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

# AFTER: O(n) space
def lcs_1d(text1, text2):
    m, n = len(text1), len(text2)
    
    # Use two rows: previous and current
    prev = [0] * (n + 1)
    curr = [0] * (n + 1)
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                curr[j] = prev[j-1] + 1  # diagonal
            else:
                curr[j] = max(prev[j], curr[j-1])  # up, left
        
        # Swap rows
        prev, curr = curr, prev
    
    return prev[n]  # Note: prev because of final swap

# EVEN BETTER: O(n) with single array + one variable
def lcs_optimized(text1, text2):
    m, n = len(text1), len(text2)
    dp = [0] * (n + 1)
    
    for i in range(1, m + 1):
        prev_diagonal = 0  # dp[i-1][j-1]
        for j in range(1, n + 1):
            temp = dp[j]  # Save dp[i-1][j] before overwrite
            if text1[i-1] == text2[j-1]:
                dp[j] = prev_diagonal + 1
            else:
                dp[j] = max(dp[j], dp[j-1])
            prev_diagonal = temp  # For next iteration
    
    return dp[n]
```

**Why we need `prev_diagonal`:**
```
Before update at (i,j):
  dp[j-1] = dp[i][j-1]     (already updated = left)
  dp[j]   = dp[i-1][j]     (not yet updated = above)
  prev_diagonal = dp[i-1][j-1]  (saved before dp[j-1] was updated)

After update:
  dp[j] = new value for dp[i][j]
```

---

## ğŸ’» Complete Examples

### Python - All Optimization Levels

```python
from typing import List

# ==========================
# House Robber - 1D to O(1)
# ==========================
def rob_full(nums: List[int]) -> int:
    """O(n) space"""
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    n = len(nums)
    dp = [0] * n
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    
    for i in range(2, n):
        dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    
    return dp[n-1]


def rob_optimized(nums: List[int]) -> int:
    """O(1) space - only need two previous values"""
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    prev2 = nums[0]  # dp[i-2]
    prev1 = max(nums[0], nums[1])  # dp[i-1]
    
    for i in range(2, len(nums)):
        curr = max(prev1, prev2 + nums[i])
        prev2 = prev1
        prev1 = curr
    
    return prev1


# ==========================
# Minimum Path Sum - 2D to O(n)
# ==========================
def min_path_full(grid: List[List[int]]) -> int:
    """O(mÃ—n) space"""
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    
    dp[0][0] = grid[0][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] + grid[0][j]
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] + grid[i][0]
    
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
    
    return dp[m-1][n-1]


def min_path_optimized(grid: List[List[int]]) -> int:
    """O(n) space - single row"""
    m, n = len(grid), len(grid[0])
    dp = [0] * n
    
    # Initialize first row
    dp[0] = grid[0][0]
    for j in range(1, n):
        dp[j] = dp[j-1] + grid[0][j]
    
    # Process remaining rows
    for i in range(1, m):
        dp[0] += grid[i][0]  # First column: only from above
        for j in range(1, n):
            dp[j] = min(dp[j], dp[j-1]) + grid[i][j]
    
    return dp[n-1]


# ==========================
# 0/1 Knapsack - Reverse Iteration Trick
# ==========================
def knapsack_full(weights: List[int], values: List[int], capacity: int) -> int:
    """O(n Ã— capacity) space"""
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            dp[i][w] = dp[i-1][w]  # Don't take
            if weights[i-1] <= w:
                dp[i][w] = max(dp[i][w], 
                              dp[i-1][w-weights[i-1]] + values[i-1])
    
    return dp[n][capacity]


def knapsack_optimized(weights: List[int], values: List[int], capacity: int) -> int:
    """O(capacity) space - iterate backwards!"""
    dp = [0] * (capacity + 1)
    
    for i in range(len(weights)):
        # MUST iterate backwards to avoid using same item twice
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[capacity]
```

### JavaScript Equivalents

```javascript
// House Robber - O(1) space
function rob(nums) {
    if (nums.length === 0) return 0;
    if (nums.length === 1) return nums[0];
    
    let prev2 = nums[0];
    let prev1 = Math.max(nums[0], nums[1]);
    
    for (let i = 2; i < nums.length; i++) {
        const curr = Math.max(prev1, prev2 + nums[i]);
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}

// Unique Paths - O(n) space
function uniquePaths(m, n) {
    const dp = new Array(n).fill(1);
    
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[j] += dp[j - 1];
        }
    }
    
    return dp[n - 1];
}

// 0/1 Knapsack - O(capacity) space
function knapsack(weights, values, capacity) {
    const dp = new Array(capacity + 1).fill(0);
    
    for (let i = 0; i < weights.length; i++) {
        // Iterate backwards!
        for (let w = capacity; w >= weights[i]; w--) {
            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);
        }
    }
    
    return dp[capacity];
}
```

---

## âš¡ Complexity Comparison

| Problem | Before | After | Reduction |
|---------|--------|-------|-----------|
| Fibonacci | O(n) | O(1) | n â†’ 1 |
| Climbing Stairs | O(n) | O(1) | n â†’ 1 |
| Unique Paths | O(mÃ—n) | O(min(m,n)) | mÃ—n â†’ n |
| LCS | O(mÃ—n) | O(min(m,n)) | mÃ—n â†’ n |
| Edit Distance | O(mÃ—n) | O(min(m,n)) | mÃ—n â†’ n |
| 0/1 Knapsack | O(nÃ—W) | O(W) | nÃ—W â†’ W |

---

## ğŸ”„ Key Patterns

### Pattern 1: Forward Iteration for Unbounded

**When items can be reused (Unbounded Knapsack):**
```python
# Iterate FORWARD - allows reusing coins
for amount in range(1, target + 1):
    for coin in coins:
        if coin <= amount:
            dp[amount] = min(dp[amount], dp[amount - coin] + 1)
```

### Pattern 2: Backward Iteration for 0/1

**When each item used at most once (0/1 Knapsack):**
```python
# Iterate BACKWARD - prevents reusing same item
for item in items:
    for w in range(capacity, item.weight - 1, -1):
        dp[w] = max(dp[w], dp[w - item.weight] + item.value)
```

### Pattern 3: Two Rows for Diagonal Dependency

**When need diagonal + above + left:**
```python
prev = [0] * (n + 1)
curr = [0] * (n + 1)

for i in range(1, m + 1):
    for j in range(1, n + 1):
        # Use prev for row i-1, curr for row i
        curr[j] = compute(prev[j-1], prev[j], curr[j-1])
    prev, curr = curr, prev
```

---

## âš ï¸ Common Mistakes

### 1. Wrong Iteration Direction for 0/1

**âŒ Wrong (forward allows reuse):**
```python
for i in range(len(weights)):
    for w in range(weights[i], capacity + 1):  # Forward!
        dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
# Bug: same item used multiple times
```

**âœ… Correct (backward prevents reuse):**
```python
for i in range(len(weights)):
    for w in range(capacity, weights[i] - 1, -1):  # Backward!
        dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
```

### 2. Losing the Diagonal in LCS

**âŒ Wrong (overwrites before reading):**
```python
for i in range(1, m + 1):
    for j in range(1, n + 1):
        if text1[i-1] == text2[j-1]:
            dp[j] = dp[j-1] + 1  # dp[j-1] already updated = wrong diagonal!
```

**âœ… Correct (save diagonal first):**
```python
for i in range(1, m + 1):
    prev_diag = 0
    for j in range(1, n + 1):
        temp = dp[j]  # Save before overwrite
        if text1[i-1] == text2[j-1]:
            dp[j] = prev_diag + 1
        else:
            dp[j] = max(dp[j], dp[j-1])
        prev_diag = temp
```

### 3. Forgetting to Handle Base Cases

**âŒ Wrong:**
```python
dp = [0] * n
for j in range(1, n):
    dp[j] = dp[j] + dp[j-1]
# Bug: first row/column not properly initialized
```

---

## ğŸ“ Practice Problems

**1D â†’ O(1):**
- [ ] [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)
- [ ] [House Robber](https://leetcode.com/problems/house-robber/)
- [ ] [Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)

**2D â†’ O(n):**
- [ ] [Unique Paths](https://leetcode.com/problems/unique-paths/)
- [ ] [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)
- [ ] [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)

**0/1 Knapsack Optimization:**
- [ ] [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)
- [ ] [Target Sum](https://leetcode.com/problems/target-sum/)
- [ ] [Coin Change](https://leetcode.com/problems/coin-change/)

<details>
<summary><strong>ğŸ§  Spaced Repetition</strong></summary>

- **Day 1:** Optimize Fibonacci from O(n) to O(1)
- **Day 3:** Optimize Unique Paths from O(mÃ—n) to O(n)
- **Day 7:** Implement 0/1 Knapsack with backward iteration
- **Day 14:** Optimize LCS with single array + diagonal variable

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Present Optimizations</strong></summary>

**After writing full solution, offer optimization:**
> "I can optimize this from O(mÃ—n) space to O(n) space because each row only depends on the previous row. Would you like me to show that?"

**If asked "can you do better on space?":**
> "Looking at the recurrence, dp[i][j] only uses dp[i-1][j] and dp[i][j-1]. I can use a single row and update in-place."

**Warning about path reconstruction:**
> "Note that with this optimization, I can't reconstruct the actual path/sequence anymore, only the optimal value. If we need the path, we'd need the full table."

</details>

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Understand concept | 20-30 min |
| Optimize 1D â†’ O(1) | 10-15 min |
| Optimize 2D â†’ O(n) | 20-30 min |
| Master backward iteration | 2-3 problems |

---

> **ğŸ’¡ Key Insight:** Space optimization works because DP is fundamentally about remembering just enough. Look at your recurrence: if dp[i] only needs dp[i-1] and dp[i-2], you don't need the whole historyâ€”just the last 2 values.

> **ğŸ”— Related:** [Bottom-Up Tabulation](./2.2-Bottom-Up-Tabulation.md) | [0/1 Knapsack](../04-Knapsack-01/6.1-Knapsack-01-Pattern.md) | [Unbounded Knapsack](../05-Knapsack-Unbounded/6.3-Unbounded-Knapsack-Pattern.md)
