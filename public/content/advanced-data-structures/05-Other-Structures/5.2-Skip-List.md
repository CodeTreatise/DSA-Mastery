# Skip List

> **A probabilistic data structure providing O(log n) average search, insert, delete.**
>
> Simpler alternative to balanced BSTs with similar performance.

---

## ğŸ¯ Overview

A Skip List is a linked list with multiple levels of "express lanes" for faster traversal.

```
Level 3:  head â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ 50 â”€â”€â”€â”€â”€â†’ nil
Level 2:  head â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ 15 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ 50 â”€â”€â”€â”€â”€â†’ nil  
Level 1:  head â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ 15 â”€â”€â”€â”€â”€â”€â”€â†’ 30 â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ 50 â”€â”€â”€â”€â”€â†’ nil
Level 0:  head â†’ 5 â†’ 10 â†’ 15 â†’ 20 â†’ 25 â†’ 30 â†’ 40 â†’ 50 â†’ 60 â†’ nil
```

**Key Idea:** Each element randomly appears in multiple levels. Higher levels skip more elements.

---

## ğŸ“ How It Works

### Search

Start at highest level, move right until value is too large, drop down.

```
Search for 25:

Level 3:  head â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ 50 (too big!)
          â†“
Level 2:  head â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ 15 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ 50 (too big!)
                          â†“
Level 1:  head â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ 15 â”€â”€â”€â”€â”€â”€â”€â†’ 30 (too big!)
                                      â†“
Level 0:  ... 15 â†’ 20 â†’ 25 âœ“ Found!
```

### Insert

1. Search to find insert position at each level
2. Randomly decide how many levels to insert into
3. Insert at each level

### Level Generation

```python
def random_level(self, p=0.5, max_level=16):
    """Generate random level using coin flips."""
    level = 1
    while random.random() < p and level < max_level:
        level += 1
    return level
```

With p=0.5:
- Level 1: 100% of elements
- Level 2: 50% of elements  
- Level 3: 25% of elements
- etc.

---

## ğŸ’» Implementation

**Python:**
```python
import random

class SkipListNode:
    def __init__(self, val, level):
        self.val = val
        self.forward = [None] * (level + 1)


class SkipList:
    """
    Skip List with O(log n) average operations.
    
    - search: O(log n) average
    - insert: O(log n) average
    - delete: O(log n) average
    - Space: O(n) average
    """
    
    MAX_LEVEL = 16
    P = 0.5
    
    def __init__(self):
        self.head = SkipListNode(-float('inf'), self.MAX_LEVEL)
        self.level = 0
    
    def _random_level(self):
        lvl = 0
        while random.random() < self.P and lvl < self.MAX_LEVEL:
            lvl += 1
        return lvl
    
    def search(self, target: int) -> bool:
        """Search for target in skip list."""
        curr = self.head
        
        # Start from highest level, move right and down
        for i in range(self.level, -1, -1):
            while curr.forward[i] and curr.forward[i].val < target:
                curr = curr.forward[i]
        
        # Move to actual element
        curr = curr.forward[0]
        return curr is not None and curr.val == target
    
    def add(self, num: int) -> None:
        """Insert num into skip list."""
        update = [None] * (self.MAX_LEVEL + 1)
        curr = self.head
        
        # Find insert position at each level
        for i in range(self.level, -1, -1):
            while curr.forward[i] and curr.forward[i].val < num:
                curr = curr.forward[i]
            update[i] = curr
        
        # Generate random level for new node
        new_level = self._random_level()
        
        # If new level is higher, update head's forward pointers
        if new_level > self.level:
            for i in range(self.level + 1, new_level + 1):
                update[i] = self.head
            self.level = new_level
        
        # Create and insert new node
        new_node = SkipListNode(num, new_level)
        for i in range(new_level + 1):
            new_node.forward[i] = update[i].forward[i]
            update[i].forward[i] = new_node
    
    def erase(self, num: int) -> bool:
        """Remove num from skip list. Returns True if found."""
        update = [None] * (self.MAX_LEVEL + 1)
        curr = self.head
        
        for i in range(self.level, -1, -1):
            while curr.forward[i] and curr.forward[i].val < num:
                curr = curr.forward[i]
            update[i] = curr
        
        curr = curr.forward[0]
        
        if curr is None or curr.val != num:
            return False
        
        # Remove node from all levels
        for i in range(self.level + 1):
            if update[i].forward[i] != curr:
                break
            update[i].forward[i] = curr.forward[i]
        
        # Reduce level if needed
        while self.level > 0 and self.head.forward[self.level] is None:
            self.level -= 1
        
        return True


# Example
sl = SkipList()
sl.add(1)
sl.add(2)
sl.add(3)
print(sl.search(0))  # False
sl.add(4)
print(sl.search(1))  # True
print(sl.erase(0))   # False
print(sl.erase(1))   # True
print(sl.search(1))  # False
```

---

## âš¡ Complexity Analysis

| Operation | Average | Worst Case |
|-----------|---------|------------|
| Search | O(log n) | O(n) |
| Insert | O(log n) | O(n) |
| Delete | O(log n) | O(n) |
| Space | O(n) | O(n log n) |

**Why O(log n) on average?**
- Expected number of levels: O(log n)
- At each level, expected nodes to traverse: O(1)
- Total: O(log n)

---

## ğŸ“Š Skip List vs BST

| Aspect | Skip List | Balanced BST |
|--------|-----------|--------------|
| Implementation | Simpler | Complex (rotations) |
| Performance | O(log n) avg | O(log n) guaranteed |
| Concurrency | Easier to lock | Harder (rebalancing) |
| Cache locality | Good (arrays) | Poor (pointer chasing) |
| Deterministic | No | Yes |

**When to use Skip List:**
- Concurrent access needed (easier locking)
- Simpler implementation preferred
- Can tolerate probabilistic bounds

**When to use BST:**
- Need guaranteed worst-case bounds
- Deterministic behavior required

---

## âš ï¸ Interview Notes

Skip Lists are **less common** in interviews but may appear in:

1. **System Design:** Redis uses skip lists for sorted sets
2. **Design Questions:** "Design a data structure with O(log n) insert/search"
3. **Comparison Questions:** "Compare skip list to balanced BST"

**Key points to mention:**
- Probabilistic O(log n) vs deterministic
- Simpler than red-black trees
- Used in practice (Redis, LevelDB)

---

## ğŸ“ Practice

| Problem | Difficulty | Notes |
|---------|------------|-------|
| [Design Skiplist](https://leetcode.com/problems/design-skiplist/) | Hard | Implement from scratch |

---

> **ğŸ’¡ Key Insight:** Skip lists trade deterministic guarantees for implementation simplicity. The random levels create a naturally balanced structure without complex rebalancing logic.

> **ğŸ”— Related:** [Ordered Set â†’](./5.4-Ordered-Set.md) | [Monotonic Stack Review](./5.3-Monotonic-Review.md)
