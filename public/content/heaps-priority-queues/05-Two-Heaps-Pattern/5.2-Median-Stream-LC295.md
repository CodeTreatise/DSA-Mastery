# 5.2 Find Median from Data Stream (LC 295)

## Problem Statement

[LeetCode 295 - Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)

The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.

Implement the `MedianFinder` class:
- `MedianFinder()` initializes the MedianFinder object.
- `void addNum(int num)` adds the integer `num` to the data structure.
- `double findMedian()` returns the median of all elements so far.

```
Example:
MedianFinder mf = new MedianFinder();
mf.addNum(1);    // arr = [1]
mf.addNum(2);    // arr = [1, 2]
mf.findMedian(); // return 1.5 (median of [1, 2])
mf.addNum(3);    // arr = [1, 2, 3]
mf.findMedian(); // return 2.0 (median of [1, 2, 3])
```

**Constraints:**
- -10‚Åµ ‚â§ num ‚â§ 10‚Åµ
- At least one element before calling `findMedian`
- At most 5 * 10‚Å¥ calls to `addNum` and `findMedian`

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is the canonical Two Heaps problem:**
- Need median (middle element)
- Data arrives as a stream
- Need efficient repeated queries

**Why naive approaches fail:**
- Sorted array: O(n) insert, O(1) median
- Unsorted array: O(1) insert, O(n) median
- **Two heaps: O(log n) insert, O(1) median** ‚úì

**Key insight:**
```
Median divides data into two halves.
- Smaller half ‚Üí MAX-heap (get maximum easily)
- Larger half ‚Üí MIN-heap (get minimum easily)
- Median is at/between these two heap roots
```

</details>

---

## ‚úÖ When to Use

- Streaming data with median queries
- Need O(log n) insert and O(1) median
- Data is continuously arriving

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Static array, one query | Overhead not worth it | Sort or QuickSelect |
| Need other percentiles | More complex | Order statistics |
| Very small n | Simple is fine | Just sort |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Two Heaps Pattern Overview](./5.1-Two-Heaps-Overview.md)
- Heap basics and operations
- Max-heap via negation in Python

**After mastering this:**
- [Sliding Window Median (LC 480)](./5.3-Sliding-Window-Median-LC480.md)
- [IPO (LC 502)](https://leetcode.com/problems/ipo/)

**Related patterns:**
- Stream processing
- Running statistics

</details>

---

## üìê How It Works

### The Two Heaps Strategy

```
Data Stream: 5, 2, 8, 3, 6

Strategy:
- small = MAX-heap (stores smaller half, negated in Python)
- large = MIN-heap (stores larger half)
- Balance: len(small) ‚àà {len(large), len(large) + 1}
- Invariant: max(small) ‚â§ min(large)
```

### Step-by-Step Trace

```
Add 5:
  small: [-5]    large: []
  Sizes: 1, 0 ‚Üí balanced (small can be 1 larger)
  Median = 5

Add 2:
  2 ‚â§ 5, add to small
  small: [-5, -2]    large: []
  Sizes: 2, 0 ‚Üí UNBALANCED! Move 5 to large
  small: [-2]    large: [5]
  Sizes: 1, 1 ‚Üí balanced
  Median = (2 + 5) / 2 = 3.5

Add 8:
  8 > 2, add to large
  small: [-2]    large: [5, 8]
  Sizes: 1, 2 ‚Üí UNBALANCED! Move 5 to small
  small: [-5, -2]    large: [8]
  Sizes: 2, 1 ‚Üí balanced
  Median = 5

Add 3:
  3 ‚â§ 5, add to small
  small: [-5, -3, -2]    large: [8]
  Sizes: 3, 1 ‚Üí UNBALANCED! Move 5 to large
  small: [-3, -2]    large: [5, 8]
  Sizes: 2, 2 ‚Üí balanced
  Median = (3 + 5) / 2 = 4.0

Add 6:
  6 > 3, add to large
  small: [-3, -2]    large: [5, 6, 8]
  Sizes: 2, 3 ‚Üí UNBALANCED! Move 5 to small
  small: [-5, -3, -2]    large: [6, 8]
  Sizes: 3, 2 ‚Üí balanced
  Median = 5

Final state:
     MAX-heap (small)        MIN-heap (large)
         [5]                      [6]
        /   \                    /
       3     2                  8
       
Median = 5 (odd count, from larger heap)
```

---

## üíª Code Implementation

### Solution: Two Heaps with Clear Logic

**Python:**
```python
import heapq

class MedianFinder:
    """
    Two Heaps for O(log n) insert, O(1) median.
    
    small: max-heap (negated) for smaller half
    large: min-heap for larger half
    
    Invariants:
    1. len(small) - len(large) ‚àà {0, 1}
    2. max(small) ‚â§ min(large)
    """
    
    def __init__(self):
        self.small = []  # Max-heap (store negated values)
        self.large = []  # Min-heap
    
    def addNum(self, num: int) -> None:
        """
        Add number to appropriate heap, then rebalance.
        Time: O(log n)
        """
        # Decide which heap based on comparison with current max of small
        if not self.small or num <= -self.small[0]:
            heapq.heappush(self.small, -num)
        else:
            heapq.heappush(self.large, num)
        
        # Rebalance: small can have at most 1 more than large
        if len(self.small) > len(self.large) + 1:
            # Move max of small to large
            val = -heapq.heappop(self.small)
            heapq.heappush(self.large, val)
        elif len(self.large) > len(self.small):
            # Move min of large to small
            val = heapq.heappop(self.large)
            heapq.heappush(self.small, -val)
    
    def findMedian(self) -> float:
        """
        Return median based on heap sizes.
        Time: O(1)
        """
        if len(self.small) > len(self.large):
            # Odd count: median is max of small
            return -self.small[0]
        else:
            # Even count: average of two middle elements
            return (-self.small[0] + self.large[0]) / 2


# Example usage:
# mf = MedianFinder()
# mf.addNum(1)
# mf.addNum(2)
# print(mf.findMedian())  # 1.5
# mf.addNum(3)
# print(mf.findMedian())  # 2.0
```

**JavaScript:**
```javascript
class MedianFinder {
    constructor() {
        this.small = new MaxHeap();  // Smaller half
        this.large = new MinHeap();  // Larger half
    }
    
    addNum(num) {
        // Add to appropriate heap
        if (this.small.size() === 0 || num <= this.small.peek()) {
            this.small.push(num);
        } else {
            this.large.push(num);
        }
        
        // Rebalance
        if (this.small.size() > this.large.size() + 1) {
            this.large.push(this.small.pop());
        } else if (this.large.size() > this.small.size()) {
            this.small.push(this.large.pop());
        }
    }
    
    findMedian() {
        if (this.small.size() > this.large.size()) {
            return this.small.peek();
        }
        return (this.small.peek() + this.large.peek()) / 2;
    }
}

// MinHeap implementation
class MinHeap {
    constructor() { this.heap = []; }
    
    size() { return this.heap.length; }
    peek() { return this.heap[0]; }
    
    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return min;
    }
    
    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.heap[parent] <= this.heap[i]) break;
            [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
            i = parent;
        }
    }
    
    _bubbleDown(i) {
        while (true) {
            let smallest = i;
            const left = 2 * i + 1, right = 2 * i + 2;
            if (left < this.heap.length && this.heap[left] < this.heap[smallest]) {
                smallest = left;
            }
            if (right < this.heap.length && this.heap[right] < this.heap[smallest]) {
                smallest = right;
            }
            if (smallest === i) break;
            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
            i = smallest;
        }
    }
}

// MaxHeap implementation
class MaxHeap {
    constructor() { this.heap = []; }
    
    size() { return this.heap.length; }
    peek() { return this.heap[0]; }
    
    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        const max = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return max;
    }
    
    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.heap[parent] >= this.heap[i]) break;
            [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
            i = parent;
        }
    }
    
    _bubbleDown(i) {
        while (true) {
            let largest = i;
            const left = 2 * i + 1, right = 2 * i + 2;
            if (left < this.heap.length && this.heap[left] > this.heap[largest]) {
                largest = left;
            }
            if (right < this.heap.length && this.heap[right] > this.heap[largest]) {
                largest = right;
            }
            if (largest === i) break;
            [this.heap[i], this.heap[largest]] = [this.heap[largest], this.heap[i]];
            i = largest;
        }
    }
}
```

### Cleaner Alternative: Always Push to Small First

```python
class MedianFinder:
    """
    Alternative: Always add to small first, then ensure invariants.
    """
    
    def __init__(self):
        self.small = []  # Max-heap (negated)
        self.large = []  # Min-heap
    
    def addNum(self, num: int) -> None:
        # Always push to small first
        heapq.heappush(self.small, -num)
        
        # Ensure max(small) ‚â§ min(large)
        if self.large and -self.small[0] > self.large[0]:
            # Move max of small to large
            heapq.heappush(self.large, -heapq.heappop(self.small))
        
        # Balance sizes
        if len(self.small) > len(self.large) + 1:
            heapq.heappush(self.large, -heapq.heappop(self.small))
        elif len(self.large) > len(self.small):
            heapq.heappush(self.small, -heapq.heappop(self.large))
    
    def findMedian(self) -> float:
        if len(self.small) > len(self.large):
            return -self.small[0]
        return (-self.small[0] + self.large[0]) / 2
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| addNum |" O(log n) "| O(1) |" Push + maybe pop = O(log n) "|
| findMedian |" O(1) "| O(1) | Just peek at roots |
| Total Space | - |" O(n) "| Store all n elements |

**Why O(log n) for addNum:**
- heappush: O(log n)
- heappop: O(log n)
- At most 3 heap operations per add
- 3 * O(log n) = O(log n)

**Comparison with alternatives:**

| Approach | addNum | findMedian | Space |
|----------|--------|------------|-------|
| Sorted array |" O(n) "| O(1) |" O(n) "|
| Unsorted + sort |" O(1) "| O(n log n) |" O(n) "|
| **Two heaps** |" **O(log n)** "| **O(1)** |" O(n) "|

---

## üîÑ Variations

| Variation | Key Change | Problem |
|-----------|------------|---------|
| **Sliding window** | Remove elements lazily | [LC 480](https://leetcode.com/problems/sliding-window-median/) |
| **Weighted median** | Track weights, not counts | Custom |
| **Kth element** | Adjust balance to k | Custom |
| **Integer only** | Can use bucket count | Optimization |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting Negation for Max-Heap

```python
# ‚ùå Wrong: Python heapq is min-heap by default
heapq.heappush(self.small, num)  # This makes it min-heap!

# ‚úÖ Correct: Negate for max-heap behavior
heapq.heappush(self.small, -num)
# Don't forget to negate when reading too!
max_of_small = -self.small[0]
```

### 2. Wrong Size Balance

```python
# ‚ùå Wrong: Allowing large to be bigger than small
# This breaks the convention for odd counts

# ‚úÖ Correct convention:
# len(small) ‚àà {len(large), len(large) + 1}
# For odd count, small has the extra element
```

### 3. Accessing Empty Heap

```python
# ‚ùå Wrong: Not checking for empty
def addNum(self, num):
    if num <= -self.small[0]:  # IndexError if small is empty!
        
# ‚úÖ Correct: Check empty first
def addNum(self, num):
    if not self.small or num <= -self.small[0]:
```

### 4. Integer Division

```python
# ‚ùå Wrong in Python 2 or some languages
median = (a + b) / 2  # Integer division!

# ‚úÖ Correct: Ensure float division
median = (a + b) / 2.0  # Or just use Python 3
```

### 5. Not Handling Both Odd and Even

```python
# ‚ùå Wrong: Only handling even case
def findMedian(self):
    return (-self.small[0] + self.large[0]) / 2  # Wrong for odd count!

# ‚úÖ Correct: Check sizes
def findMedian(self):
    if len(self.small) > len(self.large):
        return -self.small[0]  # Odd: return middle element
    return (-self.small[0] + self.large[0]) / 2  # Even: average
```

---

## üìù Practice Problems (Progressive)

### Easy (Heap warm-up)
- [ ] [Last Stone Weight (LC 1046)](https://leetcode.com/problems/last-stone-weight/) - Single heap

### Medium (Two Heaps)
- [ ] [Find Median from Data Stream (LC 295)](https://leetcode.com/problems/find-median-from-data-stream/) - **This problem**
- [ ] [IPO (LC 502)](https://leetcode.com/problems/ipo/) - Two heaps for profit/capital

### Hard (Advanced)
- [ ] [Sliding Window Median (LC 480)](https://leetcode.com/problems/sliding-window-median/) - With removal
- [ ] [Maximum Average Pass Ratio (LC 1792)](https://leetcode.com/problems/maximum-average-pass-ratio/) - Priority queue

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement from scratch, trace with [1, 2, 3]
- **Day 3:** Implement without looking, explain invariants
- **Day 7:** Implement "always push to small first" variant
- **Day 14:** Solve IPO problem
- **Day 30:** Attempt Sliding Window Median

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening (1 min):**
"For streaming median, I'll use Two Heaps. I'll keep the smaller half in a max-heap and the larger half in a min-heap. The median will always be at or between the roots."

**Drawing (helpful):**
```
"Let me draw this:
    MAX-heap (small)     MIN-heap (large)
         [5]                  [7]
        /   \                /
       3     4              9
       
If odd: median = top of small = 5
If even: median = (5 + 7) / 2 = 6"
```

**Invariants (explain clearly):**
"I maintain two invariants:
1. Sizes differ by at most 1 (small can be 1 larger)
2. max(small) ‚â§ min(large)"

**Complexity (must mention):**
"addNum is O(log n) because of heap operations. findMedian is O(1) since we just peek at roots. Space is O(n)."

**Follow-up handling:**
- *"What if elements can be removed?"* ‚Üí Lazy deletion with invalidation map
- *"What about sliding window?"* ‚Üí Track invalid elements, clean during rebalance
- *"Can we optimize for integers in a range?"* ‚Üí Bucket counting

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very frequently asked |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Common data stream question |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask follow-ups |
| Meta | ‚≠ê‚≠ê‚≠ê | Less common but possible |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand approach | 5-10 min | Draw the two heaps |
| Implement solution | 12-18 min | Watch for negation |
| Handle edge cases | 3-5 min | Empty, odd/even |
| Complexity analysis | 2-3 min |" Explain O(log n) "|
| Total interview time | 25-35 min | Hard problem |

---

## üí° Key Insight

> **Two heaps partition the data such that the median is always at or between the roots.** By using a max-heap for the smaller half and a min-heap for the larger half, we can access the median in O(1) after O(log n) insertions. The key is maintaining two invariants: balanced sizes and ordered partition.

---

## üîó Related

- **Pattern Overview:** [Two Heaps Pattern](./5.1-Two-Heaps-Overview.md)
- **Next Problem:** [Sliding Window Median (LC 480)](./5.3-Sliding-Window-Median-LC480.md)
- **Related:** [IPO (LC 502)](./5.4-IPO-LC502.md)
