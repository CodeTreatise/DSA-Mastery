# 5.2 Island Pattern (Grokking Pattern #16)

> **The "Island Pattern" - connected component traversal on grids**
>
> ğŸ¯ **Interview Impact:** Top 5 most asked grid pattern | **Covers:** ~30% of grid problems

---

## Overview

The **Island Pattern** is a specialized application of connected components on 2D grids. An "island" is a group of connected cells with the same property (usually land cells surrounded by water).

```
Grid:                Islands:
1 1 0 0 0           â”Œâ”€â”€â”€â”
1 1 0 0 0           â”‚ 1 â”‚   â† Island 1
0 0 1 0 0           â””â”€â”€â”€â”˜ â”Œâ”€â”
0 0 0 1 1                 â”‚2â”‚â† Island 2
                          â””â”€â”˜  â”Œâ”€â”€â”€â”
                              â”‚ 3 â”‚â† Island 3
                              â””â”€â”€â”€â”˜
Answer: 3 islands
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>How to Identify Island Problems</strong></summary>

**Look for these signals:**
1. 2D grid with two types of cells (land/water, 1/0, etc.)
2. "Connected" or "adjacent" cells form groups
3. Count, measure, or modify these groups

**Problem keywords:**
- "Number of islands"
- "Max area of island"
- "Surrounded regions"
- "Enclosed areas"
- "Connected components in grid"

**NOT an island problem:**
- Shortest path (use BFS with distance)
- Need to visit all cells with constraints (use DP)
- Order of traversal matters (use topological sort)

</details>

---

## âœ… When to Use

- Counting connected components in a grid
- Finding area/perimeter of regions
- Flood fill operations
- Boundary detection problems
- Any "group of connected cells" problem

## âŒ When NOT to Use

| Situation | Use Instead |
|-----------|-------------|
| Need shortest path | BFS with distance |
| Weighted grid | Dijkstra's |
| Need all paths | DFS + Backtracking |
| Dynamic changes | Union-Find |

---

## ğŸ“ How It Works

### The Core Algorithm

```
For each cell in grid:
    If cell is land AND not visited:
        1. Increment island count
        2. DFS/BFS to mark ALL connected land cells as visited
        3. (Optional: calculate area, perimeter, etc.)

Visualization (DFS marking):
Step 0:          Step 1:          Step 2:          Step 3:
1 1 0 0 0       . . 0 0 0        . . 0 0 0        . . 0 0 0
1 1 0 0 0   â†’   . . 0 0 0    â†’   . . 0 0 0    â†’   . . 0 0 0
0 0 1 0 0       0 0 1 0 0        0 0 . 0 0        0 0 . 0 0
0 0 0 1 1       0 0 0 1 1        0 0 0 1 1        0 0 0 . .
Count: 0        Count: 1         Count: 2         Count: 3
```

---

## ğŸ’» Code Implementation

### Core Island Template

**Python:**
```python
from typing import List

class IslandSolution:
    """Template for Island Pattern problems."""
    
    def __init__(self, grid: List[List[str]]):
        self.grid = grid
        self.rows = len(grid)
        self.cols = len(grid[0]) if grid else 0
        self.directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    def count_islands(self) -> int:
        """Count number of islands."""
        count = 0
        
        for r in range(self.rows):
            for c in range(self.cols):
                if self.grid[r][c] == '1':
                    count += 1
                    self._dfs(r, c)
        
        return count
    
    def _dfs(self, r: int, c: int) -> None:
        """Mark all connected land cells."""
        # Base cases
        if r < 0 or r >= self.rows or c < 0 or c >= self.cols:
            return
        if self.grid[r][c] != '1':
            return
        
        # Mark visited
        self.grid[r][c] = '0'
        
        # Explore all directions
        for dr, dc in self.directions:
            self._dfs(r + dr, c + dc)
    
    def max_area_island(self) -> int:
        """Find maximum island area."""
        max_area = 0
        
        for r in range(self.rows):
            for c in range(self.cols):
                if self.grid[r][c] == '1':
                    area = self._dfs_with_area(r, c)
                    max_area = max(max_area, area)
        
        return max_area
    
    def _dfs_with_area(self, r: int, c: int) -> int:
        """DFS that returns area of island."""
        if r < 0 or r >= self.rows or c < 0 or c >= self.cols:
            return 0
        if self.grid[r][c] != '1':
            return 0
        
        self.grid[r][c] = '0'
        
        area = 1  # Count current cell
        for dr, dc in self.directions:
            area += self._dfs_with_area(r + dr, c + dc)
        
        return area
    
    def island_perimeter(self) -> int:
        """Calculate perimeter of island (assuming single island)."""
        perimeter = 0
        
        for r in range(self.rows):
            for c in range(self.cols):
                if self.grid[r][c] == '1':
                    # Each land cell contributes 4
                    # Subtract 2 for each adjacent land (shared edge)
                    perimeter += 4
                    
                    # Check top neighbor
                    if r > 0 and self.grid[r-1][c] == '1':
                        perimeter -= 2
                    # Check left neighbor
                    if c > 0 and self.grid[r][c-1] == '1':
                        perimeter -= 2
        
        return perimeter


# Standalone functions for common problems

def numIslands(grid: List[List[str]]) -> int:
    """LC 200: Count number of islands."""
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    count = 0
    
    def dfs(r, c):
        if r < 0 or r >= rows or c < 0 or c >= cols:
            return
        if grid[r][c] != '1':
            return
        grid[r][c] = '0'
        dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                count += 1
                dfs(r, c)
    
    return count


def maxAreaOfIsland(grid: List[List[int]]) -> int:
    """LC 695: Find maximum area island."""
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    
    def dfs(r, c):
        if r < 0 or r >= rows or c < 0 or c >= cols:
            return 0
        if grid[r][c] != 1:
            return 0
        grid[r][c] = 0
        return 1 + dfs(r+1,c) + dfs(r-1,c) + dfs(r,c+1) + dfs(r,c-1)
    
    return max(dfs(r, c) for r in range(rows) for c in range(cols))
```

**JavaScript:**
```javascript
class IslandSolution {
    constructor(grid) {
        this.grid = grid;
        this.rows = grid.length;
        this.cols = grid[0]?.length || 0;
        this.directions = [[0,1], [0,-1], [1,0], [-1,0]];
    }
    
    countIslands() {
        let count = 0;
        
        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                if (this.grid[r][c] === '1') {
                    count++;
                    this.dfs(r, c);
                }
            }
        }
        
        return count;
    }
    
    dfs(r, c) {
        if (r < 0 || r >= this.rows || c < 0 || c >= this.cols) return;
        if (this.grid[r][c] !== '1') return;
        
        this.grid[r][c] = '0';
        
        for (const [dr, dc] of this.directions) {
            this.dfs(r + dr, c + dc);
        }
    }
    
    maxAreaIsland() {
        let maxArea = 0;
        
        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                if (this.grid[r][c] === 1) {
                    const area = this.dfsWithArea(r, c);
                    maxArea = Math.max(maxArea, area);
                }
            }
        }
        
        return maxArea;
    }
    
    dfsWithArea(r, c) {
        if (r < 0 || r >= this.rows || c < 0 || c >= this.cols) return 0;
        if (this.grid[r][c] !== 1) return 0;
        
        this.grid[r][c] = 0;
        
        let area = 1;
        for (const [dr, dc] of this.directions) {
            area += this.dfsWithArea(r + dr, c + dc);
        }
        
        return area;
    }
}

// Standalone functions
function numIslands(grid) {
    if (!grid || !grid[0]) return 0;
    
    const rows = grid.length, cols = grid[0].length;
    let count = 0;
    
    function dfs(r, c) {
        if (r < 0 || r >= rows || c < 0 || c >= cols) return;
        if (grid[r][c] !== '1') return;
        grid[r][c] = '0';
        dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1);
    }
    
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (grid[r][c] === '1') {
                count++;
                dfs(r, c);
            }
        }
    }
    
    return count;
}
```

---

## ğŸ”„ Variations

| Variation | Key Difference | Problem |
|-----------|----------------|---------|
| **Count Islands** | Just count DFS starts | LC 200 |
| **Max Area** | Return area during DFS | LC 695 |
| **Perimeter** | Count water-adjacent edges | LC 463 |
| **Distinct Islands** | Track shape/pattern | LC 694 |
| **Surrounded Regions** | Boundary-connected regions | LC 130 |
| **Shortest Bridge** | BFS between two islands | LC 934 |
| **Making Island Large** | Flip one 0 to 1 | LC 827 |

---

## âš ï¸ Common Mistakes

### 1. Not Handling Empty Grid

```python
# âŒ Wrong: Will crash on empty grid
def numIslands(grid):
    rows, cols = len(grid), len(grid[0])  # IndexError!

# âœ… Correct: Check first
def numIslands(grid):
    if not grid or not grid[0]:
        return 0
    rows, cols = len(grid), len(grid[0])
```

### 2. Using Wrong Type Comparison

```python
# âŒ Wrong: Grid has strings, comparing with int
if grid[r][c] == 1:  # Never true if grid has '1' strings

# âœ… Correct: Match the actual type
if grid[r][c] == '1':  # For string grid
if grid[r][c] == 1:    # For integer grid
```

### 3. Modifying Then Checking

```python
# âŒ Wrong: May modify water cells
def dfs(r, c):
    grid[r][c] = '0'  # What if it was already '0'?
    if grid[r][c] != '1':  # Too late!
        return

# âœ… Correct: Check first, then modify
def dfs(r, c):
    if grid[r][c] != '1':
        return
    grid[r][c] = '0'
```

---

## âš¡ Complexity Analysis

| Metric | Value | Explanation |
|--------|-------|-------------|
| **Time** | O(m Ã— n) | Each cell visited once |
| **Space** | O(m Ã— n) | Recursion stack (worst case) |

### Space Optimization

For very large grids, use iterative BFS:

```python
from collections import deque

def numIslands_bfs(grid):
    """BFS version - smaller stack footprint."""
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    count = 0
    
    def bfs(r, c):
        queue = deque([(r, c)])
        grid[r][c] = '0'
        
        while queue:
            cr, cc = queue.popleft()
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = cr + dr, cc + dc
                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == '1':
                    grid[nr][nc] = '0'
                    queue.append((nr, nc))
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                count += 1
                bfs(r, c)
    
    return count
```

---

## ğŸ“ Practice Problems (Progressive)

### Easy (Learn the pattern)
- [ ] [Flood Fill](https://leetcode.com/problems/flood-fill/) - LC 733
- [ ] [Island Perimeter](https://leetcode.com/problems/island-perimeter/) - LC 463

### Medium (Apply variations)
- [ ] [Number of Islands](https://leetcode.com/problems/number-of-islands/) - LC 200
- [ ] [Max Area of Island](https://leetcode.com/problems/max-area-of-island/) - LC 695
- [ ] [Surrounded Regions](https://leetcode.com/problems/surrounded-regions/) - LC 130
- [ ] [Number of Enclaves](https://leetcode.com/problems/number-of-enclaves/) - LC 1020

### Hard (Master edge cases)
- [ ] [Shortest Bridge](https://leetcode.com/problems/shortest-bridge/) - LC 934
- [ ] [Making A Large Island](https://leetcode.com/problems/making-a-large-island/) - LC 827
- [ ] [Number of Distinct Islands](https://leetcode.com/problems/number-of-distinct-islands/) - LC 694

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve Number of Islands without looking
- **Day 3:** Solve Max Area of Island
- **Day 7:** Solve Surrounded Regions
- **Day 14:** Solve Shortest Bridge
- **Day 30:** Review all medium problems

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>Communication Tips</strong></summary>

**Opening statement:**
> "I see this is a connected components problem on a grid. I'll use DFS to find and mark each island."

**Key points to mention:**
1. Grid = graph with mÃ—n nodes
2. Marking visited prevents re-counting
3. O(mÃ—n) time and space complexity

**If asked about trade-offs:**
> "DFS is simpler to code with recursion. BFS would use less stack space but needs explicit queue management."

</details>

**Company Focus:**

| Company | Frequency | Focus |
|---------|-----------|-------|
| Amazon | â­â­â­â­â­ | Basic island counting |
| Meta | â­â­â­â­ | Variations (area, perimeter) |
| Google | â­â­â­â­ | Complex variations |
| Microsoft | â­â­â­ | Standard problems |

---

> **ğŸ’¡ Key Insight:** The Island Pattern is connected components applied to grids. Each DFS/BFS from an unvisited cell explores exactly one component. The number of starts = number of components.

---

**Next:** [Grid Practice Problems â†’](./5.3-Grid-Practice/01-Flood-Fill-LC733.md)
