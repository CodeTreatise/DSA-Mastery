# 1.2 When Greedy Works

> **Definition:** Greedy algorithms work when the problem exhibits the Greedy Choice Property and Optimal Substructure‚Äîmeaning local optimal choices lead to a global optimum.

---

## üéØ Pattern Recognition

<details>
<summary><strong>Signals That Greedy Will Work</strong></summary>

**Strong indicators:**
- Problem asks for "maximum number of non-overlapping..."
- Problem asks for "minimum number of X to cover Y"
- Sorting by one criterion makes choices obvious
- Each item is either fully taken or fully skipped (no dependencies)
- Previous choices don't affect future options (except reducing problem size)

**Mathematical signals:**
- Problem has "matroid" structure (exchange property)
- Greedy choice doesn't eliminate optimal solutions
- Subproblems are independent

**Problem types that typically work:**
- Interval scheduling (sort by end time)
- Fractional optimization (sort by ratio)
- Covering problems (sort by coverage)
- Assignment problems (match smallest to smallest)

</details>

---

## ‚úÖ The Two Required Properties

### Property 1: Greedy Choice Property

**Definition:** A globally optimal solution can be arrived at by making locally optimal (greedy) choices.

```
Making the best choice at each step doesn't prevent
us from reaching the overall best solution.
```

**Example - Activity Selection:**
```
Why picking earliest-ending activity is safe:

If activity A ends earliest, including A in our solution
is always safe because:
1. A doesn't block more activities than any other choice
2. After picking A, we still have the optimal subproblem

Proof sketch:
- Suppose optimal solution O doesn't include A
- Let B be the first activity in O
- Since A ends earliest, A.end ‚â§ B.end
- We can swap B with A, and solution is still valid
- Therefore, including A is always correct
```

### Property 2: Optimal Substructure

**Definition:** An optimal solution to the problem contains optimal solutions to its subproblems.

```
After making a greedy choice, the remaining problem
is a smaller instance that can be solved the same way.
```

**Example - Activity Selection:**
```
After picking activity A (ends at time 3):

Original problem: Select max activities from all
Remaining problem: Select max activities starting ‚â• 3

The remaining problem has THE SAME STRUCTURE as original!
We can apply the same greedy strategy recursively.
```

---

## ‚ùå When Greedy Fails

| Problem | Greedy Attempt | Why It Fails | Correct Approach |
|---------|----------------|--------------|------------------|
| 0/1 Knapsack | Take highest value/weight | Can't take fractions | DP |
| Coin Change | Take largest coin first | May use more coins | DP |
| Longest Path | Take longest edge | May lead to dead end | DFS/DP |
| Edit Distance | Minimize at each position | Future positions matter | DP |
| Subset Sum | Take largest fitting | May miss exact sum | DP/Backtracking |

### Counterexample: 0/1 Knapsack

```
Items: [(weight=10, value=60), (weight=20, value=100), (weight=30, value=120)]
Capacity: 50

Greedy by value/weight ratio:
- Item 1: 60/10 = 6.0 (best ratio) ‚Üí Take it, capacity = 40
- Item 2: 100/20 = 5.0 ‚Üí Take it, capacity = 20
- Item 3: 120/30 = 4.0 ‚Üí Can't fit
Total: 60 + 100 = 160 ‚ùå

Optimal (DP):
- Take items 2 and 3: 100 + 120 = 220 ‚úÖ

Greedy fails because we can't take fractions!
```

### Counterexample: Coin Change

```
Coins: [1, 3, 4], Target: 6

Greedy (largest first):
- 4 (remaining: 2)
- 1 (remaining: 1)
- 1 (remaining: 0)
Total: 3 coins ‚ùå

Optimal:
- 3 + 3 = 6
Total: 2 coins ‚úÖ

Greedy fails when coin denominations aren't "canonical"
(like [1, 5, 10, 25] which DO work with greedy)
```

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Connections</strong></summary>

**Before this, you should know:**
- [What Is Greedy](./1.1-What-Is-Greedy.md) - Basic concept
- [Sorting](../../03-Sorting-Searching.md) - Most greedy needs sorting

**After mastering this:**
- [Greedy vs DP](./1.3-Greedy-vs-DP.md) - Decision framework
- [Proof Techniques](./2.1-Greedy-Stays-Ahead.md) - Prove correctness

**Related:**
- Interval problems always have greedy choice property
- Matroid theory formalizes when greedy works

</details>

---

## üìê How to Verify Greedy Works

### Method 1: Find a Counterexample

```python
def test_greedy_works(greedy_solution, brute_force_solution, test_cases):
    """
    Compare greedy vs optimal to find counterexamples.
    """
    for test in test_cases:
        greedy_result = greedy_solution(test)
        optimal_result = brute_force_solution(test)
        
        if greedy_result != optimal_result:
            print(f"Counterexample found: {test}")
            print(f"Greedy: {greedy_result}, Optimal: {optimal_result}")
            return False
    
    print("No counterexample found (greedy might work!)")
    return True
```

### Method 2: Prove Greedy Stays Ahead

```
For each step i:
  Prove: greedy_solution[0..i] ‚â• any_solution[0..i]

If greedy stays ahead at every step,
it's optimal at the end.
```

### Method 3: Exchange Argument

```
1. Assume optimal solution O differs from greedy solution G
2. Find first difference between O and G
3. Show we can "exchange" O's choice with G's choice
4. Prove the exchanged solution is still optimal
5. Repeat until O = G
```

---

## üíª Code Implementation

**Python - Testing Greedy Correctness:**
```python
from itertools import combinations

def activity_selection_greedy(activities):
    """Greedy: sort by end time, pick non-overlapping."""
    sorted_acts = sorted(activities, key=lambda x: x[1])
    result = []
    last_end = 0
    
    for start, end in sorted_acts:
        if start >= last_end:
            result.append((start, end))
            last_end = end
    
    return len(result)


def activity_selection_brute_force(activities):
    """Brute force: try all subsets."""
    def is_valid(subset):
        sorted_sub = sorted(subset, key=lambda x: x[0])
        for i in range(1, len(sorted_sub)):
            if sorted_sub[i][0] < sorted_sub[i-1][1]:
                return False
        return True
    
    max_count = 0
    for r in range(len(activities) + 1):
        for subset in combinations(activities, r):
            if is_valid(subset):
                max_count = max(max_count, len(subset))
    
    return max_count


# Verify greedy works for activity selection
test_cases = [
    [(1,3), (2,5), (4,6), (6,8)],
    [(0,2), (1,3), (2,4), (3,5)],
    [(1,2), (2,3), (3,4)],  # All consecutive
    [(1,10), (2,3), (4,5)],  # One spans all
]

for test in test_cases:
    greedy = activity_selection_greedy(test)
    optimal = activity_selection_brute_force(test)
    status = "‚úÖ" if greedy == optimal else "‚ùå"
    print(f"{status} Test {test}: Greedy={greedy}, Optimal={optimal}")
```

**JavaScript:**
```javascript
function activitySelectionGreedy(activities) {
    const sorted = [...activities].sort((a, b) => a[1] - b[1]);
    let count = 0;
    let lastEnd = 0;
    
    for (const [start, end] of sorted) {
        if (start >= lastEnd) {
            count++;
            lastEnd = end;
        }
    }
    return count;
}

function activitySelectionBruteForce(activities) {
    const n = activities.length;
    let maxCount = 0;
    
    // Try all 2^n subsets
    for (let mask = 0; mask < (1 << n); mask++) {
        const subset = [];
        for (let i = 0; i < n; i++) {
            if (mask & (1 << i)) subset.push(activities[i]);
        }
        
        // Check if valid (non-overlapping)
        subset.sort((a, b) => a[0] - b[0]);
        let valid = true;
        for (let i = 1; i < subset.length; i++) {
            if (subset[i][0] < subset[i-1][1]) {
                valid = false;
                break;
            }
        }
        
        if (valid) maxCount = Math.max(maxCount, subset.length);
    }
    return maxCount;
}

// Verify
const tests = [
    [[1,3], [2,5], [4,6], [6,8]],
    [[0,2], [1,3], [2,4], [3,5]],
];

tests.forEach(test => {
    const greedy = activitySelectionGreedy(test);
    const optimal = activitySelectionBruteForce(test);
    console.log(`Greedy=${greedy}, Optimal=${optimal}, Match=${greedy === optimal}`);
});
```

---

## ‚ö° Complexity Analysis

| Verification Method | Time | Use When |
|---------------------|------|----------|
| Counterexample search | O(2^n) per test | Small inputs, quick check |
| Greedy stays ahead proof | O(1) | Mathematical proof |
| Exchange argument | O(1) | Mathematical proof |

**For the algorithm itself:**
- Greedy typically runs in O(n log n) due to sorting
- Much faster than DP alternatives when applicable

---

## üîÑ Problems Where Greedy Works

| Problem | Greedy Strategy | Why It Works |
|---------|-----------------|--------------|
| Activity Selection | Sort by end time | Earliest end leaves most room |
| Fractional Knapsack | Sort by value/weight | Taking fraction of best is optimal |
| Huffman Coding | Combine lowest frequencies | Minimizes weighted path length |
| Job Sequencing | Sort by profit, schedule latest slot | Maximizes profit per deadline |
| Minimum Platforms | Sort arrivals & departures | Tracks concurrent needs |
| Assign Cookies | Sort both, match smallest | Uses minimum resource per child |

---

## ‚ö†Ô∏è Common Mistakes

1. **Not verifying with small examples**
   - ‚ùå Assuming greedy works without testing
   - ‚úÖ Try 3-5 small examples before coding

2. **Wrong greedy criterion**
   - ‚ùå Activity selection: sort by duration
   - ‚úÖ Activity selection: sort by END time

3. **Confusing "looks greedy" with "is greedy"**
   - ‚ùå "Taking the best-looking option must be optimal"
   - ‚úÖ Prove with exchange argument or counterexample search

4. **Not considering all edge cases**
   - ‚ùå Only testing "nice" inputs
   - ‚úÖ Test with overlapping, edge-touching, same-value items

---

## üìù Practice Problems

### Where Greedy Works
- [ ] [Merge Intervals](https://leetcode.com/problems/merge-intervals/) - Sort by start, merge
- [ ] [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/) - Sort by end
- [ ] [Minimum Number of Arrows](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/) - Sort by end

### Where Greedy Fails (Use DP)
- [ ] [Coin Change](https://leetcode.com/problems/coin-change/) - Arbitrary denominations
- [ ] [0/1 Knapsack](https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/) - Can't take fractions
- [ ] [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) - Non-contiguous

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Prove activity selection works
- **Day 3:** Find counterexample for coin change with [1,3,4]
- **Day 7:** Categorize 5 problems as greedy or DP
- **Day 14:** Explain both properties to someone
- **Day 30:** Solve a new problem, justify approach

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Communicating Greedy Justification</strong></summary>

**When interviewer asks "Why does greedy work here?":**

```
Option 1 - Intuitive argument:
"Choosing the earliest-ending activity is safe because it 
leaves the maximum time for remaining activities. We're 
never blocking a better solution."

Option 2 - Exchange argument:
"If there's an optimal solution that doesn't include our 
greedy choice, we can swap in our choice without reducing 
the count, so greedy is also optimal."

Option 3 - Empirical:
"Let me trace through an example to verify... [trace 2-3 cases]
It seems correct, and I can't find a counterexample."
```

**If unsure whether greedy works:**
```
"I'm not 100% sure greedy is optimal here. Let me think 
of a counterexample... [try small cases]

If I can't find one, I'll proceed with greedy. If it 
fails, we can fall back to DP."
```

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand properties | 20 min | Theory |
| Verify with examples | 15 min | Practice |
| Prove correctness | 30 min | For one problem |
| Master decision | 2-3 hours | Multiple problems |

---

> **üí° Key Insight:** Greedy works when making the locally best choice doesn't eliminate the globally best solution. When in doubt, try to construct a counterexample‚Äîif you can't find one after several attempts, greedy is probably correct.

> **üîó Related:** [What Is Greedy](./1.1-What-Is-Greedy.md) | [Greedy vs DP](./1.3-Greedy-vs-DP.md) | [Greedy Stays Ahead Proof](./2.1-Greedy-Stays-Ahead.md)
