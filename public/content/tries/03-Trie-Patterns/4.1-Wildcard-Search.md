# Wildcard Search Pattern

> **Wildcard search allows matching patterns with special characters like '.' that can match any single character - this requires DFS/backtracking on the Trie.**

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Wildcard Problems</strong></summary>

**Look for these signals:**
- Pattern matching with "." or "*" wildcards
- "Match any single character"
- "Design a search that supports wildcards"
- Flexible pattern matching

**Classic problem:**
- LC 211: Design Add and Search Words Data Structure
- Pattern: `addWord("bad")`, `search("b.d")` ‚Üí True

</details>

---

## ‚úÖ When to Use

| Scenario | Why Wildcard Search |
|----------|---------------------|
| **Pattern matching** | "b.d" matches "bad", "bed", "bid" |
| **Flexible search** | User doesn't know exact spelling |
| **Regex-like queries** | Simple pattern matching |
| **Game word validation** | Words with wildcards |

---

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|-------------------|
| **Full regex** | Use regex library |
| **Prefix-only matching** | Use startsWith |
| **Exact match** | Use basic search |
| **Very long patterns with many dots** | Consider optimizations |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Trie Class Design](../01-Trie-Fundamentals/2.2-Trie-Class-Design.md) - Basic trie
- [Search Operation](../02-Trie-Operations/3.2-Search-Operation.md) - Regular search
- [DFS/Backtracking](../../02-Recursion-Backtracking.md) - Required for wildcards

**After mastering this:**
- [Trie + Backtracking](./4.2-Trie-Plus-Backtracking.md) - Grid problems
- [Word Search II](../07-Practice-Problems/6.3-Word-Search-II.md) - Hard classic

**Combines with:**
- DFS for exploring all possibilities
- Backtracking for multiple paths

</details>

---

## üìê How It Works

### The Challenge

Regular search: `traverse character by character`
Wildcard search: `'.' can match ANY character` ‚Üí must try ALL children!

### Key Insight

```
Word: "b.d"

When we hit '.':
  - Can't just follow one path
  - Must try ALL children at current node
  - If ANY path leads to valid word ‚Üí return True
```

### Visualization

```
Trie contains: ["bad", "bed", "bid", "bag"]

         (root)
            ‚îÇ
            b
           /‚îÇ\
          a e i
         /‚îÇ  ‚îÇ  ‚îÇ
        d g  d  d
       (‚úì)(‚úì)(‚úì)(‚úì)

Search "b.d":
  'b' ‚Üí Found, move to 'b' node
  '.' ‚Üí Try ALL children: 'a', 'e', 'i'
        'a' + 'd' ‚Üí Found, is_end=True ‚úì
  Result: True (at least one path works)

Search "b.g":
  'b' ‚Üí Found
  '.' ‚Üí Try all children: 'a', 'e', 'i'
        'a' + 'g' ‚Üí Found, is_end=True ‚úì
  Result: True

Search "b..":
  'b' ‚Üí Found
  '.' ‚Üí Try all ('a', 'e', 'i')
        '.' on each ‚Üí Try all children
            Found words: "bad", "bed", "bid", "bag"
  Result: True
```

---

## üíª Code Implementation

### Recursive DFS Approach

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False


class WordDictionary:
    """
    LC 211: Design Add and Search Words Data Structure
    
    Supports wildcard '.' that matches any single character.
    """
    
    def __init__(self):
        self.root = TrieNode()
    
    def addWord(self, word: str) -> None:
        """Add word to dictionary. O(m) time."""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def search(self, word: str) -> bool:
        """
        Search for word with '.' wildcards.
        
        Time: O(m) for no wildcards, O(26^k √ó m) worst case
        where k = number of '.' and m = word length
        
        Space: O(m) for recursion stack
        """
        return self._search_from(self.root, word, 0)
    
    def _search_from(self, node: TrieNode, word: str, index: int) -> bool:
        """
        DFS helper for wildcard search.
        
        Args:
            node: Current trie node
            word: Search pattern
            index: Current position in word
        """
        # Base case: reached end of word
        if index == len(word):
            return node.is_end
        
        char = word[index]
        
        if char == '.':
            # Wildcard: try ALL children
            for child in node.children.values():
                if self._search_from(child, word, index + 1):
                    return True  # Found a match!
            return False  # None of the paths worked
        else:
            # Regular character: follow specific path
            if char not in node.children:
                return False
            return self._search_from(node.children[char], word, index + 1)


# Usage:
# wd = WordDictionary()
# wd.addWord("bad")
# wd.addWord("dad")
# wd.addWord("mad")
# wd.search("pad")  # False
# wd.search("bad")  # True
# wd.search(".ad")  # True (matches bad, dad, mad)
# wd.search("b..")  # True (matches bad)
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = new Map();
        this.isEnd = false;
    }
}

class WordDictionary {
    constructor() {
        this.root = new TrieNode();
    }
    
    addWord(word) {
        let node = this.root;
        for (const char of word) {
            if (!node.children.has(char)) {
                node.children.set(char, new TrieNode());
            }
            node = node.children.get(char);
        }
        node.isEnd = true;
    }
    
    search(word) {
        return this._searchFrom(this.root, word, 0);
    }
    
    _searchFrom(node, word, index) {
        // Base case
        if (index === word.length) {
            return node.isEnd;
        }
        
        const char = word[index];
        
        if (char === '.') {
            // Try all children
            for (const child of node.children.values()) {
                if (this._searchFrom(child, word, index + 1)) {
                    return true;
                }
            }
            return false;
        } else {
            // Follow specific path
            if (!node.children.has(char)) {
                return false;
            }
            return this._searchFrom(node.children.get(char), word, index + 1);
        }
    }
}
```

---

### Optimized with Length Bucketing

For better average performance, bucket words by length:

**Python:**
```python
class WordDictionary:
    """
    Optimized version: Separate tries by word length.
    
    Benefit: '..' only searches words of length 2, etc.
    """
    
    def __init__(self):
        self.tries = {}  # length -> Trie root
    
    def addWord(self, word: str) -> None:
        length = len(word)
        if length not in self.tries:
            self.tries[length] = TrieNode()
        
        node = self.tries[length]
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def search(self, word: str) -> bool:
        length = len(word)
        if length not in self.tries:
            return False
        
        return self._search_from(self.tries[length], word, 0)
    
    def _search_from(self, node, word, index):
        # Same as before...
        if index == len(word):
            return node.is_end
        
        char = word[index]
        
        if char == '.':
            for child in node.children.values():
                if self._search_from(child, word, index + 1):
                    return True
            return False
        else:
            if char not in node.children:
                return False
            return self._search_from(node.children[char], word, index + 1)
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space | Notes |
|------|------|-------|-------|
| **No wildcards** | O(m) | O(m) | Same as regular search |
| **One '.'** | O(26 √ó m) | O(m) | Try 26 branches |
| **k wildcards** | O(26^k √ó m) | O(m) | Exponential! |
| **All '.'** | O(n √ó m) | O(m) | n = words in trie |

**Why exponential?**
- Each '.' can branch to up to 26 children
- k wildcards means 26^k possible paths
- This is why problems limit wildcard count

**Practical mitigation:**
- Real words share prefixes (less branching)
- Length bucketing reduces search space
- Sparse children in real-world data

---

## üîÑ Variations

| Variation | Character | Matches |
|-----------|-----------|---------|
| **Single char wildcard** | `.` | Any one char |
| **Multi-char wildcard** | `*` | Zero or more chars |
| **Character class** | `[aeiou]` | Any from set |
| **Optional char** | `?` | Zero or one char |

### Multi-Character Wildcard (Harder)

```python
def search_with_star(self, pattern: str) -> bool:
    """
    '*' matches zero or more characters.
    
    Much more complex - requires DP or extensive backtracking.
    Not typically asked in interviews.
    """
    # Use DP approach similar to regex matching
    pass
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Returning Wrong on First Failed Branch

**‚ùå Wrong:**
```python
def _search_from(self, node, word, index):
    if char == '.':
        for child in node.children.values():
            result = self._search_from(child, word, index + 1)
            return result  # Returns after first child!
```

**‚úÖ Correct:**
```python
def _search_from(self, node, word, index):
    if char == '.':
        for child in node.children.values():
            if self._search_from(child, word, index + 1):
                return True  # Return True if ANY path works
        return False  # Return False only if ALL paths fail
```

### 2. Forgetting is_end Check

**‚ùå Wrong:**
```python
def _search_from(self, node, word, index):
    if index == len(word):
        return True  # Wrong! Node might not be word end!
```

**‚úÖ Correct:**
```python
def _search_from(self, node, word, index):
    if index == len(word):
        return node.is_end  # Must be complete word!
```

### 3. Not Handling Empty Pattern

**‚úÖ Handle correctly:**
```python
def search(self, word: str) -> bool:
    if not word:
        return self.root.is_end  # Empty string is word if marked
    return self._search_from(self.root, word, 0)
```

---

## üìù Practice Problems

### Medium (Core wildcard)
- [ ] [Design Add and Search Words](https://leetcode.com/problems/design-add-and-search-words-data-structure/) - LC 211 ‚≠ê

### Related patterns
- [ ] [Implement Trie](https://leetcode.com/problems/implement-trie-prefix-tree/) - LC 208
- [ ] [Word Search II](https://leetcode.com/problems/word-search-ii/) - LC 212

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement LC 211 with recursion
- **Day 3:** Add length bucketing optimization
- **Day 7:** Solve from scratch without looking
- **Day 14:** Explain the branching complexity
- **Day 30:** Teach wildcard search to someone

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Discuss in Interviews</strong></summary>

**Explaining the approach:**
> "For regular characters, I follow the normal trie path. For '.', I need to try all children of the current node and return true if any path leads to a valid word. This is essentially DFS with backtracking."

**Discussing complexity:**
> "Without wildcards, search is O(m). Each '.' adds a branching factor of up to 26. So with k wildcards, worst case is O(26^k √ó m). However, in practice it's much better because real tries are sparse."

**Optimization question:**
> "We could bucket words by length so a search for '...' only checks words of length 3. We could also add early termination if no children exist."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| **Meta** | ‚≠ê‚≠ê‚≠ê | LC 211 is common |
| **Amazon** | ‚≠ê‚≠ê | Occasionally |
| **Google** | ‚≠ê‚≠ê | As part of larger problems |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand pattern | 15-20 min | This file |
| Implement LC 211 | 20-25 min | Core implementation |
| Add optimizations | 10-15 min | Length bucketing |
| Master pattern | 45-60 min | Multiple practice |

---

> **üí° Key Insight:** Wildcard '.' is DFS on the trie - try all children and return true if ANY path succeeds. Regular characters follow one path, wildcards fork to all paths.

> **üîó Related:** [Search Operation](../02-Trie-Operations/3.2-Search-Operation.md) | [Trie + Backtracking](./4.2-Trie-Plus-Backtracking.md) | [DFS Patterns](../../02-Recursion-Backtracking.md)
