# 4.2 Series & Summations

> **The math behind "why is this O(nÂ²)?" and "why does that simplify to O(n)?" â€” explained through code, not proofs.**
>
> â±ï¸ *Estimated reading: 12 minutes*

---

## ğŸ¯ Why This Matters

When you analyze nested loops, you're computing summations. Knowing these formulas lets you instantly determine complexity without tracing every iteration.

```python
# What's the complexity of this?
for i in range(n):
    for j in range(i):
        do_something()

# Total operations: 0 + 1 + 2 + ... + (n-1) = n(n-1)/2 = O(nÂ²)
# If you know the arithmetic series formula, this is instant.
```

---

## ğŸ“ 1. Arithmetic Series

### The Formula

$$1 + 2 + 3 + \cdots + n = \frac{n(n+1)}{2}$$

### Where It Appears in DSA

```python
# Nested loop with inner depending on outer
for i in range(n):          # n iterations
    for j in range(i):      # 0, 1, 2, ..., n-1 iterations
        process()

# Total: 0 + 1 + 2 + ... + (n-1) = n(n-1)/2 = O(nÂ²)
```

```python
# Selection sort â€” inner loop shrinks
for i in range(n):
    for j in range(i+1, n):   # n-1, n-2, ..., 1, 0
        if arr[j] < arr[i]:
            arr[i], arr[j] = arr[j], arr[i]

# Total comparisons: (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(nÂ²)
```

```python
# Building all pairs
for i in range(n):
    for j in range(i+1, n):
        pairs.append((i, j))

# Number of pairs: n(n-1)/2 = C(n,2) â€” same formula!
```

### Visual Intuition

```
n = 5:
j iterations: 0 + 1 + 2 + 3 + 4

Visually (each * is one operation):

i=0: 
i=1: *
i=2: **
i=3: ***
i=4: ****

Total *'s = 1 + 2 + 3 + 4 = 10 = 5Ã—4/2 âœ“
It's half of an nÃ—n square â†’ O(nÂ²)
```

### Sum of First n Odd Numbers

$$1 + 3 + 5 + \cdots + (2n-1) = n^2$$

This is why "doing 1 + 3 + 5 + ... operations" is O(nÂ²).

---

## ğŸ“ 2. Geometric Series

### The Formula

$$1 + 2 + 4 + 8 + \cdots + 2^k = 2^{k+1} - 1$$

More generally: $\displaystyle\sum_{i=0}^{k} r^i = \frac{r^{k+1} - 1}{r - 1}$ for $r \neq 1$

### Where It Appears in DSA

```python
# Doubling pattern â€” dynamic array resizing
# ArrayList/vector grows: 1, 2, 4, 8, 16, ...
# Total elements copied: 1 + 2 + 4 + ... + n = 2n - 1 = O(n)
# That's why dynamic array append is O(1) AMORTIZED!
```

```python
# Binary tree â€” nodes per level
# Level 0: 1 node
# Level 1: 2 nodes
# Level 2: 4 nodes
# ...
# Level h: 2^h nodes
# Total nodes: 1 + 2 + 4 + ... + 2^h = 2^(h+1) - 1
# For complete tree: n â‰ˆ 2^h, so h â‰ˆ logâ‚‚(n)
```

```python
# Heap â€” buildHeap is O(n), not O(n log n)!
# Why? The sum of work at each level:
# n/2 nodes do 0 swaps
# n/4 nodes do 1 swap  â†’ n/4 Ã— 1
# n/8 nodes do 2 swaps â†’ n/8 Ã— 2
# ...
# 1 node does log(n) swaps â†’ 1 Ã— log(n)
# 
# Total: n Ã— (1/4 + 2/8 + 3/16 + ...) = n Ã— Î£(k/2^k) â‰ˆ 2n = O(n)
```

### The Key Insight: Geometric Series is Dominated by Last Term

$$1 + 2 + 4 + \cdots + 2^k \approx 2 \times 2^k$$

The last term is approximately equal to the sum of ALL previous terms. This is why:
- Dynamic array resizing is O(n) total despite individual O(n) copies
- A complete binary tree has roughly half its nodes in the last level

---

## ğŸ“ 3. Harmonic Series

### The Formula

$$1 + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{n} \approx \ln(n)$$

### Where It Appears in DSA

```python
# Sieve of Eratosthenes â€” marking composites
for p in range(2, n):
    if is_prime[p]:
        for multiple in range(p*p, n, p):
            is_prime[multiple] = False

# Inner loop runs n/2 + n/3 + n/5 + n/7 + ...
# = n Ã— (1/2 + 1/3 + 1/5 + 1/7 + ...)
# â‰ˆ n Ã— ln(ln(n))     â† sum of reciprocals of primes
# So Sieve is O(n log log n)
```

```python
# Processing sublists of size n, n/2, n/3, ...
# Example: bucket sort analysis
total_work = n + n/2 + n/3 + ... + n/n
           = n Ã— (1 + 1/2 + 1/3 + ... + 1/n)
           = n Ã— H(n)
           â‰ˆ n Ã— ln(n)
           = O(n log n)
```

---

## ğŸ“ 4. Common Summation Patterns in Code

### Pattern A: Sum of Squares

$$1^2 + 2^2 + 3^2 + \cdots + n^2 = \frac{n(n+1)(2n+1)}{6} \approx \frac{n^3}{3}$$

```python
# Triple nested loop where each depends on outer
for i in range(n):
    for j in range(i):
        for k in range(j):
            process()
# Total â‰ˆ nÂ³/6 = O(nÂ³)
```

### Pattern B: Halving Loop

```python
# How many times can we divide n by 2?
i = n
while i > 0:
    process()
    i //= 2

# Iterations: logâ‚‚(n) = O(log n)
```

### Pattern C: Doubling + Linear Work

```python
# Merge sort recurrence: T(n) = 2T(n/2) + O(n)
# Level 0: 1 problem of size n      â†’ n work
# Level 1: 2 problems of size n/2   â†’ n work
# Level 2: 4 problems of size n/4   â†’ n work
# ...
# Level k: 2^k problems of size n/2^k â†’ n work
# 
# Total levels: logâ‚‚(n)
# Total work: n Ã— logâ‚‚(n) = O(n log n)
```

### Pattern D: Square Root Decomposition

```python
# Check divisors of n
for i in range(1, int(n**0.5) + 1):
    if n % i == 0:
        print(i, n // i)

# Iterations: âˆšn = O(âˆšn)
```

---

## âš¡ Complexity Cheat Sheet from Summations

| Code Pattern | Summation | Result |
|-------------|-----------|--------|
| `for i in range(n): for j in range(i)` | 0+1+2+...+(n-1) | **O(nÂ²)** |
| `for i in range(n): for j in range(n)` | n+n+n+...+n (n times) | **O(nÂ²)** |
| Array doubling: copy 1,2,4,...,n elements | 1+2+4+...+n | **O(n)** |
| Complete binary tree: nodes per level | 1+2+4+...+n | **O(n)** |
| Merge sort: n work per level, log n levels | n Ã— log n | **O(n log n)** |
| Halving loop: n, n/2, n/4, ... | n+n/2+n/4+... | **O(n)** |
| Harmonic: n/1 + n/2 + n/3 + ... | n Ã— H(n) | **O(n log n)** |
| âˆšn iterations | âˆšn | **O(âˆšn)** |

---

## ğŸ’» Code: Verifying Summations

```python
# Verify arithmetic series
n = 1000
manual = sum(range(1, n+1))
formula = n * (n + 1) // 2
assert manual == formula  # âœ…

# Verify geometric series
k = 10
manual = sum(2**i for i in range(k+1))
formula = 2**(k+1) - 1
assert manual == formula  # âœ…

# Verify harmonic series â‰ˆ ln(n)
import math
n = 1000000
harmonic = sum(1/i for i in range(1, n+1))
approx = math.log(n)
print(f"H({n}) = {harmonic:.4f}")
print(f"ln({n}) = {approx:.4f}")
# H(1000000) = 14.3927
# ln(1000000) = 13.8155
# Close! (difference is Eulerâ€“Mascheroni constant â‰ˆ 0.5772)
```

---

## âš ï¸ Common Mistakes

| Mistake | Reality |
|---------|---------|
| "Two nested loops = always O(nÂ²)" | Not if inner loop is O(1) or shrinks geometrically |
| "1+2+4+...+n = O(nÂ²)" | No! Geometric series = O(n) |
| "Dynamic array resize is expensive" | Amortized O(1) â€” geometric series proof |
| "Sieve is O(nÂ²)" | O(n log log n) â€” harmonic series of primes |

---

> **ğŸ’¡ Key Insight:** Three formulas cover 90% of complexity analysis: (1) Arithmetic: 1+2+...+n = nÂ²/2 â†’ O(nÂ²), (2) Geometric: 1+2+4+...+n = 2n â†’ O(n), (3) log n levels Ã— n work per level â†’ O(n log n). Memorize these three and you can analyze almost any algorithm.

---

â† [4.1 Powers of 2](./4.1-Powers-Of-2-And-Logarithms.md) | **Next:** [4.3 Number Theory Essentials](./4.3-Number-Theory-Essentials.md) â†’
