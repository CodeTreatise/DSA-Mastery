# 4.1 Kth Smallest Element in BST (LC 230)

## Problem Statement

[LeetCode 230 - Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)

Given the root of a BST and an integer `k`, return the `k`th smallest element (1-indexed).

```
Input: root = [5,3,6,2,4,null,null,1], k = 3
        5
       / \
      3   6
     / \
    2   4
   /
  1

Inorder: [1, 2, 3, 4, 5, 6]
Output: 3 (3rd smallest)
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is an Inorder Property problem:**
- Inorder traversal of BST gives sorted order
- K-th smallest = k-th element in inorder traversal
- Stop early once we find k-th element

**Keywords:**
- "k-th smallest", "k-th largest"
- "BST" + "order statistics"
- "find element at position k"

**Pattern:** Inorder traversal with counter, stop at k.

</details>

---

## ‚úÖ When to Use

- Finding k-th order statistic in BST
- Any problem involving sorted position in BST
- When BST property gives natural ordering

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Frequent k-th queries |" O(h+k) each time "| Augmented BST with sizes |
| General tree | No ordering | Sort all values |
| K very large |" Still O(k) "| Reverse inorder for k-th largest |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md) - Inorder = sorted
- [Inorder Traversal](../../06-Trees/03-Tree-Traversals/3.1-DFS-Traversals/)

**After mastering this:**
- [BST Iterator (LC 173)](./4.2-BST-Iterator-LC173.md) - Controlled traversal
- [Two Sum BST (LC 653)](./4.4-Two-Sum-BST-LC653.md) - Uses iterator

**Combines with:**
- Early termination (stop at k)
- Iterative inorder with stack

</details>

---

## üìê How It Works

### The Key Insight

```
BST inorder traversal visits nodes in sorted order!

        5
       / \
      3   6
     / \
    2   4
   /
  1

Inorder traversal order: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6
                         ‚Üë   ‚Üë   ‚Üë
                        1st 2nd 3rd smallest

For k=3, we just need to count to 3 during inorder.
```

### Visualization

```
Finding k=3 (3rd smallest):

        5
       / \
      3   6
     / \
    2   4
   /
  1

Step 1: Go left to 3, then 2, then 1
Step 2: Visit 1 ‚Üí count=1
Step 3: Back to 2, Visit 2 ‚Üí count=2  
Step 4: Back to 3, Visit 3 ‚Üí count=3 = k, RETURN 3!

We never visit 4, 5, or 6 (early termination)
```

---

## üíª Code Implementation

### Approach 1: Recursive with Early Exit

**Python:**
```python
def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
    """
    Find k-th smallest element in BST.
    
    Time: O(h + k) - go down h levels, visit k nodes
    Space: O(h) - recursion stack
    
    Pattern: Inorder traversal with counter
    """
    self.count = 0
    self.result = None
    
    def inorder(node):
        if not node or self.result is not None:
            return
        
        # Left (smaller values)
        inorder(node.left)
        
        # Visit current
        self.count += 1
        if self.count == k:
            self.result = node.val
            return
        
        # Right (larger values)
        inorder(node.right)
    
    inorder(root)
    return self.result
```

**JavaScript:**
```javascript
var kthSmallest = function(root, k) {
    // Inorder with early exit
    let count = 0;
    let result = null;
    
    function inorder(node) {
        if (!node || result !== null) return;
        
        inorder(node.left);
        
        count++;
        if (count === k) {
            result = node.val;
            return;
        }
        
        inorder(node.right);
    }
    
    inorder(root);
    return result;
};
```

### Approach 2: Iterative (Preferred for Early Exit)

**Python:**
```python
def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
    """
    Iterative inorder - cleaner early exit.
    
    Time: O(h + k)
    Space: O(h) - explicit stack
    """
    stack = []
    current = root
    count = 0
    
    while stack or current:
        # Go left as far as possible
        while current:
            stack.append(current)
            current = current.left
        
        # Visit node
        current = stack.pop()
        count += 1
        if count == k:
            return current.val
        
        # Go right
        current = current.right
    
    return -1  # k > number of nodes
```

**JavaScript:**
```javascript
var kthSmallest = function(root, k) {
    // Iterative inorder - cleaner control flow
    const stack = [];
    let current = root;
    let count = 0;
    
    while (stack.length > 0 || current) {
        // Go left
        while (current) {
            stack.push(current);
            current = current.left;
        }
        
        // Visit
        current = stack.pop();
        count++;
        if (count === k) {
            return current.val;
        }
        
        // Go right
        current = current.right;
    }
    
    return -1;
};
```

### Approach 3: Augmented BST (For Frequent Queries)

**Python:**
```python
class AugmentedTreeNode:
    """Node that stores left subtree size for O(log n) k-th queries."""
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.left_count = 0  # Number of nodes in left subtree

def kthSmallestAugmented(root: AugmentedTreeNode, k: int) -> int:
    """
    Find k-th smallest in O(log n) using augmented BST.
    
    Requires: Each node stores count of left subtree.
    """
    while root:
        left_count = root.left_count
        
        if k == left_count + 1:
            return root.val
        elif k <= left_count:
            root = root.left
        else:
            k -= left_count + 1
            root = root.right
    
    return -1
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Recursive |" O(h + k) "| O(h) | May visit extra right subtree |
| Iterative |" O(h + k) "| O(h) | Clean early exit |
| Augmented BST |" O(log n) "| O(1) | Requires preprocessing |

**Why O(h + k):**
- O(h): Navigate down to leftmost node
- O(k): Visit k nodes in inorder sequence
- Best case k=1: O(h) to find minimum
- Worst case k=n: O(n) to visit all

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **K-th largest** | Reverse inorder (right before left) | Mirror problem |
| **Median** | k = (n+1)/2 | Special case |
| **Multiple queries** | Augment with subtree sizes | Optimization |
| **With updates** | Update sizes on insert/delete | Dynamic BST |

### K-th Largest

```python
def kthLargest(root: TreeNode, k: int) -> int:
    """Reverse inorder: right ‚Üí node ‚Üí left"""
    stack = []
    current = root
    count = 0
    
    while stack or current:
        while current:
            stack.append(current)
            current = current.right  # Go RIGHT first
        
        current = stack.pop()
        count += 1
        if count == k:
            return current.val
        
        current = current.left  # Then LEFT
    
    return -1
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Handling Early Exit in Recursion

```python
# ‚ùå Wrong: Continues even after finding result
def inorder(node):
    if not node:
        return
    inorder(node.left)
    self.count += 1
    if self.count == k:
        self.result = node.val
        # Missing return! Will continue to right subtree
    inorder(node.right)

# ‚úÖ Correct: Check if already found
def inorder(node):
    if not node or self.result is not None:
        return
    inorder(node.left)
    if self.result is not None:
        return  # Early exit
    self.count += 1
    if self.count == k:
        self.result = node.val
        return
    inorder(node.right)
```

### 2. Off-by-One Error

```python
# ‚ùå Wrong: 0-indexed thinking
if count == k - 1:  # Looking for index k-1
    return current.val

# ‚úÖ Correct: 1-indexed as stated in problem
if count == k:  # k=1 means first element
    return current.val
```

### 3. Forgetting to Count Current Node

```python
# ‚ùå Wrong: Only counting in left/right calls
def inorder(node):
    if node.left:
        inorder(node.left)
        count += 1  # Counting wrong nodes!
    ...

# ‚úÖ Correct: Count when visiting (between left and right)
def inorder(node):
    if not node:
        return
    inorder(node.left)
    count += 1  # Count current node
    inorder(node.right)
```

---

## üìù Practice Problems (Progressive)

### Easy (Build up)
- [ ] [Minimum Distance in BST (LC 783)](https://leetcode.com/problems/minimum-distance-between-bst-nodes/) - Inorder adjacent

### Medium (Apply pattern)
- [ ] [Kth Smallest (LC 230)](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) - This problem
- [ ] [BST Iterator (LC 173)](https://leetcode.com/problems/binary-search-tree-iterator/) - Controlled next()
- [ ] [Two Sum IV - BST (LC 653)](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) - Uses iteration
- [ ] [Inorder Successor (LC 285)](https://leetcode.com/problems/inorder-successor-in-bst/) - Next element

### Hard (Master)
- [ ] [Count of Smaller Numbers (LC 315)](https://leetcode.com/problems/count-of-smaller-numbers-after-self/) - Augmented BST

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement recursive solution
- **Day 3:** Implement iterative solution
- **Day 7:** Solve k-th largest variation
- **Day 14:** Understand augmented BST approach
- **Day 30:** Apply to LC 653 (Two Sum)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"Since inorder traversal of a BST gives elements in sorted order, the k-th smallest is just the k-th element visited during inorder traversal. I'll do an inorder traversal, count to k, and return that value."

**Key points:**
1. "Inorder of BST = sorted sequence"
2. "I can stop early once I find the k-th element"
3. "Time is O(h + k) because I go down h levels then visit k nodes"

**Follow-up: What if k-th smallest is called frequently?**
"I'd augment each node with its left subtree size. Then I can binary search in O(log n) by comparing k with left_count at each node."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | BST fundamentals |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Often asked |
| Google | ‚≠ê‚≠ê‚≠ê | May ask follow-up |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Simple concept |
| Code iterative | 8-10 min | Preferred |
| Code recursive | 8-10 min | Alternative |
| Follow-up discussion | 5-7 min | Augmented BST |
| Total interview time | 20-25 min | Medium difficulty |

---

## üí° Key Insight

> **BST encodes sorted order spatially.** Inorder traversal "reads" this sorted order sequentially. For k-th smallest, we're essentially finding the k-th position in a sorted array ‚Äî but the array is stored as a tree.

---

## üîó Related

- **Foundation:** [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
- **Next:** [BST Iterator (LC 173)](./4.2-BST-Iterator-LC173.md)
- **Uses This:** [Two Sum BST (LC 653)](./4.4-Two-Sum-BST-LC653.md)
- **Advanced:** Order Statistic Trees
