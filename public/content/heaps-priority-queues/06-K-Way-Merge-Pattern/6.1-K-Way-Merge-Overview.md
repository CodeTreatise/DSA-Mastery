# 6.1 K-Way Merge Pattern Overview

## Pattern Definition

The **K-Way Merge pattern** uses a min-heap to efficiently merge K sorted lists/arrays into a single sorted sequence. It generalizes the "merge two sorted lists" concept to K lists.

```
K Sorted Lists ‚Üí Min-Heap ‚Üí Single Sorted Output

List 1: [1, 4, 7]
List 2: [2, 5, 8]        Min-Heap         Merged Output
List 3: [3, 6, 9]   ‚Üí   (smallest)   ‚Üí   [1, 2, 3, 4, 5, 6, 7, 8, 9]
                            ‚îÇ
                    Always extract minimum
                    Push next from same list
```

This is **Grokking Pattern #14** and is essential for merge-sort style problems.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Primary signals:**
- Have K **sorted** lists/arrays/streams
- Need to merge into one sorted output
- Find the **smallest/largest** range covering all lists
- Kth element across multiple sorted lists

**Keywords in problem statement:**
- "merge K sorted..."
- "Kth smallest in matrix"
- "smallest range" covering K lists
- "sorted matrix" operations

**The core insight:**
```
If we have K sorted lists and want the next smallest overall:
1. Each list contributes one candidate (its current head)
2. Use min-heap to find smallest among K candidates
3. When extracting, add next element from same list
4. Repeat until done
```

</details>

---

## ‚úÖ When to Use

- Merging K sorted lists/arrays
- External sorting (merge sorted chunks from disk)
- Finding Kth smallest across sorted sequences
- Smallest range covering K lists

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Only 2 sorted lists | Simple two-pointer | Merge Two Sorted |
| Unsorted input | Pattern requires sorted | Sort first or different approach |
| Need Kth largest | Still works, but Top K may be simpler | Top K pattern |
| Very small K | Overhead may not be worth it | Simple iteration |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Heap Basics](../01-Heap-Fundamentals/1.1-What-Is-Heap.md)
- [Min-heap operations](../02-Heap-Operations/2.1-Insert.md)
- Merge Two Sorted Lists (LC 21)

**After mastering this:**
- [Merge K Sorted Lists (LC 23)](./6.2-Merge-K-Lists-LC23.md)
- [Kth Smallest in Sorted Matrix (LC 378)](./6.3-Kth-Smallest-Matrix-LC378.md)
- [Smallest Range Covering K Lists (LC 632)](./6.4-Smallest-Range-LC632.md)

**Combines with:**
- Linked List manipulation
- External sorting
- Stream processing

</details>

---

## üìê How It Works

### Core Algorithm

```
K-Way Merge Algorithm:

1. INITIALIZE:
   - Add first element of each list to min-heap
   - Store (value, list_index, element_index) tuple

2. EXTRACT-MERGE LOOP:
   While heap not empty:
     a. Extract minimum (val, list_idx, elem_idx)
     b. Add val to result
     c. If list has more elements:
        Push next element from same list to heap
        
3. RETURN merged result
```

### Why This Works

```
Invariant: Heap always contains one element from each non-exhausted list

At each step:
- Heap has at most K elements (one per list)
- Minimum in heap = minimum across all K lists
- Extracting minimum gives next element in merged order
- Pushing next from same list maintains invariant

Total operations:
- N total elements across all lists
- Each element pushed once, popped once
- Each operation O(log K) since heap has at most K elements
- Total: O(N log K)
```

### Visual Trace

```
Lists:
  A: [1, 4, 7]
  B: [2, 5, 8]
  C: [3, 6, 9]

Initial heap (value, list, index):
  [(1, A, 0), (2, B, 0), (3, C, 0)]
  Min = (1, A, 0)

Step 1: Pop (1, A, 0), Output: [1]
  Push (4, A, 1) - next from list A
  Heap: [(2, B, 0), (3, C, 0), (4, A, 1)]
  
Step 2: Pop (2, B, 0), Output: [1, 2]
  Push (5, B, 1) - next from list B
  Heap: [(3, C, 0), (4, A, 1), (5, B, 1)]

Step 3: Pop (3, C, 0), Output: [1, 2, 3]
  Push (6, C, 1) - next from list C
  Heap: [(4, A, 1), (5, B, 1), (6, C, 1)]

... continues ...

Final output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### Tuple Structure

```python
# For linked lists:
(node.val, list_index, node)

# For arrays:
(arr[i], list_index, element_index)

# For matrix (sorted rows):
(matrix[row][col], row, col)
```

---

## üíª Code Implementation

### Template 1: Merge K Sorted Arrays

**Python:**
```python
import heapq

def merge_k_sorted_arrays(arrays: list[list[int]]) -> list[int]:
    """
    Merge K sorted arrays into one sorted array.
    
    Time: O(N log K) where N = total elements, K = number of arrays
    Space: O(K) for heap + O(N) for result
    
    Pattern: K-Way Merge using min-heap
    """
    result = []
    min_heap = []
    
    # Initialize: add first element of each array
    for i, arr in enumerate(arrays):
        if arr:  # Skip empty arrays
            # (value, array_index, element_index)
            heapq.heappush(min_heap, (arr[0], i, 0))
    
    # Extract-merge loop
    while min_heap:
        val, arr_idx, elem_idx = heapq.heappop(min_heap)
        result.append(val)
        
        # If this array has more elements, push next
        if elem_idx + 1 < len(arrays[arr_idx]):
            next_val = arrays[arr_idx][elem_idx + 1]
            heapq.heappush(min_heap, (next_val, arr_idx, elem_idx + 1))
    
    return result


# Example:
# arrays = [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
# print(merge_k_sorted_arrays(arrays))  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**JavaScript:**
```javascript
function mergeKSortedArrays(arrays) {
    const result = [];
    const minHeap = new MinHeap();
    
    // Initialize with first element of each array
    for (let i = 0; i < arrays.length; i++) {
        if (arrays[i].length > 0) {
            // [value, arrayIndex, elementIndex]
            minHeap.push([arrays[i][0], i, 0]);
        }
    }
    
    // Extract-merge loop
    while (minHeap.size() > 0) {
        const [val, arrIdx, elemIdx] = minHeap.pop();
        result.push(val);
        
        // If array has more elements, push next
        if (elemIdx + 1 < arrays[arrIdx].length) {
            minHeap.push([arrays[arrIdx][elemIdx + 1], arrIdx, elemIdx + 1]);
        }
    }
    
    return result;
}

// MinHeap comparing by first element of array
class MinHeap {
    constructor() { this.heap = []; }
    
    size() { return this.heap.length; }
    
    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return min;
    }
    
    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.heap[parent][0] <= this.heap[i][0]) break;
            [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
            i = parent;
        }
    }
    
    _bubbleDown(i) {
        while (true) {
            let smallest = i;
            const left = 2 * i + 1, right = 2 * i + 2;
            if (left < this.heap.length && this.heap[left][0] < this.heap[smallest][0]) {
                smallest = left;
            }
            if (right < this.heap.length && this.heap[right][0] < this.heap[smallest][0]) {
                smallest = right;
            }
            if (smallest === i) break;
            [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
            i = smallest;
        }
    }
}
```

### Template 2: Merge K Sorted Linked Lists

**Python:**
```python
import heapq
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists: list[Optional[ListNode]]) -> Optional[ListNode]:
    """
    Merge K sorted linked lists.
    
    Time: O(N log K), Space: O(K)
    """
    # Handle empty input
    if not lists:
        return None
    
    min_heap = []
    
    # Initialize with head of each list
    for i, head in enumerate(lists):
        if head:
            # (value, unique_index, node)
            # unique_index prevents comparison errors when values are equal
            heapq.heappush(min_heap, (head.val, i, head))
    
    # Dummy head for result
    dummy = ListNode(0)
    current = dummy
    
    # Extract-merge loop
    while min_heap:
        val, idx, node = heapq.heappop(min_heap)
        current.next = node
        current = current.next
        
        # If this list has more nodes, push next
        if node.next:
            heapq.heappush(min_heap, (node.next.val, idx, node.next))
    
    return dummy.next
```

### Template 3: Kth Smallest in Sorted Matrix

**Python:**
```python
import heapq

def kthSmallest(matrix: list[list[int]], k: int) -> int:
    """
    Find Kth smallest element in sorted matrix.
    Each row and column is sorted.
    
    Time: O(K log n), Space: O(n)
    """
    n = len(matrix)
    min_heap = []
    
    # Initialize with first element of each row
    # (value, row, col)
    for i in range(min(n, k)):  # At most k rows needed
        heapq.heappush(min_heap, (matrix[i][0], i, 0))
    
    # Extract k-1 times, kth extraction is answer
    for _ in range(k - 1):
        val, row, col = heapq.heappop(min_heap)
        
        # Push next element from same row
        if col + 1 < n:
            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))
    
    return min_heap[0][0]
```

---

## ‚ö° Complexity Analysis

| Scenario | Time | Space | Notes |
|----------|------|-------|-------|
| Merge K arrays |" O(N log K) "| O(K) + O(N) | N = total elements |
| Merge K lists |" O(N log K) "| O(K) | Reuse list nodes |
| Kth in matrix |" O(K log n) "| O(n) | Early termination |

**Why O(N log K):**
- Each of N elements: 1 push + 1 pop
- Heap size ‚â§ K
- Each heap operation: O(log K)
- Total: N * O(log K) = O(N log K)

**Comparison with alternatives:**

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Merge all, sort |" O(N log N) "| O(N) | Ignores sorted property |
| Merge pairs (divide) |" O(N log K) "| O(1) extra |" Also O(N log K) "|
| **K-way heap** |" **O(N log K)** "| **O(K)** | Works on streams |

---

## üîÑ Variations

| Variation | Key Difference | Problem |
|-----------|----------------|---------|
| **Kth smallest** | Stop after K extractions | [LC 378](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/) |
| **Smallest range** | Track all K lists simultaneously | [LC 632](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/) |
| **Merge intervals** | After merging, combine overlapping | Custom |
| **K largest** | Use max-heap instead | Reverse problem |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Handling Empty Lists

```python
# ‚ùå Wrong: Assuming all lists have elements
for i, arr in enumerate(arrays):
    heapq.heappush(heap, (arr[0], i, 0))  # IndexError if arr is empty!

# ‚úÖ Correct: Check for empty
for i, arr in enumerate(arrays):
    if arr:  # Skip empty arrays
        heapq.heappush(heap, (arr[0], i, 0))
```

### 2. Tuple Comparison Issues with Nodes

```python
# ‚ùå Wrong: ListNode objects can't be compared
heapq.heappush(heap, (node.val, node))  # Fails if vals are equal!

# ‚úÖ Correct: Add unique tiebreaker
heapq.heappush(heap, (node.val, i, node))  # i is unique list index
```

### 3. Forgetting to Push Next Element

```python
# ‚ùå Wrong: Only popping, never pushing next
while min_heap:
    val, arr_idx, elem_idx = heapq.heappop(min_heap)
    result.append(val)
    # Missing: push next element from same list!

# ‚úÖ Correct: Always check and push next
while min_heap:
    val, arr_idx, elem_idx = heapq.heappop(min_heap)
    result.append(val)
    if elem_idx + 1 < len(arrays[arr_idx]):  # Check bounds
        heapq.heappush(min_heap, (arrays[arr_idx][elem_idx + 1], arr_idx, elem_idx + 1))
```

### 4. Wrong Index Increment

```python
# ‚ùå Wrong: Using elem_idx instead of elem_idx + 1
heapq.heappush(heap, (arr[elem_idx], arr_idx, elem_idx))  # Re-adds same element!

# ‚úÖ Correct: Increment index
heapq.heappush(heap, (arr[elem_idx + 1], arr_idx, elem_idx + 1))
```

---

## üìù Practice Problems (Progressive)

### Easy (Foundation)
- [ ] [Merge Two Sorted Lists (LC 21)](https://leetcode.com/problems/merge-two-sorted-lists/) - Two-way merge

### Medium (Core pattern)
- [ ] [Merge K Sorted Lists (LC 23)](https://leetcode.com/problems/merge-k-sorted-lists/) - **Classic problem**
- [ ] [Kth Smallest in Sorted Matrix (LC 378)](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/) - Matrix variant
- [ ] [Find K Pairs with Smallest Sums (LC 373)](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/) - Pair generation

### Hard (Advanced)
- [ ] [Smallest Range Covering K Lists (LC 632)](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/) - Track all lists

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement merge K arrays
- **Day 3:** Solve LC 23 (linked lists variant)
- **Day 7:** Solve LC 378 (matrix variant)
- **Day 14:** Attempt LC 632 (advanced)
- **Day 30:** Re-solve all with timing

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening:**
"For merging K sorted lists, I'll use the K-way merge pattern with a min-heap. The key insight is that the heap always holds one element from each non-exhausted list, so the minimum in the heap is the next element in the merged output."

**Drawing:**
```
"Let me draw this:
Lists:    Heap (min at top):     Output:
[1,4,7]         1                 [1]
[2,5,8]   ‚Üí    / \           ‚Üí   
[3,6,9]       2   3              

After extracting 1, push 4 from same list."
```

**Complexity:**
"Time is O(N log K) where N is total elements and K is number of lists. Each element does one push and one pop, each O(log K). Space is O(K) for the heap."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | LC 23 very common |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Often asked |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard heap problem |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Less frequent |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand pattern | 10-15 min | Draw the heap process |
| Implement arrays version | 10-15 min | Simpler |
| Implement lists version | 15-20 min | Node handling |
| Matrix variant | 15-20 min | 2D indexing |

---

## üí° Key Insight

> **K-way merge keeps exactly K elements in the heap‚Äîone from each list.** The minimum is always the next element in sorted order. After extracting the minimum, we push the next element from the same list, maintaining the invariant. This gives O(N log K) time, which is optimal when lists are already sorted.

---

## üîó Related

- **Prerequisites:** [Heap Basics](../01-Heap-Fundamentals/1.1-What-Is-Heap.md)
- **Core Problem:** [Merge K Sorted Lists (LC 23)](./6.2-Merge-K-Lists-LC23.md)
- **Matrix Variant:** [Kth Smallest in Matrix (LC 378)](./6.3-Kth-Smallest-Matrix-LC378.md)
- **Related Pattern:** [Top K Elements](../04-Top-K-Pattern/4.1-Top-K-Overview.md)
