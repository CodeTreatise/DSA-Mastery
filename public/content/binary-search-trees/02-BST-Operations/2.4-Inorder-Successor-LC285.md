# 2.4 Inorder Successor in BST (LC 285)

## Problem Statement

[LeetCode 285 - Inorder Successor in BST](https://leetcode.com/problems/inorder-successor-in-bst/) (Premium)

Given the root of a BST and a node `p`, return the inorder successor of that node. If no successor exists, return `null`.

The **inorder successor** of a node `p` is the node with the smallest key greater than `p.val`.

```
Input: root = [5,3,6,2,4,null,null,1], p = 4

        5
       / \
      3   6
     / \
    2   4
   /
  1

Output: 5  (inorder: 1,2,3,4,5,6 ‚Üí successor of 4 is 5)
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is an Inorder Successor problem:**
- Find next larger value in BST
- Two cases: with/without right subtree
- Uses BST property for O(h) solution

**Keywords:**
- "inorder successor", "next larger"
- "next node in inorder traversal"
- "smallest value greater than"

**Pattern:** Successor Logic
- Right subtree exists ‚Üí leftmost in right
- No right subtree ‚Üí lowest ancestor where node is in left subtree

</details>

---

## ‚úÖ When to Use

- BST deletion (find replacement for two-child node)
- BST iterator implementation
- Finding next larger element
- Range queries (next value after X)

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Need k successors |" O(k¬∑h) is slow "| Inorder traversal O(n) |
| General binary tree | No ordering property | Full inorder traversal |
| Need predecessor too | Different algorithm | Use predecessor logic |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Fundamentals](../01-BST-Fundamentals/1.3-BST-MinMax-Successor.md) - Successor concept
- [BST Search](./2.1-BST-Search-LC700.md) - Navigation pattern

**After mastering this:**
- [BST Delete (LC 450)](./2.3-BST-Delete-LC450.md) - Uses successor
- [BST Iterator (LC 173)](../04-Inorder-Property/4.2-BST-Iterator-LC173.md) - Controlled traversal
- [Kth Smallest (LC 230)](../04-Inorder-Property/4.1-Kth-Smallest-LC230.md)

**Combines with:**
- BST delete (successor replaces deleted node)
- BST iterator (next() returns successor)

</details>

---

## üìê How It Works

### Two Cases Explained

#### Case 1: Node Has Right Subtree
**Successor = Leftmost node in right subtree**

```
Find successor of 3:
        5
       / \
      3   6
     / \
    2   4   ‚Üê 3 has right subtree!

Step 1: Go to right child (4)
Step 2: Go left as far as possible (4 has no left)
Result: 4 is successor of 3
```

#### Case 2: Node Has No Right Subtree
**Successor = Nearest ancestor where node is in left subtree**

```
Find successor of 4:
        5   ‚Üê Successor! (4 is in left subtree of 5)
       / \
      3   6
     / \
    2   4   ‚Üê Start here, no right child

Walk up: 4‚Üí3 (4 is right child of 3, keep going)
        3‚Üí5 (3 is left child of 5, FOUND!)
Result: 5 is successor of 4
```

### Visual Summary

```
Inorder: 1, 2, 3, 4, 5, 6
                     ‚Üì ‚Üì
                     4‚Üí5  (successor)

        5
       / \
      3   6
     / \
    2   4
   /
  1

Node 4: No right subtree ‚Üí search from root
Node 3: Has right subtree (4) ‚Üí go right, then left
```

---

## üíª Code Implementation

### Approach 1: Search from Root (No Parent Pointer)

**Python:**
```python
def inorderSuccessor(self, root: TreeNode, p: TreeNode) -> Optional[TreeNode]:
    """
    Find inorder successor of node p in BST.
    
    Time: O(h) - traverse from root
    Space: O(1) - iterative
    
    Key insight: Track potential successor while searching.
    When we go left, current node could be the successor.
    """
    successor = None
    current = root
    
    while current:
        if p.val < current.val:
            # Current could be successor (it's larger than p)
            # Go left to find potentially smaller successor
            successor = current
            current = current.left
        else:
            # p.val >= current.val
            # Successor must be in right subtree
            current = current.right
    
    return successor
```

**JavaScript:**
```javascript
var inorderSuccessor = function(root, p) {
    // Find inorder successor - O(h) time, O(1) space
    let successor = null;
    let current = root;
    
    while (current) {
        if (p.val < current.val) {
            // Current could be successor
            successor = current;
            current = current.left;
        } else {
            // p.val >= current.val, go right
            current = current.right;
        }
    }
    
    return successor;
};
```

### Approach 2: Direct Node Access (When You Have the Node)

**Python:**
```python
def inorderSuccessor(self, root: TreeNode, p: TreeNode) -> Optional[TreeNode]:
    """
    Alternative approach when we have direct access to p.
    
    Case 1: Right subtree exists ‚Üí leftmost in right
    Case 2: No right subtree ‚Üí search from root
    """
    # Case 1: Has right subtree
    if p.right:
        current = p.right
        while current.left:
            current = current.left
        return current
    
    # Case 2: No right subtree - search from root
    successor = None
    current = root
    
    while current:
        if p.val < current.val:
            successor = current
            current = current.left
        elif p.val > current.val:
            current = current.right
        else:
            # Found p, break
            break
    
    return successor
```

**JavaScript:**
```javascript
var inorderSuccessor = function(root, p) {
    // Case 1: Has right subtree
    if (p.right) {
        let current = p.right;
        while (current.left) {
            current = current.left;
        }
        return current;
    }
    
    // Case 2: Search from root
    let successor = null;
    let current = root;
    
    while (current) {
        if (p.val < current.val) {
            successor = current;
            current = current.left;
        } else if (p.val > current.val) {
            current = current.right;
        } else {
            break;
        }
    }
    
    return successor;
};
```

### Approach 3: With Parent Pointer

**Python:**
```python
def inorderSuccessor(self, p: TreeNode) -> Optional[TreeNode]:
    """
    Find successor when nodes have parent pointers.
    Assumes p.parent exists.
    
    Time: O(h), Space: O(1)
    """
    # Case 1: Has right subtree
    if p.right:
        current = p.right
        while current.left:
            current = current.left
        return current
    
    # Case 2: Walk up until we're a left child
    while p.parent and p == p.parent.right:
        p = p.parent
    
    return p.parent  # Could be None if p was max
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Search from root |" O(h) "| O(1) | Works without parent |
| With right subtree check |" O(h) "| O(1) | Two path traversals |
| With parent pointer |" O(h) "| O(1) | Walk up the tree |

**Why O(h):**
- We traverse at most one path from root to a node
- Then potentially one path in the right subtree
- Both paths are bounded by height h

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **Inorder Predecessor** | Mirror logic (go left, then rightmost) | Similar approach |
| **Kth Successor** | Call successor k times | LC 230 variant |
| **Closest Value** | Track both successor and predecessor | LC 270 |
| **With count** | Return successor if exists, else count | Statistics |

### Inorder Predecessor

```python
def inorderPredecessor(root: TreeNode, p: TreeNode) -> Optional[TreeNode]:
    """Find largest value smaller than p (predecessor)."""
    predecessor = None
    current = root
    
    while current:
        if p.val > current.val:
            # Current could be predecessor
            predecessor = current
            current = current.right
        else:
            # p.val <= current.val, go left
            current = current.left
    
    return predecessor
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Comparison Direction

```python
# ‚ùå Wrong: Using >= instead of >
while current:
    if p.val >= current.val:  # Wrong! Should be p.val < current.val
        successor = current
        ...

# ‚úÖ Correct: Successor must be strictly greater
while current:
    if p.val < current.val:
        successor = current
        current = current.left
    else:  # p.val >= current.val
        current = current.right
```

### 2. Forgetting Edge Cases

```python
# ‚ùå Wrong: Not handling when p is the maximum
def inorderSuccessor(root, p):
    # ... search logic
    return successor  # Could return wrong value if p is max

# ‚úÖ Correct: Initialize successor to None
def inorderSuccessor(root, p):
    successor = None  # Will remain None if p is max
    # ... search logic
    return successor  # Correctly returns None for max element
```

### 3. Not Handling Right Subtree Efficiently

```python
# ‚ùå Inefficient: Always searching from root
def inorderSuccessor(root, p):
    # Always does full search, even if p has right child

# ‚úÖ Efficient: Check right subtree first
def inorderSuccessor(root, p):
    if p.right:
        # O(h) in right subtree, potentially much smaller
        return findMin(p.right)
    # Only search from root when necessary
    return searchFromRoot(root, p)
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)
- [ ] [Search in BST (LC 700)](https://leetcode.com/problems/search-in-a-binary-search-tree/) - Navigation pattern

### Medium (Apply successor logic)
- [ ] [Inorder Successor in BST (LC 285)](https://leetcode.com/problems/inorder-successor-in-bst/) - This problem
- [ ] [Inorder Successor II (LC 510)](https://leetcode.com/problems/inorder-successor-in-bst-ii/) - With parent pointer
- [ ] [Delete Node in BST (LC 450)](https://leetcode.com/problems/delete-node-in-a-bst/) - Uses successor
- [ ] [BST Iterator (LC 173)](https://leetcode.com/problems/binary-search-tree-iterator/) - Controlled next()

### Hard (Master edge cases)
- [ ] [Closest BST Value II (LC 272)](https://leetcode.com/problems/closest-binary-search-tree-value-ii/) - K closest

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Draw both cases on paper
- **Day 3:** Implement from scratch without looking
- **Day 7:** Use successor in BST delete
- **Day 14:** Implement predecessor as well
- **Day 30:** Solve LC 173 (Iterator uses this)

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"To find the inorder successor, there are two cases. If the node has a right subtree, the successor is the leftmost node in that subtree. If not, I search from the root and track the last node where I went left ‚Äî that's the successor."

**Key points:**
- Explain both cases clearly
- State O(h) complexity
- Mention it's used in BST delete

**Follow-up questions:**
- "What if the node is the maximum?" ‚Üí Return null, no successor
- "Can you do it with parent pointers?" ‚Üí Yes, walk up until left child
- "How is this used in deletion?" ‚Üí Replace deleted node's value with successor's

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Amazon | ‚≠ê‚≠ê‚≠ê | Part of BST operations |
| Facebook | ‚≠ê‚≠ê‚≠ê | Iterator pattern |
| Google | ‚≠ê‚≠ê | Combined with other problems |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand two cases | 5-7 min | Draw diagrams |
| Code solution | 10-12 min | Handle both cases |
| Discuss complexity | 2-3 min |" O(h) analysis "|
| Total interview time | 18-22 min | Medium difficulty |

---

## üí° Key Insight

> **The successor is the "next" in sorted order, which BST encodes spatially.** If there's a right subtree, the next larger is the minimum there. Otherwise, it's the nearest ancestor where we're "coming from the left" ‚Äî meaning we haven't yet visited that ancestor in inorder.

---

## üîó Related

- **Previous:** [BST Delete (LC 450)](./2.3-BST-Delete-LC450.md)
- **Concept:** [Min/Max/Successor](../01-BST-Fundamentals/1.3-BST-MinMax-Successor.md)
- **Uses This:** [BST Iterator (LC 173)](../04-Inorder-Property/4.2-BST-Iterator-LC173.md)
- **Variant:** [LC 510 - Inorder Successor II](https://leetcode.com/problems/inorder-successor-in-bst-ii/)
