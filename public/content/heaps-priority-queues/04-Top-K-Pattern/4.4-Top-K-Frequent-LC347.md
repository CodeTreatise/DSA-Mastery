# 4.4 Top K Frequent Elements (LC 347)

## Problem Statement

[LeetCode 347 - Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in **any order**.

```
Example 1:
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]

Example 2:
Input: nums = [1], k = 1
Output: [1]

Constraints:
- 1 <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4
- k is in range [1, number of unique elements]
- Answer is guaranteed to be unique
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a Frequency + Top K problem:**
- Need to count occurrences first
- Then find K elements with highest counts
- Combines hash map + heap

**Keywords:**
- "most frequent", "top k frequent"
- "highest count", "most common"
- Frequency-based ranking

**Two-step pattern:**
1. Count frequencies ‚Üí O(n)
2. Get top K by frequency ‚Üí O(n log k) with heap

</details>

---

## ‚úÖ When to Use

- Finding most common elements
- Top K by any countable property
- When you need to rank by frequency
- Log analysis, word frequency, etc.

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Need exact order | Heap doesn't preserve order | Sort by frequency |
| K = all unique | Just return unique elements | Counter.most_common() |
| Streaming data | Frequencies change | More complex approach |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Top K Pattern Overview](./4.1-Top-K-Overview.md)
- [Hash Maps](../../09-Hashing.md)
- [Heap Operations](../02-Heap-Operations/)

**After mastering this:**
- [Top K Frequent Words (LC 692)](./4.6-Top-K-Frequent-Words-LC692.md) - Custom comparator
- [Sort Characters by Frequency (LC 451)](https://leetcode.com/problems/sort-characters-by-frequency/)

**Combines with:**
- Frequency counting (Counter/dict)
- Min-heap for Top K

</details>

---

## üìê How It Works

### Step 1: Count Frequencies

```
nums = [1,1,1,2,2,3], k = 2

Frequency count:
{1: 3, 2: 2, 3: 1}
```

### Step 2: Use Heap for Top K

```
Min-heap of size K by frequency:

Process (1, freq=3): heap = [(3, 1)]
Process (2, freq=2): heap = [(2, 2), (3, 1)]  # size = K
Process (3, freq=1): 1 < root(2), skip (or push and pop)

Final heap: [(2, 2), (3, 1)]
Elements: [2, 1] or [1, 2] ‚Üê Top 2 most frequent
```

### Alternative: Bucket Sort Approach

```
If max frequency is m, create m buckets:

Bucket[3] = [1]      # elements with freq 3
Bucket[2] = [2]      # elements with freq 2
Bucket[1] = [3]      # elements with freq 1

Read from highest bucket down, take K elements:
Bucket[3] ‚Üí [1]
Bucket[2] ‚Üí [2]
Result: [1, 2] ‚úì
```

---

## üíª Code Implementation

### Approach 1: Min-Heap (Standard)

**Python:**
```python
import heapq
from collections import Counter

def topKFrequent(nums: list[int], k: int) -> list[int]:
    """
    Find K most frequent elements using min-heap.
    
    Time: O(n log k) - count O(n), heap ops O(n log k)
    Space: O(n) - counter and heap
    
    Pattern: Count frequencies, then Top K by frequency.
    """
    # Step 1: Count frequencies - O(n)
    freq = Counter(nums)
    
    # Step 2: Use min-heap of size K - O(n log k)
    # Heap contains (frequency, element)
    min_heap = []
    
    for num, count in freq.items():
        heapq.heappush(min_heap, (count, num))
        if len(min_heap) > k:
            heapq.heappop(min_heap)  # Remove lowest frequency
    
    # Extract elements from heap
    return [num for count, num in min_heap]
```

**JavaScript:**
```javascript
var topKFrequent = function(nums, k) {
    // Step 1: Count frequencies
    const freq = new Map();
    for (const num of nums) {
        freq.set(num, (freq.get(num) || 0) + 1);
    }
    
    // Step 2: Min-heap of size K
    class MinHeap {
        constructor() { this.heap = []; }
        size() { return this.heap.length; }
        peek() { return this.heap[0]; }
        
        push(val) {
            this.heap.push(val);
            this._bubbleUp(this.heap.length - 1);
        }
        
        pop() {
            if (this.size() === 0) return undefined;
            const min = this.heap[0];
            const last = this.heap.pop();
            if (this.size() > 0) {
                this.heap[0] = last;
                this._bubbleDown(0);
            }
            return min;
        }
        
        _bubbleUp(i) {
            while (i > 0) {
                const parent = Math.floor((i - 1) / 2);
                if (this.heap[parent][0] <= this.heap[i][0]) break;
                [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
                i = parent;
            }
        }
        
        _bubbleDown(i) {
            const n = this.size();
            while (true) {
                let smallest = i;
                const left = 2 * i + 1, right = 2 * i + 2;
                if (left < n && this.heap[left][0] < this.heap[smallest][0]) smallest = left;
                if (right < n && this.heap[right][0] < this.heap[smallest][0]) smallest = right;
                if (smallest === i) break;
                [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
                i = smallest;
            }
        }
    }
    
    const minHeap = new MinHeap();
    
    for (const [num, count] of freq) {
        minHeap.push([count, num]);
        if (minHeap.size() > k) {
            minHeap.pop();
        }
    }
    
    return minHeap.heap.map(([count, num]) => num);
};
```

### Approach 2: Bucket Sort (O(n) Time)

**Python:**
```python
from collections import Counter

def topKFrequent(nums: list[int], k: int) -> list[int]:
    """
    Bucket sort approach - O(n) time.
    
    Create buckets indexed by frequency.
    Max frequency is n, so n+1 buckets.
    
    Time: O(n), Space: O(n)
    """
    # Step 1: Count frequencies
    freq = Counter(nums)
    
    # Step 2: Create buckets by frequency
    # bucket[i] = list of elements with frequency i
    n = len(nums)
    buckets = [[] for _ in range(n + 1)]
    
    for num, count in freq.items():
        buckets[count].append(num)
    
    # Step 3: Collect K elements from highest buckets
    result = []
    for i in range(n, 0, -1):  # Start from highest frequency
        for num in buckets[i]:
            result.append(num)
            if len(result) == k:
                return result
    
    return result
```

**JavaScript:**
```javascript
var topKFrequent = function(nums, k) {
    // Bucket sort - O(n) time
    
    // Step 1: Count frequencies
    const freq = new Map();
    for (const num of nums) {
        freq.set(num, (freq.get(num) || 0) + 1);
    }
    
    // Step 2: Create buckets
    const n = nums.length;
    const buckets = Array.from({ length: n + 1 }, () => []);
    
    for (const [num, count] of freq) {
        buckets[count].push(num);
    }
    
    // Step 3: Collect K elements from highest buckets
    const result = [];
    for (let i = n; i > 0 && result.length < k; i--) {
        result.push(...buckets[i]);
    }
    
    return result.slice(0, k);
};
```

### Approach 3: Python One-Liner (Interview Shortcut)

**Python:**
```python
from collections import Counter

def topKFrequent(nums: list[int], k: int) -> list[int]:
    """Using Counter.most_common() - built-in optimized."""
    return [num for num, count in Counter(nums).most_common(k)]
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Min-heap |" O(n log k) "| O(n + k) | Standard approach |
| Bucket sort |" O(n) "| O(n) | Optimal time |
| Sort by freq |" O(n log n) "| O(n) | Simple but slower |
| Counter.most_common |" O(n log k) "| O(n) | Python built-in |

**When to use which:**
- **Heap:** General purpose, works for any K
- **Bucket sort:** When you need O(n) and max frequency ‚â§ n
- **Sort:** When code simplicity matters most

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **Top K Words** | Tiebreaker by lexical order | LC 692 |
| **Sort by Frequency** | Need all elements sorted | LC 451 |
| **Bottom K** | Use max-heap | Reverse logic |
| **Streaming** | Maintain running frequencies | More complex |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Heap Comparison Issues with Tuples

```python
# ‚ùå Risky: When frequencies are equal, Python compares next element
heap = []
heapq.heappush(heap, (2, [1, 2]))  # Lists aren't comparable!

# ‚úÖ Safe: Add unique tiebreaker
counter = 0
heapq.heappush(heap, (2, counter, num))
counter += 1
```

### 2. Returning Wrong Structure

```python
# ‚ùå Wrong: Returning (freq, num) tuples
return min_heap  # [(2, 2), (3, 1)] - wrong!

# ‚úÖ Correct: Extract just the elements
return [num for freq, num in min_heap]  # [2, 1]
```

### 3. Forgetting to Handle Edge Cases

```python
# ‚ùå Missing: k equals number of unique elements
if k == len(freq):
    return list(freq.keys())

# Actually, the normal algorithm handles this fine
```

### 4. Off-by-One in Bucket Sort

```python
# ‚ùå Wrong: Bucket size
buckets = [[] for _ in range(n)]  # Max index is n-1, but freq can be n!

# ‚úÖ Correct: n+1 buckets for frequencies 0 to n
buckets = [[] for _ in range(n + 1)]
```

---

## üìù Practice Problems (Progressive)

### Easy (Build up)
- [ ] [Single Number (LC 136)](https://leetcode.com/problems/single-number/) - Frequency basics

### Medium (Core problem)
- [ ] [Top K Frequent Elements (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/) - **This problem**
- [ ] [Top K Frequent Words (LC 692)](https://leetcode.com/problems/top-k-frequent-words/) - With tiebreaker
- [ ] [Sort Characters by Frequency (LC 451)](https://leetcode.com/problems/sort-characters-by-frequency/)

### Hard (Extensions)
- [ ] [Find Median from Data Stream (LC 295)](https://leetcode.com/problems/find-median-from-data-stream/) - Related heap problem

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement heap approach
- **Day 3:** Implement bucket sort approach
- **Day 7:** Solve LC 692 (with tiebreaker)
- **Day 14:** Explain when to use each approach
- **Day 30:** Code both approaches from memory

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening:**
"This is a Top K frequency problem. I'll first count frequencies with a hash map in O(n), then use a min-heap of size K to find the K most frequent elements in O(n log k)."

**If asked about optimization:**
"I can also use bucket sort for O(n) time. Since max frequency is at most n, I create n buckets where bucket[i] holds elements with frequency i. Then I iterate from highest bucket down."

**Trade-offs:**
| Approach | Time | Space | Code Complexity |
|----------|------|-------|-----------------|
| Heap |" O(n log k) "| O(n) | Medium |
| Bucket |" O(n) "| O(n) | Medium |
| Sort |" O(n log n) "| O(n) | Simple |

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Frequent + follow-ups |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | May ask for bucket sort |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Standard |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 2-3 min | Clear statement |
| Code heap solution | 8-10 min | Two-step process |
| Code bucket sort | 10-12 min | Alternative |
| Discuss trade-offs | 3-5 min | Important |
| Total interview time | 20-25 min | With optimization discussion |

---

## üí° Key Insight

> **Two-step pattern:** First count with a hash map, then apply Top K pattern on the frequencies. This combines two fundamental operations into a clean solution. The bucket sort optimization shows that when values are bounded (frequency ‚â§ n), we can achieve O(n) time.

---

## üîó Related

- **Previous:** [Kth Largest (LC 215)](./4.2-Kth-Largest-LC215.md)
- **Next:** [K Closest Points (LC 973)](./4.5-K-Closest-Points-LC973.md)
- **Variant:** [Top K Frequent Words (LC 692)](./4.6-Top-K-Frequent-Words-LC692.md)
