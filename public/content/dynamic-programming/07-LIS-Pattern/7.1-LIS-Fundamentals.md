# LIS Pattern: Longest Increasing Subsequence

> **The foundation for sequence ordering problems.** LIS teaches you how to find optimal orderings in sequences. The O(n log n) binary search solution is a classic interview optimization that demonstrates algorithmic creativity.

---

## üìã Overview

The **Longest Increasing Subsequence (LIS)** pattern applies to problems where you need to find the longest sequence where elements maintain a specific order (increasing, decreasing, or some custom ordering).

**Core Problems:**
- Longest Increasing Subsequence
- Number of Longest Increasing Subsequences  
- Russian Doll Envelopes
- Longest Chain / Box Stacking
- Maximum Sum Increasing Subsequence

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify LIS Pattern</strong></summary>

**Look for these signals:**
- Finding longest sequence with ordering constraint
- Single array/sequence (unlike LCS which has two)
- "Increasing", "decreasing", or "sorted" requirement
- Elements can be skipped (subsequence, not subarray)

**Keywords in problem statement:**
- "longest increasing"
- "longest chain"
- "maximum length sequence where..."
- "can stack/nest if..."

**Red flag that it's NOT LIS:**
- "Contiguous" elements required ‚Üí Use Kadane's or Sliding Window
- Two sequences to compare ‚Üí Use LCS

</details>

---

## ‚úÖ When to Use LIS Pattern

| Scenario | Example Problem |
|----------|-----------------|
| Find longest ordered subsequence | LIS, Longest Decreasing |
| Stack/nest items by size | Russian Dolls, Box Stacking |
| Find longest chain | Longest Chain of Pairs |
| Maximize sum with ordering | Max Sum Increasing Subseq |

## ‚ùå When NOT to Use

| Scenario | Use Instead |
|----------|-------------|
| Contiguous subarray needed | Kadane's, Sliding Window |
| Two sequences to compare | LCS pattern |
| Partition into groups | Different DP or Greedy |
| Need all LIS (count/list) | Modified DP or Segment Tree |

---

## üìê Two Core Approaches

### Approach 1: Classic O(n¬≤) DP

```
dp[i] = length of LIS ending at index i

Recurrence: dp[i] = max(dp[j] + 1) for all j < i where arr[j] < arr[i]
Base case: dp[i] = 1 (each element is an LIS of length 1)
```

### Approach 2: O(n log n) Binary Search

Maintain a "tails" array where `tails[len]` = smallest ending element for LIS of length `len+1`.

Key insight: This array is always sorted, so we can binary search!

---

## üíª Core LIS Implementations

### Solution 1: O(n¬≤) DP

```python
def length_of_lis(nums: list[int]) -> int:
    """
    Classic DP approach.
    Time: O(n¬≤), Space: O(n)
    """
    if not nums:
        return 0
    
    n = len(nums)
    # dp[i] = LIS length ending at index i
    dp = [1] * n
    
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)
```

```javascript
function lengthOfLIS(nums) {
    if (!nums.length) return 0;
    
    const n = nums.length;
    const dp = new Array(n).fill(1);
    
    for (let i = 1; i < n; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    
    return Math.max(...dp);
}
```

### Solution 2: O(n log n) Binary Search

```python
import bisect

def length_of_lis_optimal(nums: list[int]) -> int:
    """
    Binary search approach.
    Time: O(n log n), Space: O(n)
    
    tails[i] = smallest ending value for LIS of length i+1
    """
    tails = []
    
    for num in nums:
        # Find position where num should go
        pos = bisect.bisect_left(tails, num)
        
        if pos == len(tails):
            # num is larger than all tails - extend LIS
            tails.append(num)
        else:
            # Replace to maintain smallest ending value
            tails[pos] = num
    
    return len(tails)
```

```javascript
function lengthOfLISOptimal(nums) {
    const tails = [];
    
    for (const num of nums) {
        let left = 0, right = tails.length;
        
        // Binary search for leftmost position >= num
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (tails[mid] < num) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        if (left === tails.length) {
            tails.push(num);
        } else {
            tails[left] = num;
        }
    }
    
    return tails.length;
}
```

### Understanding the O(n log n) Approach

```
nums = [10, 9, 2, 5, 3, 7, 101, 18]

Process each number:
  10: tails = [10]           LIS = 1
   9: tails = [9]            9 replaces 10 (smaller ending)
   2: tails = [2]            2 replaces 9
   5: tails = [2, 5]         5 extends (5 > 2)
   3: tails = [2, 3]         3 replaces 5 (smaller ending for len 2)
   7: tails = [2, 3, 7]      7 extends
 101: tails = [2, 3, 7, 101] 101 extends
  18: tails = [2, 3, 7, 18]  18 replaces 101

Final length = 4

Note: tails = [2,3,7,18] is NOT the actual LIS!
      It just has the right length.
      Actual LIS could be [2,5,7,101] or [2,3,7,18] etc.
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space |
|----------|------|-------|
| O(n¬≤) DP | O(n¬≤) | O(n) |
| Binary Search | O(n log n) | O(n) |

**When to use which:**
- O(n¬≤): Need actual subsequence, smaller n, clearer logic
- O(n log n): Just need length, large n, performance critical

---

## üîÑ LIS Variations

### 1. Recover Actual LIS

```python
def get_lis(nums: list[int]) -> list[int]:
    """Return one actual LIS, not just length."""
    n = len(nums)
    dp = [1] * n
    parent = [-1] * n
    
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i] and dp[j] + 1 > dp[i]:
                dp[i] = dp[j] + 1
                parent[i] = j
    
    # Find ending index of LIS
    max_len = max(dp)
    end_idx = dp.index(max_len)
    
    # Backtrack to build LIS
    lis = []
    while end_idx != -1:
        lis.append(nums[end_idx])
        end_idx = parent[end_idx]
    
    return lis[::-1]
```

### 2. Count Number of LIS (LC 673)

```python
def find_number_of_lis(nums: list[int]) -> int:
    """Count how many LIS exist."""
    n = len(nums)
    if n == 0:
        return 0
    
    length = [1] * n  # LIS length ending at i
    count = [1] * n   # Number of LIS ending at i
    
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                if length[j] + 1 > length[i]:
                    length[i] = length[j] + 1
                    count[i] = count[j]
                elif length[j] + 1 == length[i]:
                    count[i] += count[j]
    
    max_len = max(length)
    return sum(c for l, c in zip(length, count) if l == max_len)
```

### 3. Longest Non-Decreasing Subsequence

```python
def longest_non_decreasing(nums: list[int]) -> int:
    """Allow equal elements (‚â§ instead of <)."""
    import bisect
    
    tails = []
    for num in nums:
        # Use bisect_right for non-decreasing (allow equals)
        pos = bisect.bisect_right(tails, num)
        if pos == len(tails):
            tails.append(num)
        else:
            tails[pos] = num
    
    return len(tails)
```

### 4. Longest Decreasing Subsequence

```python
def longest_decreasing(nums: list[int]) -> int:
    """Just negate or reverse logic."""
    # Method 1: Negate values
    return length_of_lis_optimal([-x for x in nums])
    
    # Method 2: Reverse array
    # return length_of_lis_optimal(nums[::-1])
```

### 5. Maximum Sum Increasing Subsequence

```python
def max_sum_increasing_subseq(nums: list[int]) -> int:
    """Maximum sum instead of maximum length."""
    n = len(nums)
    dp = nums[:]  # dp[i] = max sum ending at i
    
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + nums[i])
    
    return max(dp)
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Confusing < with <=

**‚ùå Wrong (allows duplicates):**
```python
if nums[j] <= nums[i]:  # Wrong for STRICTLY increasing
    dp[i] = max(dp[i], dp[j] + 1)
```

**‚úÖ Correct:**
```python
if nums[j] < nums[i]:  # Strictly increasing
    dp[i] = max(dp[i], dp[j] + 1)
```

### 2. Using Wrong bisect Function

```python
# bisect_left: strictly increasing (< not <=)
pos = bisect.bisect_left(tails, num)

# bisect_right: non-decreasing (<= allowed)
pos = bisect.bisect_right(tails, num)
```

### 3. Thinking tails[] IS the LIS

**‚ùå Wrong:**
```python
tails = length_of_lis_binary_search(nums)
return tails  # This is NOT the actual LIS!
```

**‚úÖ Correct:**
```python
# tails[] gives correct LENGTH
# To get actual LIS, use O(n¬≤) with parent tracking
```

### 4. Forgetting Each Element is LIS of Length 1

```python
# Base case: every element alone is an LIS of length 1
dp = [1] * n  # NOT [0] * n
```

---

## üìä LIS Problem: Russian Doll Envelopes (LC 354)

**Problem:** Given envelopes with (width, height), find max envelopes you can nest.

**Key insight:** Sort by width ascending, then height DESCENDING. Now find LIS on heights!

```python
def max_envelopes(envelopes: list[list[int]]) -> int:
    """
    Sort by width ascending, height DESCENDING.
    Then LIS on heights.
    """
    import bisect
    
    # Sort: width ascending, height descending
    envelopes.sort(key=lambda x: (x[0], -x[1]))
    
    # LIS on heights
    tails = []
    for _, h in envelopes:
        pos = bisect.bisect_left(tails, h)
        if pos == len(tails):
            tails.append(h)
        else:
            tails[pos] = h
    
    return len(tails)
```

**Why height descending?**
- If we have same width, we can only pick ONE envelope
- Descending height ensures we can't pick multiple same-width envelopes
- When heights are descending, LIS can't pick consecutive same-width ones

---

## üìù Practice Problems (Progressive)

### Easy-Medium
- [ ] [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) - Core problem
- [ ] [674. Longest Continuous Increasing Subsequence](https://leetcode.com/problems/longest-continuous-increasing-subsequence/) - Contiguous version

### Medium
- [ ] [673. Number of Longest Increasing Subsequence](https://leetcode.com/problems/number-of-longest-increasing-subsequence/) - Count all LIS
- [ ] [354. Russian Doll Envelopes](https://leetcode.com/problems/russian-doll-envelopes/) - 2D LIS
- [ ] [646. Maximum Length of Pair Chain](https://leetcode.com/problems/maximum-length-of-pair-chain/) - Interval LIS
- [ ] [1048. Longest String Chain](https://leetcode.com/problems/longest-string-chain/) - String LIS

### Hard
- [ ] [1964. Find the Longest Valid Obstacle Course at Each Position](https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/) - Running LIS
- [ ] [2111. Minimum Operations to Make the Array K-Increasing](https://leetcode.com/problems/minimum-operations-to-make-the-array-k-increasing/) - LIS application

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: Basic LIS (O(n¬≤))
- Day 3: LIS with binary search (O(n log n))
- Day 5: Count Number of LIS
- Day 7: Review and compare approaches

**Week 2:**
- Day 8: Russian Doll Envelopes (2D reduction)
- Day 10: Longest String Chain
- Day 12: Maximum Sum Increasing Subsequence
- Day 14: Pattern review

</details>

---

## üé§ Interview Tips

**Time to solve:**
- O(n¬≤) approach: 10-15 minutes
- O(n log n) approach: 20-25 minutes

**Communication for O(n¬≤):**
> "I'll use dp[i] for the LIS length ending at index i. For each position, I check all previous elements‚Äîif they're smaller, I can extend their LIS. The answer is the maximum across all dp values."

**Communication for O(n log n):**
> "I'll maintain a 'tails' array where tails[len-1] is the smallest ending value for an LIS of that length. Since this array stays sorted, I can binary search to find where each new element should go. If it extends, I append; otherwise, I replace to maintain optimality."

**Key insight to mention:**
> "The tails array doesn't give us the actual LIS‚Äîjust the length. The values change as we process, but the LENGTH is always correct."

**Company frequency:**
| Company | Frequency |
|---------|-----------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Meta | ‚≠ê‚≠ê‚≠ê |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Learn O(n¬≤) DP | 30 min |
| Learn O(n log n) | 45 min |
| Solve basic LIS | 15-20 min |
| Solve Russian Dolls | 25-30 min |
| Master pattern | 6-8 problems |

---

> **üí° Key Insight:** The O(n log n) binary search approach is brilliant because it maintains invariants (smallest ending for each length) that allow efficient updates. The tails array is NOT the LIS itself‚Äîit's a clever data structure that tracks "what's possible" at each length.

> **üîó Related:** [Fibonacci Pattern](../02-Fibonacci-Pattern/) | [Interval DP](../08-Interval-DP/) | [Binary Search Patterns](../../03-Sorting-Searching/)
