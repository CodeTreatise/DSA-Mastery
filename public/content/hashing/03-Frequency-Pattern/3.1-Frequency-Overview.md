# Frequency Counting Pattern

> **The most common hash map usage: count occurrences in O(n) time.**

Frequency counting is the foundation of many hash map problems. The pattern is simple: iterate through data, counting occurrences of each element. This enables O(n) solutions to problems that would otherwise require O(n¬≤) or sorting.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Count occurrences", "frequency", "how many times"
- "Most common", "least common", "top K frequent"
- "Anagram" (same character frequencies)
- "First/last unique", "appears once/twice"
- Comparing two collections for same elements

**Keywords in problem statement:**
- "count", "frequency", "occurrences"
- "majority", "most frequent", "top K"
- "unique", "distinct", "appears only once"
- "anagram", "permutation"

**Pattern variations:**
1. Count and compare (anagram check)
2. Count and find (first unique)
3. Count and sort (top K frequent)
4. Count and validate (character constraints)

</details>

---

## ‚úÖ When to Use

- Counting element occurrences
- Finding most/least frequent elements
- Comparing two collections by content (anagrams)
- Finding elements that appear specific number of times
- Grouping by frequency

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Elements are in small fixed range | Array counting is O(1) space | Array index as counter |
| Only need existence, not count | Simpler structure | Hash Set |
| Need ordered frequencies | Counter doesn't sort | Counter + sorting |
| Streaming with limited memory | Can't store all counts | Probabilistic (Count-Min Sketch) |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Hash Map Basics](../02-Hash-Map-Set/2.1-Hash-Map-Basics.md)
- Basic array iteration
- Python `collections.Counter` / JS `Map`

**After mastering this:**
- [Top K Frequent](./3.4-Top-K-Frequent-LC347.md) - Combines with Heap/Bucket Sort
- [Group Anagrams](../06-Grouping-Pattern/6.2-Group-Anagrams-LC49.md) - Grouping by frequency signature
- Sliding Window problems with frequency constraints

**Combines with:**
- Heap for Top K problems
- Bucket Sort for O(n) sorting by frequency
- Sliding Window for substring problems

</details>

---

## üìê How It Works

### Core Pattern

```python
# Basic frequency counting
freq = {}
for item in collection:
    freq[item] = freq.get(item, 0) + 1
```

### Python's Counter (Preferred)

```python
from collections import Counter

# Automatic frequency counting
freq = Counter(collection)

# Common operations
freq.most_common(k)      # Top k elements by frequency
freq.total()             # Sum of all counts (Python 3.10+)
freq.elements()          # Iterator of elements (repeated by count)
freq1 - freq2            # Subtract counts
freq1 & freq2            # Intersection (min counts)
freq1 | freq2            # Union (max counts)
```

### JavaScript Equivalents

```javascript
// Using Map
const freq = new Map();
for (const item of collection) {
    freq.set(item, (freq.get(item) || 0) + 1);
}

// Using Object (string keys only)
const freq = {};
for (const item of collection) {
    freq[item] = (freq[item] || 0) + 1;
}
```

### Visualization: Anagram Check

```
word1 = "listen"
word2 = "silent"

Count word1: {l:1, i:1, s:1, t:1, e:1, n:1}
Count word2: {s:1, i:1, l:1, e:1, n:1, t:1}

Same counts? Yes ‚Üí Anagram! ‚úì

Alternative: Count up for word1, count down for word2
            All zeros at end ‚Üí Anagram
```

### Visualization: First Unique

```
string = "leetcode"

Step 1: Count all characters
        {l:1, e:3, t:1, c:1, o:1, d:1}

Step 2: Find first with count = 1
        l ‚Üí count=1 ‚Üí FOUND at index 0

Answer: index 0
```

---

## üíª Code Implementation

### Python - Basic Patterns

```python
from collections import Counter, defaultdict
from typing import List

# Pattern 1: Count occurrences
def count_elements(arr: List[int]) -> dict:
    """Count frequency of each element."""
    return Counter(arr)

# Pattern 2: Check anagram
def is_anagram(s: str, t: str) -> bool:
    """
    Check if t is an anagram of s.
    Time: O(n), Space: O(1) for 26 letters
    """
    return Counter(s) == Counter(t)

# Pattern 3: Find first unique
def first_unique(s: str) -> int:
    """
    Return index of first non-repeating character.
    Time: O(n), Space: O(1) for 26 letters
    """
    freq = Counter(s)
    for i, char in enumerate(s):
        if freq[char] == 1:
            return i
    return -1

# Pattern 4: Majority element (appears > n/2 times)
def majority_element(nums: List[int]) -> int:
    """
    Find element appearing more than n/2 times.
    Time: O(n), Space: O(n)
    """
    freq = Counter(nums)
    return freq.most_common(1)[0][0]

# Pattern 5: Top K frequent
def top_k_frequent(nums: List[int], k: int) -> List[int]:
    """
    Return k most frequent elements.
    Time: O(n), Space: O(n)
    """
    freq = Counter(nums)
    return [item for item, count in freq.most_common(k)]

# Pattern 6: Single number (appears once, others appear twice)
def single_number(nums: List[int]) -> int:
    """Find the element that appears only once."""
    freq = Counter(nums)
    for num, count in freq.items():
        if count == 1:
            return num
    return -1  # Note: XOR approach is O(1) space
```

### Python - defaultdict Patterns

```python
from collections import defaultdict

# Pattern: Group by frequency
def group_by_frequency(arr: List[int]) -> dict:
    """Group elements by their frequency."""
    freq = Counter(arr)
    groups = defaultdict(list)
    for num, count in freq.items():
        groups[count].append(num)
    return dict(groups)

# Pattern: Count with custom accumulator
def character_positions(s: str) -> dict:
    """Map each character to list of its positions."""
    positions = defaultdict(list)
    for i, char in enumerate(s):
        positions[char].append(i)
    return dict(positions)
```

### JavaScript

```javascript
// Pattern 1: Count occurrences
function countElements(arr) {
    const freq = new Map();
    for (const item of arr) {
        freq.set(item, (freq.get(item) || 0) + 1);
    }
    return freq;
}

// Pattern 2: Check anagram
function isAnagram(s, t) {
    if (s.length !== t.length) return false;
    
    const freq = new Map();
    
    // Count characters in s
    for (const char of s) {
        freq.set(char, (freq.get(char) || 0) + 1);
    }
    
    // Subtract characters in t
    for (const char of t) {
        if (!freq.has(char)) return false;
        freq.set(char, freq.get(char) - 1);
        if (freq.get(char) === 0) freq.delete(char);
    }
    
    return freq.size === 0;
}

// Pattern 3: First unique character
function firstUnique(s) {
    const freq = new Map();
    
    for (const char of s) {
        freq.set(char, (freq.get(char) || 0) + 1);
    }
    
    for (let i = 0; i < s.length; i++) {
        if (freq.get(s[i]) === 1) {
            return i;
        }
    }
    
    return -1;
}

// Pattern 4: Top K frequent
function topKFrequent(nums, k) {
    const freq = new Map();
    for (const num of nums) {
        freq.set(num, (freq.get(num) || 0) + 1);
    }
    
    // Convert to array and sort by frequency
    return [...freq.entries()]
        .sort((a, b) => b[1] - a[1])
        .slice(0, k)
        .map(([num]) => num);
}

// Pattern 5: Majority element
function majorityElement(nums) {
    const freq = new Map();
    const threshold = Math.floor(nums.length / 2);
    
    for (const num of nums) {
        const count = (freq.get(num) || 0) + 1;
        freq.set(num, count);
        if (count > threshold) return num;
    }
    
    return -1;
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Count all elements | O(n) | O(k) | k = unique elements |
| Check anagram | O(n) | O(1)* | *26 letters = constant |
| First unique | O(n) | O(1)* | Two passes |
| Majority element | O(n) | O(n) | Or O(1) with Boyer-Moore |
| Top K frequent | O(n log k) | O(n) | With heap |

**Space Considerations:**
- For lowercase letters: O(26) = O(1)
- For unicode: O(n) worst case
- For integers: O(n) worst case

---

## üîÑ Variations

| Variation | Description | Example Problem |
|-----------|-------------|-----------------|
| **Count and Compare** | Compare frequencies of two collections | Valid Anagram |
| **Count and Find** | Find element with specific frequency | First Unique Character |
| **Count and Sort** | Order by frequency | Top K Frequent |
| **Count with Constraint** | Frequency meets condition | Majority Element |
| **Sliding Count** | Maintain frequency in window | Minimum Window Substring |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Handle Missing Keys

```python
# ‚ùå WRONG: KeyError if key doesn't exist
freq = {}
freq['a'] += 1  # KeyError!

# ‚úÖ CORRECT: Use .get() or defaultdict
freq['a'] = freq.get('a', 0) + 1
# OR
from collections import defaultdict
freq = defaultdict(int)
freq['a'] += 1
```

### 2. Not Handling Different Lengths

```python
# ‚ùå WRONG: Anagram check without length check
def is_anagram(s, t):
    return Counter(s) == Counter(t)  # Works but inefficient

# ‚úÖ BETTER: Early return for different lengths
def is_anagram(s, t):
    if len(s) != len(t):
        return False
    return Counter(s) == Counter(t)
```

### 3. Modifying Counter While Iterating

```python
# ‚ùå WRONG: Modifying during iteration
freq = Counter([1, 2, 2, 3])
for num in freq:
    if freq[num] == 1:
        del freq[num]  # RuntimeError!

# ‚úÖ CORRECT: Create list of keys first
for num in list(freq.keys()):
    if freq[num] == 1:
        del freq[num]
```

### 4. Case Sensitivity

```python
# ‚ùå WRONG: "Listen" and "Silent" won't match
def is_anagram(s, t):
    return Counter(s) == Counter(t)
    # "Listen" vs "Silent" ‚Üí False!

# ‚úÖ CORRECT: Normalize case if needed
def is_anagram(s, t):
    return Counter(s.lower()) == Counter(t.lower())
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)

| Problem | Link | Focus |
|---------|------|-------|
| Valid Anagram | [LC 242](https://leetcode.com/problems/valid-anagram/) | Basic frequency comparison |
| First Unique Character | [LC 387](https://leetcode.com/problems/first-unique-character-in-a-string/) | Count then find |
| Contains Duplicate | [LC 217](https://leetcode.com/problems/contains-duplicate/) | Set for uniqueness |
| Majority Element | [LC 169](https://leetcode.com/problems/majority-element/) | Frequency threshold |

### Medium (Apply variations)

| Problem | Link | Focus |
|---------|------|-------|
| Top K Frequent Elements | [LC 347](https://leetcode.com/problems/top-k-frequent-elements/) | Count + sort |
| Group Anagrams | [LC 49](https://leetcode.com/problems/group-anagrams/) | Frequency as key |
| Sort Characters By Frequency | [LC 451](https://leetcode.com/problems/sort-characters-by-frequency/) | Count + build string |
| Find All Anagrams | [LC 438](https://leetcode.com/problems/find-all-anagrams-in-a-string/) | Sliding window frequency |

### Hard (Master edge cases)

| Problem | Link | Focus |
|---------|------|-------|
| Minimum Window Substring | [LC 76](https://leetcode.com/problems/minimum-window-substring/) | Sliding window + count |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve LC 242 (Valid Anagram) - understand Counter
- **Day 3:** Solve LC 387 (First Unique) - count then find pattern
- **Day 7:** Solve LC 347 (Top K) - combine with sorting/heap
- **Day 14:** Solve LC 438 (Find Anagrams) - sliding window + frequency
- **Day 30:** Should be automatic for any frequency problem

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interview</strong></summary>

**Recognize the pattern:**
> "This looks like a frequency counting problem. I'll use a hash map to count occurrences in O(n) time."

**Python shortcut:**
> "In Python, I'll use Counter from collections which gives me frequency counting plus useful methods like most_common()."

**Space discussion:**
> "Space complexity is O(k) where k is the number of unique elements. For lowercase letters, this is effectively O(1) since k ‚â§ 26."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common pattern |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Often combined with other patterns |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Expects clean Counter usage |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Common in string problems |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Learn Counter/Map basics | 15-20 min |
| Solve Valid Anagram | 5-10 min |
| Solve Top K Frequent | 15-20 min |
| Master pattern variations | 1-2 hours |

---

> **üí° Key Insight:** Frequency counting transforms "how many of each?" questions into O(n) solutions. The hash map trades O(n) space for avoiding O(n¬≤) nested loops or O(n log n) sorting.

> **üîó Related:** [Valid Anagram](./3.2-Valid-Anagram-LC242.md) | [First Unique](./3.3-First-Unique-Char-LC387.md) | [Top K Frequent](./3.4-Top-K-Frequent-LC347.md)
