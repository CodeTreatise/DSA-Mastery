# 5.4 IPO (LC 502)

## Problem Statement

You are given `n` projects with profits `profits[i]` and minimum capital requirements `capital[i]`. You start with capital `w`. Complete at most `k` projects to **maximize your capital**.

You can only start a project if your current capital is â‰¥ its required capital. After completing a project, its profit is added to your capital.

```
Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
Output: 4

Explanation:
- Initial capital = 0
- Start project 0 (capital=0, profit=1): capital becomes 0+1 = 1
- Start project 2 (capital=1, profit=3): capital becomes 1+3 = 4
- Maximum capital = 4
```

**LeetCode:** [502. IPO](https://leetcode.com/problems/ipo/)

---

## ðŸŽ¯ Pattern Recognition

<details>
<summary><strong>Pattern: Two Heaps for Dynamic Selection</strong></summary>

**Key signals:**
- Selection based on constraint (capital)
- Maximize within available options (max profit)
- Constraint changes after each selection (capital increases)

**Why Two Heaps:**
```
Need to track two things:
1. Which projects are available? (capital â‰¤ current w)
2. Among available, which is best? (max profit)

Min-heap: Projects sorted by capital requirement
  â†’ Efficiently find newly available projects

Max-heap: Available projects sorted by profit
  â†’ Efficiently select most profitable
```

**The pattern:**
```
While can do more projects and have options:
  1. Move newly affordable projects to "available" pool
  2. Pick most profitable from available
  3. Update capital, repeat
```

</details>

---

## âœ… When to Use This Pattern

| Scenario | Approach |
|----------|----------|
| Select from dynamic pool | Two heaps |
| Constraint unlocks more options | Min-heap for constraints |
| Maximize selection value | Max-heap for values |

## âŒ When NOT to Use

| Scenario | Better Alternative |
|----------|---------------------|
| Static pool (no constraint changes) | Simple sort |
| All options always available | Just sort by value |
| Need all items, order matters | Topological sort |

---

## ðŸ“ Solution Approach

### Two Heaps Strategy

```
Data Structures:
- min_heap: (capital, profit) - sorted by capital required
- max_heap: (profit) - available projects sorted by profit (negated)

Algorithm:
1. Put all projects in min_heap (sorted by capital)
2. For each of k iterations:
   a. Move all affordable projects (capital â‰¤ w) to max_heap
   b. If max_heap empty, can't do more projects
   c. Pop most profitable, add profit to w
3. Return final w
```

### Walkthrough Example

```
k=2, w=0, profits=[1,2,3], capital=[0,1,1]

Step 1: Initialize
  min_heap = [(0,1), (1,2), (1,3)]  // (capital, profit)
  max_heap = []
  w = 0

Step 2: First project
  Move affordable (capital â‰¤ 0) to max_heap:
    (0,1) â†’ max_heap = [(-1)]
  min_heap = [(1,2), (1,3)]
  
  Pop max_heap: profit = 1
  w = 0 + 1 = 1

Step 3: Second project
  Move affordable (capital â‰¤ 1) to max_heap:
    (1,2), (1,3) â†’ max_heap = [(-3), (-2)]
  min_heap = []
  
  Pop max_heap: profit = 3
  w = 1 + 3 = 4

Step 4: k projects done
  Return w = 4
```

---

## ðŸ’» Code Implementation

### Python Solution

**Python:**
```python
import heapq

def findMaximizedCapital(k: int, w: int, profits: list[int], capital: list[int]) -> int:
    """
    LC 502: IPO - Maximize capital by selecting k projects.
    
    Two Heaps:
    - min_heap: (capital_required, profit) - unlock order
    - max_heap: (-profit) - selection order
    
    Time: O(n log n) for heap operations
    Space: O(n) for heaps
    """
    n = len(profits)
    
    # Min-heap: (capital required, profit, index)
    # Sorted by capital to efficiently find newly affordable projects
    min_heap = [(capital[i], profits[i]) for i in range(n)]
    heapq.heapify(min_heap)
    
    # Max-heap: -profit of available projects
    max_heap = []
    
    for _ in range(k):
        # Move all affordable projects to max_heap
        while min_heap and min_heap[0][0] <= w:
            cap, profit = heapq.heappop(min_heap)
            heapq.heappush(max_heap, -profit)
        
        # If no affordable projects, can't continue
        if not max_heap:
            break
        
        # Take most profitable available project
        w += -heapq.heappop(max_heap)
    
    return w


# Example
k, w = 2, 0
profits = [1, 2, 3]
capital = [0, 1, 1]
print(findMaximizedCapital(k, w, profits, capital))  # 4
```

### Optimized Version

**Python:**
```python
import heapq

def findMaximizedCapital_optimized(k: int, w: int, profits: list[int], capital: list[int]) -> int:
    """
    Optimized: Handle case where all projects are affordable.
    """
    n = len(profits)
    
    # Special case: If we can afford all projects, just take k largest profits
    if all(c <= w for c in capital):
        return w + sum(heapq.nlargest(k, profits))
    
    # Combine and sort by capital
    projects = sorted(zip(capital, profits))
    
    max_heap = []
    project_idx = 0
    
    for _ in range(k):
        # Add all affordable projects
        while project_idx < n and projects[project_idx][0] <= w:
            heapq.heappush(max_heap, -projects[project_idx][1])
            project_idx += 1
        
        if not max_heap:
            break
        
        w += -heapq.heappop(max_heap)
    
    return w
```

### JavaScript Solution

**JavaScript:**
```javascript
class MaxHeap {
    constructor() {
        this.heap = [];
    }
    
    size() { return this.heap.length; }
    
    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        const max = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return max;
    }
    
    _bubbleUp(i) {
        while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.heap[parent] >= this.heap[i]) break;
            [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
            i = parent;
        }
    }
    
    _bubbleDown(i) {
        const n = this.heap.length;
        while (true) {
            let largest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;
            if (left < n && this.heap[left] > this.heap[largest]) largest = left;
            if (right < n && this.heap[right] > this.heap[largest]) largest = right;
            if (largest === i) break;
            [this.heap[i], this.heap[largest]] = [this.heap[largest], this.heap[i]];
            i = largest;
        }
    }
}


function findMaximizedCapital(k, w, profits, capital) {
    const n = profits.length;
    
    // Combine and sort by capital
    const projects = capital.map((c, i) => [c, profits[i]]);
    projects.sort((a, b) => a[0] - b[0]);
    
    const maxHeap = new MaxHeap();
    let projectIdx = 0;
    
    for (let i = 0; i < k; i++) {
        // Add all affordable projects
        while (projectIdx < n && projects[projectIdx][0] <= w) {
            maxHeap.push(projects[projectIdx][1]);
            projectIdx++;
        }
        
        if (maxHeap.size() === 0) break;
        
        w += maxHeap.pop();
    }
    
    return w;
}

// Example
console.log(findMaximizedCapital(2, 0, [1, 2, 3], [0, 1, 1]));  // 4
```

---

## âš¡ Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| Initial heap |" O(n) or O(n log n) "| O(n) |
| k iterations |" O(k log n) "| - |
| Move to max_heap |" O(n log n) total "| - |
| **Total** |" O(n log n) "| O(n) |

**Why O(n log n):**
- Each project is pushed to max_heap at most once: O(n log n)
- Each project is popped from max_heap at most once: O(k log n)
- Total: O((n + k) log n) = O(n log n) since k â‰¤ n

---

## ðŸ”„ Variations

| Variation | Change | Approach |
|-----------|--------|----------|
| With cooldown | Wait time between projects | Add time dimension |
| Limited by time | Each project takes time | Knapsack-like |
| Multiple resources | Need multiple constraints | More complex |
| Minimum profit threshold | Only take if profit â‰¥ X | Filter in max_heap pop |

---

## âš ï¸ Common Mistakes

### 1. Not Using Two Heaps

```python
# âŒ Wrong: Sorting once doesn't account for changing capital
projects = sorted(zip(capital, profits))
for cap, profit in projects:
    if cap <= w:
        w += profit  # Wrong! Should pick max profit among affordable

# âœ… Correct: Use max_heap to always pick best affordable
while min_heap and min_heap[0][0] <= w:
    cap, profit = heapq.heappop(min_heap)
    heapq.heappush(max_heap, -profit)
w += -heapq.heappop(max_heap)
```

### 2. Forgetting to Check Empty Max Heap

```python
# âŒ Wrong: Assuming there's always an affordable project
for _ in range(k):
    while min_heap and min_heap[0][0] <= w:
        ...
    w += -heapq.heappop(max_heap)  # Error if max_heap empty!

# âœ… Correct: Check before popping
if not max_heap:
    break
w += -heapq.heappop(max_heap)
```

### 3. Moving Projects to Max Heap After Each Pop

```python
# âŒ Wrong: Only moving affordable after pop
for _ in range(k):
    if min_heap and min_heap[0][0] <= w:  # Only checks one!
        ...
    w += -heapq.heappop(max_heap)

# âœ… Correct: Move ALL affordable at once (while loop)
for _ in range(k):
    while min_heap and min_heap[0][0] <= w:
        cap, profit = heapq.heappop(min_heap)
        heapq.heappush(max_heap, -profit)
    ...
```

### 4. Wrong Heap Type

```python
# âŒ Wrong: Using max-heap for capital (should be min-heap)
# We want smallest capital first (to check affordability)

# âœ… Correct:
# min_heap for capital: smallest capital at top â†’ check if affordable
# max_heap for profit: largest profit at top â†’ select best
```

---

## ðŸ“ Related Practice Problems

### Similar Pattern
- [ ] [Find Median from Data Stream (LC 295)](https://leetcode.com/problems/find-median-from-data-stream/)
- [ ] [Sliding Window Median (LC 480)](https://leetcode.com/problems/sliding-window-median/)

### Greedy with Heaps
- [ ] [Task Scheduler (LC 621)](https://leetcode.com/problems/task-scheduler/)
- [ ] [Meeting Rooms II (LC 253)](https://leetcode.com/problems/meeting-rooms-ii/)
- [ ] [Reorganize String (LC 767)](https://leetcode.com/problems/reorganize-string/)

<details>
<summary><strong>ðŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Understand two-heap approach
- **Day 3:** Implement from scratch
- **Day 7:** Trace through example
- **Day 14:** Compare with other two-heap problems
- **Day 30:** Explain pattern to someone

</details>

---

## ðŸŽ¤ Interview Context

<details>
<summary><strong>How to Communicate This Solution</strong></summary>

**Opening:**
"This is a greedy problem where I always want to pick the most profitable affordable project. The key insight is that as I complete projects, my capital increases, unlocking more options."

**Explaining two heaps:**
"I use a min-heap sorted by capital requirement to efficiently find newly affordable projects. These go into a max-heap sorted by profit so I can always pick the best one."

**Walking through:**
"In each iteration, I first move all projects with capital â‰¤ my current w into the available pool. Then I greedily take the most profitable one and add its profit to my capital."

**Complexity:**
"Each project enters and leaves each heap at most once, so total is O(n log n). Space is O(n) for the heaps."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | â­â­â­â­ | Resource allocation theme |
| Google | â­â­â­ | Hard problems |
| Meta | â­â­â­ | Two heaps pattern |
| Bloomberg | â­â­â­â­ | Financial domain |

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 5-7 min | Read constraints |
| Design solution | 7-10 min | Two heaps insight |
| Implement | 15-18 min | Both heaps |
| Test | 3-5 min | Trace through |

**Interview target:** 30-35 minutes

---

## ðŸ’¡ Key Insight

> **Use two heaps when selection criteria changes dynamically.** Min-heap tracks what becomes available (sorted by unlock condition), max-heap tracks what's best among available (sorted by value). As the constraint relaxes (capital increases), move items from min-heap to max-heap and greedily select the best.

---

## ðŸ”— Related

- **Previous:** [Sliding Window Median (LC 480)](./5.3-Sliding-Window-Median-LC480.md)
- **Pattern:** [Two Heaps Overview](./5.1-Two-Heaps-Overview.md)
- **Related:** [Task Scheduler (LC 621)](../07-Scheduling-Problems/7.2-Task-Scheduler-LC621.md)
