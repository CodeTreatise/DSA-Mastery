# 4.1 Interval Greedy Overview

> **Definition:** Interval problems involve collections of ranges `[start, end]` where we need to optimize some property‚Äîmaximize non-overlapping, merge overlapping, or find minimum to cover.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Interval Problems</strong></summary>

**Look for these signals:**
- Input is array of pairs: `[[s1,e1], [s2,e2], ...]`
- Problems mention: intervals, meetings, ranges, time slots
- Keywords: "overlapping", "merge", "non-overlapping", "cover"

**Visual Recognition:**
```
Timeline problems:
Event A:    [======]
Event B:         [=======]
Event C:                    [====]

Question types:
‚Ä¢ How many can happen without overlap? (Activity Selection)
‚Ä¢ Can we merge overlapping ones? (Merge Intervals)
‚Ä¢ Minimum resources for all? (Meeting Rooms)
‚Ä¢ Minimum arrows to pop? (Min Arrows)
```

</details>

---

## ‚úÖ When to Use Interval Greedy

| Situation | Pattern | Sort By |
|-----------|---------|---------|
| Maximize non-overlapping activities | Activity Selection | **END time** |
| Merge overlapping intervals | Merge Intervals | **START time** |
| Find minimum to cover all | Min Arrows | **END time** |
| Count simultaneous overlap | Meeting Rooms II | **START + END (sweep)** |
| Insert and merge | Insert Interval | **START time** |

---

## ‚ùå When NOT to Use Interval Greedy

| Situation | Better Approach | Why |
|-----------|-----------------|-----|
| Weight/priority on intervals | DP (Weighted Job Scheduling) | Can't just pick by end time |
| Finding ALL non-overlapping sets | Backtracking | Need to enumerate |
| Interval coloring (min colors) | Graph coloring | More complex structure |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Sorting algorithms](../../03-Sorting-Searching.md)
- [Greedy fundamentals](../01-Greedy-Fundamentals/1.1-What-Is-Greedy.md)
- Tuple/pair sorting in your language

**After mastering this:**
- [Weighted Job Scheduling (DP)](../../11-Dynamic-Programming.md)
- [Meeting Rooms II (Heap)](../../08-Heaps-Priority-Queues.md)
- Line sweep algorithms

**Combines with:**
- Heaps for dynamic overlap counting
- Binary search for efficient interval lookup
- Sorting for all interval problems

</details>

---

## üìê The Three Core Interval Patterns

### Pattern 1: Sort by END Time

**Use when:** Maximize number of non-overlapping

```
Goal: Pick maximum activities
Strategy: Pick earliest ENDING first

Timeline:
  [1,4]   [====]
  [2,3]    [=]          ‚Üê Pick this (ends earliest)
  [3,5]      [===]      ‚Üê Pick this (starts after [2,3])
  [4,7]       [====]

Answer: 2 activities
```

**Why it works:** Ending earliest leaves maximum room for remaining activities.

---

### Pattern 2: Sort by START Time

**Use when:** Merge overlapping intervals

```
Goal: Merge overlapping ranges
Strategy: Sort by start, extend end as needed

Timeline:
  [1,3]   [===]
  [2,4]    [===]       ‚Üê Overlaps! Extend end to 4
  [5,7]         [===]  ‚Üê No overlap, new interval

Answer: [[1,4], [5,7]]
```

**Why it works:** Processing left-to-right, we can extend current interval or start new one.

---

### Pattern 3: Sweep Line (Two Pointers/Heap)

**Use when:** Count simultaneous overlaps

```
Goal: Maximum concurrent meetings
Strategy: Track starts and ends separately

Events (sorted):
  +1 at time 1 (meeting starts)
  +1 at time 2 (another starts)
  -1 at time 3 (one ends)
  
Current count at each time:
  Time 1: 1 meeting
  Time 2: 2 meetings ‚Üê Maximum!
  Time 3: 1 meeting

Answer: 2 rooms needed
```

---

## üíª Core Templates

### Template 1: Activity Selection (Sort by End)

```python
def max_non_overlapping(intervals):
    """
    Maximum number of non-overlapping intervals.
    
    Time: O(n log n), Space: O(1)
    
    Pattern: Sort by END time
    """
    if not intervals:
        return 0
    
    # Sort by end time
    intervals.sort(key=lambda x: x[1])
    
    count = 1
    last_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        start, end = intervals[i]
        if start >= last_end:  # Non-overlapping
            count += 1
            last_end = end
    
    return count
```

```javascript
function maxNonOverlapping(intervals) {
    if (intervals.length === 0) return 0;
    
    // Sort by end time
    intervals.sort((a, b) => a[1] - b[1]);
    
    let count = 1;
    let lastEnd = intervals[0][1];
    
    for (let i = 1; i < intervals.length; i++) {
        const [start, end] = intervals[i];
        if (start >= lastEnd) {
            count++;
            lastEnd = end;
        }
    }
    
    return count;
}
```

---

### Template 2: Merge Intervals (Sort by Start)

```python
def merge_intervals(intervals):
    """
    Merge all overlapping intervals.
    
    Time: O(n log n), Space: O(n)
    
    Pattern: Sort by START time
    """
    if not intervals:
        return []
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    merged = [intervals[0]]
    
    for i in range(1, len(intervals)):
        current = intervals[i]
        last = merged[-1]
        
        if current[0] <= last[1]:  # Overlapping
            # Extend the end
            merged[-1][1] = max(last[1], current[1])
        else:
            # No overlap, add new interval
            merged.append(current)
    
    return merged
```

```javascript
function mergeIntervals(intervals) {
    if (intervals.length === 0) return [];
    
    intervals.sort((a, b) => a[0] - b[0]);
    
    const merged = [intervals[0]];
    
    for (let i = 1; i < intervals.length; i++) {
        const current = intervals[i];
        const last = merged[merged.length - 1];
        
        if (current[0] <= last[1]) {
            last[1] = Math.max(last[1], current[1]);
        } else {
            merged.push(current);
        }
    }
    
    return merged;
}
```

---

### Template 3: Meeting Rooms (Sweep Line / Heap)

```python
import heapq

def min_meeting_rooms(intervals):
    """
    Minimum number of meeting rooms needed.
    
    Time: O(n log n), Space: O(n)
    
    Pattern: Min-heap for end times
    """
    if not intervals:
        return 0
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    # Min-heap of end times
    heap = []
    
    for start, end in intervals:
        # If earliest ending meeting ends before this starts
        if heap and heap[0] <= start:
            heapq.heappop(heap)  # Reuse that room
        
        heapq.heappush(heap, end)  # Schedule this meeting
    
    return len(heap)  # Size of heap = rooms needed
```

```javascript
// Using sorted events approach (no heap needed)
function minMeetingRooms(intervals) {
    const starts = intervals.map(i => i[0]).sort((a, b) => a - b);
    const ends = intervals.map(i => i[1]).sort((a, b) => a - b);
    
    let rooms = 0, endPtr = 0;
    
    for (let i = 0; i < intervals.length; i++) {
        if (starts[i] < ends[endPtr]) {
            rooms++;  // Need new room
        } else {
            endPtr++;  // Reuse room
        }
    }
    
    return rooms;
}
```

---

## ‚ö° Complexity Analysis

| Pattern | Time | Space | Sort By |
|---------|------|-------|---------|
| Activity Selection | O(n log n) | O(1) | End |
| Merge Intervals | O(n log n) | O(n) | Start |
| Non-overlapping Count | O(n log n) | O(1) | End |
| Meeting Rooms II | O(n log n) | O(n) | Start (heap) |
| Min Arrows | O(n log n) | O(1) | End |
| Insert Interval | O(n) | O(n) | Already sorted |

---

## üîÑ Problem Variations

| Problem | Sort By | Key Logic |
|---------|---------|-----------|
| Max non-overlapping | End | `if start >= last_end` |
| Min removals for non-overlap | End | `total - max_kept` |
| Merge overlapping | Start | `if curr_start <= last_end` |
| Min arrows to pop balloons | End | Count groups |
| Meeting rooms needed | Start + heap | Track concurrent |
| Insert and merge | Start | Insert in sorted order |
| Interval intersection | Start | Two pointers |

---

## ‚ö†Ô∏è Common Mistakes

1. **Wrong sorting criterion**
   - ‚ùå Sort by start for activity selection
   - ‚úÖ Sort by END for activity selection

2. **Confusion about overlap condition**
   - For non-overlapping: `start >= last_end` (touching is OK)
   - For merging: `start <= last_end` (touching should merge)
   - Clarify with interviewer!

3. **Off-by-one in comparison**
   ```python
   # [1,2] and [2,3]: do they overlap?
   # Depends on problem! Clarify if endpoints are inclusive.
   ```

4. **Modifying input while iterating**
   - ‚ùå `intervals.sort()` changes original
   - ‚úÖ Use `sorted()` if you need original later

5. **Forgetting empty input**
   - ‚ùå Crash on empty list
   - ‚úÖ Handle `if not intervals: return ...`

---

## üìù Practice Problems (Progressive)

### Easy (Learn the patterns)
- [ ] [Meeting Rooms](https://leetcode.com/problems/meeting-rooms/) - Can one person attend all?
- [ ] [Merge Intervals](https://leetcode.com/problems/merge-intervals/) - Classic merge

### Medium (Apply variations)
- [ ] [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/) - Min removals
- [ ] [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/) - Min rooms
- [ ] [Insert Interval](https://leetcode.com/problems/insert-interval/) - Merge after insert
- [ ] [Minimum Number of Arrows](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/) - Min groups

### Hard (Master edge cases)
- [ ] [Employee Free Time](https://leetcode.com/problems/employee-free-time/) - Merge across lists
- [ ] [Course Schedule III](https://leetcode.com/problems/course-schedule-iii/) - With deadlines

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: Solve Merge Intervals + Non-overlapping Intervals
- Day 3: Solve Meeting Rooms II
- Day 7: Solve without looking at template

**Week 2:**
- Day 1: Min Arrows + Insert Interval
- Day 3: Identify pattern in 5 problem descriptions
- Day 7: Solve Course Schedule III

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Communication Strategy for Interval Problems</strong></summary>

**Company Frequency:**
| Company | Frequency | Common Problems |
|---------|-----------|-----------------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Meeting Rooms, Merge Intervals |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Interval scheduling with constraints |
| Meta | ‚≠ê‚≠ê‚≠ê | Calendar merge problems |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Standard interval problems |

**Interview Communication:**

```
"This is an interval problem. Let me identify the type:
- If we need max non-overlapping ‚Üí sort by end time
- If we need to merge ‚Üí sort by start time
- If we need room count ‚Üí use heap or sweep line

For this problem, we want [X], so I'll sort by [Y]..."
```

**Key questions to ask:**
1. "Are endpoints inclusive or exclusive?"
2. "Can intervals touch (e.g., [1,2] and [2,3])?"
3. "Is the input already sorted?"

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Recognize as interval problem | 30 sec |
| Choose sort criterion | 1 min |
| Implement | 5-8 min |
| Debug edge cases | 2-3 min |
| **Total** | **10-15 min** |

---

> **üí° Key Insight:** Most interval problems are solved by sorting. The question is just: sort by START (for merging/processing left-to-right) or sort by END (for maximizing non-overlapping)?

> **üîó Related:** [Sort by End Pattern](./4.2-Sort-By-End-Pattern.md) | [Sort by Start Pattern](./4.3-Sort-By-Start-Pattern.md) | [Meeting Rooms II](./4.4-Interval-Practice/Meeting-Rooms-II.md)
