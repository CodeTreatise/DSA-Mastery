# 3.3 Sorting Pitfalls in Both Languages

> **The silent bugs that cause wrong answers on LeetCode â€” even when your algorithm is correct.**
>
> â±ï¸ *Estimated reading: 15 minutes*

---

## ğŸ¯ Why This File Exists

Sorting is used in ~30% of LeetCode problems (intervals, greedy, binary search, etc.). Both Python and JavaScript have sorting traps that produce **silently wrong** results â€” no errors, no crashes, just wrong output.

---

## ğŸ”´ THE #1 JavaScript Trap: Lexicographic Sort

### The Problem

```javascript
// You expect: [1, 2, 3, 10, 20]
// You get:
[10, 2, 1, 20, 3].sort();
// â†’ [1, 10, 2, 20, 3]  ğŸ˜±
```

**Why?** `Array.sort()` converts elements to **strings** and sorts lexicographically (dictionary order). As strings: `"10" < "2"` because `"1" < "2"`.

### The Fix

```javascript
// âœ… ALWAYS pass a comparator for numbers
[10, 2, 1, 20, 3].sort((a, b) => a - b);
// â†’ [1, 2, 3, 10, 20] âœ…

// Descending
[10, 2, 1, 20, 3].sort((a, b) => b - a);
// â†’ [20, 10, 3, 2, 1] âœ…
```

### Real LeetCode Impact

```javascript
// LC 56: Merge Intervals
// âŒ WRONG â€” lexicographic sort on first element
intervals.sort();
// [[1,3], [15,18], [2,6], [8,10]]  â† 15 before 2!

// âœ… CORRECT
intervals.sort((a, b) => a[0] - b[0]);
// [[1,3], [2,6], [8,10], [15,18]]
```

> **âš ï¸ Rule:** In JavaScript, NEVER call `.sort()` on numbers without `(a, b) => a - b`. Make this muscle memory.

---

## ğŸŸ¡ Python Sort: Generally Safe, But Watch Custom Keys

### Python's Default Sort is Smart

```python
# Python sorts numbers correctly by default
[10, 2, 1, 20, 3].sort()
# â†’ [1, 2, 3, 10, 20] âœ…

# Strings sort lexicographically (which is usually what you want)
["banana", "apple", "cherry"].sort()
# â†’ ["apple", "banana", "cherry"] âœ…
```

### Pitfall 1: Mixed Types

```python
# âŒ Python 3 cannot compare different types
[1, "2", 3].sort()
# TypeError: '<' not supported between instances of 'str' and 'int'

# âœ… Ensure uniform types
[1, 2, 3].sort()          # All ints â€” fine
["1", "2", "3"].sort()    # All strings â€” fine
```

### Pitfall 2: String Numbers Sort Lexicographically

```python
# âš ï¸ When numbers are strings, sorting is lexicographic
["10", "2", "1", "20", "3"].sort()
# â†’ ["1", "10", "2", "20", "3"]  â€” same trap as JS!

# âœ… Fix: convert to int for comparison
["10", "2", "1", "20", "3"].sort(key=int)
# â†’ ["1", "2", "3", "10", "20"] âœ…
```

### Pitfall 3: `sort()` vs `sorted()`

```python
# sort() modifies IN PLACE, returns None
nums = [3, 1, 2]
result = nums.sort()
print(result)   # None!  â† Common mistake
print(nums)     # [1, 2, 3]

# sorted() returns NEW list, original unchanged
nums = [3, 1, 2]
result = sorted(nums)
print(result)   # [1, 2, 3]
print(nums)     # [3, 1, 2] â€” unchanged
```

---

## ğŸ“ Custom Comparators: Side-by-Side

### Sort by Multiple Criteria

**Problem:** Sort people by age (ascending), then by name (alphabetically) for ties.

```python
# Python â€” tuple key (natural multi-sort)
people = [("Alice", 30), ("Bob", 25), ("Charlie", 30)]
people.sort(key=lambda p: (p[1], p[0]))
# â†’ [("Bob", 25), ("Alice", 30), ("Charlie", 30)]

# Descending age, ascending name:
people.sort(key=lambda p: (-p[1], p[0]))
# â†’ [("Alice", 30), ("Charlie", 30), ("Bob", 25)]
```

```javascript
// JavaScript â€” multi-criteria in comparator
const people = [["Alice", 30], ["Bob", 25], ["Charlie", 30]];
people.sort((a, b) => {
    if (a[1] !== b[1]) return a[1] - b[1];  // Age ascending
    return a[0].localeCompare(b[0]);          // Name alphabetical
});
// â†’ [["Bob", 25], ["Alice", 30], ["Charlie", 30]]
```

### Custom Comparison Functions

**Problem:** LC 179 â€” Largest Number. Given `[3, 30, 34, 5, 9]`, form the largest number: `"9534330"`.

```python
# Python â€” cmp_to_key for complex comparisons
from functools import cmp_to_key

def compare(a, b):
    # Compare "ab" vs "ba"
    if a + b > b + a: return -1   # a should come first
    if a + b < b + a: return 1    # b should come first
    return 0

nums = [3, 30, 34, 5, 9]
strs = [str(n) for n in nums]
strs.sort(key=cmp_to_key(compare))
result = ''.join(strs)
# "9534330"
```

```javascript
// JavaScript â€” comparator returns negative/zero/positive
const nums = [3, 30, 34, 5, 9];
const strs = nums.map(String);
strs.sort((a, b) => {
    // Compare "ab" vs "ba"
    return (b + a).localeCompare(a + b);
});
const result = strs.join('');
// "9534330"
```

---

## ğŸ”„ Stable vs Unstable Sort

### What Is Stability?

A **stable** sort preserves the relative order of equal elements.

```
Input:  [(Alice, A), (Bob, B), (Charlie, A)]
Sort by grade:

Stable:   [(Alice, A), (Charlie, A), (Bob, B)]     â† Alice before Charlie (original order)
Unstable: [(Charlie, A), (Alice, A), (Bob, B)]     â† Order of A's may change
```

### Language Stability

| Language | Algorithm | Stable? |
|----------|-----------|---------|
| Python | Timsort | âœ… Yes, always |
| JavaScript (V8/Chrome) | Timsort (since 2019) | âœ… Yes |
| JavaScript (older engines) | Varies | âš ï¸ Not guaranteed |

### When Stability Matters

```python
# Sort by grade, then by name â€” stability makes this work in two passes
students = [("Charlie", "A"), ("Alice", "B"), ("Bob", "A"), ("Dave", "B")]

# Step 1: Sort by name (secondary criterion)
students.sort(key=lambda s: s[0])

# Step 2: Sort by grade (primary criterion) â€” stable sort preserves name order within same grade
students.sort(key=lambda s: s[1])
# â†’ [("Bob", "A"), ("Charlie", "A"), ("Alice", "B"), ("Dave", "B")]
# Within grade A: Bob before Charlie (alphabetical from step 1 preserved)
```

> **ğŸ’¡ In practice:** Python's tuple-key sort handles multi-criteria in one pass, so you rarely need to rely on stability explicitly.

---

## âš¡ Complexity & Performance

| | Python `sort()` | JavaScript `sort()` |
|--|----------------|---------------------|
| **Algorithm** | Timsort | Timsort (modern engines) |
| **Time** | O(n log n) | O(n log n) |
| **Space** | O(n) | O(n) |
| **Best case** | O(n) for nearly sorted | O(n) for nearly sorted |
| **Stable** | âœ… Always | âœ… Modern engines |

### In-Place vs New Array

```python
# Python
nums.sort()               # In-place, O(1) extra space, returns None
sorted(nums)              # New list, O(n) extra space, returns list
```

```javascript
// JavaScript
nums.sort((a, b) => a - b);  // In-place, returns same array
[...nums].sort((a, b) => a - b);  // New array (spread then sort)
```

---

## âš ï¸ Common Mistakes Summary

| Mistake | Language | Impact | Fix |
|---------|----------|--------|-----|
| `.sort()` on numbers without comparator | JS | **Wrong answers** | Always use `(a, b) => a - b` |
| Using `result = arr.sort()` expecting new array | Both | Confusion | Python: `result = sorted(arr)`. JS: `.sort()` mutates |
| Sorting string-numbers lexicographically | Both | Wrong order | Convert to int/use `key=int` |
| Negative number comparator `(a, b) => a > b` | JS | **Wrong!** | Must return number: `a - b` |
| Forgetting `cmp_to_key` for complex comparisons | Python | Crash | Import from `functools` |
| Sorting mutates the original array | JS | Unintended side effects | Spread first: `[...arr].sort()` |

### The Boolean Comparator Bug (JavaScript)

```javascript
// âŒ WRONG â€” returns boolean, not number
[3, 1, 2].sort((a, b) => a > b);
// May produce wrong results! sort() expects negative/0/positive

// âœ… CORRECT â€” returns number
[3, 1, 2].sort((a, b) => a - b);
```

**Why?** `.sort()` checks if the return value is negative, zero, or positive. `true` coerces to `1` and `false` to `0`, so `a > b` never returns a negative number â€” it can never indicate "a comes first."

---

## ğŸ“ Quick Reference Card

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              SORTING CHEAT SHEET                       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                        â•‘
â•‘  Python:                                               â•‘
â•‘    nums.sort()              âœ… Numbers work correctly   â•‘
â•‘    sorted(nums)             âœ… Returns new list         â•‘
â•‘    sorted(nums, key=func)   âœ… Custom key               â•‘
â•‘    sort(key=cmp_to_key(f))  âœ… Custom comparator        â•‘
â•‘                                                        â•‘
â•‘  JavaScript:                                           â•‘
â•‘    nums.sort()              âŒ LEXICOGRAPHIC!           â•‘
â•‘    nums.sort((a,b) => a-b)  âœ… Ascending numbers        â•‘
â•‘    nums.sort((a,b) => b-a)  âœ… Descending numbers       â•‘
â•‘    [...nums].sort(...)      âœ… Non-mutating              â•‘
â•‘                                                        â•‘
â•‘  GOLDEN RULE:                                          â•‘
â•‘    In JS, NEVER sort numbers without (a, b) => a - b   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

> **ğŸ’¡ Key Insight:** The JS lexicographic sort trap is the most common "silent wrong answer" bug in LeetCode submissions. If you're getting wrong answers on a sorting-based problem in JavaScript, check your comparator FIRST.

---

â† [3.2 JavaScript DSA Toolkit](./3.2-JavaScript-DSA-Toolkit.md) | **Back to:** [Prerequisites Index](../00-Prerequisites.md)
