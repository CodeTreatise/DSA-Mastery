# 9.2 Cycle Detection in Directed Graphs

> **Three-color DFS marking for detecting back edges**
>
> ‚è±Ô∏è **Study Time:** 30 min | üìä **Priority:** High | üéØ **Pattern:** DFS with State

---

## Overview

Cycle detection in **directed graphs** is different from undirected graphs. We can't just check if a neighbor is visited - we need to know if it's **currently in our DFS path**.

**The Three-Color Algorithm:**
```
WHITE (0) = Not visited
GRAY  (1) = Currently being explored (in current DFS path)
BLACK (2) = Completely processed (all descendants visited)

Cycle exists if we see a GRAY node while exploring!
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Problem</strong></summary>

**Look for these signals:**
- Directed graph (dependencies, prerequisites)
- "Can all courses be finished?" (if no circular dependency)
- "Is topological sort possible?" (only if DAG)
- "Detect circular dependency"

**Keywords in problem statement:**
- "prerequisites", "dependencies"
- "before/after relationship"
- "order", "schedule", "circular"

**Important distinction:**
- Undirected: Any visited neighbor (except parent) = cycle
- Directed: Only GRAY neighbor = cycle (BLACK is fine!)

</details>

---

## ‚úÖ When to Use

- Detecting circular dependencies
- Validating prerequisite structures
- Checking if topological sort is possible
- Dependency graph validation

## ‚ùå When NOT to Use

| Instead of... | Use... | When... |
|--------------|--------|---------|
| Three-color DFS | Parent tracking | Undirected graph |
| DFS | Kahn's algorithm | Also need topological order |
| Full cycle detection | Quick check | Just need "has cycle?" answer |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [DFS Pattern](../04-DFS-Traversal/4.1-DFS-Fundamentals.md)
- [Undirected Cycles](./9.1-Undirected-Cycles.md)

**After mastering this:**
- [Topological Sort](../06-Topological-Sort/6.1-Topo-Sort-Fundamentals.md)
- [Strongly Connected Components](../12-Advanced/12.2-SCC-Bridges.md)

**Combines with:**
- Topological sort (only works on DAGs)
- Course scheduling problems
- Build system dependency checking

</details>

---

## üìê How It Works

### Why Three Colors?

```
Consider this directed graph:

    A ‚Üí B ‚Üí C
    ‚Üì
    D

DFS from A:
1. Visit A (GRAY)
2. Visit B (GRAY) 
3. Visit C (GRAY)
4. C has no neighbors, mark BLACK
5. Back to B, mark BLACK
6. Back to A, visit D (GRAY)
7. D has no neighbors, mark BLACK
8. Back to A, mark BLACK

If we only used "visited", when we're at D and see A as visited,
we might wrongly think there's a cycle!

But A is BLACK (fully processed), not GRAY (in current path).
No cycle!
```

### Cycle Example

```
    A ‚Üí B
    ‚Üë   ‚Üì
    ‚îî‚îÄ‚îÄ C

DFS from A:
1. Visit A (GRAY)
2. Visit B (GRAY)
3. Visit C (GRAY)
4. C's neighbor is A... and A is GRAY!
   A is in current DFS path ‚Üí CYCLE DETECTED!
```

---

## üíª Code Implementation

**Python:**
```python
from collections import defaultdict
from typing import List

# Color constants
WHITE, GRAY, BLACK = 0, 1, 2


def hasCycle(numCourses: int, prerequisites: List[List[int]]) -> bool:
    """
    Detect cycle in directed graph using three-color DFS.
    
    Time: O(V + E)
    Space: O(V)
    """
    graph = defaultdict(list)
    for course, prereq in prerequisites:
        graph[prereq].append(course)
    
    color = [WHITE] * numCourses
    
    def dfs(node: int) -> bool:
        """Returns True if cycle detected."""
        color[node] = GRAY
        
        for neighbor in graph[node]:
            if color[neighbor] == GRAY:
                return True  # Back edge = cycle!
            if color[neighbor] == WHITE:
                if dfs(neighbor):
                    return True
        
        color[node] = BLACK
        return False
    
    # Check all nodes (graph might be disconnected)
    for i in range(numCourses):
        if color[i] == WHITE:
            if dfs(i):
                return True
    
    return False


def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:
    """
    LC 207: Course Schedule
    Can finish all courses? (= no cycle in dependency graph)
    """
    return not hasCycle(numCourses, prerequisites)


def findCyclePath(n: int, edges: List[List[int]]) -> List[int]:
    """
    Find and return the actual cycle path.
    """
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
    
    color = [WHITE] * n
    parent = [-1] * n
    cycle_start = cycle_end = -1
    
    def dfs(node: int, par: int) -> bool:
        nonlocal cycle_start, cycle_end
        color[node] = GRAY
        parent[node] = par
        
        for neighbor in graph[node]:
            if color[neighbor] == GRAY:
                cycle_start = neighbor
                cycle_end = node
                return True
            if color[neighbor] == WHITE:
                if dfs(neighbor, node):
                    return True
        
        color[node] = BLACK
        return False
    
    for i in range(n):
        if color[i] == WHITE:
            if dfs(i, -1):
                break
    
    if cycle_start == -1:
        return []
    
    # Reconstruct cycle
    path = [cycle_start]
    current = cycle_end
    while current != cycle_start:
        path.append(current)
        current = parent[current]
    path.append(cycle_start)
    
    return path[::-1]


# Alternative: Using recursion stack boolean
def hasCycleRecStack(n: int, graph: dict) -> bool:
    """
    Alternative implementation using recursion stack.
    """
    visited = [False] * n
    rec_stack = [False] * n  # Currently in recursion
    
    def dfs(node: int) -> bool:
        visited[node] = True
        rec_stack[node] = True
        
        for neighbor in graph[node]:
            if not visited[neighbor]:
                if dfs(neighbor):
                    return True
            elif rec_stack[neighbor]:
                return True  # In current path = cycle!
        
        rec_stack[node] = False  # Backtrack
        return False
    
    for i in range(n):
        if not visited[i]:
            if dfs(i):
                return True
    
    return False


# Test
print(canFinish(2, [[1,0]]))  # True: 0 ‚Üí 1
print(canFinish(2, [[1,0],[0,1]]))  # False: 0 ‚Üî 1 cycle
```

**JavaScript:**
```javascript
const WHITE = 0, GRAY = 1, BLACK = 2;

function canFinish(numCourses, prerequisites) {
    const graph = new Map();
    for (let i = 0; i < numCourses; i++) {
        graph.set(i, []);
    }
    for (const [course, prereq] of prerequisites) {
        graph.get(prereq).push(course);
    }
    
    const color = new Array(numCourses).fill(WHITE);
    
    function dfs(node) {
        color[node] = GRAY;
        
        for (const neighbor of graph.get(node)) {
            if (color[neighbor] === GRAY) {
                return true; // Cycle!
            }
            if (color[neighbor] === WHITE && dfs(neighbor)) {
                return true;
            }
        }
        
        color[node] = BLACK;
        return false;
    }
    
    for (let i = 0; i < numCourses; i++) {
        if (color[i] === WHITE && dfs(i)) {
            return false; // Has cycle, can't finish
        }
    }
    
    return true;
}

// Alternative: recursion stack approach
function hasCycle(n, graph) {
    const visited = new Array(n).fill(false);
    const recStack = new Array(n).fill(false);
    
    function dfs(node) {
        visited[node] = true;
        recStack[node] = true;
        
        for (const neighbor of (graph.get(node) || [])) {
            if (!visited[neighbor]) {
                if (dfs(neighbor)) return true;
            } else if (recStack[neighbor]) {
                return true;
            }
        }
        
        recStack[node] = false;
        return false;
    }
    
    for (let i = 0; i < n; i++) {
        if (!visited[i] && dfs(i)) {
            return true;
        }
    }
    
    return false;
}
```

---

## ‚ö° Complexity Analysis

| Aspect | Complexity | Notes |
|--------|------------|-------|
| **Time** | O(V + E) | Each vertex and edge visited once |
| **Space** | O(V) | Color array + recursion stack |

**Why O(V + E):**
- Each vertex changes color: WHITE ‚Üí GRAY ‚Üí BLACK (once each)
- Each edge is checked once when we visit its source

---

## üîÑ Variations

### Kahn's Algorithm (BFS-based)

Alternative cycle detection using in-degree:

```python
from collections import deque

def hasCycleKahn(n: int, edges: List[List[int]]) -> bool:
    """
    If Kahn's can't process all nodes, there's a cycle.
    """
    graph = defaultdict(list)
    in_degree = [0] * n
    
    for u, v in edges:
        graph[u].append(v)
        in_degree[v] += 1
    
    queue = deque([i for i in range(n) if in_degree[i] == 0])
    processed = 0
    
    while queue:
        node = queue.popleft()
        processed += 1
        
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    return processed != n  # True if cycle (couldn't process all)
```

### Detect Cycle in Functional Graph

Each node has exactly one outgoing edge (like linked list with possible cycle):

```python
def hasCycleFunctional(n: int, edges: List[int]) -> bool:
    """
    edges[i] = the single neighbor of node i
    Use Floyd's cycle detection!
    """
    slow = fast = 0
    
    while True:
        slow = edges[slow]
        fast = edges[edges[fast]]
        
        if slow == fast:
            return True  # Cycle detected
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Undirected Logic for Directed Graph

```python
# ‚ùå WRONG: Parent check doesn't work for directed
if visited[neighbor] and neighbor != parent:
    return True

# ‚úÖ CORRECT: Use three colors
if color[neighbor] == GRAY:  # In current path
    return True
```

### 2. Confusing BLACK with Cycle

```python
# ‚ùå WRONG: Any visited neighbor is cycle
if color[neighbor] != WHITE:
    return True  # But BLACK is fine!

# ‚úÖ CORRECT: Only GRAY means cycle
if color[neighbor] == GRAY:
    return True
```

### 3. Not Resetting Recursion Stack

```python
# ‚ùå WRONG: Forgetting to reset on backtrack
def dfs(node):
    rec_stack[node] = True
    # ... explore ...
    # Forgot to set rec_stack[node] = False!

# ‚úÖ CORRECT: Reset when done
def dfs(node):
    rec_stack[node] = True
    # ... explore ...
    rec_stack[node] = False  # Backtrack!
```

---

## üìù Practice Problems (Progressive)

### Easy (Basic detection)
- [ ] [Course Schedule](https://leetcode.com/problems/course-schedule/) - Classic cycle detection
- [ ] [Course Schedule II](https://leetcode.com/problems/course-schedule-ii/) - Topo sort if no cycle

### Medium (Variations)
- [ ] [Find Eventual Safe States](https://leetcode.com/problems/find-eventual-safe-states/) - Nodes not in any cycle
- [ ] [Parallel Courses](https://leetcode.com/problems/parallel-courses/) - With cycle = impossible

### Hard (Advanced)
- [ ] [Longest Cycle in a Graph](https://leetcode.com/problems/longest-cycle-in-a-graph/) - Find cycle length
- [ ] [Detect Cycles in 2D Grid](https://leetcode.com/problems/detect-cycles-in-2d-grid/) - Grid + cycle

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

| Day | Activity |
|-----|----------|
| 1 | Implement three-color DFS |
| 3 | Solve Course Schedule |
| 7 | Explain WHITE/GRAY/BLACK meaning |
| 14 | Solve Find Eventual Safe States |

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening:**
> "For cycle detection in a directed graph, I'll use three-color DFS. WHITE means unvisited, GRAY means currently in the DFS path, and BLACK means fully processed."

**Explaining the logic:**
> "A cycle exists if I encounter a GRAY node - that means I'm seeing a node that's currently in my DFS path, creating a back edge."

**Why not just visited?:**
> "In directed graphs, reaching a visited node isn't always a cycle. If it's BLACK (fully processed), it's fine - we just saw it from a different path. Only GRAY (in current path) indicates a cycle."

</details>

**Company Focus:**
| Company | Frequency | Notes |
|---------|-----------|-------|
| **Meta** | Very High | Course Schedule is classic |
| **Amazon** | High | Dependency problems |
| **Google** | High | Complex variations |
| **Microsoft** | High | Build system dependencies |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn three-color DFS | 25 min | Key concept |
| Implement from scratch | 10 min | After understanding |
| Solve Course Schedule | 15 min | Direct application |
| Compare with Kahn's | 15 min | Alternative approach |

---

> **üí° Key Insight:** GRAY = "currently exploring" = "in my ancestry path". A back edge to GRAY means we've found a path from a node back to its ancestor = CYCLE!

---

> **üîó Related:** [Undirected Cycles](./9.1-Undirected-Cycles.md) | [Topological Sort](../06-Topological-Sort/6.1-Topo-Sort-Fundamentals.md) | [DFS Pattern](../04-DFS-Traversal/4.1-DFS-Fundamentals.md)

---

**Back:** [‚Üê Undirected Cycles](./9.1-Undirected-Cycles.md) | **Next:** [Bipartite Graphs ‚Üí](../10-Bipartite/10.1-Bipartite-Basics.md)
