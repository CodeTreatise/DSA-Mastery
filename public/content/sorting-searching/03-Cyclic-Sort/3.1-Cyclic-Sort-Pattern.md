# 3.1 - Cyclic Sort Pattern

> **The Grokking Pattern for Missing/Duplicate Numbers**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - High frequency pattern  
> **Key Insight:** Numbers in range [1, n] can be placed at index [0, n-1]

---

## Overview

**Cyclic Sort** is a pattern for problems where:
- Numbers are in a **contiguous range** [1, n] or [0, n]
- Array size is n
- Need to find **missing numbers** or **duplicates**

The key insight: Each number can be placed at its "correct" index, making O(n) time and O(1) space possible.

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Cyclic Sort</strong></summary>

**Keywords:**
- "Numbers 1 to n"
- "Find missing number"
- "Find duplicate"
- "First missing positive"
- "Array of size n"

**The insight:**
```
Array: [3, 1, 5, 4, 2]  (numbers 1-5)

Each number num should be at index num-1:
- 1 should be at index 0
- 2 should be at index 1
- 3 should be at index 2
- etc.

After cyclic sort: [1, 2, 3, 4, 5]
                    ‚Üë  ‚Üë  ‚Üë  ‚Üë  ‚Üë
                    0  1  2  3  4
```

</details>

---

## ‚úÖ When to Use

- Numbers in range [1, n] or [0, n-1]
- Finding missing numbers
- Finding duplicates
- Finding first missing positive
- O(1) space constraint

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Numbers not in range | Hash Set | Can't use index mapping |
| Need to preserve order | Different approach | Cyclic sort modifies array |
| Range is huge | Hash Map | Can't allocate that much space |
| Multiple duplicates of same number | Count array | Cyclic sort handles one duplicate |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this:**
- Array index manipulation
- In-place swapping

**Related patterns:**
- Counting Sort (similar index concept)
- Hash Set (alternative with O(n) space)

**Classic problems:**
1. Missing Number (LC 268)
2. Find All Duplicates (LC 442)
3. Find All Missing Numbers (LC 448)
4. First Missing Positive (LC 41) ‚≠ê
5. Set Mismatch (LC 645)

</details>

---

## üìê How It Works

### The Core Algorithm

**Step 1:** Place each number at its correct index
```
Array: [3, 1, 5, 4, 2]

i=0: arr[0]=3, should be at index 2
     Swap arr[0] and arr[2]: [5, 1, 3, 4, 2]
     
i=0: arr[0]=5, should be at index 4
     Swap arr[0] and arr[4]: [2, 1, 3, 4, 5]
     
i=0: arr[0]=2, should be at index 1
     Swap arr[0] and arr[1]: [1, 2, 3, 4, 5]
     
i=0: arr[0]=1, correct position! Move to i=1

i=1: arr[1]=2, correct! Move to i=2
... all correct!

Result: [1, 2, 3, 4, 5]
```

**Step 2:** Scan for anomalies
- If `arr[i] != i + 1`, then `i + 1` is missing

### Visualization

```
Initial: [3, 1, 5, 4, 2]
          0  1  2  3  4

Step 1: Place 3 at index 2
         [5, 1, 3, 4, 2]
              ‚Üë
         3 is now correct

Step 2: Place 5 at index 4
         [2, 1, 3, 4, 5]
                      ‚Üë
         5 is now correct

Step 3: Place 2 at index 1
         [1, 2, 3, 4, 5]
          ‚Üë  ‚Üë
         Both correct!

Done: All numbers at correct indices
```

---

## üíª Code Implementation

### Core Cyclic Sort

**Python:**
```python
def cyclic_sort(nums: list[int]) -> list[int]:
    """
    Sort array containing numbers 1 to n.
    
    Time: O(n), Space: O(1)
    
    Key insight: Each element is swapped at most once,
    so total swaps ‚â§ n-1.
    """
    i = 0
    
    while i < len(nums):
        # Where should nums[i] be placed?
        correct_idx = nums[i] - 1  # For 1-indexed numbers
        
        if nums[i] != nums[correct_idx]:
            # Swap to correct position
            nums[i], nums[correct_idx] = nums[correct_idx], nums[i]
        else:
            # Current position is correct, move on
            i += 1
    
    return nums


# Example
print(cyclic_sort([3, 1, 5, 4, 2]))  # [1, 2, 3, 4, 5]
```

**JavaScript:**
```javascript
function cyclicSort(nums) {
    let i = 0;
    
    while (i < nums.length) {
        const correctIdx = nums[i] - 1;
        
        if (nums[i] !== nums[correctIdx]) {
            [nums[i], nums[correctIdx]] = [nums[correctIdx], nums[i]];
        } else {
            i++;
        }
    }
    
    return nums;
}
```

---

### Problem 1: Missing Number (LC 268)

Array contains n distinct numbers from [0, n], find the missing one.

```python
def missing_number(nums: list[int]) -> int:
    """
    Find missing number in [0, n].
    
    Time: O(n), Space: O(1)
    """
    n = len(nums)
    i = 0
    
    while i < n:
        # For [0, n], correct index = nums[i] itself
        if nums[i] < n and nums[i] != nums[nums[i]]:
            correct_idx = nums[i]
            nums[i], nums[correct_idx] = nums[correct_idx], nums[i]
        else:
            i += 1
    
    # Find the missing number
    for i in range(n):
        if nums[i] != i:
            return i
    
    return n  # All 0 to n-1 present, n is missing


# Alternative: XOR or sum approach
def missing_number_xor(nums: list[int]) -> int:
    """XOR approach: a ^ a = 0, so missing number remains."""
    result = len(nums)
    for i, num in enumerate(nums):
        result ^= i ^ num
    return result


def missing_number_sum(nums: list[int]) -> int:
    """Sum approach: expected sum - actual sum."""
    n = len(nums)
    expected = n * (n + 1) // 2
    return expected - sum(nums)


# Example
print(missing_number([3, 0, 1]))  # 2
```

---

### Problem 2: Find All Duplicates (LC 442)

Numbers in range [1, n], some appear twice, some once. Find duplicates.

```python
def find_duplicates(nums: list[int]) -> list[int]:
    """
    Find all duplicates using cyclic sort.
    
    Time: O(n), Space: O(1)
    """
    i = 0
    
    while i < len(nums):
        correct_idx = nums[i] - 1
        
        if nums[i] != nums[correct_idx]:
            nums[i], nums[correct_idx] = nums[correct_idx], nums[i]
        else:
            i += 1
    
    # Find duplicates: where nums[i] != i + 1
    duplicates = []
    for i in range(len(nums)):
        if nums[i] != i + 1:
            duplicates.append(nums[i])
    
    return duplicates


# Alternative: Negative marking (modifies but restores)
def find_duplicates_marking(nums: list[int]) -> list[int]:
    """Mark visited indices as negative."""
    duplicates = []
    
    for num in nums:
        idx = abs(num) - 1
        if nums[idx] < 0:
            duplicates.append(abs(num))
        else:
            nums[idx] = -nums[idx]
    
    return duplicates


# Example
print(find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]))  # [2, 3]
```

---

### Problem 3: Find All Missing Numbers (LC 448)

Numbers in range [1, n], some missing. Find all missing.

```python
def find_disappeared_numbers(nums: list[int]) -> list[int]:
    """
    Find all missing numbers using cyclic sort.
    
    Time: O(n), Space: O(1)
    """
    i = 0
    
    while i < len(nums):
        correct_idx = nums[i] - 1
        
        if nums[i] != nums[correct_idx]:
            nums[i], nums[correct_idx] = nums[correct_idx], nums[i]
        else:
            i += 1
    
    # Find missing: where nums[i] != i + 1
    missing = []
    for i in range(len(nums)):
        if nums[i] != i + 1:
            missing.append(i + 1)
    
    return missing


# Example
print(find_disappeared_numbers([4, 3, 2, 7, 8, 2, 3, 1]))  # [5, 6]
```

---

### Problem 4: First Missing Positive (LC 41) ‚≠ê HARD

Find the smallest missing positive integer.

```python
def first_missing_positive(nums: list[int]) -> int:
    """
    Find first missing positive.
    
    Key insight: Answer is in range [1, n+1].
    Ignore numbers <= 0 or > n.
    
    Time: O(n), Space: O(1)
    """
    n = len(nums)
    i = 0
    
    while i < n:
        # Only care about numbers in [1, n]
        num = nums[i]
        correct_idx = num - 1
        
        if 1 <= num <= n and nums[i] != nums[correct_idx]:
            nums[i], nums[correct_idx] = nums[correct_idx], nums[i]
        else:
            i += 1
    
    # Find first missing positive
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    
    return n + 1  # All 1 to n present


# Example
print(first_missing_positive([3, 4, -1, 1]))  # 2
print(first_missing_positive([1, 2, 0]))  # 3
print(first_missing_positive([7, 8, 9, 11, 12]))  # 1
```

---

### Problem 5: Set Mismatch (LC 645)

One number is duplicated, one is missing. Find both.

```python
def find_error_nums(nums: list[int]) -> list[int]:
    """
    Find duplicate and missing number.
    
    Time: O(n), Space: O(1)
    """
    i = 0
    
    while i < len(nums):
        correct_idx = nums[i] - 1
        
        if nums[i] != nums[correct_idx]:
            nums[i], nums[correct_idx] = nums[correct_idx], nums[i]
        else:
            i += 1
    
    # Find the mismatch
    for i in range(len(nums)):
        if nums[i] != i + 1:
            return [nums[i], i + 1]  # [duplicate, missing]
    
    return []


# Example
print(find_error_nums([1, 2, 2, 4]))  # [2, 3]
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Why |
|-----------|------|-------|-----|
| Cyclic Sort |" O(n) "| O(1) | Each element swapped at most once |
| Find anomaly |" O(n) "| O(1) | Single scan |
| **Total** |" O(n) "| O(1) | Two passes |

**Why O(n) despite nested while loop?**
```
Each swap puts one element in its correct position.
An element in correct position is never moved again.
Maximum n elements ‚Üí maximum n swaps.
Total operations: O(n)
```

---

## üîÑ Variations

| Problem | Key Modification | LeetCode |
|---------|-----------------|----------|
| Missing Number | Range [0, n] | LC 268 |
| All Duplicates | Report all duplicates | LC 442 |
| All Missing | Report all missing | LC 448 |
| First Missing Positive | Ignore out-of-range | LC 41 |
| Set Mismatch | One dup + one missing | LC 645 |
| Find Duplicate | Only one duplicate | LC 287 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Index Calculation

‚ùå **Wrong:**
```python
correct_idx = nums[i]  # For 0-indexed range
# But if range is [1, n], this is wrong!
```

‚úÖ **Correct:**
```python
# For range [1, n]: correct_idx = nums[i] - 1
# For range [0, n-1]: correct_idx = nums[i]
```

### 2. Infinite Loop with Duplicates

‚ùå **Wrong:**
```python
while i < n:
    if nums[i] != i + 1:  # Keep swapping forever with duplicates!
        swap(nums[i], nums[nums[i] - 1])
```

‚úÖ **Correct:**
```python
while i < n:
    correct_idx = nums[i] - 1
    if nums[i] != nums[correct_idx]:  # Check target position
        swap
    else:
        i += 1
```

### 3. Not Handling Out-of-Range Numbers

‚ùå **Wrong (for First Missing Positive):**
```python
correct_idx = nums[i] - 1
nums[i], nums[correct_idx] = ...  # IndexError if nums[i] > n!
```

‚úÖ **Correct:**
```python
if 1 <= nums[i] <= n:  # Only process valid range
    correct_idx = nums[i] - 1
    if nums[i] != nums[correct_idx]:
        swap
```

---

## üìù Practice Problems

### Easy

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Missing Number | Basic cyclic sort | [LC 268](https://leetcode.com/problems/missing-number/) |

### Medium

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Find All Duplicates | Report duplicates | [LC 442](https://leetcode.com/problems/find-all-duplicates-in-an-array/) |
| Find All Missing Numbers | Report missing | [LC 448](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/) |
| Set Mismatch | Both dup and missing | [LC 645](https://leetcode.com/problems/set-mismatch/) |

### Hard

| Problem | Focus | LeetCode |
|---------|-------|----------|
| First Missing Positive | Handle out-of-range | [LC 41](https://leetcode.com/problems/first-missing-positive/) |
| Find the Duplicate Number | Floyd's cycle | [LC 287](https://leetcode.com/problems/find-the-duplicate-number/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** LC 268 Missing Number (understand the pattern)

**Day 3:** LC 448 Find All Missing Numbers

**Day 5:** LC 442 Find All Duplicates

**Day 7:** LC 645 Set Mismatch

**Day 14:** LC 41 First Missing Positive (the hard one!)

**Key insight to remember:**
"Numbers 1 to n can live at indices 0 to n-1"

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate</strong></summary>

**Recognizing the pattern:**
> "Since numbers are in the range [1, n], I can use cyclic sort to place each number at its correct index in O(n) time with O(1) space."

**Explaining the approach:**
> "Each number num should be at index num-1. I'll swap elements until each is in the right place, then scan for anomalies."

**Why it's O(n):**
> "Even though there's a while loop inside, each element is swapped at most once. So total swaps are at most n."

**Company Focus:**

| Company | Common Problems |
|---------|-----------------|
| Google | First Missing Positive |
| Amazon | Missing Number, All Missing |
| Meta | Find Duplicates |
| Microsoft | Set Mismatch |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand cyclic sort | 20-25 min | Core pattern |
| LC 268 Missing Number | 10-15 min | Start here |
| LC 448 All Missing | 15-20 min | Slight variation |
| LC 442 All Duplicates | 15-20 min | Same idea |
| LC 41 First Missing Positive | 25-35 min | Handle edge cases |

---

## üí° Key Insight

> **Cyclic Sort = Index as Hash**
>
> When numbers are in range [1, n] and array size is n:
> - Number 1 belongs at index 0
> - Number 2 belongs at index 1
> - Number k belongs at index k-1
>
> After sorting, if `nums[i] != i + 1`:
> - `nums[i]` is a duplicate (it's in the wrong spot)
> - `i + 1` is missing (nothing in its spot)
>
> This gives O(n) time with O(1) space!

---

## üîó Related

- [Sorting Basics](../01-Sorting/1.1-Sorting-Basics.md) - General sorting
- [Counting Sort](../01-Sorting/1.6-Linear-Time-Sorting.md) - Similar index concept
- [Missing/Duplicate Problems](./3.2-Missing-Duplicate-Problems.md) - More variations
