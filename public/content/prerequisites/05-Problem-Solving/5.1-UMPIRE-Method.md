# 5.1 The UMPIRE Method

> **A structured 6-step framework for solving ANY coding interview problem ‚Äî developed by CodePath.org and battle-tested across thousands of interview prep students.**
>
> ‚è±Ô∏è *Estimated reading: 15 minutes*

---

## üéØ Why You Need a Framework

The #1 reason people fail coding interviews isn't lack of knowledge ‚Äî it's **lack of structure**. They jump into coding without a plan, get stuck, panic, and run out of time.

UMPIRE gives you a repeatable process:

```
U ‚Äî Understand the problem
M ‚Äî Match to known patterns
P ‚Äî Plan your approach
I ‚Äî Implement the solution
R ‚Äî Review your code
E ‚Äî Evaluate complexity
```

---

## üìê The 6 Steps

### U ‚Äî Understand (2-3 minutes)

**Goal:** Make sure you know EXACTLY what's being asked before writing any code.

**Do this every time:**

1. **Restate the problem** in your own words
2. **Clarify inputs:** Types? Ranges? Can be empty? Sorted?
3. **Clarify outputs:** What to return? What format?
4. **Work through examples:** Trace the given examples by hand
5. **Ask about edge cases:**
   - Empty input?
   - Single element?
   - All same values?
   - Negative numbers?
   - Already sorted?

**Example script:**
> "So I'm given an array of integers and a target sum. I need to find two numbers that add up to the target and return their indices. Can the array have duplicates? Can I use the same element twice? Is there always exactly one solution?"

### ‚ö†Ô∏è Common Mistake

Jumping to code after reading the problem title. "Two Sum? I know this!" ‚Äî then you miss that it's asking for indices, not values. Or that the array is sorted (different optimal approach).

---

### M ‚Äî Match (1-2 minutes)

**Goal:** Connect this problem to patterns you already know.

**Pattern matching checklist:**

| Signal in Problem | Likely Pattern |
|-------------------|---------------|
| "Find pair in sorted array" | Two Pointers |
| "Contiguous subarray of size k" | Sliding Window |
| "Find in sorted array" | Binary Search |
| "All combinations/permutations" | Backtracking |
| "Shortest path" | BFS |
| "Connected components" | DFS / Union-Find |
| "Optimal substructure + overlapping" | Dynamic Programming |
| "Intervals overlap/merge" | Merge Intervals |
| "Top K / Kth largest" | Heap |
| "Prefix/word search" | Trie |

**Say it out loud:**
> "This looks like a Two Pointers problem because the array is sorted and we're finding a pair that sums to a target."

If you can't match to a pattern, consider:
- Brute force first ‚Üí then optimize
- What data structure gives you the lookup time you need?
- Can you sort the input to enable a pattern?

---

### P ‚Äî Plan (2-3 minutes)

**Goal:** Write pseudocode or bullet points BEFORE coding.

**This is the most important step.** Many candidates skip it and pay the price.

```
Plan for Two Sum (sorted):
1. Initialize left = 0, right = len(arr) - 1
2. While left < right:
   a. Calculate sum = arr[left] + arr[right]
   b. If sum == target: return [left, right]
   c. If sum < target: left++  (need larger)
   d. If sum > target: right-- (need smaller)
3. Return [-1, -1] (no solution found)
```

**What a good plan includes:**
- ‚úÖ Data structures you'll use
- ‚úÖ The main loop/recursion structure
- ‚úÖ How you handle edge cases
- ‚úÖ Expected time/space complexity

**What to skip:**
- ‚ùå Exact syntax
- ‚ùå Variable names
- ‚ùå Language-specific details

---

### I ‚Äî Implement (10-15 minutes)

**Goal:** Translate your plan to clean, working code.

**Guidelines:**
- Follow your plan step by step
- Use descriptive variable names
- Add brief comments for non-obvious logic
- Talk through what you're writing
- Don't optimize prematurely

```python
def two_sum_sorted(nums, target):
    left, right = 0, len(nums) - 1
    
    while left < right:
        current_sum = nums[left] + nums[right]
        
        if current_sum == target:
            return [left, right]
        elif current_sum < target:
            left += 1      # Need a larger sum
        else:
            right -= 1     # Need a smaller sum
    
    return [-1, -1]  # No pair found
```

### ‚ö†Ô∏è If You Get Stuck While Coding

Don't sit in silence. Say:
> "I'm thinking about how to handle [specific issue]. Let me trace through an example..."

Then work through a small example on paper/whiteboard.

---

### R ‚Äî Review (2-3 minutes)

**Goal:** Find bugs BEFORE running code.

**Review checklist:**
1. **Trace through example:** Walk through your code with the given example, tracking variables
2. **Check edge cases:**
   - Empty array ‚Üí does the while loop handle it?
   - Single element ‚Üí left == right, loop doesn't execute ‚úÖ
   - Target not found ‚Üí returns [-1, -1] ‚úÖ
3. **Off-by-one errors:** Loop bounds, array indexing
4. **Return value:** Correct type and format?

**Trace example:** `nums = [1, 3, 5, 7], target = 8`
```
left=0, right=3: sum=1+7=8 == target ‚Üí return [0, 3] ‚úÖ
```

**Edge case:** `nums = [1, 2], target = 10`
```
left=0, right=1: sum=1+2=3 < 10 ‚Üí left=1
left=1, right=1: left < right fails ‚Üí return [-1, -1] ‚úÖ
```

---

### E ‚Äî Evaluate (1 minute)

**Goal:** State time and space complexity. Interviewers ALWAYS ask this.

**Template:**
> "The time complexity is O(n) because each pointer moves at most n times, and each step is O(1). The space complexity is O(1) because we only use two pointer variables."

**Always explain WHY, not just state the Big O:**
- ‚ùå "It's O(n log n)" 
- ‚úÖ "It's O(n log n) because we sort the array first (O(n log n)), then do a linear scan (O(n)). The sort dominates."

---

## ‚è±Ô∏è Time Budget (45-Minute Interview)

| Step | Time | % |
|------|------|---|
| **U** ‚Äî Understand | 2-3 min | 5% |
| **M** ‚Äî Match | 1-2 min | 3% |
| **P** ‚Äî Plan | 2-3 min | 5% |
| **I** ‚Äî Implement | 15-20 min | 40% |
| **R** ‚Äî Review | 3-5 min | 8% |
| **E** ‚Äî Evaluate | 1-2 min | 3% |
| Discussion / Follow-ups | 10-15 min | 30% |
| Buffer | 3-5 min | ~6% |

---

## üìê UMPIRE Applied: Full Example

### Problem: LC 15 ‚Äî 3Sum

**U ‚Äî Understand:**
> "Find all unique triplets [a, b, c] where a + b + c = 0. No duplicate triplets in the result."

Key clarifications: Can be negative? Yes. Duplicates in input? Yes, but skip duplicate results.

**M ‚Äî Match:**
> "This is a Two Pointers problem. If I fix one number, I need two numbers that sum to its negative ‚Äî that's Two Sum on a sorted array."

**P ‚Äî Plan:**
```
1. Sort the array
2. For each nums[i] (the fixed number):
   a. Skip if same as previous (avoid duplicates)
   b. Use two pointers (left=i+1, right=end) for Two Sum
   c. Target = -nums[i]
   d. Skip duplicate left/right values
3. Return all triplets
```

**I ‚Äî Implement:**
```python
def threeSum(nums):
    nums.sort()
    result = []
    
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i-1]:
            continue  # Skip duplicate fixed values
        
        left, right = i + 1, len(nums) - 1
        target = -nums[i]
        
        while left < right:
            total = nums[left] + nums[right]
            if total == target:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left+1]:
                    left += 1   # Skip duplicates
                while left < right and nums[right] == nums[right-1]:
                    right -= 1  # Skip duplicates
                left += 1
                right -= 1
            elif total < target:
                left += 1
            else:
                right -= 1
    
    return result
```

**R ‚Äî Review:** Traced with [-1, 0, 1, 2, -1, -4]. After sort: [-4, -1, -1, 0, 1, 2]. Found [-1, -1, 2] and [-1, 0, 1]. No duplicates. ‚úÖ

**E ‚Äî Evaluate:**
> "Time: O(n¬≤) ‚Äî sorting is O(n log n), then for each of n elements we do a two-pointer scan in O(n). Space: O(1) excluding the output (O(n) for sorting in Python)."

---

## üé§ Communication Tips

| Phase | What to Say |
|-------|------------|
| **U** | "Let me make sure I understand... [restate]. Can I assume...?" |
| **M** | "This reminds me of [pattern] because [signal]." |
| **P** | "My approach is to... Let me outline the steps." |
| **I** | "I'm writing [what] because [why]." |
| **R** | "Let me trace through the example to verify..." |
| **E** | "Time is O(X) because... Space is O(Y) because..." |

---

## ‚ö†Ô∏è Anti-Patterns

| What NOT to Do | What to Do Instead |
|----------------|-------------------|
| Start coding immediately | Spend 3-5 min on U + M + P |
| Code in silence | Narrate your thinking |
| Say "I've seen this before" | Explain the pattern and why it applies |
| Give up after 5 min | Talk through brute force, then optimize |
| Skip edge cases | Explicitly test empty, single, duplicate inputs |
| State complexity without explaining | Always explain WHY it's that complexity |

---

> **üí° Key Insight:** UMPIRE isn't about being slow ‚Äî it's about being *deliberate*. Candidates who spend 5 minutes planning solve problems faster than those who start coding immediately. The plan IS the solution; the code is just the translation.
>
> *Credit: UMPIRE method developed by [CodePath.org](https://www.codepath.org/), a nonprofit providing free coding education.*

---

**Next:** [5.2 Complexity Constraints Guide](./5.2-Complexity-Constraints-Guide.md) ‚Üí
