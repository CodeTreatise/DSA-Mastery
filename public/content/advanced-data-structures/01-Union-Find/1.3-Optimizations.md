# Union-Find: Optimizations

> **Path Compression + Union by Rank = Near O(1) for all operations**
>
> The two optimizations that make Union-Find practical for real-world use.

---

## ðŸŽ¯ Why Optimizations Matter

Without optimizations, Union-Find degenerates to O(n) per operation:

```
Worst case without optimizations:

union(0,1), union(1,2), union(2,3), union(3,4)

Creates a linear chain:
0 â†’ 1 â†’ 2 â†’ 3 â†’ 4

find(0) traverses 4 edges!
```

With optimizations:
- **Path Compression:** Flatten the tree during find
- **Union by Rank/Size:** Keep trees balanced

Together: **O(Î±(n))** where Î± is the inverse Ackermann function â‰ˆ **O(1)** for practical purposes.

---

## ðŸ“ Optimization 1: Path Compression

### The Idea

When we call `find(x)`, we traverse from x to the root. **Path compression** makes all nodes on this path point directly to the root.

```
Before find(0):           After find(0):
                         
    4 (root)                  4 (root)
    â†‘                       â†— â†‘ â†–
    3                      0  3  1
    â†‘                         â†‘
    2                         2
    â†‘
    1
    â†‘
    0

find(0) returns 4, but now 0 â†’ 4 directly!
```

### Implementation

**Python:**
```python
def find(self, x: int) -> int:
    """
    Find with path compression.
    
    Makes every node on the path point directly to root.
    Time: O(Î±(n)) amortized â‰ˆ O(1)
    """
    if self.parent[x] != x:
        self.parent[x] = self.find(self.parent[x])  # Recursively compress
    return self.parent[x]
```

**JavaScript:**
```javascript
find(x) {
    if (this.parent[x] !== x) {
        this.parent[x] = this.find(this.parent[x]);  // Recursively compress
    }
    return this.parent[x];
}
```

### Iterative Version (Two-Pass)

```python
def find(self, x: int) -> int:
    """
    Iterative path compression (two-pass).
    
    Pass 1: Find root
    Pass 2: Update all nodes to point to root
    """
    # Pass 1: Find root
    root = x
    while self.parent[root] != root:
        root = self.parent[root]
    
    # Pass 2: Compress path
    while self.parent[x] != root:
        next_x = self.parent[x]
        self.parent[x] = root
        x = next_x
    
    return root
```

### Path Halving (Alternative)

```python
def find(self, x: int) -> int:
    """
    Path halving: Make every other node point to grandparent.
    
    Slightly less compression but simpler loop.
    """
    while self.parent[x] != x:
        self.parent[x] = self.parent[self.parent[x]]  # Skip to grandparent
        x = self.parent[x]
    return x
```

---

## ðŸ“ Optimization 2: Union by Rank

### The Idea

When merging two trees, attach the **shorter** tree under the **taller** tree. This keeps the overall tree height small.

```
Without union by rank:          With union by rank:
Always attach x to y            Attach shorter to taller

    y                               y
    â†‘                             â†—   â†–
    x                            x     z
  â†—   â†–                         â†‘
 a     b                        a   b
                                    â†‘
Trees can get tall!              c

Height stays O(log n)
```

### Implementation

**Python:**
```python
class UnionFind:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.rank = [0] * n  # Height/depth of tree rooted at i
    
    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x: int, y: int) -> bool:
        """
        Union by rank: attach smaller tree under larger.
        
        Rank is an upper bound on tree height.
        Only increment rank when merging equal-rank trees.
        """
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False
        
        # Attach smaller rank tree under larger rank tree
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            # Equal ranks: choose one, increment its rank
            self.parent[root_x] = root_y
            self.rank[root_y] += 1
        
        return True
```

**JavaScript:**
```javascript
class UnionFind {
    constructor(n) {
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.rank = new Array(n).fill(0);
    }
    
    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
    }
    
    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);
        
        if (rootX === rootY) return false;
        
        if (this.rank[rootX] < this.rank[rootY]) {
            this.parent[rootX] = rootY;
        } else if (this.rank[rootX] > this.rank[rootY]) {
            this.parent[rootY] = rootX;
        } else {
            this.parent[rootX] = rootY;
            this.rank[rootY]++;
        }
        
        return true;
    }
}
```

---

## ðŸ“ Optimization 3: Union by Size

### Alternative to Rank

Track the **size** (number of nodes) of each tree instead of rank. Attach smaller tree to larger tree.

**Advantage:** Size is always accurate (rank is only an upper bound after path compression).

**Python:**
```python
class UnionFindSize:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.size = [1] * n  # Size of tree rooted at i
    
    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x: int, y: int) -> bool:
        """Union by size: attach smaller tree under larger."""
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False
        
        # Attach smaller to larger
        if self.size[root_x] < self.size[root_y]:
            self.parent[root_x] = root_y
            self.size[root_y] += self.size[root_x]
        else:
            self.parent[root_y] = root_x
            self.size[root_x] += self.size[root_y]
        
        return True
    
    def get_size(self, x: int) -> int:
        """Get size of the set containing x."""
        return self.size[self.find(x)]
```

**JavaScript:**
```javascript
class UnionFindSize {
    constructor(n) {
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.size = new Array(n).fill(1);
    }
    
    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
    }
    
    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);
        
        if (rootX === rootY) return false;
        
        if (this.size[rootX] < this.size[rootY]) {
            this.parent[rootX] = rootY;
            this.size[rootY] += this.size[rootX];
        } else {
            this.parent[rootY] = rootX;
            this.size[rootX] += this.size[rootY];
        }
        
        return true;
    }
    
    getSize(x) {
        return this.size[this.find(x)];
    }
}
```

---

## ðŸ’» Complete Optimized Implementation

**Python (Production-Ready):**
```python
class UnionFind:
    """
    Optimized Union-Find with path compression and union by rank.
    
    Time Complexity: O(Î±(n)) â‰ˆ O(1) per operation
    Space Complexity: O(n)
    
    Features:
    - Path compression in find()
    - Union by rank
    - Component count tracking
    - Size tracking
    """
    
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.size = [1] * n
        self.count = n  # Number of components
    
    def find(self, x: int) -> int:
        """Find root with path compression."""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x: int, y: int) -> bool:
        """Union by rank. Returns True if merge happened."""
        root_x, root_y = self.find(x), self.find(y)
        
        if root_x == root_y:
            return False
        
        # Union by rank
        if self.rank[root_x] < self.rank[root_y]:
            root_x, root_y = root_y, root_x  # Ensure root_x has higher rank
        
        self.parent[root_y] = root_x
        self.size[root_x] += self.size[root_y]
        
        if self.rank[root_x] == self.rank[root_y]:
            self.rank[root_x] += 1
        
        self.count -= 1
        return True
    
    def connected(self, x: int, y: int) -> bool:
        """Check if x and y are in the same set."""
        return self.find(x) == self.find(y)
    
    def get_count(self) -> int:
        """Get number of disjoint sets."""
        return self.count
    
    def get_size(self, x: int) -> int:
        """Get size of set containing x."""
        return self.size[self.find(x)]


# Example: Number of Provinces
def findCircleNum(isConnected: list[list[int]]) -> int:
    n = len(isConnected)
    uf = UnionFind(n)
    
    for i in range(n):
        for j in range(i + 1, n):
            if isConnected[i][j] == 1:
                uf.union(i, j)
    
    return uf.get_count()


# Test
print(findCircleNum([[1,1,0],[1,1,0],[0,0,1]]))  # 2
print(findCircleNum([[1,0,0],[0,1,0],[0,0,1]]))  # 3
```

**JavaScript (Production-Ready):**
```javascript
class UnionFind {
    constructor(n) {
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.rank = new Array(n).fill(0);
        this.size = new Array(n).fill(1);
        this.count = n;
    }
    
    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
    }
    
    union(x, y) {
        let rootX = this.find(x);
        let rootY = this.find(y);
        
        if (rootX === rootY) return false;
        
        if (this.rank[rootX] < this.rank[rootY]) {
            [rootX, rootY] = [rootY, rootX];
        }
        
        this.parent[rootY] = rootX;
        this.size[rootX] += this.size[rootY];
        
        if (this.rank[rootX] === this.rank[rootY]) {
            this.rank[rootX]++;
        }
        
        this.count--;
        return true;
    }
    
    connected(x, y) {
        return this.find(x) === this.find(y);
    }
    
    getCount() {
        return this.count;
    }
    
    getSize(x) {
        return this.size[this.find(x)];
    }
}

// Example: Number of Provinces
function findCircleNum(isConnected) {
    const n = isConnected.length;
    const uf = new UnionFind(n);
    
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            if (isConnected[i][j] === 1) {
                uf.union(i, j);
            }
        }
    }
    
    return uf.getCount();
}

console.log(findCircleNum([[1,1,0],[1,1,0],[0,0,1]]));  // 2
console.log(findCircleNum([[1,0,0],[0,1,0],[0,0,1]]));  // 3
```

---

## âš¡ Complexity Analysis

### Comparison Table

| Implementation | find() | union() | Space |
|----------------|--------|---------|-------|
| Basic (no optimizations) | O(n) | O(n) | O(n) |
| Path compression only | O(log n) amortized | O(log n) | O(n) |
| Union by rank only | O(log n) | O(log n) | O(n) |
| **Both optimizations** | **O(Î±(n)) â‰ˆ O(1)** | **O(Î±(n)) â‰ˆ O(1)** | O(n) |

### What is Î±(n)?

Î±(n) is the **inverse Ackermann function**:

| n | Î±(n) |
|---|------|
| 1 | 0 |
| 2-4 | 1 |
| 5-16 | 2 |
| 17-65536 | 3 |
| 65537-2^65536 | 4 |
| > 2^65536 | 5 |

For any practical input size (even 10^18), Î±(n) â‰¤ 4.

**Bottom line:** Consider it O(1) for interviews!

---

## ðŸ”„ Rank vs Size

| Feature | Union by Rank | Union by Size |
|---------|--------------|---------------|
| **What it tracks** | Upper bound on height | Exact number of nodes |
| **After path compression** | May overestimate | Always accurate |
| **Extra feature** | None | Can query set size |
| **When to use** | Default choice | When you need sizes |

---

## âš ï¸ Common Mistakes

### 1. Forgetting Path Compression

```python
# âŒ Wrong: No compression
def find(self, x):
    while self.parent[x] != x:
        x = self.parent[x]
    return x

# âœ… Correct: With compression
def find(self, x):
    if self.parent[x] != x:
        self.parent[x] = self.find(self.parent[x])
    return self.parent[x]
```

### 2. Wrong Rank Update

```python
# âŒ Wrong: Always increment rank
self.parent[root_y] = root_x
self.rank[root_x] += 1  # Wrong! Only if equal ranks

# âœ… Correct: Only increment when equal
if self.rank[root_x] == self.rank[root_y]:
    self.rank[root_x] += 1
```

### 3. Not Updating Size Correctly

```python
# âŒ Wrong: Size not updated to root
self.parent[root_y] = root_x
# Forgot to update size!

# âœ… Correct: Add sizes
self.parent[root_y] = root_x
self.size[root_x] += self.size[root_y]
```

---

## ðŸ“ Practice Problems

| Problem | Why It's Good |
|---------|---------------|
| [Number of Provinces](https://leetcode.com/problems/number-of-provinces/) | Test basic implementation |
| [Redundant Connection](https://leetcode.com/problems/redundant-connection/) | Cycle detection |
| [Accounts Merge](https://leetcode.com/problems/accounts-merge/) | Complex grouping |

---

## ðŸŽ¤ Interview Tips

**What to say about optimizations:**

> "I'll use two optimizations to get near-constant time operations:
> 1. **Path compression**: When finding a root, I make all nodes point directly to it, flattening the tree.
> 2. **Union by rank**: When merging, I attach the shorter tree under the taller one to keep height logarithmic.
> 
> Together, these give O(Î±(n)) per operation, where Î± is the inverse Ackermann functionâ€”effectively O(1) for any practical input."

---

> **ðŸ’¡ Key Insight:** Path compression and union by rank work together synergistically. Path compression flattens trees after traversals, while union by rank prevents tall trees from forming in the first place.

> **ðŸ”— Related:** [Union-Find Fundamentals](./1.1-Union-Find-Fundamentals.md) | [Connected Components](./1.4-Advanced-Patterns/01-Connected-Components.md)

---

**Next:** [Advanced Patterns â†’](./1.4-Advanced-Patterns/01-Connected-Components.md)
