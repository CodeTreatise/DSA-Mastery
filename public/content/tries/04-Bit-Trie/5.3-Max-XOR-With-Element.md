# LC 1707: Maximum XOR With an Element From Array

> **Extension of Maximum XOR with an added constraint: the number must be â‰¤ a threshold. Combine Bit Trie with offline processing.**

---

## ðŸ“‹ Problem Statement

**LeetCode 1707 - Hard**

You are given an array `nums` consisting of non-negative integers. You are also given a `queries` array, where `queries[i] = [xi, mi]`.

For each query, find the maximum value of `nums[j] XOR xi` for all `j` where `nums[j] <= mi`. If no such element exists, answer is -1.

Return an array `answer` where `answer[i]` is the answer to the i-th query.

```
Input: nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
Output: [3,3,7]
Explanation:
- Query [3,1]: nums[j] <= 1 are {0,1}. Max XOR = 3^1=2, 3^0=3 â†’ 3
- Query [1,3]: nums[j] <= 3 are {0,1,2,3}. Max XOR = 1^2=3 â†’ 3  
- Query [5,6]: All nums apply. Max XOR = 5^2=7 â†’ 7
```

**Constraints:**
- 1 <= nums.length, queries.length <= 10^5
- queries[i].length == 2
- 0 <= nums[j], xi, mi <= 10^9

---

## ðŸŽ¯ Pattern Recognition

**Pattern:** Bit Trie + Offline Query Processing

**Key insight:** Instead of processing queries in given order, sort both nums and queries by the threshold value. Process queries in increasing threshold order, adding eligible numbers to Trie as we go.

---

## ðŸ“ Approach

### Why Offline Processing?

**Online approach problem:**
- For each query, we'd need to find numbers â‰¤ mi and query Trie
- Would require rebuilding/filtering Trie for each query

**Offline approach benefit:**
- Sort queries by mi (threshold)
- Sort nums by value
- Add numbers to Trie incrementally as thresholds increase
- Each number is inserted exactly once

---

## ðŸ’» Solution

### Optimal Solution: Sorted Queries + Bit Trie

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = [None, None]


class Solution:
    """
    Offline processing: Sort queries by threshold, add nums incrementally.
    
    Time: O(n log n + q log q + (n + q) Ã— 31)
    Space: O(n Ã— 31)
    """
    
    def maximizeXor(self, nums: list[int], queries: list[list[int]]) -> list[int]:
        # Sort nums
        nums.sort()
        
        # Sort queries by threshold (mi), keep original index
        sorted_queries = sorted(enumerate(queries), key=lambda x: x[1][1])
        
        root = TrieNode()
        max_bits = 31
        num_idx = 0
        n = len(nums)
        result = [-1] * len(queries)
        
        def insert(num: int) -> None:
            node = root
            for i in range(max_bits - 1, -1, -1):
                bit = (num >> i) & 1
                if node.children[bit] is None:
                    node.children[bit] = TrieNode()
                node = node.children[bit]
        
        def get_max_xor(num: int) -> int:
            if root.children[0] is None and root.children[1] is None:
                return -1  # Empty Trie
            
            node = root
            xor_val = 0
            
            for i in range(max_bits - 1, -1, -1):
                bit = (num >> i) & 1
                opposite = 1 - bit
                
                if node.children[opposite] is not None:
                    xor_val |= (1 << i)
                    node = node.children[opposite]
                elif node.children[bit] is not None:
                    node = node.children[bit]
                else:
                    return -1  # Should not happen if Trie not empty
            
            return xor_val
        
        # Process queries in order of increasing threshold
        for orig_idx, (xi, mi) in sorted_queries:
            # Add all nums <= mi to Trie
            while num_idx < n and nums[num_idx] <= mi:
                insert(nums[num_idx])
                num_idx += 1
            
            # Query max XOR
            result[orig_idx] = get_max_xor(xi)
        
        return result


# Test
sol = Solution()
print(sol.maximizeXor([0,1,2,3,4], [[3,1],[1,3],[5,6]]))  # [3,3,7]
print(sol.maximizeXor([5,2,4,6,6,3], [[12,4],[8,1],[6,3]]))  # [15,-1,5]
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = [null, null];
    }
}

function maximizeXor(nums, queries) {
    nums.sort((a, b) => a - b);
    
    // Sort queries by threshold, keep original index
    const sortedQueries = queries
        .map((q, i) => [i, q])
        .sort((a, b) => a[1][1] - b[1][1]);
    
    const root = new TrieNode();
    const maxBits = 31;
    let numIdx = 0;
    const result = new Array(queries.length).fill(-1);
    
    function insert(num) {
        let node = root;
        for (let i = maxBits - 1; i >= 0; i--) {
            const bit = (num >> i) & 1;
            if (node.children[bit] === null) {
                node.children[bit] = new TrieNode();
            }
            node = node.children[bit];
        }
    }
    
    function getMaxXor(num) {
        if (root.children[0] === null && root.children[1] === null) {
            return -1;
        }
        
        let node = root;
        let xorVal = 0;
        
        for (let i = maxBits - 1; i >= 0; i--) {
            const bit = (num >> i) & 1;
            const opposite = 1 - bit;
            
            if (node.children[opposite] !== null) {
                xorVal |= (1 << i);
                node = node.children[opposite];
            } else if (node.children[bit] !== null) {
                node = node.children[bit];
            } else {
                return -1;
            }
        }
        
        return xorVal;
    }
    
    for (const [origIdx, [xi, mi]] of sortedQueries) {
        while (numIdx < nums.length && nums[numIdx] <= mi) {
            insert(nums[numIdx]);
            numIdx++;
        }
        result[origIdx] = getMaxXor(xi);
    }
    
    return result;
}
```

---

### Alternative: Online with Deletion (More Complex)

For completeness, here's how you could handle it online with a more complex Trie that supports min/max value tracking at nodes:

**Python (Conceptual):**
```python
class TrieNodeWithMinMax:
    def __init__(self):
        self.children = [None, None]
        self.min_val = float('inf')  # Track minimum value in subtree


class SolutionOnline:
    """
    Online approach: Store min value at each node.
    When querying, only follow paths where min_val <= threshold.
    """
    
    def insert(self, num: int, root) -> None:
        node = root
        for i in range(30, -1, -1):
            bit = (num >> i) & 1
            if node.children[bit] is None:
                node.children[bit] = TrieNodeWithMinMax()
            node = node.children[bit]
            node.min_val = min(node.min_val, num)
    
    def get_max_xor_with_limit(self, num: int, limit: int, root) -> int:
        node = root
        xor_val = 0
        
        for i in range(30, -1, -1):
            bit = (num >> i) & 1
            opposite = 1 - bit
            
            # Try opposite bit if it has valid values
            if (node.children[opposite] is not None and 
                node.children[opposite].min_val <= limit):
                xor_val |= (1 << i)
                node = node.children[opposite]
            elif (node.children[bit] is not None and
                  node.children[bit].min_val <= limit):
                node = node.children[bit]
            else:
                return -1
        
        return xor_val
```

---

## ðŸ” Walkthrough: Offline Approach

```
nums = [0, 1, 2, 3, 4]
queries = [[3,1], [1,3], [5,6]]

Step 1: Sort nums = [0, 1, 2, 3, 4]

Step 2: Sort queries by threshold (mi):
- [3, 1] â†’ threshold 1, original index 0
- [1, 3] â†’ threshold 3, original index 1  
- [5, 6] â†’ threshold 6, original index 2

Step 3: Process queries in threshold order:

Query [3, 1] (threshold 1):
- Add nums <= 1 to Trie: insert(0), insert(1)
- Trie now has: 0, 1
- Query max XOR with 3: 3^1=2, 3^0=3 â†’ max is 3
- result[0] = 3

Query [1, 3] (threshold 3):
- Add nums <= 3 to Trie: insert(2), insert(3)
- Trie now has: 0, 1, 2, 3
- Query max XOR with 1: 1^2=3 â†’ max is 3
- result[1] = 3

Query [5, 6] (threshold 6):
- Add nums <= 6 to Trie: insert(4)
- Trie now has: 0, 1, 2, 3, 4
- Query max XOR with 5: 5^2=7 â†’ max is 7
- result[2] = 7

Final result: [3, 3, 7]
```

---

## âš¡ Complexity Analysis

| Phase | Time | Space |
|-------|------|-------|
| Sort nums | O(n log n) | O(log n) |
| Sort queries | O(q log q) | O(q) |
| Build Trie | O(n Ã— 31) | O(n Ã— 31) |
| Query | O(q Ã— 31) | O(1) |
| **Total** | **O(n log n + q log q + 31(n+q))** | **O(n Ã— 31)** |

**Simplified:** O((n + q) log(n + q)) for sorting + O((n + q) Ã— 31) for Trie operations.

---

## âš ï¸ Edge Cases

| Case | Handling |
|------|----------|
| No nums <= mi | Return -1 for that query |
| mi < min(nums) | Return -1 |
| All same numbers | XOR with self is 0 |
| Empty nums | All queries return -1 |

---

## ðŸŽ¤ Interview Tips

**Opening statement:**
"The constraint that nums[j] must be <= mi is tricky. I'll use offline processing - sort queries by threshold and add numbers incrementally."

**Key insight to communicate:**
"By processing queries in order of increasing threshold, each number is inserted exactly once, and the Trie only grows. This avoids deletion complexity."

**Follow-up questions:**
- "What if queries come in streaming order?" â†’ Use min-value tracking at nodes
- "What if we need exact equals, not <=?" â†’ Modify threshold comparison

---

## ðŸ“ Practice Checklist

- [ ] Understand offline query processing
- [ ] Implement sorted queries with original indices
- [ ] Handle empty Trie case (-1)
- [ ] Solve in < 30 minutes
- [ ] Know the online alternative approach

<details>
<summary><strong>ðŸ§  Spaced Repetition</strong></summary>

- **Day 1:** Trace through the offline approach
- **Day 3:** Implement without looking
- **Day 7:** Explain why offline is better than online
- **Day 14:** Solve a similar constraint problem

</details>

---

> **ðŸ’¡ Key Insight:** Offline processing transforms a constraint problem into an incremental building problem. Sort by constraint, add data incrementally, and the Trie only ever grows.

> **ðŸ”— Related:** [Maximum XOR](5.2-Maximum-XOR.md) | [Count Pairs With XOR](5.4-Count-XOR-Pairs.md)
