# Trie Variations

> **Beyond the basic character Trie: specialized structures for different use cases including Suffix Trie, Compressed Trie (Radix Tree), and Ternary Search Trie.**

---

## ðŸ“‹ Overview

The standard Trie (prefix tree) has several variations optimized for specific use cases:

| Variation | Key Feature | Best For |
|-----------|-------------|----------|
| **Suffix Trie** | All suffixes indexed | Substring search |
| **Compressed Trie (Radix)** | Merged single-child paths | Memory efficiency |
| **Ternary Search Trie** | 3 children (less/equal/greater) | Memory + speed balance |
| **Generalized Suffix Tree** | Multiple strings' suffixes | Pattern matching |

---

## 1ï¸âƒ£ Suffix Trie

### What Is It?

A **Suffix Trie** stores all suffixes of a string, enabling O(m) substring search where m is pattern length.

**For string "banana":**
```
Suffixes:
- banana
- anana
- nana
- ana
- na
- a

All stored in a single Trie structure.
```

### When to Use

| Use Case | Why |
|----------|-----|
| Substring search | Check if pattern exists anywhere in string |
| Repeated substrings | Find patterns that appear multiple times |
| Longest repeated substring | Available at deepest branching node |

### Implementation

**Python:**
```python
class SuffixTrie:
    """
    Suffix Trie for a single string.
    
    Build: O(nÂ²) time and space
    Search: O(m) where m is pattern length
    """
    
    def __init__(self, text: str):
        self.root = {}
        self.text = text
        self._build(text)
    
    def _build(self, text: str) -> None:
        """Insert all suffixes."""
        # Add terminal character to distinguish "an" vs "ana"
        text = text + "$"
        
        for i in range(len(text)):
            self._insert_suffix(text[i:], i)
    
    def _insert_suffix(self, suffix: str, start_idx: int) -> None:
        node = self.root
        for char in suffix:
            if char not in node:
                node[char] = {}
            node = node[char]
        node['$idx'] = start_idx  # Store starting position
    
    def contains_substring(self, pattern: str) -> bool:
        """Check if pattern exists as substring."""
        node = self.root
        for char in pattern:
            if char not in node:
                return False
            node = node[char]
        return True
    
    def find_all_occurrences(self, pattern: str) -> list[int]:
        """Find all starting positions of pattern."""
        node = self.root
        for char in pattern:
            if char not in node:
                return []
            node = node[char]
        
        # DFS to collect all indices
        return self._collect_indices(node)
    
    def _collect_indices(self, node: dict) -> list[int]:
        indices = []
        if '$idx' in node:
            indices.append(node['$idx'])
        for char in node:
            if char != '$idx':
                indices.extend(self._collect_indices(node[char]))
        return indices


# Usage
st = SuffixTrie("banana")
print(st.contains_substring("nan"))  # True
print(st.contains_substring("xyz"))  # False
print(st.find_all_occurrences("an"))  # [1, 3] (positions of "an")
```

### Complexity

| Operation | Time | Space |
|-----------|------|-------|
| Build | O(nÂ²) | O(nÂ²) |
| Search | O(m) | O(1) |

**Note:** For better space, use Suffix Tree or Suffix Array (O(n) space).

---

## 2ï¸âƒ£ Compressed Trie (Radix Tree)

### What Is It?

A **Compressed Trie** (Patricia Trie, Radix Tree) merges single-child nodes into one, storing multiple characters per edge.

**Standard Trie:**
```
     root
       |
       c
       |
       a
       |
       r
      / \
     s   e
     |
     $
```

**Compressed Trie:**
```
     root
       |
      "car"
      / \
    "s"  "e"
     $
```

### When to Use

| Use Case | Why |
|----------|-----|
| Memory-constrained | Much fewer nodes |
| Sparse key space | Long unique prefixes |
| IP routing | CIDR prefix matching |

### Implementation

**Python:**
```python
class RadixNode:
    def __init__(self, label: str = ""):
        self.label = label  # Edge label (can be multiple chars)
        self.children = {}
        self.is_end = False


class RadixTree:
    """
    Compressed Trie / Patricia Trie.
    
    Space: O(n) for n words (much better than O(total_chars))
    """
    
    def __init__(self):
        self.root = RadixNode()
    
    def insert(self, word: str) -> None:
        node = self.root
        i = 0
        
        while i < len(word):
            found = False
            
            for edge_char, child in node.children.items():
                if word[i] == edge_char:
                    # Found matching edge, check common prefix
                    label = child.label
                    j = 0
                    
                    while j < len(label) and i + j < len(word) and label[j] == word[i + j]:
                        j += 1
                    
                    if j == len(label):
                        # Consumed entire edge label
                        node = child
                        i += j
                        found = True
                        break
                    else:
                        # Need to split edge
                        self._split_edge(node, child, edge_char, label, j, word[i:])
                        return
            
            if not found:
                # No matching edge, create new child
                new_node = RadixNode(word[i:])
                new_node.is_end = True
                node.children[word[i]] = new_node
                return
        
        node.is_end = True
    
    def _split_edge(self, parent, old_child, edge_char, label, split_pos, remaining_word):
        """Split an edge at split_pos."""
        # Create intermediate node
        mid_node = RadixNode(label[:split_pos])
        
        # Update old child
        old_child.label = label[split_pos:]
        mid_node.children[label[split_pos]] = old_child
        
        # Add new word suffix
        if split_pos < len(remaining_word):
            new_suffix = remaining_word[split_pos:]
            new_node = RadixNode(new_suffix)
            new_node.is_end = True
            mid_node.children[new_suffix[0]] = new_node
        else:
            mid_node.is_end = True
        
        # Update parent
        parent.children[edge_char] = mid_node
    
    def search(self, word: str) -> bool:
        node = self.root
        i = 0
        
        while i < len(word):
            found = False
            for edge_char, child in node.children.items():
                if word[i] == edge_char:
                    label = child.label
                    if word[i:i+len(label)] == label:
                        node = child
                        i += len(label)
                        found = True
                        break
                    else:
                        return False
            
            if not found:
                return False
        
        return node.is_end


# Usage
rt = RadixTree()
rt.insert("test")
rt.insert("testing")
rt.insert("team")
print(rt.search("test"))     # True
print(rt.search("testing"))  # True
print(rt.search("tester"))   # False
```

---

## 3ï¸âƒ£ Ternary Search Trie (TST)

### What Is It?

A **Ternary Search Trie** stores characters in BST-like nodes with three children:
- **Left:** Characters less than current
- **Middle:** Characters equal (continue word)
- **Right:** Characters greater than current

### Why Use TST?

| Aspect | Standard Trie | TST |
|--------|---------------|-----|
| Space | O(alphabet_size) per node | O(1) per node |
| Search | O(m) | O(m + log n) average |
| Good for | Dense alphabets | Sparse alphabets |

### Implementation

**Python:**
```python
class TSTNode:
    def __init__(self, char: str):
        self.char = char
        self.left = None   # chars < char
        self.mid = None    # continue word
        self.right = None  # chars > char
        self.is_end = False


class TernarySearchTrie:
    """
    TST: Memory-efficient for sparse alphabets.
    
    Time: O(m + log n) average per operation
    Space: O(n Ã— m) total
    """
    
    def __init__(self):
        self.root = None
    
    def insert(self, word: str) -> None:
        self.root = self._insert(self.root, word, 0)
    
    def _insert(self, node, word: str, i: int):
        char = word[i]
        
        if node is None:
            node = TSTNode(char)
        
        if char < node.char:
            node.left = self._insert(node.left, word, i)
        elif char > node.char:
            node.right = self._insert(node.right, word, i)
        elif i < len(word) - 1:
            node.mid = self._insert(node.mid, word, i + 1)
        else:
            node.is_end = True
        
        return node
    
    def search(self, word: str) -> bool:
        node = self._search(self.root, word, 0)
        return node is not None and node.is_end
    
    def _search(self, node, word: str, i: int):
        if node is None:
            return None
        
        char = word[i]
        
        if char < node.char:
            return self._search(node.left, word, i)
        elif char > node.char:
            return self._search(node.right, word, i)
        elif i < len(word) - 1:
            return self._search(node.mid, word, i + 1)
        else:
            return node
    
    def starts_with(self, prefix: str) -> bool:
        node = self._search(self.root, prefix, 0)
        return node is not None


# Usage
tst = TernarySearchTrie()
tst.insert("cat")
tst.insert("car")
tst.insert("card")
print(tst.search("car"))       # True
print(tst.search("care"))      # False
print(tst.starts_with("ca"))   # True
```

---

## ðŸ“Š Comparison Summary

| Feature | Standard Trie | Suffix Trie | Radix Tree | TST |
|---------|---------------|-------------|------------|-----|
| Space/node | O(alphabet) | O(alphabet) | O(1) + label | O(1) |
| Search time | O(m) | O(m) | O(m) | O(m + log n) |
| Build time | O(total chars) | O(nÂ²) | O(total chars) | O(total chars Ã— log n) |
| Best for | Prefix search | Substring | Memory efficiency | Sparse alphabet |
| Memory | High | Very high | Low | Medium |

---

## ðŸŽ¯ Pattern Recognition

| If you see... | Consider... |
|---------------|-------------|
| "Find substring" | Suffix Trie/Tree |
| "Memory constrained + prefix" | Radix Tree |
| "Large alphabet (Unicode)" | TST |
| "Longest repeated substring" | Suffix structures |
| "IP routing / CIDR" | Radix Tree |

---

## âš ï¸ Common Mistakes

1. **Using Suffix Trie for large strings**
   - O(nÂ²) space is prohibitive for n > 10^4
   - Use Suffix Array or Suffix Tree instead

2. **Forgetting terminal markers in Suffix Trie**
   - Without "$", "an" and "ana" might confuse

3. **Over-engineering for simple problems**
   - Standard Trie is often sufficient
   - Don't use Radix Tree unless memory is actually an issue

---

## ðŸ“ Practice Problems

**Suffix-related:**
- [ ] Longest Repeated Substring
- [ ] Shortest Unique Prefix

**Radix Tree:**
- [ ] [Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/) (can use Radix)

**General:**
- [ ] Design search autocomplete with memory constraints

---

> **ðŸ’¡ Key Insight:** Choose your Trie variation based on constraints: Suffix Trie for substring search, Radix Tree for memory efficiency, TST for balanced memory/speed trade-off.

> **ðŸ”— Related:** [Basic Trie](../01-Trie-Fundamentals/1.1-What-Is-Trie.md) | [Bit Trie](../04-Bit-Trie/5.1-Bit-Trie-Fundamentals.md)
