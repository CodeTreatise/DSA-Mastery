# Two Sum (LeetCode 1)

> **The most famous coding interview problem. Master this and you understand hash maps.**

Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

**Constraints:**
- Each input has exactly one solution
- You may not use the same element twice
- Return answer in any order

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem signals:**
- "Find two numbers that sum to target" ‚úì
- Return **indices** not values
- Unsorted array (no mention of sorting)
- Exactly one solution guaranteed

**This is the classic Two Sum pattern:**
- Use hash map for O(1) complement lookup
- Store value ‚Üí index mapping
- Single pass through array

</details>

---

## ‚úÖ When to Use

- Finding a pair with target sum
- Need O(n) time complexity
- Array is unsorted
- Need to return indices (not just existence)

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Sorted array | Can achieve O(1) space | Two Pointers |
| Find all pairs | Hash map finds first | Track all occurrences |
| Very large arrays, memory constraint | O(n) space | Sort + Two Pointers |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, know:**
- Hash map operations (O(1) get/set)
- Array iteration with indices

**After mastering:**
- [3Sum](https://leetcode.com/problems/3sum/) - Triplets summing to zero
- [Two Sum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) - Sorted variant

**Combines with:**
- Prefix Sum (subarray sum problems)
- Sliding Window (constraint on distance)

</details>

---

## üìê How It Works

### Problem Example

```
Input: nums = [2, 7, 11, 15], target = 9
Output: [0, 1]
Explanation: nums[0] + nums[1] = 2 + 7 = 9
```

### Approach Comparison

| Approach | Time | Space | Description |
|----------|------|-------|-------------|
| Brute Force | O(n¬≤) | O(1) | Check every pair |
| Sort + Two Pointers | O(n log n) | O(n) | Need to track original indices |
| **Hash Map** | **O(n)** | **O(n)** | Store and lookup complements |

### Visualization

```
nums = [2, 7, 11, 15], target = 9

Step 1: i=0, num=2
        complement = 9 - 2 = 7
        seen = {}
        7 not in seen ‚Üí store seen[2] = 0
        seen = {2: 0}

Step 2: i=1, num=7
        complement = 9 - 7 = 2
        seen = {2: 0}
        2 IS in seen! ‚Üí return [seen[2], 1] = [0, 1] ‚úì
```

### Edge Case: Duplicate Values

```
nums = [3, 3], target = 6

Step 1: i=0, num=3
        complement = 6 - 3 = 3
        seen = {}
        3 not in seen ‚Üí store seen[3] = 0
        
Step 2: i=1, num=3
        complement = 6 - 3 = 3
        seen = {3: 0}
        3 IS in seen! ‚Üí return [0, 1] ‚úì

Works because we CHECK before STORING!
```

---

## üíª Code Implementation

### Python

```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        """
        Two Sum using hash map for O(1) complement lookup.
        
        Time: O(n) - single pass
        Space: O(n) - hash map storage
        """
        seen = {}  # value ‚Üí index
        
        for i, num in enumerate(nums):
            complement = target - num
            
            # Check if complement exists in seen values
            if complement in seen:
                return [seen[complement], i]
            
            # Store current value with its index
            seen[num] = i
        
        # Problem guarantees a solution exists
        return []
    
    def twoSum_bruteforce(self, nums: List[int], target: int) -> List[int]:
        """Brute force O(n¬≤) for comparison."""
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                if nums[i] + nums[j] == target:
                    return [i, j]
        return []
```

### JavaScript

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    // Hash map: value ‚Üí index
    const seen = new Map();
    
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        
        // Check if complement exists
        if (seen.has(complement)) {
            return [seen.get(complement), i];
        }
        
        // Store current value with its index
        seen.set(nums[i], i);
    }
    
    return []; // Problem guarantees solution exists
};

// Brute force for comparison
var twoSumBruteForce = function(nums, target) {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
    return [];
};
```

### Java

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        // Hash map: value ‚Üí index
        Map<Integer, Integer> seen = new HashMap<>();
        
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            
            if (seen.containsKey(complement)) {
                return new int[] { seen.get(complement), i };
            }
            
            seen.put(nums[i], i);
        }
        
        return new int[] {}; // Problem guarantees solution
    }
}
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Best | O(1) | O(1) | Answer at indices 0, 1 |
| Average | O(n) | O(n) | Typical case |
| Worst | O(n) | O(n) | Answer at last two elements |

**Time Complexity Breakdown:**
- Iterate through n elements: O(n)
- Each hash map operation (get/set): O(1) average
- Total: O(n) √ó O(1) = O(n)

**Space Complexity Breakdown:**
- Hash map stores at most n-1 elements
- Each entry: key (integer) + value (integer)
- Total: O(n)

---

## üîÑ Variations

| Variation | Key Difference | Link |
|-----------|----------------|------|
| Two Sum II (Sorted) | Use Two Pointers, O(1) space | [LC 167](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) |
| Two Sum Less Than K | Find pair with sum < K, maximize | [LC 1099](https://leetcode.com/problems/two-sum-less-than-k/) |
| Two Sum - Unique Pairs | Count unique pairs | Interview variant |
| Two Sum - Closest | Find pair closest to target | Interview variant |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Storing Before Checking

```python
# ‚ùå WRONG: May use same element twice
seen = {}
for i, num in enumerate(nums):
    seen[num] = i  # Store first
    if target - num in seen:
        return [seen[target - num], i]  # [i, i] when target = 2*num!

# ‚úÖ CORRECT: Check before storing
seen = {}
for i, num in enumerate(nums):
    if target - num in seen:  # Check first
        return [seen[target - num], i]
    seen[num] = i  # Store after
```

### 2. Off-by-One in Brute Force

```python
# ‚ùå WRONG: j starts from 0, may use same element
for i in range(n):
    for j in range(n):  # Should be range(i + 1, n)
        if nums[i] + nums[j] == target:
            return [i, j]

# ‚úÖ CORRECT: j starts from i + 1
for i in range(n):
    for j in range(i + 1, n):
        if nums[i] + nums[j] == target:
            return [i, j]
```

### 3. Using `in` on Map Values Instead of Keys

```python
# ‚ùå WRONG in JavaScript (checks if value is iterable, not membership)
if (complement in seen) // 'in' checks object keys as strings

# ‚úÖ CORRECT: Use Map.has()
if (seen.has(complement))
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Link | Notes |
|---------|------------|------|-------|
| Two Sum | üü¢ Easy | [LC 1](https://leetcode.com/problems/two-sum/) | This problem |
| Two Sum II | üü° Medium | [LC 167](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) | Two Pointers |
| 3Sum | üü° Medium | [LC 15](https://leetcode.com/problems/3sum/) | Build on Two Sum |
| 4Sum | üü° Medium | [LC 18](https://leetcode.com/problems/4sum/) | Recursive pattern |
| Two Sum IV - BST | üü¢ Easy | [LC 653](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) | Tree variant |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve Two Sum (LC 1) in < 5 minutes
- **Day 3:** Solve Two Sum II (LC 167) with Two Pointers
- **Day 7:** Solve 3Sum using Two Sum as building block
- **Day 14:** Explain pattern to someone, implement without IDE
- **Day 30:** Revisit - should be automatic

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interview</strong></summary>

**Step 1: Clarify (30 sec)**
> "So I need to find two numbers that sum to target and return their indices. Quick questions: Is there always exactly one solution? Can I use the same element twice? Is the array sorted?"

**Step 2: Approach (1 min)**
> "I'll use a hash map approach. For each number, I calculate its complement (target - num). If the complement is already in my hash map, I found the pair. Otherwise, I store the current number. This gives O(n) time and O(n) space."

**Step 3: Code (3-5 min)**
> [Write clean code with comments]

**Step 4: Test (1-2 min)**
> "Let me trace through [2, 7, 11, 15] with target 9..."

**Step 5: Complexity**
> "Time is O(n) for single pass, space is O(n) for the hash map. If memory were critical, I could sort and use two pointers for O(n log n) time and O(1) extra space, but I'd need to track original indices."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Phone screen favorite |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Expect O(n) solution |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Must solve in < 10 min |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Common warm-up |
| All Companies | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | **Most asked LC problem** |

---

## ‚è±Ô∏è Time Estimates

| Activity | Target Time | Notes |
|----------|-------------|-------|
| First solution | 10-15 min | Learning the pattern |
| Interview target | 5-7 min | With explanation |
| Expert level | 2-3 min | Should be automatic |

---

> **üí° Key Insight:** The magic of Two Sum is recognizing that "find a + b = target" becomes "for each a, check if (target - a) exists" - transforming a search problem into a lookup problem that hash maps solve in O(1).

> **üîó Related:** [Two Sum Overview](./4.1-Two-Sum-Overview.md) | [Contains Duplicate II](./4.3-Contains-Duplicate-II-LC219.md) | [3Sum](https://leetcode.com/problems/3sum/)
