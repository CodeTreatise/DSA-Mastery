# 3.1 Hash Maps (Hash Tables)

> **The O(1) Lookup Superpower**  
> **Interview Frequency:** Used in ~30% of all coding problems  
> **Prerequisite for:** Two Sum (unsorted), Subarray Sum, Anagram problems

---

> **üìå Note:** This file covers **Hash Map fundamentals** - how hashing works, collision handling, and language-specific APIs. For **Hash Map as an algorithm technique** (Two Sum pattern, frequency counting, complement lookup), see [05 Hash Map Technique](../01-Arrays/1.4-Common-Techniques/05-Hash-Map-Technique.md).

---

## What is a Hash Map?

A **Hash Map** (also called Hash Table, Dictionary, or Associative Array) is a data structure that stores **key-value pairs** and provides **O(1) average time** for insert, lookup, and delete operations.

> üí° *When Two Pointers requires sorted input, Hash Map is often the alternative for unsorted data.*

---

## ‚úÖ When to Use Hash Maps

- **O(1) lookup needed** - Finding complements, checking existence
- **Unsorted data** - Can't use Two Pointers without sorting first
- **Frequency counting** - Character counts, element frequencies
- **Caching/Memoization** - Store computed results
- **Grouping by key** - Group anagrams, categorize elements
- **Finding duplicates** - First/last occurrence tracking
- **Subarray sum problems** - With prefix sum technique

---

## ‚ùå When NOT to Use Hash Maps

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Data is already sorted | Two Pointers |" O(1) space vs O(n) space "|
| Need ordered iteration | TreeMap / Sorted Dict | Hash Maps don't maintain order |
| Memory is very constrained | Sort + Two Pointers |" O(n log n) time but O(1) space "|
| Known small value range (e.g., 1-26) | Array | Direct indexing is faster |
| Need min/max operations | Heap | Hash Map doesn't support efficient min/max |
| Range queries needed | Segment Tree / BIT | Hash Map can't do range operations |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Array Basics](../01-Arrays/1.1-Array-Basics.md) - Fundamental operations
- [Time Complexity](../../00-Prerequisites.md) - Big O understanding

**After mastering this:**
- [Hash Map Technique](../01-Arrays/1.4-Common-Techniques/05-Hash-Map-Technique.md) - Problem-solving patterns
- [Two Pointers](../01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md) - Alternative for sorted data

**Combines with:**
- **Prefix Sum** - Subarray sum equals K pattern
- **Sliding Window** - Track window contents
- **Trees/Graphs** - Path sum, visited tracking

</details>

---

## üîÑ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| **Hash Set** | Keys only, no values | Check existence, remove duplicates |
| **Hash Map** | Key-value pairs | Store associated data |
| **Multimap** | Multiple values per key | Group by key |
| **LinkedHashMap** | Maintains insertion order | LRU Cache |
| **TreeMap** | Sorted by key | Ordered iteration |
| **DefaultDict** | Auto-initializes missing keys | Counting, grouping |
| **Counter** | Built-in frequency counting | Character/element counts |

---

## üìê How Hashing Works

```
Key: "apple"
     ‚Üì
Hash Function: hash("apple") = 2
     ‚Üì
Storage: 
‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 0 ‚îÇ                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1 ‚îÇ                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 2 ‚îÇ "apple" ‚Üí 5       ‚îÇ  ‚Üê Stored here
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 3 ‚îÇ                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 4 ‚îÇ                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Steps:**
1. **Hash Function:** Converts key to an integer (hash code)
2. **Index Calculation:** `index = hash_code % array_size`
3. **Store/Retrieve:** Access array at calculated index

---

## üîÄ Collision Handling

When two keys hash to the same index:

### Chaining (Most Common)

```
Hash Table with Chaining:
‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 0 ‚îÇ                                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1 ‚îÇ ["cat"‚Üí3] ‚Üí ["dog"‚Üí7]           ‚îÇ  ‚Üê Linked list
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 2 ‚îÇ ["apple"‚Üí5]                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 3 ‚îÇ                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Open Addressing (Linear Probing)

```
If index 2 is occupied, try 3, then 4, etc.

‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 0 ‚îÇ               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1 ‚îÇ               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 2 ‚îÇ "apple" ‚Üí 5   ‚îÇ  ‚Üê First key
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 3 ‚îÇ "banana" ‚Üí 3  ‚îÇ  ‚Üê Collision, moved to next slot
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 4 ‚îÇ               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## ‚ö° Time Complexity

### üîÄ When to Use Hash Map vs Two Pointers

```mermaid
flowchart TD
    A["Need O(1) lookup?"] --> B{Data sorted?}
    B -->|Yes| C{O(1) space needed?}
    C -->|Yes| D[‚úÖ Two Pointers]
    C -->|No| E[Either works]
    B -->|No| F{Can afford O(n) space?}
    F -->|Yes| G[‚úÖ Hash Map]
    F -->|No| H[Sort first + Two Pointers]
    
    style D fill:#90EE90
    style G fill:#87CEEB
```

| Operation | Average | Worst | Notes |
|-----------|---------|-------|-------|
| Insert |" O(1) "| O(n) | Worst when many collisions |
| Lookup |" O(1) "| O(n) | Worst when all keys collide |
| Delete |" O(1) "| O(n) | Same as lookup |
| Space |" O(n) "| O(n) | n = number of entries |

**When O(1)?**
- Good hash function (uniform distribution)
- Load factor < 0.75 (auto-resize triggers)

**When O(n)?**
- All keys hash to same index (worst case)
- Very poor hash function

---

## üíª Language Implementations

### Python

```python
# dict - built-in hash map
d = {}                          # Empty
d = {'a': 1, 'b': 2}           # With values
d = dict(a=1, b=2)             # Alternative

# Basic operations
d['c'] = 3                      # Insert/Update
value = d['a']                  # Lookup (KeyError if missing)
value = d.get('z', 0)           # Safe lookup with default
del d['a']                      # Delete

# Check existence
if 'a' in d:                    # O(1)
    print(d['a'])

# Iteration
for key in d:                   # Keys
    print(key)
for key, value in d.items():    # Key-value pairs
    print(f"{key}: {value}")
for value in d.values():        # Values only
    print(value)

# Useful methods
d.keys()                        # All keys
d.values()                      # All values
d.items()                       # Key-value tuples
len(d)                          # Number of entries
d.pop('a', None)                # Remove and return (with default)
d.clear()                       # Remove all
```

### Python: defaultdict and Counter

```python
from collections import defaultdict, Counter

# defaultdict - auto-creates missing keys
freq = defaultdict(int)         # Default value: 0
freq['a'] += 1                  # No KeyError!
freq['b'] += 1
# {'a': 1, 'b': 1}

# List as default
adj = defaultdict(list)
adj['node1'].append('node2')    # No need to initialize list

# Counter - frequency counting
text = "hello"
count = Counter(text)           # {'l': 2, 'h': 1, 'e': 1, 'o': 1}

# Most common
count.most_common(2)            # [('l', 2), ('h', 1)]

# Operations
counter1 + counter2             # Add counts
counter1 - counter2             # Subtract counts
counter1 & counter2             # Min of each
counter1 | counter2             # Max of each
```

### JavaScript

```javascript
// Object - simple key-value (keys are strings)
let obj = {};
let obj = { a: 1, b: 2 };

// Basic operations
obj['c'] = 3;                   // Insert
obj.c = 3;                      // Dot notation
let value = obj['a'];           // Lookup
delete obj['a'];                // Delete

// Check existence
if ('a' in obj) { }
if (obj.hasOwnProperty('a')) { }

// Iteration
Object.keys(obj)                // ['a', 'b']
Object.values(obj)              // [1, 2]
Object.entries(obj)             // [['a',1], ['b',2]]

// Map - more flexible (any key type)
let map = new Map();
map.set('a', 1);                // Insert
map.get('a');                   // Lookup
map.has('a');                   // Check existence
map.delete('a');                // Delete
map.size;                       // Number of entries

// Map iteration
for (let [key, value] of map) {
    console.log(key, value);
}

// Set - unique values only
let set = new Set([1, 2, 3, 3]); // {1, 2, 3}
set.add(4);
set.has(2);                     // true
set.delete(1);
set.size;
```

### Java

```java
import java.util.*;

// HashMap
Map<String, Integer> map = new HashMap<>();
map.put("a", 1);                // Insert
map.get("a");                   // Lookup
map.getOrDefault("z", 0);       // Safe lookup
map.containsKey("a");           // Check existence
map.remove("a");                // Delete
map.size();                     // Number of entries

// Iteration
for (String key : map.keySet()) { }
for (Integer val : map.values()) { }
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    entry.getKey();
    entry.getValue();
}

// HashSet - unique values
Set<Integer> set = new HashSet<>();
set.add(1);
set.contains(1);                // true
set.remove(1);
```

---

## üéØ Common Patterns

### 1. Two Sum (Unsorted Array)

```python
def two_sum(nums: list[int], target: int) -> list[int]:
    """Find indices of two numbers that sum to target.
    
    Pattern: Hash Map for complement lookup
    Time: O(n), Space: O(n)
    """
    seen = {}  # value ‚Üí index
    
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    
    return [-1, -1]


# Example
print(two_sum([2, 7, 11, 15], 9))  # [0, 1]
print(two_sum([3, 2, 4], 6))       # [1, 2]
```

**Why Hash Map?**
- Array is unsorted ‚Üí Two Pointers won't work
- Need O(1) lookup for complement
- Trade space for time: O(n) space ‚Üí O(n) time

### 2. Frequency Counting

```python
def is_anagram(s: str, t: str) -> bool:
    """Check if t is anagram of s.
    
    Time: O(n), Space: O(1) - only 26 letters
    """
    if len(s) != len(t):
        return False
    
    from collections import Counter
    return Counter(s) == Counter(t)


# Manual approach
def is_anagram_manual(s: str, t: str) -> bool:
    if len(s) != len(t):
        return False
    
    count = {}
    for c in s:
        count[c] = count.get(c, 0) + 1
    for c in t:
        count[c] = count.get(c, 0) - 1
        if count[c] < 0:
            return False
    
    return True
```

### 3. First Non-Repeating Element

```python
def first_unique_char(s: str) -> int:
    """Find index of first non-repeating character.
    
    Time: O(n), Space: O(1) - only 26 letters
    """
    from collections import Counter
    count = Counter(s)
    
    for i, c in enumerate(s):
        if count[c] == 1:
            return i
    
    return -1


# Example
print(first_unique_char("leetcode"))  # 0 ('l')
print(first_unique_char("loveleetcode"))  # 2 ('v')
```

### 4. Subarray Sum Equals K

```python
def subarray_sum(nums: list[int], k: int) -> int:
    """Count subarrays with sum equal to k.
    
    Pattern: Prefix Sum + Hash Map
    Time: O(n), Space: O(n)
    """
    count = 0
    prefix_sum = 0
    sum_count = {0: 1}  # prefix_sum ‚Üí count
    
    for num in nums:
        prefix_sum += num
        
        # If (prefix_sum - k) exists, we found subarrays
        if prefix_sum - k in sum_count:
            count += sum_count[prefix_sum - k]
        
        # Store current prefix sum
        sum_count[prefix_sum] = sum_count.get(prefix_sum, 0) + 1
    
    return count


# Example
print(subarray_sum([1, 1, 1], 2))  # 2 ([1,1] at indices 0-1 and 1-2)
print(subarray_sum([1, 2, 3], 3))  # 2 ([1,2] and [3])
```

### 5. Group Anagrams

```python
def group_anagrams(strs: list[str]) -> list[list[str]]:
    """Group strings that are anagrams of each other.
    
    Pattern: Hash Map with sorted string as key
    Time: O(n * k log k), Space: O(n * k)
    where n = number of strings, k = max string length
    """
    from collections import defaultdict
    
    groups = defaultdict(list)
    
    for s in strs:
        # Use sorted string as key (anagrams have same sorted form)
        key = tuple(sorted(s))
        groups[key].append(s)
    
    return list(groups.values())


# Example
print(group_anagrams(["eat", "tea", "tan", "ate", "nat", "bat"]))
# [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]
```

### 6. Contains Duplicate

```python
def contains_duplicate(nums: list[int]) -> bool:
    """Check if array contains any duplicates.
    
    Time: O(n), Space: O(n)
    """
    seen = set()
    
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    
    return False


# One-liner
def contains_duplicate_oneliner(nums: list[int]) -> bool:
    return len(nums) != len(set(nums))
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Mutable Keys

‚ùå **Wrong:**
```python
d = {}
d[[1, 2, 3]] = "value"  # TypeError: unhashable type: 'list'
```

‚úÖ **Correct:**
```python
d = {}
d[tuple([1, 2, 3])] = "value"  # Tuples are hashable
d[(1, 2, 3)] = "value"
```

### 2. Missing Key Access

‚ùå **Wrong:**
```python
d = {'a': 1}
value = d['b']  # KeyError!
```

‚úÖ **Correct:**
```python
# Option 1: Use .get() with default
value = d.get('b', 0)

# Option 2: Check first
if 'b' in d:
    value = d['b']

# Option 3: defaultdict
from collections import defaultdict
d = defaultdict(int)
value = d['b']  # Returns 0, no error
```

### 3. Modifying While Iterating

‚ùå **Wrong:**
```python
d = {'a': 1, 'b': 2, 'c': 3}
for key in d:
    if d[key] < 2:
        del d[key]  # RuntimeError: dictionary changed size
```

‚úÖ **Correct:**
```python
# Create list of keys first
for key in list(d.keys()):
    if d[key] < 2:
        del d[key]

# Or use dictionary comprehension
d = {k: v for k, v in d.items() if v >= 2}
```

### 4. JavaScript Object vs Map

‚ùå **Wrong for numeric keys:**
```javascript
let obj = {};
obj[1] = "one";
obj["1"] = "ONE";
console.log(obj);  // { '1': 'ONE' } - only one entry!
```

‚úÖ **Correct:**
```javascript
let map = new Map();
map.set(1, "one");
map.set("1", "ONE");
console.log(map.size);  // 2 - different keys!
```

---

## üìä Hash Map vs Alternatives

| Scenario | Best Choice | Why |
|----------|-------------|-----|
| Unsorted array, find pair | **Hash Map** |" O(1) lookup for complement "|
| Sorted array, find pair | Two Pointers |" O(1) space "|
| Count frequencies | **Hash Map** |" O(1) increment "|
| Find duplicates | **Hash Set** |" O(1) contains check "|
| Ordered keys needed | TreeMap / OrderedDict | Maintains order |
| Known small range (1-1000) | Array | Direct indexing |

---

## üìù Practice Problems (Progressive)

### Easy (Learn the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Two Sum | Hash Map for complement | [LC 1](https://leetcode.com/problems/two-sum/) |
| Valid Anagram | Frequency counting | [LC 242](https://leetcode.com/problems/valid-anagram/) |
| Contains Duplicate | Hash Set | [LC 217](https://leetcode.com/problems/contains-duplicate/) |
| First Unique Character | Frequency + scan | [LC 387](https://leetcode.com/problems/first-unique-character-in-a-string/) |
| Ransom Note | Frequency comparison | [LC 383](https://leetcode.com/problems/ransom-note/) |

### Medium (Apply variations)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Group Anagrams | Hash Map with clever key | [LC 49](https://leetcode.com/problems/group-anagrams/) |
| Subarray Sum Equals K | Prefix Sum + Hash Map | [LC 560](https://leetcode.com/problems/subarray-sum-equals-k/) |
| Top K Frequent Elements | Counter + heap | [LC 347](https://leetcode.com/problems/top-k-frequent-elements/) |
| Longest Consecutive Sequence |" Hash Set for O(n) "| [LC 128](https://leetcode.com/problems/longest-consecutive-sequence/) |

### Hard (Master edge cases)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Minimum Window Substring | Hash Map + Sliding Window | [LC 76](https://leetcode.com/problems/minimum-window-substring/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

After learning hash maps:
- **Day 1:** Solve Two Sum, explain why Hash Map vs sorted
- **Day 3:** Solve Group Anagrams without hints
- **Day 7:** Implement hash table from scratch (chaining)
- **Day 14:** Solve Subarray Sum Equals K (prefix sum + hash)
- **Day 30:** Explain collision handling to someone

</details>

---

## üé§ Interview Context

<details>
<summary><strong>What Interviewers Expect</strong></summary>

**Must-know:**
- Hash Map for O(1) lookup
- When to use Hash Map vs Two Pointers
- Collision handling (chaining, open addressing)
- Trade-off: O(n) space for O(1) time

**Common interview scenarios:**
| Problem Type | Expected Approach |
|--------------|-------------------|
| Two Sum (unsorted) | Hash Map |
| Frequency counting | Hash Map / Counter |
| Finding duplicates | Hash Set |
| Grouping by property | Hash Map with clever key |
| Subarray with sum k | Prefix Sum + Hash Map |

**Company focus:**
| Company | Hash Map Focus |
|---------|---------------|
| Amazon | Two Sum variations, frequency |
| Google | Complex key design, trade-offs |
| Meta | Clean code, edge cases |
| Microsoft | Fundamentals, collision handling |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn concept | 20-30 min | Understanding hashing |
| Solve Easy problem | 10-15 min | Two Sum, Anagram |
| Solve Medium problem | 20-30 min | Group Anagrams |
| Master pattern | 4-6 problems | Various applications |

---

## üìö Resources

**Videos:**
- [NeetCode - Hashing Problems](https://www.youtube.com/playlist?list=PLot-Xpze53lfOdF3KwpMSFEyfE77zIwiP)
- [Striver - Hashing Theory](https://www.youtube.com/watch?v=KEs5UUAwZjA)

**Articles:**
- [Tech Interview Handbook - Hash Table](https://www.techinterviewhandbook.org/algorithms/hash-table/)
- [GeeksforGeeks - Hashing Tutorial](https://www.geeksforgeeks.org/hashing-data-structure/)

---

> **üí° Key Insight:** Hash Maps trade space for time. When you need O(1) lookup and can afford O(n) space, Hash Map is usually the answer. Two Sum unsorted? Hash Map. Frequency counting? Hash Map. Finding duplicates? Hash Set.

> **üîó Related:** [Two Pointers](../01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md) (sorted alternative) | [Prefix Sum](../01-Arrays/1.4-Common-Techniques/03-Prefix-Sum.md) (combines with Hash Map)
