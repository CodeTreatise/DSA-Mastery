# Distinct Subsequences (LC 115)

> **Counting, not just matching.** How many ways can you form string `t` as a subsequence of string `s`? This is the counting variant of the subsequence matching problem.

---

## ðŸ“‹ Problem Statement

**LeetCode:** [115. Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/)

Given two strings `s` and `t`, return the number of distinct subsequences of `s` which equals `t`.

A subsequence of a string is a new string generated by deleting some (can be none) of the characters without disturbing the relative order of the remaining characters.

The answer is guaranteed to fit in a 32-bit signed integer.

**Examples:**
```
Input: s = "rabbbit", t = "rabbit"
Output: 3
Explanation: There are 3 ways to choose "rabbit" from "rabbbit":
  ra_bbit (skip 3rd 'b')
  rab_bit (skip 4th 'b')
  rabb_it (skip 5th 'b')

Input: s = "babgbag", t = "bag"
Output: 5
Explanation: 
  ba____g (indices 0,1,6)
  ba___a_ (indices 0,1,4)
  b__g_ag (indices 0,3,4,6 - wait, that's "bgag")
  Actually: ba_g___ (0,1,3), ba___g (0,1,6), b__gbag removes chars...
  5 different ways to select "bag"
```

**Constraints:**
- 1 â‰¤ s.length, t.length â‰¤ 1000
- s and t consist of English letters

---

## ðŸŽ¯ Pattern Recognition

**Why DP?**
- Overlapping subproblems: counting for prefixes
- Optimal substructure: ways for `s[:i]` and `t[:j]` builds on smaller
- Choice at each step: include or skip character

**State:** `dp[i][j]` = number of ways to form `t[0..j-1]` from `s[0..i-1]`

---

## ðŸ“ Approach Analysis

### Transition Logic

At each position, we decide: do we USE `s[i-1]` to match `t[j-1]`?

```
if s[i-1] == t[j-1]:
    dp[i][j] = dp[i-1][j-1]  # Use s[i-1] to match t[j-1]
             + dp[i-1][j]    # Skip s[i-1], find other ways
else:
    dp[i][j] = dp[i-1][j]    # Can't use s[i-1], skip it
```

### Base Cases

```
dp[i][0] = 1 for all i
  â†’ Empty target can be formed in exactly 1 way (delete all of s)

dp[0][j] = 0 for j > 0
  â†’ Non-empty target can't be formed from empty source
```

### Visualization

```
s = "rabbbit", t = "rabbit"

     ""  r  a  b  b  i  t
""   1   0  0  0  0  0  0
r    1   1  0  0  0  0  0
a    1   1  1  0  0  0  0
b    1   1  1  1  0  0  0
b    1   1  1  2  1  0  0   â† 2 ways to form "rab"
b    1   1  1  3  3  0  0   â† 3 ways to form "rab", "rabb"
i    1   1  1  3  3  3  0
t    1   1  1  3  3  3  3   â† 3 ways to form "rabbit"

Transition example: dp[5][4] = dp[4][3] + dp[4][4] = 2 + 1 = 3
```

---

## ðŸ’» Solutions

### Solution 1: 2D DP (Clear)

```python
def num_distinct(s: str, t: str) -> int:
    """
    Count distinct subsequences.
    Time: O(mn), Space: O(mn)
    """
    m, n = len(s), len(t)
    
    # dp[i][j] = ways to form t[:j] from s[:i]
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Base case: empty t can be formed 1 way
    for i in range(m + 1):
        dp[i][0] = 1
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                # Use s[i-1] OR skip it
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                # Must skip s[i-1]
                dp[i][j] = dp[i - 1][j]
    
    return dp[m][n]
```

```javascript
function numDistinct(s, t) {
    const m = s.length, n = t.length;
    const dp = Array.from({length: m + 1}, () => new Array(n + 1).fill(0));
    
    // Empty t can be formed 1 way
    for (let i = 0; i <= m; i++) {
        dp[i][0] = 1;
    }
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (s[i - 1] === t[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    
    return dp[m][n];
}
```

### Solution 2: Space-Optimized 1D DP

```python
def num_distinct_optimized(s: str, t: str) -> int:
    """
    Space-optimized: process RIGHT to LEFT.
    Time: O(mn), Space: O(n)
    
    Key: Process j from right to left to avoid overwriting
         values we still need (like 0/1 knapsack).
    """
    m, n = len(s), len(t)
    
    # dp[j] = ways to form t[:j] from s[:i]
    dp = [0] * (n + 1)
    dp[0] = 1  # Empty t
    
    for i in range(1, m + 1):
        # Process right to left!
        for j in range(min(i, n), 0, -1):
            if s[i - 1] == t[j - 1]:
                dp[j] += dp[j - 1]  # Add "use s[i-1]" ways
            # else: dp[j] stays same (skip s[i-1])
    
    return dp[n]
```

```javascript
function numDistinctOptimized(s, t) {
    const m = s.length, n = t.length;
    const dp = new Array(n + 1).fill(0);
    dp[0] = 1;
    
    for (let i = 1; i <= m; i++) {
        // Right to left to preserve values
        for (let j = Math.min(i, n); j >= 1; j--) {
            if (s[i - 1] === t[j - 1]) {
                dp[j] += dp[j - 1];
            }
        }
    }
    
    return dp[n];
}
```

### Solution 3: Top-Down with Memoization

```python
def num_distinct_memo(s: str, t: str) -> int:
    """Recursive with memoization."""
    from functools import lru_cache
    
    @lru_cache(maxsize=None)
    def dp(i: int, j: int) -> int:
        # Formed all of t
        if j == 0:
            return 1
        # Ran out of s but still need t
        if i == 0:
            return 0
        
        # Skip s[i-1]
        result = dp(i - 1, j)
        
        # Use s[i-1] if matches
        if s[i - 1] == t[j - 1]:
            result += dp(i - 1, j - 1)
        
        return result
    
    return dp(len(s), len(t))
```

---

## âš¡ Complexity Analysis

| Approach | Time | Space |
|----------|------|-------|
| 2D DP | O(mn) | O(mn) |
| 1D DP | O(mn) | O(n) |
| Memoization | O(mn) | O(mn) |

**Why right-to-left for 1D?**
- `dp[j]` needs `dp[j-1]` from the previous row
- If we go left-to-right, we overwrite `dp[j-1]` before using it
- Right-to-left preserves the values we need

---

## ðŸ“Š Detailed Trace

```
s = "babgbag", t = "bag"

     ""   b   a   g
""   1    0   0   0
b    1    1   0   0   (s[0]='b', t[0]='b': dp[1][1]=dp[0][0]+dp[0][1]=1+0=1)
a    1    1   1   0   (s[1]='a', t[1]='a': dp[2][2]=dp[1][1]+dp[1][2]=1+0=1)
b    1    2   1   0   (s[2]='b', t[0]='b': dp[3][1]=dp[2][0]+dp[2][1]=1+1=2)
g    1    2   1   1   (s[3]='g', t[2]='g': dp[4][3]=dp[3][2]+dp[3][3]=1+0=1)
b    1    3   2   1   (s[4]='b': dp[5][1]=2+1=3, but also affects dp[5][2]?)
                       Actually: dp[5][1]=dp[4][0]+dp[4][1]=1+2=3
                                dp[5][2]=dp[4][2]=1 (no match for 'a')
a    1    3   5   1   (s[5]='a', t[1]='a': dp[6][2]=dp[5][1]+dp[5][2]=3+2=5)
g    1    3   5   5   (s[6]='g', t[2]='g': dp[7][3]=dp[6][2]+dp[6][3]=5+1... wait)

Let me recalculate more carefully:

     ""   b   a   g
""   1    0   0   0
b    1    1   0   0
a    1    1   1   0
b    1    2   1   0
g    1    2   1   1
b    1    3   1   1
a    1    3   4   1
g    1    3   4   5

Answer: 5 âœ“
```

---

## âš ï¸ Common Mistakes

### 1. Wrong Base Case

**âŒ Wrong:**
```python
dp[0][0] = 1
# Forgot other base cases
```

**âœ… Correct:**
```python
for i in range(m + 1):
    dp[i][0] = 1  # Empty t: 1 way for ALL i
```

### 2. Left-to-Right in 1D (Overwrites Values)

**âŒ Wrong:**
```python
for j in range(1, n + 1):  # Left to right
    if s[i-1] == t[j-1]:
        dp[j] += dp[j-1]  # dp[j-1] already updated!
```

**âœ… Correct:**
```python
for j in range(min(i, n), 0, -1):  # Right to left
    if s[i-1] == t[j-1]:
        dp[j] += dp[j-1]  # dp[j-1] still from previous row
```

### 3. Integer Overflow (in some languages)

```python
# Python handles big integers naturally
# In C++/Java, you may need modulo or BigInteger
```

### 4. Confusing "Include" vs "Skip"

```python
# When s[i-1] == t[j-1]:
#   Include: dp[i-1][j-1] â†’ both advance
#   Skip:    dp[i-1][j]   â†’ only s advances

# When s[i-1] != t[j-1]:
#   Only skip: dp[i-1][j]
```

---

## ðŸ”„ Related Problems

### Is Subsequence (LC 392) - Boolean Version

```python
def is_subsequence(s: str, t: str) -> bool:
    """Simpler: just check if possible, not count."""
    si = 0
    for c in t:
        if si < len(s) and s[si] == c:
            si += 1
    return si == len(s)
```

### Number of Subsequences That Satisfy Condition (LC 1498)

Different problem: counting subsequences with min/max constraint.

---

## ðŸ“ Practice Problems

| Problem | Difficulty | Relation |
|---------|------------|----------|
| [392. Is Subsequence](https://leetcode.com/problems/is-subsequence/) | Easy | Boolean version |
| [115. Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/) | Hard | This problem |
| [940. Distinct Subsequences II](https://leetcode.com/problems/distinct-subsequences-ii/) | Hard | Different: count distinct subseqs |
| [1143. LCS](https://leetcode.com/problems/longest-common-subsequence/) | Medium | Related DP structure |

---

## ðŸŽ¤ Interview Tips

**Time to solve:** 20-25 minutes

**Communication template:**
> "I need to count how many ways t appears as a subsequence of s.

> I'll use dp[i][j] = number of ways to form t[0..j-1] from s[0..i-1].

> At each character of s, I have two choices if it matches the current character of t: USE it (look at dp[i-1][j-1]) or SKIP it (look at dp[i-1][j]). The answer is the sum.

> The key insight is that this is a counting problem, not just boolean, so I add the ways instead of OR-ing."

**Why count, not boolean?**
> "We add dp[i-1][j-1] + dp[i-1][j] because both paths contribute to the total count. It's like counting paths in a grid where we can take different routes."

**Space optimization insight:**
> "We can use 1D DP by processing right to left, similar to 0/1 knapsack. This preserves the dp[j-1] value from the previous row."

**Company frequency:**
| Company | Frequency |
|---------|-----------|
| Google | â­â­â­â­ |
| Meta | â­â­â­ |
| Amazon | â­â­â­ |
| Bloomberg | â­â­â­ |

---

## ðŸ’¡ Insight: Include-or-Skip Pattern

This problem exemplifies the **include-or-skip** counting pattern:

```
When current items match:
  count = count_using_current + count_skipping_current
        = dp[i-1][j-1] + dp[i-1][j]

When they don't match:
  count = count_skipping_current
        = dp[i-1][j]
```

This pattern appears in:
- **0/1 Knapsack** (include item or skip)
- **Coin Change II** (use coin or skip)
- **Subset Sum** (include element or skip)

---

> **ðŸ’¡ Key Insight:** The magic is in the transition: when characters match, we ADD the "use" and "skip" paths because both contribute to the count. This is what distinguishes counting problems from boolean matching problems.

> **ðŸ”— Related:** [String DP Patterns](../10.1-String-DP-Patterns.md) | [LCS](../../06-LCS-Pattern/6.6-LCS-Practice/01-LCS-LC1143.md) | [0/1 Knapsack](../../04-Knapsack-01/6.1-Knapsack-01-Pattern.md)
