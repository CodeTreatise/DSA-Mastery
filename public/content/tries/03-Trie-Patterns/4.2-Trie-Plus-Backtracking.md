# Trie + Backtracking Pattern

> **Trie + Backtracking is the killer combination for grid word search problems - use Trie to prune invalid paths early and backtracking to explore all directions.**

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Find all words from dictionary in grid"
- "Word search with multiple words"
- "Board with characters, find valid words"
- Given: grid + word list, find: all matching words

**Classic problem:**
- LC 212: Word Search II
- Given m√ón board and list of words, find all words that exist

**Why Trie + Backtracking?**
- Backtracking alone: O(n √ó m √ó 4^L) per word √ó W words
- With Trie: O(n √ó m √ó 4^L) total - search all words simultaneously!

</details>

---

## ‚úÖ When to Use

| Scenario | Why This Pattern |
|----------|-----------------|
| **Multiple word search in grid** | Search all words in one traversal |
| **Dictionary validation on path** | Prune invalid prefixes early |
| **Finding all valid combinations** | Trie tells us what's "valid" |
| **Word games (Boggle, Scrabble)** | Real-world application |

---

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|-------------------|
| **Single word in grid** | Simple backtracking (LC 79) |
| **No dictionary constraint** | Just backtracking |
| **Very small word list (< 5)** | Check each word separately |
| **Exact match, not prefix** | Hash set |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Trie basics](../01-Trie-Fundamentals/1.1-What-Is-Trie.md) - Structure
- [StartsWith](../02-Trie-Operations/3.3-StartsWith-Prefix.md) - Prefix checking
- [Backtracking template](../../02-Recursion-Backtracking.md) - Explore + undo
- [Grid DFS](../../10-Graphs.md) - 4-directional exploration

**After mastering this:**
- Word Search II optimization
- Similar grid + dictionary problems

**Combines:**
- Trie for prefix validation
- Backtracking for path exploration
- Grid DFS for 4-directional movement

</details>

---

## üìê How It Works

### The Power of Combination

**Without Trie (Naive):**
```
For each word in dictionary:
    For each cell in grid:
        Backtrack to find word
Time: O(W √ó N √ó M √ó 4^L) where W = words, L = word length
```

**With Trie:**
```
Build trie from all words
For each cell in grid:
    Backtrack following trie paths (all words at once!)
Time: O(N √ó M √ó 4^L) - words don't multiply!
```

### Key Insight: Pruning

The Trie tells us immediately if the current path can lead to any word:
- If `startsWith(current_path)` is False ‚Üí prune this branch
- If `is_end` is True ‚Üí found a word, but keep going (might find longer words!)

### Visualization

```
Board:            Words: ["oath", "pea", "eat", "rain"]
‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê
‚îÇ o ‚îÇ a ‚îÇ a ‚îÇ n ‚îÇ  Trie:
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚î§       (root)
‚îÇ e ‚îÇ t ‚îÇ a ‚îÇ e ‚îÇ       /  |  \  \
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚î§      o   p   e   r
‚îÇ i ‚îÇ h ‚îÇ k ‚îÇ r ‚îÇ      |   |   |   |
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚î§      a   e   a   a
‚îÇ i ‚îÇ f ‚îÇ l ‚îÇ v ‚îÇ      |   |   |   |
‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò      t   a   t   i
                       |      (‚úì) |
                       h          n
                      (‚úì)        (‚úì)

Start at 'o':
  Path: "o" ‚Üí In trie? Yes, continue
  Path: "oa" ‚Üí In trie? Yes ("oath" branch)
  Path: "oat" ‚Üí In trie? Yes
  Path: "oath" ‚Üí In trie? Yes, is_end=True! Found "oath"!

Start at 'e':
  Path: "e" ‚Üí In trie? Yes ("eat" branch)
  Path: "ea" ‚Üí In trie? Yes
  Path: "eat" ‚Üí In trie? Yes, is_end=True! Found "eat"!
  
Start at 'k':
  Path: "k" ‚Üí In trie? No! Prune immediately.
```

---

## üíª Code Implementation

### Complete Solution (LC 212)

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.word = None  # Store complete word at end


class Solution:
    """
    LC 212: Word Search II
    
    Find all words from dictionary that exist in grid.
    """
    
    def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:
        """
        Time: O(N √ó M √ó 4^L) where L = max word length
        Space: O(W √ó L) for trie + O(L) for recursion
        """
        # Step 1: Build trie from all words
        root = self._build_trie(words)
        
        # Step 2: Search grid with backtracking
        result = []
        rows, cols = len(board), len(board[0])
        
        for r in range(rows):
            for c in range(cols):
                self._backtrack(board, r, c, root, result)
        
        return result
    
    def _build_trie(self, words: list[str]) -> TrieNode:
        """Build trie from word list."""
        root = TrieNode()
        for word in words:
            node = root
            for char in word:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
            node.word = word  # Store word at end node
        return root
    
    def _backtrack(self, board: list[list[str]], 
                   row: int, col: int, 
                   node: TrieNode, result: list) -> None:
        """
        DFS from (row, col) following trie paths.
        """
        # Boundary check
        rows, cols = len(board), len(board[0])
        if row < 0 or row >= rows or col < 0 or col >= cols:
            return
        
        char = board[row][col]
        
        # Pruning: If char not in trie children, no words possible
        if char not in node.children:
            return
        
        # Move to child node in trie
        node = node.children[char]
        
        # Found a word!
        if node.word is not None:
            result.append(node.word)
            node.word = None  # Avoid duplicates
        
        # Mark as visited
        board[row][col] = '#'
        
        # Explore 4 directions
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        for dr, dc in directions:
            self._backtrack(board, row + dr, col + dc, node, result)
        
        # Unmark (backtrack)
        board[row][col] = char
        
        # Optimization: Remove leaf nodes (pruning)
        # If node has no children and no word, parent can remove it
        # This prevents revisiting dead-end paths
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = new Map();
        this.word = null;
    }
}

class Solution {
    findWords(board, words) {
        // Build trie
        const root = this._buildTrie(words);
        
        // Search grid
        const result = [];
        const rows = board.length;
        const cols = board[0].length;
        
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                this._backtrack(board, r, c, root, result);
            }
        }
        
        return result;
    }
    
    _buildTrie(words) {
        const root = new TrieNode();
        for (const word of words) {
            let node = root;
            for (const char of word) {
                if (!node.children.has(char)) {
                    node.children.set(char, new TrieNode());
                }
                node = node.children.get(char);
            }
            node.word = word;
        }
        return root;
    }
    
    _backtrack(board, row, col, node, result) {
        const rows = board.length;
        const cols = board[0].length;
        
        // Boundary check
        if (row < 0 || row >= rows || col < 0 || col >= cols) {
            return;
        }
        
        const char = board[row][col];
        
        // Pruning
        if (!node.children.has(char)) {
            return;
        }
        
        node = node.children.get(char);
        
        // Found word
        if (node.word !== null) {
            result.push(node.word);
            node.word = null;  // Avoid duplicates
        }
        
        // Mark visited
        board[row][col] = '#';
        
        // Explore
        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const [dr, dc] of directions) {
            this._backtrack(board, row + dr, col + dc, node, result);
        }
        
        // Backtrack
        board[row][col] = char;
    }
}
```

---

### Optimized with Pruning

**Python (with node removal):**
```python
def _backtrack(self, board, row, col, parent_char, parent_node, result):
    """Optimized with trie pruning."""
    
    # ... (same boundary and char checks)
    
    node = parent_node.children[char]
    
    if node.word:
        result.append(node.word)
        node.word = None
    
    board[row][col] = '#'
    
    for dr, dc in directions:
        self._backtrack(board, row + dr, col + dc, char, node, result)
    
    board[row][col] = char
    
    # Optimization: Remove empty nodes
    if not node.children and not node.word:
        del parent_node.children[char]
```

---

## ‚ö° Complexity Analysis

| Aspect | Value | Notes |
|--------|-------|-------|
| **Time** | O(N √ó M √ó 4^L) | L = max word length |
| **Space** | O(W √ó L + L) | Trie + recursion stack |

**Why this complexity:**
- Start from each cell: N √ó M
- Explore up to 4 directions at each step
- Max depth is L (word length)
- But pruning drastically reduces actual paths explored

**Comparison:**

| Approach | Time | Notes |
|----------|------|-------|
| Naive (word by word) | O(W √ó N √ó M √ó 4^L) | W words |
| With Trie | O(N √ó M √ó 4^L) | All words at once |
| With Trie + Pruning | Much less in practice | Early termination |

---

## üîÑ Variations

| Variation | Difference | Example |
|-----------|------------|---------|
| **Single word search** | No trie needed | LC 79 |
| **Find longest word** | Track length | Modified 212 |
| **Count occurrences** | Don't stop at first | Statistics |
| **With obstacles** | Some cells blocked | Extend logic |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Storing Complete Word

**‚ùå Wrong:**
```python
# Just tracking is_end, then reconstructing path
if node.is_end:
    result.append(???)  # Don't know the word!
```

**‚úÖ Correct:**
```python
# Store word at end node
if node.word is not None:
    result.append(node.word)
```

### 2. Not Removing Duplicates

**‚ùå Wrong:**
```python
if node.word:
    result.append(node.word)  # Same word added multiple times!
```

**‚úÖ Correct:**
```python
if node.word:
    result.append(node.word)
    node.word = None  # Mark as found
```

### 3. Forgetting to Backtrack

**‚ùå Wrong:**
```python
board[row][col] = '#'  # Mark
# Explore...
# Forgot to unmark!
```

**‚úÖ Correct:**
```python
board[row][col] = '#'  # Mark
# Explore...
board[row][col] = char  # Unmark (backtrack)!
```

### 4. Wrong Pruning Condition

**‚ùå Wrong:**
```python
# Checking is_end instead of children
if char not in node.children or node.is_end:
    return  # Wrong! is_end doesn't mean stop exploring!
```

**‚úÖ Correct:**
```python
# Only prune if no path forward
if char not in node.children:
    return  # Keep going even if is_end (might find longer words)
```

---

## üìù Practice Problems

### Medium (Build up)
- [ ] [Word Search](https://leetcode.com/problems/word-search/) - LC 79 (single word)
- [ ] [Design Add and Search Words](https://leetcode.com/problems/design-add-and-search-words-data-structure/) - LC 211

### Hard (Full pattern)
- [ ] [Word Search II](https://leetcode.com/problems/word-search-ii/) - LC 212 ‚≠ê‚≠ê‚≠ê

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Solve LC 79 (single word search)
- **Day 3:** Implement LC 212 with basic trie
- **Day 7:** Add optimizations (node removal)
- **Day 14:** Solve LC 212 in 30 minutes
- **Day 30:** Explain the pattern to someone

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Discuss in Interviews</strong></summary>

**Recognizing the pattern:**
> "We have a grid and multiple words to find. Searching each word separately would be O(W √ó N √ó M √ó 4^L). Using a Trie lets us search all words simultaneously - we follow the trie as we explore the grid, pruning paths that can't lead to any word."

**Explaining the approach:**
> "First, I build a trie from all words. Then from each cell, I do DFS following trie paths. If a character isn't in the trie children, I prune. When I find a word (is_end), I add it to results and continue exploring for longer words."

**Key optimizations:**
> "I'll store the complete word at the end node to avoid path reconstruction. I'll mark found words as None to avoid duplicates. And I can remove empty trie nodes after exploration to prevent revisiting dead-ends."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| **Amazon** | ‚≠ê‚≠ê‚≠ê‚≠ê | Classic interview problem |
| **Google** | ‚≠ê‚≠ê‚≠ê | Tests trie + backtracking |
| **Meta** | ‚≠ê‚≠ê‚≠ê | Common |
| **Microsoft** | ‚≠ê‚≠ê | Occasionally |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand pattern | 20-25 min | This file |
| Implement LC 79 first | 20 min | Single word baseline |
| Implement LC 212 | 35-45 min | Full pattern |
| Add optimizations | 10-15 min | Node removal |
| Interview pace | 30-35 min | With practice |

---

> **üí° Key Insight:** The Trie acts as a "smart dictionary" that guides your DFS - instead of searching for each word separately, you search for all words at once, pruning branches that can't lead to any word. This changes O(W √ó grid) to O(grid).

> **üîó Related:** [Wildcard Search](./4.1-Wildcard-Search.md) | [Backtracking Template](../../02-Recursion-Backtracking.md) | [Grid DFS](../../10-Graphs.md)
