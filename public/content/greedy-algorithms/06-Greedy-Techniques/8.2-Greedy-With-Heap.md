# 8.2 Greedy with Heap Technique

> **Definition:** Greedy with Heap combines greedy decision-making with a heap (priority queue) to efficiently access the best choice at each step.

---

## üéØ Pattern Recognition

**When to use Greedy + Heap:**

| Signal | Example |
|--------|---------|
| "K largest/smallest" | Top K frequent elements |
| Need best element repeatedly | Merge K sorted lists |
| Dynamic priority changes | Task scheduling with cooldowns |
| "At each step, pick the best" | Huffman coding |

**Key insight:** Heap gives O(log n) access to best element, perfect for repeated greedy choices.

---

## ‚úÖ When to Use

- Need to repeatedly pick max/min element
- Elements have changing priorities
- K-way merge operations
- Scheduling with priorities

## ‚ùå When NOT to Use

- Only need best element once (sort instead)
- Fixed order processing
- Element comparison is O(n) anyway

---

## üìê The Pattern

### General Template

```python
import heapq

def greedy_with_heap(items, constraint):
    # Step 1: Initialize heap with starting items
    # Python heapq is min-heap; negate for max-heap
    heap = []
    for item in items:
        heapq.heappush(heap, (priority, item))
    
    result = []
    
    # Step 2: Greedily pick best until done
    while heap and more_work:
        priority, item = heapq.heappop(heap)
        
        # Step 3: Process item
        process(item)
        result.append(item)
        
        # Step 4: Maybe re-add or add new items
        if should_readd(item):
            new_priority = update(item)
            heapq.heappush(heap, (new_priority, item))
    
    return result
```

---

## üíª Classic Examples

### 1. Merge K Sorted Lists (LeetCode 23)

```python
import heapq
from typing import List, Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:
    """
    Use min-heap to always pick smallest head.
    
    Time: O(N log k) where N = total nodes, k = number of lists
    Space: O(k) for heap
    """
    heap = []
    
    # Add all list heads to heap
    for i, head in enumerate(lists):
        if head:
            heapq.heappush(heap, (head.val, i, head))
    
    dummy = ListNode()
    current = dummy
    
    while heap:
        val, idx, node = heapq.heappop(heap)
        current.next = node
        current = current.next
        
        # Add next node from same list
        if node.next:
            heapq.heappush(heap, (node.next.val, idx, node.next))
    
    return dummy.next
```

### 2. Task Scheduler (LeetCode 621)

```python
import heapq
from collections import Counter

def leastInterval(tasks: list[str], n: int) -> int:
    """
    Greedy: Always run most frequent task available.
    
    Time: O(N log 26) = O(N)
    Space: O(1) - at most 26 tasks
    """
    freq = Counter(tasks)
    
    # Max-heap of frequencies (negate for max-heap)
    heap = [-f for f in freq.values()]
    heapq.heapify(heap)
    
    time = 0
    cooldown = []  # (ready_time, frequency)
    
    while heap or cooldown:
        time += 1
        
        # Add ready tasks back to heap
        while cooldown and cooldown[0][0] <= time:
            _, f = heapq.heappop(cooldown)
            heapq.heappush(heap, f)
        
        if heap:
            freq = heapq.heappop(heap)
            freq += 1  # Decrease count (remember, negated)
            
            if freq < 0:  # Still has remaining tasks
                heapq.heappush(cooldown, (time + n + 1, freq))
    
    return time
```

```javascript
function leastInterval(tasks, n) {
    const freq = {};
    for (const task of tasks) {
        freq[task] = (freq[task] || 0) + 1;
    }
    
    // Max-heap simulation using sorted array
    const counts = Object.values(freq).sort((a, b) => b - a);
    
    let time = 0;
    
    while (counts[0] > 0) {
        // One cycle of n+1 slots
        let cycle = 0;
        const temp = [];
        
        for (let i = 0; i < n + 1; i++) {
            if (counts[0] > 0) {
                counts.sort((a, b) => b - a);
                counts[0]--;
                cycle++;
            }
        }
        
        // If we're not done, add full cycle
        if (counts[0] > 0) {
            time += n + 1;
        } else {
            time += cycle;
        }
    }
    
    return time;
}
```

### 3. Meeting Rooms II (LeetCode 253)

```python
import heapq

def minMeetingRooms(intervals: list[list[int]]) -> int:
    """
    Min-heap tracks earliest ending meeting.
    
    Time: O(n log n)
    Space: O(n)
    """
    if not intervals:
        return 0
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    # Min-heap of end times (rooms in use)
    heap = []
    heapq.heappush(heap, intervals[0][1])
    
    for i in range(1, len(intervals)):
        start, end = intervals[i]
        
        # If earliest room frees before this meeting starts, reuse it
        if heap[0] <= start:
            heapq.heappop(heap)
        
        # Allocate room for this meeting
        heapq.heappush(heap, end)
    
    return len(heap)
```

### 4. Course Schedule III (LeetCode 630)

```python
import heapq

def scheduleCourse(courses: list[list[int]]) -> int:
    """
    Greedy + Max-heap: Take course, but swap if find better option.
    
    Time: O(n log n)
    Space: O(n)
    """
    # Sort by deadline
    courses.sort(key=lambda x: x[1])
    
    heap = []  # Max-heap of durations (negated)
    time = 0
    
    for duration, deadline in courses:
        heapq.heappush(heap, -duration)
        time += duration
        
        # If over deadline, drop longest course
        if time > deadline:
            longest = -heapq.heappop(heap)
            time -= longest
    
    return len(heap)
```

---

## üìê Visual: Course Schedule III

```
courses = [[100,200], [200,1300], [1000,1250], [2000,3200]]
Sorted by deadline: same

Process [100, 200]:
  heap = [100], time = 100 ‚úì (100 <= 200)

Process [200, 1300]:
  heap = [200, 100], time = 300 ‚úì (300 <= 1300)

Process [1000, 1250]:
  heap = [1000, 200, 100], time = 1300
  1300 > 1250 ‚ùå ‚Üí pop longest (1000)
  heap = [200, 100], time = 300 ‚úì

Process [2000, 3200]:
  heap = [2000, 200, 100], time = 2300 ‚úì (2300 <= 3200)

Answer: 3 courses
```

---

## ‚ö° Complexity Analysis

| Problem | Time | Space | Heap Size |
|---------|------|-------|-----------|
| Merge K Lists | O(N log k) | O(k) | k lists |
| Task Scheduler | O(N log 26) | O(26) | 26 tasks |
| Meeting Rooms II | O(n log n) | O(n) | n rooms |
| Course Schedule III | O(n log n) | O(n) | n courses |

---

## üîÑ Heap Type Selection

| Need | Heap Type | Python |
|------|-----------|--------|
| Smallest first | Min-heap | `heapq` default |
| Largest first | Max-heap | Negate values |
| Custom priority | Min-heap | Tuple (priority, item) |

### Max-Heap in Python

```python
import heapq

# Max-heap pattern: negate values
heap = []
heapq.heappush(heap, -5)  # Push 5
heapq.heappush(heap, -3)  # Push 3
heapq.heappush(heap, -8)  # Push 8

val = -heapq.heappop(heap)  # Returns 8 (largest)
```

### Custom Priority

```python
# Priority by (deadline, -profit)
heapq.heappush(heap, (deadline, -profit, task))
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Negate for Max-Heap

```python
# ‚ùå Wrong: Trying to get max with min-heap
heap = [5, 3, 8]
heapq.heapify(heap)
heapq.heappop(heap)  # Returns 3, not 8!

# ‚úÖ Correct: Negate values
heap = [-5, -3, -8]
heapq.heapify(heap)
-heapq.heappop(heap)  # Returns 8
```

### 2. Comparison Error with Custom Objects

```python
# ‚ùå Wrong: Objects without comparison
class Task:
    def __init__(self, priority):
        self.priority = priority

heap = [(1, Task(1)), (1, Task(2))]  # Error if priorities tie!

# ‚úÖ Correct: Add unique tiebreaker
counter = 0
heap = [(1, counter, Task(1)), (1, counter+1, Task(2))]
```

### 3. Not Re-Adding Items After Processing

```python
# ‚ùå Wrong: Forgetting to add back
item = heapq.heappop(heap)
process(item)
# Forgot to re-add if item should continue!

# ‚úÖ Correct: Re-add if needed
if item.remaining > 0:
    heapq.heappush(heap, (item.priority, item))
```

---

## üìù Practice Problems

| Problem | Heap Usage | Difficulty |
|---------|------------|------------|
| [Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) | Min-heap of heads | Hard |
| [Task Scheduler](https://leetcode.com/problems/task-scheduler/) | Max-heap + cooldown | Medium |
| [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/) | Min-heap of ends | Medium |
| [Course Schedule III](https://leetcode.com/problems/course-schedule-iii/) | Max-heap + swap | Hard |
| [Reorganize String](https://leetcode.com/problems/reorganize-string/) | Max-heap | Medium |
| [Find Median from Stream](https://leetcode.com/problems/find-median-from-data-stream/) | Two heaps | Hard |
| [Cheapest Flights K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/) | Dijkstra variant | Medium |

---

## üé§ Interview Tips

<details>
<summary><strong>How to Communicate</strong></summary>

**When to mention heap:**
"This requires repeatedly picking the best available option, so I'll use a heap for O(log n) access instead of O(n) scanning."

**Explain the greedy choice:**
"At each step, the greedy choice is to pick the [smallest/largest/highest priority] element. The heap maintains this invariant efficiently."

**Complexity discussion:**
"With n items and k heap operations, this gives O(n log k) time complexity. The heap space is O(k)."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Recognize heap needed | 2-3 min |
| Design heap structure | 2-3 min |
| Implement solution | 8-10 min |
| Debug heap operations | 2-3 min |
| **Total** | **15-20 min** |

---

> **üí° Key Insight:** When greedy requires "pick best" repeatedly, heap transforms O(n) per pick into O(log n). Look for "largest/smallest remaining" signals.

> **üîó Related:** [Interval Greedy](../02-Interval-Pattern/4.1-Interval-Greedy-Overview.md) | [Scheduling](../04-Scheduling-Pattern/6.1-Scheduling-Greedy-Overview.md)
