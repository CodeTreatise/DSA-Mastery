# 3.2 Priority Queue Implementation

## Definition

This section covers implementing a **complete Priority Queue** from scratch using a binary heap, including handling custom priorities and objects.

```
Priority Queue Interface:

class PriorityQueue:
    enqueue(item, priority)  ‚Üí Add item with priority
    dequeue()                ‚Üí Remove and return highest priority item
    peek()                   ‚Üí View highest priority item
    size()                   ‚Üí Number of items
    isEmpty()                ‚Üí Check if empty
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>Implementation Decisions</strong></summary>

**Key decisions when implementing:**
1. Min-heap or max-heap? (Which priority wins?)
2. How to handle ties? (FIFO, arbitrary?)
3. How to store priority + data together?
4. Need decrease-key operation?

**Common approaches:**
- **Tuples:** `(priority, data)` - Simple, common
- **Dataclass:** Custom class with comparison - Clean
- **Dictionary + heap:** For indexed/updatable PQ - Complex

</details>

---

## ‚úÖ When to Use Each Approach

| Approach | Use When | Complexity |
|----------|----------|------------|
| Simple tuples | Priority is a number | Easiest |
| Tuples with counter | Need stable ordering | Easy |
| Dataclass | Complex objects | Medium |
| Indexed PQ | Need decrease-key | Hard |

## ‚ùå Approaches to Avoid

| Avoid | Why | Use Instead |
|-------|-----|-------------|
| Sorted list |" O(n) insert "| Heap |
| Unsorted list |" O(n) find min "| Heap |
| Storing objects directly | Comparison errors | Tuples |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Priority Queue Basics](./3.1-PQ-Basics.md)
- [Heap Operations](../02-Heap-Operations/2.1-Insert.md)
- [Array Representation](../01-Heap-Fundamentals/1.4-Array-Representation.md)

**After mastering this:**
- [Priority Queue Applications](./3.3-PQ-Applications.md)
- [Top K Pattern](../04-Top-K-Pattern/4.1-Top-K-Overview.md)

</details>

---

## üìê How It Works

### Implementation Strategy

```
Binary Heap-Based Priority Queue:

Internal Storage: Array
‚îú‚îÄ‚îÄ Index 0: Root (highest priority)
‚îú‚îÄ‚îÄ Left child of i: 2*i + 1
‚îú‚îÄ‚îÄ Right child of i: 2*i + 2
‚îî‚îÄ‚îÄ Parent of i: (i-1) // 2

Operations:
‚îú‚îÄ‚îÄ enqueue ‚Üí push to end, bubble up
‚îú‚îÄ‚îÄ dequeue ‚Üí swap root with last, pop, bubble down
‚îú‚îÄ‚îÄ peek ‚Üí return arr[0]
‚îî‚îÄ‚îÄ size ‚Üí return len(arr)
```

### Handling Priorities with Data

```
Option 1: Tuples (priority, data)
  heap = [(3, "task_a"), (1, "task_b"), (2, "task_c")]
  
  Comparison: By first element (priority)
  Problem: If priorities equal, compares data ‚Üí error if not comparable

Option 2: Tuples with counter (priority, counter, data)
  heap = [(3, 0, "task_a"), (1, 1, "task_b"), (2, 2, "task_c")]
  
  Counter ensures unique ordering, never compares data
  FIFO behavior for equal priorities

Option 3: Wrapper class with __lt__
  class Entry:
      def __init__(self, priority, data):
          self.priority = priority
          self.data = data
      def __lt__(self, other):
          return self.priority < other.priority
```

---

## üíª Code Implementation

### Complete Min Priority Queue (Python)

**Python:**
```python
import heapq
from typing import Any, Generic, TypeVar

T = TypeVar('T')


class MinPriorityQueue(Generic[T]):
    """
    Min-Priority Queue using heapq.
    Lower priority value = higher priority.
    
    Uses (priority, counter, item) tuples to handle:
    1. Priority comparison
    2. Stable ordering (FIFO for equal priorities)
    3. Non-comparable items
    """
    
    def __init__(self):
        self._heap: list[tuple[int, int, T]] = []
        self._counter = 0
    
    def __len__(self) -> int:
        return len(self._heap)
    
    def __bool__(self) -> bool:
        return len(self._heap) > 0
    
    def is_empty(self) -> bool:
        return len(self._heap) == 0
    
    def enqueue(self, item: T, priority: int = 0) -> None:
        """
        Add item with given priority.
        Time: O(log n)
        """
        entry = (priority, self._counter, item)
        self._counter += 1
        heapq.heappush(self._heap, entry)
    
    def dequeue(self) -> T:
        """
        Remove and return highest priority (lowest value) item.
        Time: O(log n)
        Raises: IndexError if empty
        """
        if self.is_empty():
            raise IndexError("dequeue from empty priority queue")
        priority, counter, item = heapq.heappop(self._heap)
        return item
    
    def peek(self) -> T:
        """
        Return highest priority item without removing.
        Time: O(1)
        Raises: IndexError if empty
        """
        if self.is_empty():
            raise IndexError("peek from empty priority queue")
        return self._heap[0][2]
    
    def peek_priority(self) -> int:
        """Return the priority of the highest priority item."""
        if self.is_empty():
            raise IndexError("peek from empty priority queue")
        return self._heap[0][0]


# Usage example
pq = MinPriorityQueue()
pq.enqueue("Task A", priority=3)
pq.enqueue("Task B", priority=1)
pq.enqueue("Task C", priority=2)
pq.enqueue("Task D", priority=1)  # Same priority as B

print(pq.dequeue())  # "Task B" (priority 1, first inserted)
print(pq.dequeue())  # "Task D" (priority 1, second inserted)
print(pq.dequeue())  # "Task C" (priority 2)
print(pq.dequeue())  # "Task A" (priority 3)
```

### Complete Max Priority Queue (Python)

**Python:**
```python
import heapq
from typing import Any, Generic, TypeVar

T = TypeVar('T')


class MaxPriorityQueue(Generic[T]):
    """
    Max-Priority Queue using heapq.
    Higher priority value = higher priority.
    Negates priorities internally.
    """
    
    def __init__(self):
        self._heap: list[tuple[int, int, T]] = []
        self._counter = 0
    
    def __len__(self) -> int:
        return len(self._heap)
    
    def __bool__(self) -> bool:
        return len(self._heap) > 0
    
    def is_empty(self) -> bool:
        return len(self._heap) == 0
    
    def enqueue(self, item: T, priority: int = 0) -> None:
        """Add item with given priority. Time: O(log n)"""
        # Negate priority for max-heap behavior
        entry = (-priority, self._counter, item)
        self._counter += 1
        heapq.heappush(self._heap, entry)
    
    def dequeue(self) -> T:
        """Remove and return highest priority item. Time: O(log n)"""
        if self.is_empty():
            raise IndexError("dequeue from empty priority queue")
        neg_priority, counter, item = heapq.heappop(self._heap)
        return item
    
    def peek(self) -> T:
        """Return highest priority item without removing. Time: O(1)"""
        if self.is_empty():
            raise IndexError("peek from empty priority queue")
        return self._heap[0][2]
    
    def peek_priority(self) -> int:
        """Return the priority of the highest priority item."""
        if self.is_empty():
            raise IndexError("peek from empty priority queue")
        return -self._heap[0][0]  # Negate back


# Usage example
max_pq = MaxPriorityQueue()
max_pq.enqueue("Low priority", priority=1)
max_pq.enqueue("High priority", priority=10)
max_pq.enqueue("Medium priority", priority=5)

print(max_pq.dequeue())  # "High priority"
print(max_pq.dequeue())  # "Medium priority"
print(max_pq.dequeue())  # "Low priority"
```

### Complete Implementation (JavaScript)

**JavaScript:**
```javascript
class PriorityQueue {
    /**
     * Priority Queue implementation using binary heap.
     * @param {Function} compareFn - Comparison function (default: min-heap)
     */
    constructor(compareFn = (a, b) => a.priority - b.priority) {
        this._heap = [];
        this._compare = compareFn;
    }
    
    get size() {
        return this._heap.length;
    }
    
    isEmpty() {
        return this._heap.length === 0;
    }
    
    /**
     * Add item with priority.
     * @param {*} item - The item to add
     * @param {number} priority - The priority value
     * Time: O(log n)
     */
    enqueue(item, priority = 0) {
        const entry = { item, priority };
        this._heap.push(entry);
        this._bubbleUp(this._heap.length - 1);
    }
    
    /**
     * Remove and return highest priority item.
     * Time: O(log n)
     */
    dequeue() {
        if (this.isEmpty()) return undefined;
        
        const top = this._heap[0];
        const last = this._heap.pop();
        
        if (!this.isEmpty()) {
            this._heap[0] = last;
            this._bubbleDown(0);
        }
        
        return top.item;
    }
    
    /**
     * Return highest priority item without removing.
     * Time: O(1)
     */
    peek() {
        return this.isEmpty() ? undefined : this._heap[0].item;
    }
    
    /**
     * Return priority of highest priority item.
     * Time: O(1)
     */
    peekPriority() {
        return this.isEmpty() ? undefined : this._heap[0].priority;
    }
    
    _bubbleUp(index) {
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this._compare(this._heap[parentIndex], this._heap[index]) <= 0) {
                break;
            }
            [this._heap[parentIndex], this._heap[index]] = 
                [this._heap[index], this._heap[parentIndex]];
            index = parentIndex;
        }
    }
    
    _bubbleDown(index) {
        const n = this._heap.length;
        
        while (true) {
            let smallest = index;
            const leftIndex = 2 * index + 1;
            const rightIndex = 2 * index + 2;
            
            if (leftIndex < n && 
                this._compare(this._heap[leftIndex], this._heap[smallest]) < 0) {
                smallest = leftIndex;
            }
            if (rightIndex < n && 
                this._compare(this._heap[rightIndex], this._heap[smallest]) < 0) {
                smallest = rightIndex;
            }
            
            if (smallest === index) break;
            
            [this._heap[index], this._heap[smallest]] = 
                [this._heap[smallest], this._heap[index]];
            index = smallest;
        }
    }
}

// Min-Priority Queue (default)
const minPQ = new PriorityQueue();
minPQ.enqueue("Task A", 3);
minPQ.enqueue("Task B", 1);
minPQ.enqueue("Task C", 2);

console.log(minPQ.dequeue()); // "Task B"
console.log(minPQ.dequeue()); // "Task C"
console.log(minPQ.dequeue()); // "Task A"

// Max-Priority Queue
const maxPQ = new PriorityQueue((a, b) => b.priority - a.priority);
maxPQ.enqueue("Low", 1);
maxPQ.enqueue("High", 10);
maxPQ.enqueue("Medium", 5);

console.log(maxPQ.dequeue()); // "High"
console.log(maxPQ.dequeue()); // "Medium"
console.log(maxPQ.dequeue()); // "Low"
```

### Indexed Priority Queue (Advanced)

**Python:**
```python
import heapq
from typing import Dict, Any

class IndexedPriorityQueue:
    """
    Indexed Priority Queue with update capability.
    Supports decrease-key operation (useful for Dijkstra).
    
    Uses lazy deletion: old entries are ignored when popped.
    """
    
    def __init__(self):
        self._heap = []  # (priority, counter, key)
        self._entry_finder: Dict[Any, list] = {}  # key -> entry
        self._counter = 0
        self._REMOVED = '<removed>'
    
    def __len__(self):
        return len(self._entry_finder)
    
    def __contains__(self, key):
        return key in self._entry_finder
    
    def add_or_update(self, key: Any, priority: int) -> None:
        """
        Add new key or update existing key's priority.
        Time: O(log n)
        """
        if key in self._entry_finder:
            self._remove(key)
        
        entry = [priority, self._counter, key]
        self._counter += 1
        self._entry_finder[key] = entry
        heapq.heappush(self._heap, entry)
    
    def _remove(self, key: Any) -> None:
        """Mark entry as removed. Actual removal happens on pop."""
        entry = self._entry_finder.pop(key)
        entry[2] = self._REMOVED  # Mark as removed
    
    def pop(self) -> tuple[Any, int]:
        """
        Remove and return (key, priority) of highest priority item.
        Time: O(log n) amortized
        """
        while self._heap:
            priority, counter, key = heapq.heappop(self._heap)
            if key is not self._REMOVED:
                del self._entry_finder[key]
                return (key, priority)
        raise KeyError("pop from empty priority queue")
    
    def peek(self) -> tuple[Any, int]:
        """Return (key, priority) without removing."""
        while self._heap:
            priority, counter, key = self._heap[0]
            if key is not self._REMOVED:
                return (key, priority)
            heapq.heappop(self._heap)  # Remove stale entry
        raise KeyError("peek from empty priority queue")


# Usage: Dijkstra's algorithm simulation
pq = IndexedPriorityQueue()
pq.add_or_update("node_a", 10)
pq.add_or_update("node_b", 5)
pq.add_or_update("node_c", 15)

# Update priority (decrease-key)
pq.add_or_update("node_a", 3)  # Found shorter path to node_a

print(pq.pop())  # ('node_a', 3)
print(pq.pop())  # ('node_b', 5)
print(pq.pop())  # ('node_c', 15)
```

---

## ‚ö° Complexity Analysis

| Operation | Simple PQ | Indexed PQ |
|-----------|-----------|------------|
| enqueue |" O(log n) "| O(log n) |
| dequeue |" O(log n) "| O(log n) amortized |
| peek |" O(1) "| O(1) amortized |
| update_priority | N/A |" O(log n) "|
| contains |" O(n) "| O(1) |

**Space complexity:** O(n) for all implementations

---

## üîÑ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| **Min-PQ** | Smallest priority first | Dijkstra, BFS |
| **Max-PQ** | Largest priority first | Scheduling |
| **Indexed PQ** | Update priorities | Graph algorithms |
| **Stable PQ** | FIFO for ties | Fair scheduling |
| **Bounded PQ** | Fixed max size | Top K |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Handling Non-Comparable Items

```python
import heapq

class Task:
    def __init__(self, name):
        self.name = name

# ‚ùå Wrong: Tasks aren't comparable
heap = []
heapq.heappush(heap, (1, Task("A")))
heapq.heappush(heap, (1, Task("B")))  # TypeError on tie!

# ‚úÖ Correct: Add unique counter
counter = 0
heap = []
heapq.heappush(heap, (1, counter := counter + 1, Task("A")))
heapq.heappush(heap, (1, counter := counter + 1, Task("B")))  # Works!
```

### 2. Forgetting to Handle Empty Queue

```python
import heapq

# ‚ùå Wrong: No empty check
heap = []
item = heapq.heappop(heap)  # IndexError!

# ‚úÖ Correct: Always check
if heap:
    item = heapq.heappop(heap)
else:
    # Handle empty case
    pass
```

### 3. Modifying Items After Insertion

```python
import heapq

# ‚ùå Wrong: Modifying item's priority after insertion
entry = [3, "task"]
heap = [entry]
heapq.heapify(heap)
entry[0] = 1  # Changed priority, but heap not updated!

# ‚úÖ Correct: Use indexed PQ or re-insert
# Either remove old, add new, or use lazy deletion
```

### 4. Using Wrong Comparator Direction

```javascript
// ‚ùå Wrong: Expected max-heap but got min-heap
const pq = new PriorityQueue((a, b) => a.priority - b.priority);
// This is min-heap: smaller priority wins

// ‚úÖ Correct: For max-heap, reverse comparison
const maxPQ = new PriorityQueue((a, b) => b.priority - a.priority);
// This is max-heap: larger priority wins
```

---

## üìù Practice Problems (Progressive)

### Easy (Basic implementation)
- [ ] Implement MinPriorityQueue class
- [ ] Implement MaxPriorityQueue class
- [ ] [Last Stone Weight (LC 1046)](https://leetcode.com/problems/last-stone-weight/)

### Medium (Apply implementation)
- [ ] [Kth Largest Element in a Stream (LC 703)](https://leetcode.com/problems/kth-largest-element-in-a-stream/)
- [ ] [Task Scheduler (LC 621)](https://leetcode.com/problems/task-scheduler/)
- [ ] [Top K Frequent Words (LC 692)](https://leetcode.com/problems/top-k-frequent-words/)

### Hard (Advanced implementation)
- [ ] Implement IndexedPriorityQueue
- [ ] [Design Twitter (LC 355)](https://leetcode.com/problems/design-twitter/)
- [ ] [Sliding Window Median (LC 480)](https://leetcode.com/problems/sliding-window-median/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement basic PQ with tuples
- **Day 3:** Handle ties with counter
- **Day 7:** Implement from scratch (no heapq)
- **Day 14:** Implement indexed PQ
- **Day 30:** Apply to complex problem

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Explain Your Implementation</strong></summary>

**When presenting implementation:**
"I'll implement the priority queue using a binary heap stored as an array. Each element is a tuple of (priority, insertion_counter, data). The counter ensures stable ordering and prevents comparison errors if two items have equal priority."

**Design decisions to mention:**
1. "Using tuples with counter for stable ordering"
2. "Min-heap by default, negate for max-heap"
3. "O(log n) for insert and extract, O(1) for peek"

**Advanced topics:**
"For Dijkstra's algorithm where we need decrease-key, I'd use an indexed priority queue with lazy deletion - mark old entries as removed, ignore them when popping."

</details>

**Company Focus:**

| Company | Frequency | Focus |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Implementation details |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê | Edge cases, optimization |
| Meta | ‚≠ê‚≠ê‚≠ê | Correctness |
| Startups | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | From scratch implementation |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Simple tuple PQ | 15-20 min | Using heapq |
| Full implementation | 25-30 min | From scratch |
| Indexed PQ | 30-40 min | With lazy deletion |
| Debug edge cases | 15-20 min | Empty, ties, updates |

---

## üí° Key Insight

> **Use (priority, counter, data) tuples** to implement a robust priority queue. The counter ensures stable ordering (FIFO for equal priorities) and prevents comparison errors when data items aren't comparable. This simple pattern handles 90% of priority queue use cases.

---

## üîó Related

- **Previous:** [Priority Queue Basics](./3.1-PQ-Basics.md)
- **Next:** [Priority Queue Applications](./3.3-PQ-Applications.md)
- **Operations:** [Insert](../02-Heap-Operations/2.1-Insert.md) | [Extract](../02-Heap-Operations/2.2-Extract.md)
