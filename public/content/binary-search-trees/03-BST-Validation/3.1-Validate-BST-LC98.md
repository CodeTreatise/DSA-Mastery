# 3.1 Validate Binary Search Tree (LC 98)

## Problem Statement

[LeetCode 98 - Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)

Given the root of a binary tree, determine if it is a valid BST.

A valid BST is defined as:
- The left subtree contains only nodes with keys **less than** the node's key
- The right subtree contains only nodes with keys **greater than** the node's key
- Both subtrees must also be valid BSTs

```
Input: root = [5,1,4,null,null,3,6]
        5
       / \
      1   4
         / \
        3   6

Output: false
Explanation: The root's right child is 4, but 3 (in 4's left) is less than 5.
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**This is a Range DFS / BST Validation problem:**
- Need to verify BST property for ALL nodes
- Each node must be within a valid range
- Range narrows as we go deeper

**Keywords:**
- "valid BST", "validate", "is BST"
- "BST property", "ordering"
- "left subtree less than", "right subtree greater than"

**Pattern:** Pass min/max range to each recursive call, narrowing the valid range at each level.

</details>

---

## ‚úÖ When to Use

- Verifying tree is valid BST
- Pre-processing before BST operations
- Tree problems that require BST property
- Data validation

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| General tree structure check | BST validation is ordering-specific | Different validation |
| Need to fix invalid BST | Just validates, doesn't repair | LC 99 Recover BST |
| Already know it's BST | Redundant check | Skip validation |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Definition](../01-BST-Fundamentals/1.1-BST-Definition.md)
- [DFS Traversals](../../06-Trees/03-Tree-Traversals/3.1-DFS-Traversals/)
- [Recursion on Trees](../../06-Trees/01-Tree-Fundamentals/1.4-Recursion-Trees.md)

**After mastering this:**
- [Recover BST (LC 99)](./3.2-Recover-BST-LC99.md) - Fix invalid BST
- [Trim BST (LC 669)](./3.3-Trim-BST-LC669.md) - Range-based modification
- [Range Sum BST](../05-BST-Range-Problems/) - Use range logic

**Combines with:**
- DFS traversal pattern
- Range tracking technique
- Inorder traversal (alternative approach)

</details>

---

## üìê How It Works

### The Key Insight: Valid Range

```
Each node has a valid range it must fall within:

        5 (-‚àû, +‚àû)      Root can be any value
       / \
      1   4             Wrong! 4 should be in (5, +‚àû)
     /   / \
    0   3   6

For left child: range becomes (-‚àû, parent)
For right child: range becomes (parent, +‚àû)

Correct tree:
        5 (-‚àû, +‚àû)
       / \
      3   8
     / \   \
    1   4   10
    
Node 3: range (-‚àû, 5) ‚úì
Node 8: range (5, +‚àû) ‚úì
Node 4: range (3, 5) ‚úì
Node 10: range (8, +‚àû) ‚úì
```

### Why Checking Just Parent is Wrong

```
INVALID BST that passes parent-only check:

        5
       / \
      3   8
       \
        7   ‚Üê 7 > 3 (OK with parent) but 7 > 5 (violates grandparent!)

7 is in left subtree of 5, so 7 must be < 5.
We need to track the RANGE, not just the parent.
```

### Two Approaches

#### Approach 1: Range DFS (Top-Down)
- Pass valid (min, max) range to each node
- Narrow range as we descend

#### Approach 2: Inorder Traversal
- Valid BST ‚Üí inorder traversal is strictly increasing
- Track previous value and ensure each node > previous

---

## üíª Code Implementation

### Approach 1: Range DFS (Recommended)

**Python:**
```python
def isValidBST(self, root: Optional[TreeNode]) -> bool:
    """
    Validate BST using range DFS.
    
    Time: O(n) - visit each node once
    Space: O(h) - recursion stack
    
    Pattern: Each node has a valid range (min, max) exclusive.
    """
    def validate(node: TreeNode, min_val: float, max_val: float) -> bool:
        if not node:
            return True
        
        # Node must be within valid range
        if node.val <= min_val or node.val >= max_val:
            return False
        
        # Left subtree: values must be < current (max becomes node.val)
        # Right subtree: values must be > current (min becomes node.val)
        return (validate(node.left, min_val, node.val) and
                validate(node.right, node.val, max_val))
    
    return validate(root, float('-inf'), float('inf'))
```

**JavaScript:**
```javascript
var isValidBST = function(root) {
    // Range DFS - O(n) time, O(h) space
    function validate(node, minVal, maxVal) {
        if (!node) return true;
        
        // Must be within valid range (exclusive)
        if (node.val <= minVal || node.val >= maxVal) {
            return false;
        }
        
        return validate(node.left, minVal, node.val) &&
               validate(node.right, node.val, maxVal);
    }
    
    return validate(root, -Infinity, Infinity);
};
```

### Approach 2: Inorder Traversal

**Python:**
```python
def isValidBST(self, root: Optional[TreeNode]) -> bool:
    """
    Validate using inorder traversal.
    
    Insight: Inorder of valid BST is strictly increasing.
    
    Time: O(n), Space: O(h)
    """
    self.prev = float('-inf')
    
    def inorder(node: TreeNode) -> bool:
        if not node:
            return True
        
        # Check left subtree
        if not inorder(node.left):
            return False
        
        # Check current node vs previous
        if node.val <= self.prev:
            return False
        self.prev = node.val
        
        # Check right subtree
        return inorder(node.right)
    
    return inorder(root)
```

**JavaScript:**
```javascript
var isValidBST = function(root) {
    // Inorder traversal approach
    let prev = -Infinity;
    
    function inorder(node) {
        if (!node) return true;
        
        // Left
        if (!inorder(node.left)) return false;
        
        // Current - must be greater than previous
        if (node.val <= prev) return false;
        prev = node.val;
        
        // Right
        return inorder(node.right);
    }
    
    return inorder(root);
};
```

### Approach 3: Iterative Inorder

**Python:**
```python
def isValidBST(self, root: Optional[TreeNode]) -> bool:
    """Iterative inorder with O(h) space."""
    stack = []
    prev = float('-inf')
    current = root
    
    while stack or current:
        # Go left
        while current:
            stack.append(current)
            current = current.left
        
        # Visit node
        current = stack.pop()
        if current.val <= prev:
            return False
        prev = current.val
        
        # Go right
        current = current.right
    
    return True
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Range DFS |" O(n) "| O(h) | Visit each node once |
| Recursive Inorder |" O(n) "| O(h) | Same complexity |
| Iterative Inorder |" O(n) "| O(h) | Explicit stack |

**Why O(n) time:**
- Must check every node to ensure validity
- Each node is visited exactly once

**Why O(h) space:**
- Recursion/stack depth equals tree height
- O(log n) for balanced, O(n) for skewed

---

## üîÑ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **Allow duplicates** | Change `<=` to `<` on one side | Modified BST |
| **Find first violation** | Return the violating node | Debugging |
| **Count violations** | Don't short-circuit | Analysis |
| **Recover BST** | Find and swap two nodes | LC 99 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Only Checking Immediate Children

```python
# ‚ùå WRONG: Only checks parent-child relationship
def isValidBST(root):
    if not root:
        return True
    if root.left and root.left.val >= root.val:
        return False
    if root.right and root.right.val <= root.val:
        return False
    return isValidBST(root.left) and isValidBST(root.right)

# This returns True for:
#       5
#      / \
#     3   8
#      \
#       7  ‚Üê 7 > 3 but 7 > 5 (should be False!)

# ‚úÖ CORRECT: Track valid range
def isValidBST(root):
    def validate(node, min_val, max_val):
        if not node:
            return True
        if node.val <= min_val or node.val >= max_val:
            return False
        return (validate(node.left, min_val, node.val) and
                validate(node.right, node.val, max_val))
    return validate(root, float('-inf'), float('inf'))
```

### 2. Using `<=` Instead of `<` for Range

```python
# ‚ùå Wrong: Allows equal values
if node.val < min_val or node.val > max_val:  # Missing equal check!
    return False

# ‚úÖ Correct: Strict inequality (standard BST has unique values)
if node.val <= min_val or node.val >= max_val:
    return False
```

### 3. Integer Overflow in Some Languages

```python
# ‚ùå Potential issue in languages with fixed-size integers
min_val = -2147483648 - 1  # Overflow!

# ‚úÖ Use float('inf') or separate null checks
min_val = float('-inf')
max_val = float('inf')
```

---

## üìù Practice Problems (Progressive)

### Easy (Build understanding)
- [ ] [Search in BST (LC 700)](https://leetcode.com/problems/search-in-a-binary-search-tree/) - BST navigation
- [ ] [Range Sum of BST (LC 938)](https://leetcode.com/problems/range-sum-of-bst/) - Range concept

### Medium (Apply validation)
- [ ] [Validate BST (LC 98)](https://leetcode.com/problems/validate-binary-search-tree/) - This problem
- [ ] [Trim BST (LC 669)](https://leetcode.com/problems/trim-a-binary-search-tree/) - Range modification
- [ ] [Construct BST from Preorder (LC 1008)](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/) - Uses valid range

### Hard (Master edge cases)
- [ ] [Recover BST (LC 99)](https://leetcode.com/problems/recover-binary-search-tree/) - Find violations

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement range DFS from scratch
- **Day 3:** Implement inorder approach
- **Day 7:** Explain why parent-only check fails
- **Day 14:** Solve without looking at code
- **Day 30:** Use range technique in LC 1008

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"I'll use a range-based DFS. Each node has a valid range it must fall within. For the root it's (-‚àû, +‚àû), and the range narrows as I go down ‚Äî left children must be less than their ancestor chain, right children must be greater."

**Common clarifications:**
- "Are there duplicate values?" ‚Üí Standard BST has unique values
- "Can I modify the tree?" ‚Üí No, just validate

**Key points to mention:**
1. Why checking only parent is insufficient
2. Time O(n) because we visit every node
3. Alternative inorder approach

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Fundamental BST |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Often as warm-up |
| Google | ‚≠ê‚≠ê‚≠ê | Usually combined with other |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand problem | 3-4 min | Clarify BST property |
| Code range DFS | 8-10 min | Clean implementation |
| Code inorder | 8-10 min | Alternative approach |
| Edge cases | 3-4 min | Empty tree, single node |
| Total interview time | 20-25 min | Medium difficulty |

---

## üí° Key Insight

> **The BST property is about ALL ancestors, not just the parent.** A node in the left subtree must be less than ALL its ancestors on the right path up. The range DFS naturally captures this by narrowing the valid range at each level.

---

## üîó Related

- **Foundation:** [BST Definition](../01-BST-Fundamentals/1.1-BST-Definition.md)
- **Next:** [Recover BST (LC 99)](./3.2-Recover-BST-LC99.md)
- **Uses Range:** [Range Sum BST (LC 938)](../05-BST-Range-Problems/5.2-Range-Sum-BST-LC938.md)
- **Comparison:** [BST vs Binary Tree](../01-BST-Fundamentals/1.4-BST-vs-Trees.md)
