# 5.1 Range Problems Overview

## Introduction

Range problems on BSTs leverage the ordered property to efficiently process nodes within a value range [low, high]. The BST structure allows us to prune entire subtrees that fall outside the range.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Range Problems</strong></summary>

**Keywords:**
- "within range [L, R]"
- "between low and high"
- "values in interval"
- "count/sum nodes in range"

**BST Advantage:**
- If `node.val < low`: Skip left subtree (all values smaller)
- If `node.val > high`: Skip right subtree (all values larger)
- If `low ‚â§ node.val ‚â§ high`: Include node, explore both

</details>

---

## ‚úÖ When to Use

- Problems involving value ranges on BST
- Need to sum, count, or collect nodes in [low, high]
- When pruning can avoid unnecessary traversal

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| General tree | No ordering to prune | Full traversal |
| Range by position | BST orders by value, not position | Inorder traversal |
| Frequent range queries |" O(h + k) each time "| Segment tree or BIT |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
- [BST Traversal](../01-BST-Fundamentals/1.1-BST-Definition.md)
- [Trim BST (LC 669)](../03-BST-Validation/3.3-Trim-BST-LC669.md)

**After mastering this:**
- [Range Sum BST (LC 938)](./5.2-Range-Sum-BST-LC938.md)
- More complex range queries

**Combines with:**
- DFS with pruning
- BST navigation

</details>

---

## üìê How It Works

### Range DFS Strategy

```
Given range [low, high] and current node:

         10
        /  \
       5    15
      / \   / \
     3   7 12  18

For range [6, 14]:

At 10: 6 ‚â§ 10 ‚â§ 14 ‚Üí INCLUDE, check both subtrees
At 5:  5 < 6 ‚Üí SKIP left subtree, check right only
At 7:  6 ‚â§ 7 ‚â§ 14 ‚Üí INCLUDE
At 15: 15 > 14 ‚Üí SKIP right subtree, check left only
At 12: 6 ‚â§ 12 ‚â§ 14 ‚Üí INCLUDE

Result: nodes 10, 7, 12 are in range
```

### The Three Cases

```python
def range_dfs(node, low, high):
    if not node:
        return
    
    if node.val < low:
        # Current and left subtree are too small
        # Only check right subtree
        range_dfs(node.right, low, high)
    
    elif node.val > high:
        # Current and right subtree are too large
        # Only check left subtree
        range_dfs(node.left, low, high)
    
    else:
        # low ‚â§ node.val ‚â§ high
        # Node is in range, check both subtrees
        process(node)
        range_dfs(node.left, low, high)
        range_dfs(node.right, low, high)
```

---

## üíª Code Template

### Generic Range DFS

**Python:**
```python
def rangeQuery(root: TreeNode, low: int, high: int) -> int:
    """
    Template for range queries on BST.
    
    Time: O(h + k) where k = nodes in range
    Space: O(h) recursion stack
    """
    result = 0
    
    def dfs(node):
        nonlocal result
        if not node:
            return
        
        # Check if current node is in range
        if low <= node.val <= high:
            result += node.val  # or count += 1, or append, etc.
        
        # Prune: only go left if there might be values in range
        if node.val > low:
            dfs(node.left)
        
        # Prune: only go right if there might be values in range
        if node.val < high:
            dfs(node.right)
    
    dfs(root)
    return result
```

**JavaScript:**
```javascript
function rangeQuery(root, low, high) {
    // Template for range queries on BST
    let result = 0;
    
    function dfs(node) {
        if (!node) return;
        
        if (low <= node.val && node.val <= high) {
            result += node.val;
        }
        
        if (node.val > low) dfs(node.left);
        if (node.val < high) dfs(node.right);
    }
    
    dfs(root);
    return result;
}
```

### Iterative Version

**Python:**
```python
def rangeQueryIterative(root: TreeNode, low: int, high: int) -> int:
    """Iterative BFS with pruning."""
    if not root:
        return 0
    
    result = 0
    queue = [root]
    
    while queue:
        node = queue.pop()
        
        if low <= node.val <= high:
            result += node.val
        
        if node.left and node.val > low:
            queue.append(node.left)
        
        if node.right and node.val < high:
            queue.append(node.right)
    
    return result
```

---

## ‚ö° Complexity Analysis

| Metric | Complexity | Notes |
|--------|------------|-------|
| Time |" O(h + k) "| h to find range, k nodes in range |
| Space |" O(h) "| Recursion stack or queue |

**Why O(h + k):**
- O(h): Navigate down to find first node in range
- O(k): Visit k nodes that fall within [low, high]
- Pruning prevents visiting nodes outside range

---

## üîÑ Common Range Operations

| Operation | Description | Modification |
|-----------|-------------|--------------|
| **Range Sum** | Sum values in [low, high] | `result += node.val` |
| **Range Count** | Count nodes in [low, high] | `count += 1` |
| **Range Collect** | List nodes in [low, high] | `result.append(node.val)` |
| **Range Max/Min** | Find extremes in range | Track max/min during DFS |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Incorrect Pruning Condition

```python
# ‚ùå Wrong: Strict inequality misses boundary nodes
if node.val >= low:  # Should be > for pruning
    dfs(node.left)

# ‚úÖ Correct: Use > for pruning (don't prune when equal)
if node.val > low:
    dfs(node.left)
```

### 2. Not Checking Both Directions

```python
# ‚ùå Wrong: Stops at first match
if low <= node.val <= high:
    return node.val  # Misses other nodes in range!

# ‚úÖ Correct: Continue to both subtrees
if low <= node.val <= high:
    result += node.val
    dfs(node.left)   # There might be more in left
    dfs(node.right)  # And in right
```

### 3. Confusing Pruning Logic

```python
# ‚ùå Wrong: Inverted condition
if node.val < low:
    dfs(node.left)  # Should go right when too small!

# ‚úÖ Correct: 
if node.val < low:
    dfs(node.right)  # Too small, look for larger values
```

---

## üìù Practice Problems

| Problem | Difficulty | Key Concept |
|---------|------------|-------------|
| [Range Sum BST (LC 938)](https://leetcode.com/problems/range-sum-of-bst/) | Easy | Basic range DFS |
| [Trim BST (LC 669)](https://leetcode.com/problems/trim-a-binary-search-tree/) | Medium | Remove nodes outside range |
| [Count Nodes in Range](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/) | Medium | Count variant |

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This</strong></summary>

**Key points:**
1. "BST's ordering lets us prune entire subtrees"
2. "If current value is below low, skip left subtree"
3. "If current value is above high, skip right subtree"
4. "This gives O(h + k) time instead of O(n)"

**When interviewer asks about complexity:**
"In the worst case where all nodes are in range, it's O(n). But typically it's O(h + k) where k is nodes in range, because we prune subtrees outside the range."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand pattern | 10 min | One-time learning |
| Apply to new problem | 5-8 min | Template adaptation |
| Code solution | 8-10 min | Range DFS |
| Discuss complexity | 2-3 min | Explain pruning |

---

## üí° Key Insight

> **Range queries on BST are O(h + k), not O(n).** The BST property lets us prune entire subtrees that can't contain values in range. This is like binary search combined with traversal ‚Äî we skip branches that can't have answers.

---

## üîó Related

- **Next:** [Range Sum BST (LC 938)](./5.2-Range-Sum-BST-LC938.md)
- **Related:** [Trim BST (LC 669)](../03-BST-Validation/3.3-Trim-BST-LC669.md)
- **Foundation:** [BST Properties](../01-BST-Fundamentals/1.2-BST-Properties.md)
