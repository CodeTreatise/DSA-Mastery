# 2.1 Binary Search Basics

> **The Most Important Search Algorithm**  
> **Interview Value:** â­â­â­â­â­ - ~15% of interview problems use Binary Search  
> **Prerequisites:** [01-Arrays](../../01-Arrays-Strings/01-Arrays/)

---

## Overview

**Binary Search** is a divide-and-conquer algorithm that finds elements in a **sorted** array in O(log n) time by repeatedly halving the search space.

```
Linear Search: [1, 2, 3, 4, 5, 6, 7, 8, 9] â†’ Check all 9 elements â†’ O(n)
Binary Search: [1, 2, 3, 4, 5, 6, 7, 8, 9] â†’ Check 4 elements max â†’ O(log n)
```

The key insight: **Each comparison eliminates HALF the remaining elements.**

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>When to Identify Binary Search</strong></summary>

**Look for these signals:**
- Array is **sorted** (or can be sorted)
- Need to find an element, position, or boundary
- Problem mentions **O(log n)** requirement
- Finding **minimum/maximum** that satisfies a condition
- Answer lies in a **known range**

**Keywords in problem statement:**
- "sorted array", "find", "search"
- "minimum X such that...", "maximum Y such that..."
- "first/last occurrence"
- "rotated sorted array"

**The Binary Search Decision:**
```
Is the array sorted? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                            â”‚
        YES                          NO
         â”‚                            â”‚
         â–¼                            â–¼
  Use Binary Search          Can you define a monotonic
  O(log n)                   condition on the answer?
                                      â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
                             YES              NO
                              â”‚               â”‚
                              â–¼               â–¼
                      Binary Search      Linear Search
                      on Answer          O(n)
```

</details>

---

## âœ… When to Use

- **Sorted array** - Find element, insertion point, boundary
- **Rotated sorted array** - Find minimum, search element
- **Search space with monotonic property** - Binary search on answer
- **Finding boundaries** - First/last occurrence
- **Optimization problems** - Minimum/maximum satisfying condition

---

## âŒ When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Unsorted array | Linear Search or Sort first | No order to exploit |
| Linked list | Linear traversal | No random access |
| Frequent insertions/deletions | BST or Hash Map | Maintaining sort is expensive |
| Small arrays (n < 10) | Linear Search | Setup overhead not worth it |
| Finding ALL occurrences | Linear scan or Two searches | Need to scan range anyway |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Array Basics](../../01-Arrays-Strings/01-Arrays/1.1-Array-Basics.md)
- [Two Pointers](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md)
- [Recursion Basics](../../02-Recursion-Backtracking/01-Recursion/1.1-Recursion-Basics.md)

**After mastering this:**
- [Boundary Search](./2.2-Binary-Search-Patterns/02-Boundary-Search.md)
- [Rotated Arrays](./2.2-Binary-Search-Patterns/03-Rotated-Arrays.md)
- [Search on Answer](./2.2-Binary-Search-Patterns/04-Search-On-Answer.md)

**Combines with:**
- Two Pointers (for range problems)
- Divide & Conquer (conceptual foundation)
- Sorting (preprocessing step)

</details>

---

## ğŸ“ How It Works

### The Core Idea

```
Given sorted array: [1, 3, 5, 7, 9, 11, 13, 15]
Find: 11

Step 1: Check middle (7)
        [1, 3, 5, 7, 9, 11, 13, 15]
                 â†‘
        11 > 7, so search RIGHT half

Step 2: Check middle of right half (11)
        [9, 11, 13, 15]
             â†‘
        11 == 11, FOUND at index 5!
```

### Visualization

```
Array: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
Find: 23

Iteration 1:
[2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
 L              M                   R
mid=4, arr[4]=16
23 > 16 â†’ search right

Iteration 2:
[2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
                  L    M         R
mid=7, arr[7]=56
23 < 56 â†’ search left

Iteration 3:
[2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
                  L M  R
mid=5, arr[5]=23
23 == 23 â†’ FOUND!

Only 3 comparisons for 10 elements!
```

### Why O(log n)?

```
Array size: 1000 elements
After 1 comparison: 500 elements remain
After 2 comparisons: 250 elements remain
After 3 comparisons: 125 elements remain
...
After 10 comparisons: 1 element remains

logâ‚‚(1000) â‰ˆ 10 comparisons maximum!
```

---

## ğŸ’» Code Implementation

### Template 1: Iterative (Standard)

**Python:**
```python
def binary_search(arr: list[int], target: int) -> int:
    """
    Standard binary search - find exact element.
    
    Returns: Index of target, or -1 if not found
    Time: O(log n), Space: O(1)
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:  # Note: <= not <
        mid = left + (right - left) // 2  # Avoid overflow
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1   # Search right half
        else:
            right = mid - 1  # Search left half
    
    return -1  # Not found


# Example
arr = [1, 3, 5, 7, 9, 11, 13, 15]
print(binary_search(arr, 11))  # 5
print(binary_search(arr, 6))   # -1
```

**JavaScript:**
```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

console.log(binarySearch([1, 3, 5, 7, 9, 11, 13, 15], 11)); // 5
```

---

### Template 2: Recursive

```python
def binary_search_recursive(arr: list[int], target: int, 
                            left: int = 0, right: int = None) -> int:
    """
    Recursive binary search.
    
    Time: O(log n), Space: O(log n) for call stack
    """
    if right is None:
        right = len(arr) - 1
    
    # Base case: element not found
    if left > right:
        return -1
    
    mid = left + (right - left) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)


print(binary_search_recursive([1, 3, 5, 7, 9], 5))  # 2
```

```javascript
function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
    if (left > right) return -1;
    
    const mid = left + Math.floor((right - left) / 2);
    
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right);
    }
    return binarySearchRecursive(arr, target, left, mid - 1);
}
```

---

### Template 3: Search Insert Position

```python
def search_insert(arr: list[int], target: int) -> int:
    """
    Find index to insert target while maintaining sorted order.
    
    Returns: Index where target is or should be inserted
    Time: O(log n), Space: O(1)
    """
    left, right = 0, len(arr)  # Note: right = len(arr), not len-1
    
    while left < right:  # Note: < not <=
        mid = left + (right - left) // 2
        
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid  # Don't exclude mid
    
    return left


# Example
arr = [1, 3, 5, 6]
print(search_insert(arr, 5))  # 2 (exists at index 2)
print(search_insert(arr, 2))  # 1 (insert between 1 and 3)
print(search_insert(arr, 7))  # 4 (insert at end)
```

---

### Using Python's bisect Module

```python
import bisect

arr = [1, 3, 5, 7, 9]

# Find insertion point (leftmost)
print(bisect.bisect_left(arr, 5))   # 2 (index of 5)
print(bisect.bisect_left(arr, 6))   # 3 (where 6 would go)

# Find insertion point (rightmost)
print(bisect.bisect_right(arr, 5))  # 3 (after 5)

# Insert while maintaining order
bisect.insort(arr, 6)
print(arr)  # [1, 3, 5, 6, 7, 9]
```

---

## âš¡ Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Iterative |" O(log n) "| O(1) | â­ Preferred |
| Recursive |" O(log n) "| O(log n) | Call stack |
| With preprocessing |" O(n log n) "| Depends | If sorting needed |

**Why O(log n)?**
- Each iteration cuts search space in half
- For n elements: logâ‚‚(n) iterations maximum
- 1 billion elements â†’ only ~30 comparisons!

**Comparison with Linear Search:**

| n |" Linear O(n) "| Binary O(log n) |
|---|-------------|-----------------|
| 100 | 100 ops | 7 ops |
| 1,000 | 1,000 ops | 10 ops |
| 1,000,000 | 1,000,000 ops | 20 ops |
| 1,000,000,000 | 1 billion ops | 30 ops |

---

## ğŸ”„ Variations

| Variation | Key Difference | Next Lesson |
|-----------|----------------|-------------|
| **Exact match** | Find specific element | This lesson |
| **Lower bound** | First element â‰¥ target | [Boundary Search](./2.2-Binary-Search-Patterns/02-Boundary-Search.md) |
| **Upper bound** | First element > target | [Boundary Search](./2.2-Binary-Search-Patterns/02-Boundary-Search.md) |
| **Rotated array** | Array rotated at pivot | [Rotated Arrays](./2.2-Binary-Search-Patterns/03-Rotated-Arrays.md) |
| **Search on answer** | Find min/max value | [Search on Answer](./2.2-Binary-Search-Patterns/04-Search-On-Answer.md) |
| **2D Matrix** | Search in matrix | [2D Matrix Search](./2.2-Binary-Search-Patterns/05-2D-Matrix-Search.md) |

---

## âš ï¸ Common Mistakes

### 1. Integer Overflow in Mid Calculation

âŒ **Wrong:**
```python
mid = (left + right) // 2  # Can overflow in some languages!
```

âœ… **Correct:**
```python
mid = left + (right - left) // 2  # Always safe
```

### 2. Wrong Loop Condition

âŒ **Wrong (misses elements):**
```python
while left < right:  # Misses when left == right
    if arr[mid] == target:
        return mid
```

âœ… **Correct (for exact match):**
```python
while left <= right:  # Checks all elements
```

### 3. Infinite Loop from Wrong Boundary Update

âŒ **Wrong:**
```python
if arr[mid] < target:
    left = mid  # Can cause infinite loop!
```

âœ… **Correct:**
```python
if arr[mid] < target:
    left = mid + 1  # Always make progress
```

### 4. Off-by-One in Initial Bounds

âŒ **Wrong:**
```python
right = len(arr)  # For exact match, this is wrong
```

âœ… **Correct:**
```python
right = len(arr) - 1  # For exact match (inclusive bounds)
# OR
right = len(arr)  # For insertion point (exclusive right bound)
```

### 5. Not Handling Empty Array

âŒ **Wrong:**
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1  # Crashes on empty array
```

âœ… **Correct:**
```python
def binary_search(arr, target):
    if not arr:
        return -1
    left, right = 0, len(arr) - 1
```

---

## ğŸ“ Practice Problems

### Easy (Learn the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Binary Search | Classic implementation | [LC 704](https://leetcode.com/problems/binary-search/) |
| Search Insert Position | Insertion point | [LC 35](https://leetcode.com/problems/search-insert-position/) |
| Sqrt(x) | Binary search on value | [LC 69](https://leetcode.com/problems/sqrtx/) |
| Valid Perfect Square | Binary search check | [LC 367](https://leetcode.com/problems/valid-perfect-square/) |

### Medium (Apply variations)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Find First and Last Position | Boundary search | [LC 34](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/) |
| Find Peak Element | Modified binary search | [LC 162](https://leetcode.com/problems/find-peak-element/) |
| Search in Rotated Sorted Array | Rotated array | [LC 33](https://leetcode.com/problems/search-in-rotated-sorted-array/) |

### Hard (Master the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Median of Two Sorted Arrays | Complex binary search | [LC 4](https://leetcode.com/problems/median-of-two-sorted-arrays/) |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

**Week 1: Foundation**
- Day 1: Binary Search (LC 704)
- Day 2: Search Insert Position (LC 35)
- Day 3: Redo both without looking
- Day 5: Sqrt(x)

**Week 2: Variations**
- Day 8: Find First and Last Position
- Day 10: Find Peak Element
- Day 14: Review all, identify patterns

**Key Practice:**
- Write binary search from memory (no reference)
- Identify which template to use
- Draw the search space narrowing

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Opening statement:**
> "I notice the array is sorted, so I'll use binary search to achieve O(log n) time complexity."

**Walking through the approach:**
> "I'll maintain two pointers, left and right, defining my search space. At each step, I compare the middle element with the target and eliminate half the search space."

**During coding:**
> "I'm using `left + (right - left) // 2` instead of `(left + right) // 2` to avoid potential integer overflow."

**Complexity discussion:**
> "Time is O(log n) because we halve the search space each iteration. Space is O(1) for the iterative approach."

**Common follow-up questions:**
- "What if there are duplicates?" â†’ Use boundary search
- "What if the array is rotated?" â†’ Modified binary search
- "Can you do it recursively?" â†’ Yes, but O(log n) space

**Company Focus:**

| Company | Binary Search Frequency |
|---------|------------------------|
| Google | â­â­â­â­â­ Very common |
| Amazon | â­â­â­â­â­ Very common |
| Meta | â­â­â­â­ Common |
| Microsoft | â­â­â­â­ Common |

</details>

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn basic template | 20-30 min | Understand the logic |
| LC 704 Binary Search | 10-15 min | Should be quick |
| LC 35 Search Insert | 15-20 min | Different template |
| Master all variations | 1-2 weeks | Multiple problems |
| Write from memory | 2-5 min | Interview goal |

---

## ğŸ’¡ Key Insight

> **Binary Search is about eliminating half the possibilities with each comparison.**
>
> The three key decisions:
> 1. **Which template?** `left <= right` (exact) vs `left < right` (boundary)
> 2. **How to update bounds?** Include or exclude mid?
> 3. **What to return?** Index, value, or boolean?
>
> Master these decisions, and you can solve ANY binary search problem.

---

## ğŸ”— Related

- [Boundary Search](./2.2-Binary-Search-Patterns/02-Boundary-Search.md) - First/last occurrence
- [Rotated Arrays](./2.2-Binary-Search-Patterns/03-Rotated-Arrays.md) - Modified binary search
- [Search on Answer](./2.2-Binary-Search-Patterns/04-Search-On-Answer.md) - Optimization problems
- [Two Pointers](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md) - Related technique
