# 1.7 - Sorting Problems

> **Classic Interview Problems Using Sorting**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - Very common patterns  
> **Focus:** Sort + Two Pointers, Sort + Merge, Custom Comparators

---

## Overview

Many interview problems become much easier after sorting. This file covers the most common patterns where sorting is the key insight.

| Pattern | Examples | Complexity Added |
|---------|----------|------------------|
| Sort + Two Pointers | 3Sum, Meeting Rooms |" O(n log n) + O(n) "|
| Sort + Merge | Merge Intervals |" O(n log n) + O(n) "|
| Custom Comparator | Largest Number, Sort Colors | Varies |
| Partial Sort | Kth Largest, Top K |" O(n) to O(n log k) "|

---

## üéØ Pattern Recognition

<details>
<summary><strong>When Sorting Helps</strong></summary>

**Keywords suggesting sort first:**
- "Find pairs/triplets with sum"
- "Merge intervals"
- "Closest pair"
- "Meeting rooms"
- "Sort by custom criteria"

**The insight:**
```
Before sorting: Random order ‚Üí Need O(n¬≤) to find pairs
After sorting: Ordered ‚Üí Two pointers O(n) or Binary Search O(log n)
```

</details>

---

## ‚úÖ When to Use Sort-First Approach

- **Finding pairs/triplets** - Two pointers after sorting
- **Interval problems** - Merge, insert, find overlaps
- **Closest/farthest elements** - Neighbors after sorting
- **Custom ordering** - Define comparator
- **Grouping by property** - Sort as hash key

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Need to preserve order | Hash Map | Sorting destroys order |
| Already sorted input | Skip sort step |" Unnecessary O(n log n) "|
| Finding single element |" Hash Map O(n) "| Sorting overkill |
| Streaming data | Heap / BST | Can't sort unbounded stream |
| Very small arrays | Brute force | Sorting overhead not worth it |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Related Patterns</strong></summary>

**Before this, you should know:**
- [Sorting Basics](./1.1-Sorting-Basics.md)
- [Two Pointers](../../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md)
- [Heap Basics](../../08-Heaps-Priority-Queues.md)

**Patterns that combine with sorting:**
- Two Pointers (3Sum, Container With Most Water)
- Binary Search (Search Insert Position after sort)
- Sweep Line (Meeting Rooms)
- Greedy (Activity Selection)

</details>

---

## üîÑ Variations

| Pattern | Technique After Sort | Examples |
|---------|---------------------|----------|
| Sort + Two Pointers |" O(n) pair finding "| 3Sum, 4Sum, 2Sum II |
| Sort + Merge |" O(n) interval merge "| Merge Intervals, Insert Interval |
| Sort + Sweep Line |" O(n) event processing "| Meeting Rooms II, Skyline |
| Sort + Custom Comparator | Define ordering | Largest Number, Custom Sort |
| Sort as Key | Hash by sorted form | Group Anagrams |
| Partial Sort | Top K with heap | Kth Largest, Top K Frequent |

---

## Problem 1: 3Sum (LC 15) ‚≠ê‚≠ê‚≠ê

Find all unique triplets that sum to zero.

### Pattern: Sort + Two Pointers

```python
def three_sum(nums: list[int]) -> list[list[int]]:
    """
    Find all unique triplets summing to zero.
    
    Approach: Sort, then for each element, use two pointers.
    
    Time: O(n¬≤), Space: O(1) excluding output
    """
    nums.sort()
    result = []
    n = len(nums)
    
    for i in range(n - 2):
        # Skip duplicates for first element
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        
        # Early termination
        if nums[i] > 0:  # If smallest is positive, no solution
            break
        
        # Two pointers for remaining two elements
        left, right = i + 1, n - 1
        target = -nums[i]
        
        while left < right:
            current_sum = nums[left] + nums[right]
            
            if current_sum == target:
                result.append([nums[i], nums[left], nums[right]])
                
                # Skip duplicates
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                
                left += 1
                right -= 1
            elif current_sum < target:
                left += 1
            else:
                right -= 1
    
    return result


# Example
print(three_sum([-1, 0, 1, 2, -1, -4]))
# [[-1, -1, 2], [-1, 0, 1]]
```

---

## Problem 2: Merge Intervals (LC 56) ‚≠ê‚≠ê‚≠ê

Merge all overlapping intervals.

### Pattern: Sort + Linear Scan

```python
def merge_intervals(intervals: list[list[int]]) -> list[list[int]]:
    """
    Merge overlapping intervals.
    
    Approach: Sort by start time, then merge if overlapping.
    
    Time: O(n log n), Space: O(n) for output
    """
    if not intervals:
        return []
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    merged = [intervals[0]]
    
    for start, end in intervals[1:]:
        # Check if overlaps with last merged interval
        if start <= merged[-1][1]:
            # Merge: extend the end
            merged[-1][1] = max(merged[-1][1], end)
        else:
            # No overlap: add as new interval
            merged.append([start, end])
    
    return merged


# Example
print(merge_intervals([[1,3], [2,6], [8,10], [15,18]]))
# [[1, 6], [8, 10], [15, 18]]
```

---

## Problem 3: Meeting Rooms II (LC 253) ‚≠ê‚≠ê‚≠ê

Find minimum number of meeting rooms required.

### Pattern: Sort + Sweep Line (or Heap)

```python
def min_meeting_rooms(intervals: list[list[int]]) -> int:
    """
    Find minimum meeting rooms needed.
    
    Approach 1: Sweep line - process start and end events.
    
    Time: O(n log n), Space: O(n)
    """
    events = []
    for start, end in intervals:
        events.append((start, 1))   # Meeting starts
        events.append((end, -1))    # Meeting ends
    
    # Sort by time, end events before start events at same time
    events.sort(key=lambda x: (x[0], x[1]))
    
    max_rooms = current_rooms = 0
    for time, event_type in events:
        current_rooms += event_type
        max_rooms = max(max_rooms, current_rooms)
    
    return max_rooms


# Approach 2: Using heap
import heapq

def min_meeting_rooms_heap(intervals: list[list[int]]) -> int:
    """
    Approach 2: Sort by start, use heap for end times.
    """
    if not intervals:
        return 0
    
    intervals.sort(key=lambda x: x[0])
    
    # Heap of end times (rooms in use)
    heap = []
    
    for start, end in intervals:
        # If earliest ending room is free, reuse it
        if heap and heap[0] <= start:
            heapq.heappop(heap)
        
        # Allocate room (add end time)
        heapq.heappush(heap, end)
    
    return len(heap)


# Example
print(min_meeting_rooms([[0,30], [5,10], [15,20]]))  # 2
```

---

## Problem 4: Sort Colors (LC 75) - Dutch National Flag ‚≠ê‚≠ê‚≠ê

Sort array with only 0s, 1s, and 2s in-place.

### Pattern: Three-Way Partition

```python
def sort_colors(nums: list[int]) -> None:
    """
    Sort array containing only 0, 1, 2.
    
    Dutch National Flag algorithm (three-way partition).
    
    Time: O(n), Space: O(1)
    """
    # Three pointers
    low = 0          # Next position for 0
    mid = 0          # Current element
    high = len(nums) - 1  # Next position for 2
    
    while mid <= high:
        if nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == 1:
            mid += 1
        else:  # nums[mid] == 2
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1
            # Don't increment mid - need to check swapped element


# Example
arr = [2, 0, 2, 1, 1, 0]
sort_colors(arr)
print(arr)  # [0, 0, 1, 1, 2, 2]
```

---

## Problem 5: Largest Number (LC 179) ‚≠ê‚≠ê‚≠ê

Form the largest number from a list of integers.

### Pattern: Custom Comparator

```python
from functools import cmp_to_key

def largest_number(nums: list[int]) -> str:
    """
    Arrange numbers to form the largest number.
    
    Key insight: Compare a+b vs b+a as strings.
    
    Time: O(n log n), Space: O(n)
    """
    def compare(a: str, b: str) -> int:
        # If a+b > b+a, a should come first (return -1 for descending)
        if a + b > b + a:
            return -1
        elif a + b < b + a:
            return 1
        return 0
    
    # Convert to strings
    strs = [str(num) for num in nums]
    
    # Sort with custom comparator
    strs.sort(key=cmp_to_key(compare))
    
    # Handle edge case: all zeros
    if strs[0] == '0':
        return '0'
    
    return ''.join(strs)


# Example
print(largest_number([3, 30, 34, 5, 9]))  # "9534330"
print(largest_number([10, 2]))  # "210"
```

---

## Problem 6: Kth Largest Element (LC 215) ‚≠ê‚≠ê‚≠ê

Find the kth largest element.

### Pattern: Quick Select or Heap

```python
import heapq
import random

def find_kth_largest_heap(nums: list[int], k: int) -> int:
    """
    Using min-heap of size k.
    
    Time: O(n log k), Space: O(k)
    """
    # Keep k largest elements in min-heap
    heap = []
    
    for num in nums:
        if len(heap) < k:
            heapq.heappush(heap, num)
        elif num > heap[0]:
            heapq.heapreplace(heap, num)
    
    return heap[0]  # kth largest is smallest in heap


def find_kth_largest_quickselect(nums: list[int], k: int) -> int:
    """
    Using Quick Select.
    
    Time: O(n) average, O(n¬≤) worst, Space: O(1)
    """
    k = len(nums) - k  # Convert to kth smallest (0-indexed)
    
    def partition(left: int, right: int) -> int:
        pivot_idx = random.randint(left, right)
        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
        
        pivot = nums[right]
        i = left - 1
        
        for j in range(left, right):
            if nums[j] < pivot:
                i += 1
                nums[i], nums[j] = nums[j], nums[i]
        
        nums[i + 1], nums[right] = nums[right], nums[i + 1]
        return i + 1
    
    left, right = 0, len(nums) - 1
    
    while True:
        p = partition(left, right)
        if p == k:
            return nums[k]
        elif p < k:
            left = p + 1
        else:
            right = p - 1


# Example
print(find_kth_largest_heap([3, 2, 1, 5, 6, 4], 2))  # 5
print(find_kth_largest_quickselect([3, 2, 1, 5, 6, 4], 2))  # 5
```

---

## Problem 7: Top K Frequent Elements (LC 347) ‚≠ê‚≠ê‚≠ê

Find k most frequent elements.

### Pattern: Bucket Sort or Heap

```python
from collections import Counter
import heapq

def top_k_frequent_bucket(nums: list[int], k: int) -> list[int]:
    """
    Using bucket sort by frequency.
    
    Time: O(n), Space: O(n)
    """
    count = Counter(nums)
    
    # Buckets: index = frequency, value = list of numbers with that frequency
    buckets = [[] for _ in range(len(nums) + 1)]
    
    for num, freq in count.items():
        buckets[freq].append(num)
    
    # Collect top k from highest frequency buckets
    result = []
    for freq in range(len(buckets) - 1, 0, -1):
        for num in buckets[freq]:
            result.append(num)
            if len(result) == k:
                return result
    
    return result


def top_k_frequent_heap(nums: list[int], k: int) -> list[int]:
    """
    Using min-heap of size k.
    
    Time: O(n log k), Space: O(n)
    """
    count = Counter(nums)
    
    # Use heap to find k most frequent
    return heapq.nlargest(k, count.keys(), key=count.get)


# Example
print(top_k_frequent_bucket([1,1,1,2,2,3], 2))  # [1, 2]
print(top_k_frequent_heap([1,1,1,2,2,3], 2))  # [1, 2]
```

---

## Problem 8: Valid Anagram / Group Anagrams

### Pattern: Sort as Key

```python
def is_anagram(s: str, t: str) -> bool:
    """Check if two strings are anagrams."""
    return sorted(s) == sorted(t)


def group_anagrams(strs: list[str]) -> list[list[str]]:
    """
    Group anagrams together.
    
    Time: O(n * k log k) where k = max string length
    Space: O(n * k)
    """
    from collections import defaultdict
    
    groups = defaultdict(list)
    
    for s in strs:
        # Sorted string as key
        key = ''.join(sorted(s))
        groups[key].append(s)
    
    return list(groups.values())


# Example
print(group_anagrams(["eat", "tea", "tan", "ate", "nat", "bat"]))
# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]
```

---

## ‚ö° Summary: When to Sort First

| Problem Type | After Sorting | LeetCode |
|--------------|---------------|----------|
| Find pairs/triplets |" Two pointers O(n) "| 3Sum, 4Sum |
| Overlapping intervals |" Linear merge O(n) "| LC 56 |
| Meeting rooms |" Sweep line O(n) "| LC 253 |
| Closest pair | Two pointers | LC 16 |
| Kth element | Partial sort | LC 215 |
| Custom order | Comparator | LC 179 |
| Group by property | Sort as key | LC 49 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Handling Duplicates in 3Sum

‚ùå **Wrong:**
```python
for i in range(n - 2):
    # Missing duplicate check
    left, right = i + 1, n - 1
```

‚úÖ **Correct:**
```python
for i in range(n - 2):
    if i > 0 and nums[i] == nums[i - 1]:
        continue  # Skip duplicates
```

### 2. Wrong Interval Merge Logic

‚ùå **Wrong:**
```python
if current[0] <= merged[-1][1]:
    merged[-1][1] = current[1]  # Should take max!
```

‚úÖ **Correct:**
```python
if current[0] <= merged[-1][1]:
    merged[-1][1] = max(merged[-1][1], current[1])
```

### 3. Custom Comparator Returns Wrong Values

‚ùå **Wrong:**
```python
def compare(a, b):
    return a + b > b + a  # Returns bool, not int!
```

‚úÖ **Correct:**
```python
def compare(a, b):
    if a + b > b + a: return -1
    elif a + b < b + a: return 1
    return 0
```

---

## üìù Practice Problems

### Medium

| Problem | Pattern | LeetCode |
|---------|---------|----------|
| 3Sum | Sort + Two Pointers | [LC 15](https://leetcode.com/problems/3sum/) |
| Merge Intervals | Sort + Merge | [LC 56](https://leetcode.com/problems/merge-intervals/) |
| Sort Colors | 3-Way Partition | [LC 75](https://leetcode.com/problems/sort-colors/) |
| Kth Largest | Quick Select / Heap | [LC 215](https://leetcode.com/problems/kth-largest-element-in-an-array/) |
| Top K Frequent | Bucket Sort | [LC 347](https://leetcode.com/problems/top-k-frequent-elements/) |
| Largest Number | Custom Comparator | [LC 179](https://leetcode.com/problems/largest-number/) |
| Group Anagrams | Sort as Key | [LC 49](https://leetcode.com/problems/group-anagrams/) |
| Meeting Rooms II | Sweep Line | [LC 253](https://leetcode.com/problems/meeting-rooms-ii/) |

### Hard

| Problem | Pattern | LeetCode |
|---------|---------|----------|
| 4Sum | Sort + Two Pointers | [LC 18](https://leetcode.com/problems/4sum/) |
| Insert Interval | Sort + Merge | [LC 57](https://leetcode.com/problems/insert-interval/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: LC 56 Merge Intervals
- Day 3: LC 15 3Sum
- Day 5: LC 75 Sort Colors

**Week 2:**
- Day 8: LC 215 Kth Largest
- Day 10: LC 179 Largest Number
- Day 14: LC 253 Meeting Rooms II

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate</strong></summary>

**Recognizing the pattern:**
> "This problem involves finding pairs/intervals, so I'll sort first to enable efficient scanning."

**Trade-off discussion:**
> "Sorting takes O(n log n), but then I can solve the rest in O(n), giving O(n log n) total instead of O(n¬≤)."

**Company Focus:**

| Company | Common Problems |
|---------|-----------------|
| Google | 3Sum, Meeting Rooms |
| Amazon | Merge Intervals, Top K |
| Meta | Sort Colors, Group Anagrams |
| Microsoft | Kth Largest, Largest Number |

</details>

---

## ‚è±Ô∏è Time Estimates

| Problem | Target Time | Key Focus |
|---------|-------------|-----------|
| 3Sum | 20-25 min | Duplicate handling |
| Merge Intervals | 15-20 min | Merge logic |
| Sort Colors | 15 min | 3-way partition |
| Kth Largest | 15-20 min | Quick Select or Heap |
| Largest Number | 15-20 min | Custom comparator |
| Group Anagrams | 15 min | Sort as key |
| Meeting Rooms II | 20-25 min | Sweep line or heap |

---

## üí° Key Insight

> **Sorting is often the key to reducing complexity:**
>
> | Before Sort | After Sort |
> |-------------|------------|
> |" O(n¬≤) pair search "| O(n) two pointers |
> |" O(n¬≤) interval merge "| O(n) linear scan |
> | Complex comparisons | Simple neighbor checks |
>
> **When you see pair/triplet/interval problems, think: "What if I sort first?"**

---

## üîó Related

- [Sorting Basics](./1.1-Sorting-Basics.md) - Algorithm overview
- [Two Pointers](../01-Arrays-Strings/01-Arrays/1.4-Common-Techniques/01-Two-Pointers.md) - After sorting
- [Merge Sort](./1.3-Merge-Sort.md) - Merge technique
