# Palindrome DP Pattern

> **Master the art of symmetry.** Palindrome problems appear frequently in interviews and showcase elegant DP patternsâ€”from the center-expansion technique for substrings to interval DP for subsequences. Understanding both approaches unlocks a whole family of problems.

---

## ðŸ“‹ Overview

The **Palindrome DP** pattern covers problems that involve:
- Finding palindromic substrings or subsequences
- Counting palindromes
- Converting strings to/from palindromes
- Partitioning into palindromic segments

**Key Distinction:**
- **Substring:** Contiguous characters (can use center expansion)
- **Subsequence:** Non-contiguous, order preserved (requires interval DP)

---

## ðŸŽ¯ Pattern Recognition

<details>
<summary><strong>How to Identify Palindrome DP</strong></summary>

**Look for these signals:**
- "Palindrome" mentioned explicitly
- Symmetry-related problems
- "Reads same forwards and backwards"
- Minimum operations to make palindrome

**Keywords in problem statement:**
- "palindromic substring/subsequence"
- "partition into palindromes"
- "minimum insertions/deletions for palindrome"
- "count palindromes"

**Decide which approach:**
- Substring (contiguous) â†’ Center expansion or expand around
- Subsequence â†’ Interval DP or LCS transformation
- Counting all â†’ 2D DP with memoization
- Partitioning â†’ DP + palindrome precomputation

</details>

---

## âœ… Core Problems

| Problem | Type | Approach |
|---------|------|----------|
| Longest Palindromic Substring | Substring | Center expansion or DP |
| Longest Palindromic Subsequence | Subsequence | LCS(s, rev(s)) or Interval DP |
| Palindromic Substrings Count | Counting | Center expansion or DP |
| Palindrome Partitioning II | Partitioning | DP + palindrome precompute |
| Min Insertions for Palindrome | Transformation | n - LPS(s) |

---

## ðŸ“ Three Core Approaches

### Approach 1: Center Expansion (Substrings)

For each possible center, expand outward while palindrome.

```python
def longest_palindrome_substring(s: str) -> str:
    """
    Expand around each center.
    Time: O(nÂ²), Space: O(1)
    """
    def expand(left: int, right: int) -> str:
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]
    
    result = ""
    for i in range(len(s)):
        # Odd length palindrome (single center)
        odd = expand(i, i)
        if len(odd) > len(result):
            result = odd
        
        # Even length palindrome (between two chars)
        even = expand(i, i + 1)
        if len(even) > len(result):
            result = even
    
    return result
```

### Approach 2: 2D DP for Substrings

`dp[i][j]` = True if s[i:j+1] is a palindrome.

```python
def is_palindrome_dp(s: str) -> list[list[bool]]:
    """
    Build 2D palindrome table.
    Time: O(nÂ²), Space: O(nÂ²)
    """
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    
    # Single characters are palindromes
    for i in range(n):
        dp[i][i] = True
    
    # Two characters
    for i in range(n - 1):
        dp[i][i + 1] = (s[i] == s[i + 1])
    
    # Longer lengths
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
    
    return dp
```

### Approach 3: Interval DP for Subsequences

`dp[i][j]` = LPS length for s[i:j+1].

```python
def longest_palindrome_subseq(s: str) -> int:
    """
    Interval DP for longest palindromic subsequence.
    Time: O(nÂ²), Space: O(nÂ²)
    """
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    
    # Base case: single chars
    for i in range(n):
        dp[i][i] = 1
    
    # Fill by increasing length
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    
    return dp[0][n - 1]
```

---

## ðŸ’» Core Problems with Solutions

### Problem 1: Longest Palindromic Substring (LC 5)

```python
def longest_palindrome(s: str) -> str:
    """
    Find longest palindromic substring.
    """
    def expand(l: int, r: int) -> tuple[int, int]:
        while l >= 0 and r < len(s) and s[l] == s[r]:
            l -= 1
            r += 1
        return l + 1, r
    
    start, end = 0, 0
    for i in range(len(s)):
        # Odd length
        l1, r1 = expand(i, i)
        if r1 - l1 > end - start:
            start, end = l1, r1
        
        # Even length
        l2, r2 = expand(i, i + 1)
        if r2 - l2 > end - start:
            start, end = l2, r2
    
    return s[start:end]
```

```javascript
function longestPalindrome(s) {
    let start = 0, maxLen = 0;
    
    function expand(l, r) {
        while (l >= 0 && r < s.length && s[l] === s[r]) {
            l--;
            r++;
        }
        return r - l - 1;
    }
    
    for (let i = 0; i < s.length; i++) {
        const len1 = expand(i, i);
        const len2 = expand(i, i + 1);
        const len = Math.max(len1, len2);
        
        if (len > maxLen) {
            maxLen = len;
            start = i - Math.floor((len - 1) / 2);
        }
    }
    
    return s.substring(start, start + maxLen);
}
```

### Problem 2: Palindromic Substrings Count (LC 647)

```python
def count_substrings(s: str) -> int:
    """
    Count all palindromic substrings.
    """
    count = 0
    
    def expand(l: int, r: int) -> int:
        cnt = 0
        while l >= 0 and r < len(s) and s[l] == s[r]:
            cnt += 1
            l -= 1
            r += 1
        return cnt
    
    for i in range(len(s)):
        count += expand(i, i)      # Odd length
        count += expand(i, i + 1)  # Even length
    
    return count
```

### Problem 3: Longest Palindromic Subsequence (LC 516)

```python
def longest_palindrome_subseq(s: str) -> int:
    """
    LPS = LCS(s, reverse(s))
    """
    rev = s[::-1]
    n = len(s)
    
    # Standard LCS
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if s[i-1] == rev[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[n][n]
```

### Problem 4: Min Insertions for Palindrome (LC 1312)

```python
def min_insertions(s: str) -> int:
    """
    Minimum insertions = n - LPS(s)
    """
    lps = longest_palindrome_subseq(s)
    return len(s) - lps
```

### Problem 5: Palindrome Partitioning II (LC 132)

```python
def min_cut(s: str) -> int:
    """
    Minimum cuts to partition into palindromes.
    """
    n = len(s)
    
    # Precompute: is s[i:j+1] a palindrome?
    is_pal = [[False] * n for _ in range(n)]
    for i in range(n):
        is_pal[i][i] = True
    for i in range(n - 1):
        is_pal[i][i + 1] = (s[i] == s[i + 1])
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            is_pal[i][j] = (s[i] == s[j]) and is_pal[i + 1][j - 1]
    
    # dp[i] = min cuts for s[0:i+1]
    dp = [float('inf')] * n
    
    for i in range(n):
        if is_pal[0][i]:
            dp[i] = 0  # Whole prefix is palindrome
        else:
            for j in range(i):
                if is_pal[j + 1][i]:
                    dp[i] = min(dp[i], dp[j] + 1)
    
    return dp[n - 1]
```

---

## âš¡ Complexity Analysis

| Problem | Time | Space |
|---------|------|-------|
| Longest Substring (expand) | O(nÂ²) | O(1) |
| Count Substrings | O(nÂ²) | O(1) |
| LPS (Interval DP) | O(nÂ²) | O(nÂ²) |
| LPS (Space-optimized) | O(nÂ²) | O(n) |
| Min Cuts (Partition) | O(nÂ²) | O(nÂ²) |

**Manacher's Algorithm:** O(n) for longest palindromic substring, but rarely asked in interviews.

---

## ðŸ”„ Palindrome Transformations

### LPS as LCS

```python
# Longest Palindromic Subsequence = LCS(s, reverse(s))
lps = lcs(s, s[::-1])
```

### Min Operations for Palindrome

```python
# Min insertions to make palindrome = n - LPS
min_insert = len(s) - lps(s)

# Min deletions to make palindrome = n - LPS (same!)
min_delete = len(s) - lps(s)
```

### Check if K-Palindrome

```python
def is_k_palindrome(s: str, k: int) -> bool:
    """Can we remove at most k chars to get palindrome?"""
    lps = longest_palindrome_subseq(s)
    return len(s) - lps <= k
```

---

## âš ï¸ Common Mistakes

### 1. Substring vs Subsequence Confusion

**Substring:** Contiguous - "bab" in "cbabad"
**Subsequence:** Non-contiguous - "aba" from "abacd"

Use different approaches!

### 2. Wrong Center Expansion for Even Lengths

**âŒ Wrong:**
```python
for i in range(len(s)):
    expand(i, i)  # Only odd lengths!
```

**âœ… Correct:**
```python
for i in range(len(s)):
    expand(i, i)      # Odd: "aba"
    expand(i, i + 1)  # Even: "abba"
```

### 3. Interval DP Fill Order

**âŒ Wrong:**
```python
for i in range(n):
    for j in range(i, n):
        # dp[i+1][j-1] might not be computed!
```

**âœ… Correct:**
```python
for length in range(2, n + 1):  # Increasing length
    for i in range(n - length + 1):
        j = i + length - 1
        # Now dp[i+1][j-1] is ready
```

### 4. Off-by-One in Palindrome Check

```python
# If s[i] == s[j], inner part is s[i+1:j]
dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
# Make sure i+1 <= j-1 or handle base case
```

---

## ðŸ“Š Approach Decision Tree

```
Palindrome Problem?
    â”‚
    â”œâ”€â”€ Substring (contiguous)?
    â”‚   â”œâ”€â”€ Find longest â†’ Center Expansion
    â”‚   â”œâ”€â”€ Count all â†’ Center Expansion
    â”‚   â””â”€â”€ Check if palindrome â†’ Two pointers O(n)
    â”‚
    â”œâ”€â”€ Subsequence (non-contiguous)?
    â”‚   â”œâ”€â”€ Find longest â†’ LCS(s, rev(s)) or Interval DP
    â”‚   â”œâ”€â”€ Min operations â†’ n - LPS
    â”‚   â””â”€â”€ Count distinct â†’ Advanced Interval DP
    â”‚
    â””â”€â”€ Partitioning?
        â”œâ”€â”€ Min cuts â†’ DP + palindrome precompute
        â””â”€â”€ All partitions â†’ Backtracking
```

---

## ðŸ“ Practice Problems (Progressive)

### Easy-Medium
- [ ] [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/) - Two pointers
- [ ] [680. Valid Palindrome II](https://leetcode.com/problems/valid-palindrome-ii/) - One deletion

### Medium
- [ ] [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/) - Center expansion
- [ ] [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/) - Count
- [ ] [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/) - Interval DP

### Hard
- [ ] [132. Palindrome Partitioning II](https://leetcode.com/problems/palindrome-partitioning-ii/) - Min cuts
- [ ] [1312. Min Insertions](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/) - Transformation
- [ ] [730. Count Different Palindromic Subsequences](https://leetcode.com/problems/count-different-palindromic-subsequences/) - Distinct count

<details>
<summary><strong>ðŸ§  Spaced Repetition Schedule</strong></summary>

**Week 1:**
- Day 1: Longest Palindromic Substring (center expansion)
- Day 3: Count Palindromic Substrings
- Day 5: Longest Palindromic Subsequence
- Day 7: Review both approaches

**Week 2:**
- Day 8: Min Insertions for Palindrome
- Day 10: Palindrome Partitioning II
- Day 12: Valid Palindrome II
- Day 14: Full pattern review

</details>

---

## ðŸŽ¤ Interview Context

**Decision process:**
1. Identify: substring vs subsequence?
2. Choose approach: center expansion vs interval DP
3. Implement with clear variable naming
4. Mention time/space trade-offs

**Communication template (substring):**
> "For palindromic substrings, I'll use center expansion. For each character, I treat it as the center of both odd and even length palindromes, expanding outward while characters match. This is O(nÂ²) time and O(1) space."

**Communication template (subsequence):**
> "For palindromic subsequences, I recognize that LPS(s) equals LCS(s, reverse(s)). Alternatively, I can use interval DP where dp[i][j] represents the LPS of s[i:j+1], filling by increasing length."

**Company frequency:**
| Company | Frequency | Focus |
|---------|-----------|-------|
| Amazon | â­â­â­â­â­ | Substring, Subsequence |
| Google | â­â­â­â­ | Variations |
| Meta | â­â­â­â­ | String manipulation |
| Microsoft | â­â­â­ | Basic problems |

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Learn center expansion | 30 min |
| Learn interval DP | 45 min |
| Solve longest substring | 15 min |
| Solve LPS | 20 min |
| Master pattern | 6-8 problems |

---

> **ðŸ’¡ Key Insight:** Palindrome problems split into two worlds: substrings (use center expansion for O(1) space) and subsequences (use interval DP or LCS transformation). The elegant connection LPS(s) = LCS(s, rev(s)) demonstrates that palindromes are fundamentally about matching a string with its reverse.

> **ðŸ”— Related:** [LCS Pattern](../06-LCS-Pattern/) | [Interval DP](../08-Interval-DP/) | [String DP](../09-String-DP/)
