# 2.3 Peek Operation

## Definition

**Peek** returns the root element (minimum or maximum) **without removing it**. This is the simplest heap operation.

```
Peek on Min-Heap:

    1     ‚Üê peek() returns 1
   / \
  3   2
 / \
7   4

heap = [1, 3, 2, 7, 4]
peek = heap[0] = 1

No modification to heap!
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>When Peek Is Used</strong></summary>

**Common scenarios:**
- Check top priority without dequeuing
- Conditional extraction (peek first, then decide)
- Debugging heap state
- Comparing current extreme before decision

**Key insight:**
```
Peek = O(1) array access
No restructuring needed
Non-destructive operation
```

</details>

---

## ‚úÖ When to Use

| Scenario | Why Peek? |
|----------|-----------|
| Check if min/max meets threshold | Avoid removing if not needed |
| Two heaps balance check | Compare roots without extracting |
| Conditional logic | Look before deciding |
| Debugging | Inspect without changing |

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|---------------------|
| Need to remove element | Use extract/pop |
| Need all elements | Iterate or copy |
| Empty heap | Check size first |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Heap](../01-Heap-Fundamentals/1.1-What-Is-Heap.md)
- [Array Representation](../01-Heap-Fundamentals/1.4-Array-Representation.md)

**After mastering this:**
- [Heapify](./2.4-Heapify.md)
- [Replace](./2.5-Replace.md)

**Used in:**
- Two Heaps pattern (compare roots)
- Priority queue peek

</details>

---

## üìê How It Works

### The Simplest Operation

```
Peek is literally just reading the first element:

def peek(heap):
    return heap[0]

Why does this work?
- Heap property guarantees extreme at root
- Min-heap: root is minimum
- Max-heap: root is maximum
- Root is always at index 0
```

### Peek in Two Heaps Pattern

```
Two Heaps for Median:

   small (max-heap)     large (min-heap)
        [5]                  [7]
       /   \                /   \
      3     2              9    10

peek(small) = 5  (max of smaller half)
peek(large) = 7  (min of larger half)

median = (5 + 7) / 2 = 6

Both peeks are O(1), no extraction needed!
```

---

## üíª Code Implementation

**Python:**
```python
import heapq

def peek_min(heap: list) -> any:
    """
    Peek at minimum element (min-heap).
    
    Time: O(1)
    Space: O(1)
    """
    if not heap:
        return None
    return heap[0]


def peek_max_with_negation(heap: list) -> any:
    """
    Peek at maximum when using negation for max-heap.
    
    Time: O(1)
    """
    if not heap:
        return None
    return -heap[0]  # Negate back


# Examples:
min_heap = [1, 3, 2, 7, 4]
print(peek_min(min_heap))  # 1

max_heap = [-10, -7, -8]  # Max-heap with negation
print(peek_max_with_negation(max_heap))  # 10


# Using heapq's nsmallest for peek-like behavior:
def peek_n_smallest(heap: list, n: int) -> list:
    """
    Peek at n smallest elements.
    Note: Creates a copy, not truly O(1) for n > 1.
    
    Time: O(n log n) for n elements
    """
    return heapq.nsmallest(n, heap)
```

**JavaScript:**
```javascript
function peekMin(heap) {
    return heap.length > 0 ? heap[0] : undefined;
}

function peekMax(heap) {
    // Assuming max-heap implementation
    return heap.length > 0 ? heap[0] : undefined;
}

// Example:
const minHeap = [1, 3, 2, 7, 4];
console.log(peekMin(minHeap));  // 1

// For class-based heap:
class MinHeap {
    constructor() { this.heap = []; }
    
    peek() {
        return this.heap[0];
    }
    
    size() {
        return this.heap.length;
    }
    
    isEmpty() {
        return this.heap.length === 0;
    }
    
    // ... other methods
}
```

### Peek with Validation

```python
class SafeHeap:
    """Heap with safe peek that handles edge cases."""
    
    def __init__(self):
        self.heap = []
    
    def peek(self):
        """Safe peek with empty check."""
        if not self.heap:
            raise IndexError("peek from empty heap")
        return self.heap[0]
    
    def peek_or_default(self, default=None):
        """Peek with default value for empty heap."""
        return self.heap[0] if self.heap else default
    
    def try_peek(self):
        """Return (success, value) tuple."""
        if self.heap:
            return (True, self.heap[0])
        return (False, None)


# Usage:
heap = SafeHeap()
print(heap.peek_or_default(-1))  # -1 (empty heap)

heap.heap = [5, 7, 6]
print(heap.peek())  # 5
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space | Notes |
|------|------|-------|-------|
| All |" O(1) "| O(1) | Simple array access |

**Why O(1)?**
```
Heap stored as array
Root always at index 0
heap[0] is direct memory access
No computation, no traversal
```

---

## üîÑ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| **peek()** | Get root | Most common |
| **peek_or_default** | Return default if empty | Avoid exceptions |
| **peek_n** | Get n smallest/largest | Multiple elements |
| **peek_at_index** | Raw array access | Debugging |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Peeking Empty Heap

```python
# ‚ùå Wrong: No empty check
def bad_peek(heap):
    return heap[0]  # IndexError if empty!

# ‚úÖ Correct: Check first
def good_peek(heap):
    if not heap:
        return None
    return heap[0]
```

### 2. Confusing Peek with Pop

```python
# ‚ùå Wrong: Expecting peek to remove
min_val = heap[0]
# Heap still contains min_val!

# ‚úÖ Correct: Use pop to remove
min_val = heapq.heappop(heap)
# Now heap doesn't contain min_val
```

### 3. Modifying After Peek

```python
# ‚ùå Wrong: Modifying returned reference (if heap contains objects)
item = heap[0]
item.priority = 100  # Breaks heap property!

# ‚úÖ Correct: Don't modify; extract, modify, reinsert
item = heapq.heappop(heap)
item.priority = 100
heapq.heappush(heap, item)
```

---

## üìù Practice Problems (Progressive)

### Easy (Understand peek)
- [ ] Implement peek for min-heap class
- [ ] [Last Stone Weight (LC 1046)](https://leetcode.com/problems/last-stone-weight/) - Compare stones

### Medium (Apply peek)
- [ ] [Find Median from Stream (LC 295)](https://leetcode.com/problems/find-median-from-data-stream/) - Peek both heaps
- [ ] [Kth Largest in Stream (LC 703)](https://leetcode.com/problems/kth-largest-element-in-a-stream/) - Return peek

### Hard (Master peek patterns)
- [ ] [Sliding Window Median (LC 480)](https://leetcode.com/problems/sliding-window-median/) - Multiple peeks

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement peek with empty check
- **Day 3:** Use peek in Two Heaps pattern
- **Day 7:** Solve LC 703 (return peek)
- **Day 14:** Compare peek vs pop use cases
- **Day 30:** Review when peek is appropriate

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Explain This in Interviews</strong></summary>

**Describing peek:**
"Peek just returns the root element in O(1) without removing it. Since the heap property guarantees the extreme value is always at the root, and the root is at index 0, it's just an array access."

**When to use:**
"I use peek when I need to check the top element before deciding whether to extract it. For example, in the Two Heaps pattern for median, I peek both heaps to compute the median without removing anything."

**Comparison with pop:**
"Peek is O(1) and doesn't modify the heap. Pop is O(log n) because it needs to restore the heap property after removal."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 2-3 min | Very simple |
| Implement | 2-3 min | One line |
| Handle edge cases | 2-3 min | Empty check |

---

## üí° Key Insight

> **Peek is O(1) because the heap property guarantees the extreme element is always at the root.** Since the root is always at index 0 in the array representation, peek is just `return heap[0]`. This is why heaps are perfect for "get min/max" operations - no search needed.

---

## üîó Related

- **Previous:** [Extract Operation](./2.2-Extract.md)
- **Next:** [Heapify](./2.4-Heapify.md)
- **Used in:** [Two Heaps Pattern](../05-Two-Heaps-Pattern/5.1-Two-Heaps-Overview.md)
