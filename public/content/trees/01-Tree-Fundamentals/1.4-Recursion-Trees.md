# 1.4 - Recursion on Trees

> **Foundation:** Understanding why recursion is the natural fit for trees
>
> **Priority:** Master this before attempting tree problems

---

## Overview

Trees and recursion are a perfect match because trees are **recursive data structures** - each subtree is itself a tree. This makes recursive solutions intuitive and often the cleanest approach.

```
A tree of n nodes = 
    1 root node + 
    left subtree (a tree) + 
    right subtree (a tree)
```

---

## üéØ Why Recursion Works for Trees

### The Recursive Structure

```
        1              The tree rooted at 1 contains:
       / \             - Node 1
      2   3            - Left subtree (tree rooted at 2)
     / \               - Right subtree (tree rooted at 3)
    4   5

The left subtree rooted at 2 contains:
- Node 2
- Left subtree (tree rooted at 4)
- Right subtree (tree rooted at 5)

This pattern continues recursively!
```

### The Base Case Pattern

Every tree recursion needs a base case - usually when the node is `None`:

```python
def some_tree_function(node):
    # Base case: empty tree
    if not node:
        return base_value  # 0, True, [], etc.
    
    # Recursive case: process current + subtrees
    left_result = some_tree_function(node.left)
    right_result = some_tree_function(node.right)
    
    return combine(node.val, left_result, right_result)
```

---

## üìê The Three Recursion Patterns

### Pattern 1: Process Root First (Preorder-like)

```python
def process_preorder(node):
    if not node:
        return
    
    # 1. Process current node FIRST
    do_something(node.val)
    
    # 2. Then recurse on children
    process_preorder(node.left)
    process_preorder(node.right)
```

**Use when:**
- Need to make decisions before seeing children
- Copying/cloning trees
- Path tracking from root

**Example: Find a path to target**
```python
def has_path_to(node, target, path=[]):
    if not node:
        return False
    
    path.append(node.val)  # Add current first
    
    if node.val == target:
        return True
    
    if has_path_to(node.left, target, path) or has_path_to(node.right, target, path):
        return True
    
    path.pop()  # Backtrack
    return False
```

### Pattern 2: Process Children First (Postorder-like)

```python
def process_postorder(node):
    if not node:
        return base_value
    
    # 1. Recurse on children FIRST
    left_result = process_postorder(node.left)
    right_result = process_postorder(node.right)
    
    # 2. Then process current node with children's results
    return combine(node.val, left_result, right_result)
```

**Use when:**
- Need information from children to process parent
- Calculating heights, sizes, sums
- Bottom-up calculations

**Example: Calculate height**
```python
def height(node):
    if not node:
        return 0
    
    left_height = height(node.left)
    right_height = height(node.right)
    
    return 1 + max(left_height, right_height)
```

### Pattern 3: Pass Information Down (Top-Down)

```python
def process_topdown(node, info_from_parent):
    if not node:
        return
    
    # Use info from parent
    new_info = compute(info_from_parent, node.val)
    
    # Pass updated info to children
    process_topdown(node.left, new_info)
    process_topdown(node.right, new_info)
```

**Use when:**
- Computing depth/level
- Path sums
- Passing constraints (like BST validation)

**Example: Check if path sum equals target**
```python
def has_path_sum(node, target):
    if not node:
        return False
    
    # Leaf node: check if remaining equals node value
    if not node.left and not node.right:
        return target == node.val
    
    # Pass reduced target to children
    remaining = target - node.val
    return has_path_sum(node.left, remaining) or has_path_sum(node.right, remaining)
```

---

## üíª Common Recursive Templates

### Template 1: Return a Value

```python
def compute_value(node):
    """Return some computed value from the tree."""
    if not node:
        return identity_value  # 0 for sum, -inf for max, etc.
    
    left = compute_value(node.left)
    right = compute_value(node.right)
    
    return combine(node.val, left, right)

# Examples:
# Sum: return node.val + left + right
# Max: return max(node.val, left, right)
# Count: return 1 + left + right
```

### Template 2: Return Boolean

```python
def check_condition(node, *args):
    """Check if tree satisfies some condition."""
    if not node:
        return True  # or False, depending on problem
    
    # Check current node
    if not current_condition(node):
        return False
    
    # Check children
    return check_condition(node.left, *args) and check_condition(node.right, *args)
```

### Template 3: Collect Results

```python
def collect_values(node, result):
    """Collect values into a list."""
    if not node:
        return
    
    result.append(node.val)  # or conditional append
    collect_values(node.left, result)
    collect_values(node.right, result)
```

### Template 4: Transform Tree

```python
def transform_tree(node):
    """Create a new tree based on original."""
    if not node:
        return None
    
    new_node = TreeNode(transform(node.val))
    new_node.left = transform_tree(node.left)
    new_node.right = transform_tree(node.right)
    
    return new_node
```

---

## üîÑ Recursion vs Iteration

### When to Use Recursion

| Use Recursion When | Example |
|-------------------|---------|
| Natural recursive structure | Tree traversals, divide & conquer |
| Need clean, readable code | Height, same tree check |
| Path/ancestor tracking is easy | Path sum, LCA |
| Tree is not too deep | Most interview problems |

### When to Use Iteration

| Use Iteration When | Example |
|-------------------|---------|
| Risk of stack overflow | Very deep trees |
| Need level-by-level processing | BFS problems |
| Interviewer specifically asks | "Can you do it iteratively?" |
| Performance critical | Production code |

### Converting Recursion to Iteration

**DFS with explicit stack:**
```python
def iterative_preorder(root):
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        # Push right first so left is processed first
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result
```

---

## ‚ö†Ô∏è Common Recursion Mistakes

### 1. Forgetting Base Case

```python
# ‚ùå WRONG: No base case - infinite recursion
def count_nodes(node):
    return 1 + count_nodes(node.left) + count_nodes(node.right)

# ‚úÖ CORRECT: Handle None
def count_nodes(node):
    if not node:
        return 0
    return 1 + count_nodes(node.left) + count_nodes(node.right)
```

### 2. Modifying Mutable Default Arguments

```python
# ‚ùå WRONG: Mutable default argument
def collect(node, result=[]):  # result is shared across calls!
    if node:
        result.append(node.val)
        collect(node.left, result)
        collect(node.right, result)
    return result

# ‚úÖ CORRECT: Use None as default
def collect(node, result=None):
    if result is None:
        result = []
    if node:
        result.append(node.val)
        collect(node.left, result)
        collect(node.right, result)
    return result
```

### 3. Not Using Return Values

```python
# ‚ùå WRONG: Ignoring what recursion returns
def find_node(node, target):
    if not node:
        return None
    if node.val == target:
        return node
    find_node(node.left, target)  # Not returning!
    find_node(node.right, target)

# ‚úÖ CORRECT: Return the result
def find_node(node, target):
    if not node:
        return None
    if node.val == target:
        return node
    left = find_node(node.left, target)
    return left if left else find_node(node.right, target)
```

### 4. Wrong Recursive Logic

```python
# ‚ùå WRONG: AND when should be OR
def has_path_sum(node, target):
    if not node:
        return False
    if not node.left and not node.right:
        return target == node.val
    # Wrong: requires BOTH paths to work
    return has_path_sum(node.left, target - node.val) and \
           has_path_sum(node.right, target - node.val)

# ‚úÖ CORRECT: Either path works
def has_path_sum(node, target):
    if not node:
        return False
    if not node.left and not node.right:
        return target == node.val
    return has_path_sum(node.left, target - node.val) or \
           has_path_sum(node.right, target - node.val)
```

---

## üìê Tracing Through Recursion

### Visualization Technique

```
height(1)
‚îú‚îÄ‚îÄ height(2)
‚îÇ   ‚îú‚îÄ‚îÄ height(4)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ height(None) ‚Üí 0
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ height(None) ‚Üí 0
‚îÇ   ‚îÇ   ‚Üí max(0,0) + 1 = 1
‚îÇ   ‚îî‚îÄ‚îÄ height(5)
‚îÇ       ‚îú‚îÄ‚îÄ height(None) ‚Üí 0
‚îÇ       ‚îî‚îÄ‚îÄ height(None) ‚Üí 0
‚îÇ       ‚Üí max(0,0) + 1 = 1
‚îÇ   ‚Üí max(1,1) + 1 = 2
‚îî‚îÄ‚îÄ height(3)
    ‚îú‚îÄ‚îÄ height(None) ‚Üí 0
    ‚îî‚îÄ‚îÄ height(None) ‚Üí 0
    ‚Üí max(0,0) + 1 = 1
‚Üí max(2,1) + 1 = 3
```

### The Call Stack

```
For tree:
    1
   / \
  2   3
 /
4

Calling height(1):
Stack: [height(1)]
       [height(1), height(2)]
       [height(1), height(2), height(4)]
       [height(1), height(2), height(4), height(None)]  ‚Üê returns 0
       [height(1), height(2), height(4)]                 ‚Üê returns 1
       [height(1), height(2)]                            ‚Üê returns 2
       [height(1), height(3)]
       [height(1)]                                       ‚Üê returns 3
```

---

## üìù Practice Progression

### Phase 1: Basic Recursion
- [ ] [Maximum Depth](https://leetcode.com/problems/maximum-depth-of-binary-tree/) - LC 104
- [ ] [Same Tree](https://leetcode.com/problems/same-tree/) - LC 100
- [ ] [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/) - LC 226

### Phase 2: Path Recursion
- [ ] [Path Sum](https://leetcode.com/problems/path-sum/) - LC 112
- [ ] [Path Sum II](https://leetcode.com/problems/path-sum-ii/) - LC 113
- [ ] [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) - LC 257

### Phase 3: Complex Recursion
- [ ] [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/) - LC 110
- [ ] [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) - LC 543
- [ ] [LCA](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) - LC 236

---

## üé§ Interview Context

<details>
<summary><strong>Communicating Recursive Solutions</strong></summary>

**Explain base case:**
> "First, I handle the base case - if the node is None, I return [0/True/None]."

**Explain recursive step:**
> "For each node, I recursively process the left and right subtrees, then combine the results."

**Trace through example:**
> "Let me trace through this example. For node 1, we first recurse on node 2..."

**Discuss complexity:**
> "Time is O(n) because we visit each node once. Space is O(h) for the call stack, where h is the height."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand recursion patterns | 20-30 min | Foundation |
| Practice basic problems | 30-45 min | 3-5 problems |
| Master tracing | 15-20 min | Visualization |

---

> **üí° Key Insight:** Tree recursion follows a simple pattern: handle the base case (None), process current node, and combine results from subtrees. The key is knowing WHEN to process the current node (before, after, or during recursion) based on what information you need.

---

## üîó Related

- [DFS Traversals](../03-Tree-Traversals/3.1-DFS-Traversals/00-DFS-Concept.md)
- [Recursion Fundamentals](../../02-Recursion-Backtracking/01-Recursion/1.1-Recursion-Basics.md)
- [Tree Properties Problems](../04-Tree-Properties/)
