# Segment Tree Fundamentals

> **Answer range queries and perform point/range updates in O(log n) time.**
>
> Perfect for problems like "find sum/min/max in range [L, R]" with updates.

---

## ðŸŽ¯ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Problem statement signals:**
- "Range sum/min/max query"
- "Update element and query range"
- "Multiple range queries with updates"
- "Point update + range query"
- "Range update + point/range query"

**Key constraints:**
- Need both queries AND updates
- Static array â†’ prefix sum is enough
- With updates â†’ need Segment Tree

</details>

---

## âœ… When to Use

| Scenario | Why Segment Tree |
|----------|------------------|
| Range queries + updates | O(log n) for both |
| Min/Max in range | Can aggregate |
| Sum in range | Can aggregate |
| Count in range | Can aggregate |
| GCD in range | Any associative operation |

---

## âŒ When NOT to Use

| Scenario | Better Alternative |
|----------|-------------------|
| No updates | Prefix Sum (O(1) query) |
| Only prefix queries | Prefix Sum |
| 2D queries | 2D Segment Tree (complex) |
| Simple point queries | Plain array |
| Very sparse data | HashMap-based approach |

---

## ðŸ“ Concept Overview

### What is a Segment Tree?

A **binary tree** where:
- Each **leaf** represents an array element
- Each **internal node** represents a segment (range) of the array
- Each node stores an **aggregate** (sum, min, max, etc.) of its segment

```
Array: [1, 3, 5, 7, 9, 11]

Segment Tree (for sum):
                    [0-5]: 36
                   /        \
           [0-2]: 9          [3-5]: 27
           /     \            /      \
      [0-1]: 4  [2-2]: 5  [3-4]: 16  [5-5]: 11
      /    \              /     \
  [0-0]: 1  [1-1]: 3  [3-3]: 7  [4-4]: 9

Leaf nodes: [1, 3, 5, 7, 9, 11]
Internal nodes: aggregates of children
```

### Array Representation

We can represent the tree as an array (like a heap):

```
Index:     1    2    3    4    5    6    7    8    9   10   11   12   13
Value:   [36,   9,  27,   4,   5,  16,  11,   1,   3,   _,   _,   7,   9, ...]

         root  left right  ...children...           ...leaves (padded)...

For node at index i:
- Left child:  2*i
- Right child: 2*i + 1
- Parent:      i // 2
```

**Array size:** Need 4*n space to be safe (for non-power-of-2 arrays).

---

## ðŸ’» Basic Implementation (Range Sum)

**Python:**
```python
class SegmentTree:
    """
    Segment Tree for range sum queries.
    
    Operations:
    - build: O(n)
    - update: O(log n)
    - query: O(log n)
    
    Space: O(4n)
    """
    
    def __init__(self, arr: list):
        self.n = len(arr)
        self.tree = [0] * (4 * self.n)  # Safe size
        if self.n > 0:
            self._build(arr, 1, 0, self.n - 1)
    
    def _build(self, arr: list, node: int, start: int, end: int) -> None:
        """Build the segment tree recursively."""
        if start == end:
            # Leaf node
            self.tree[node] = arr[start]
        else:
            mid = (start + end) // 2
            left_child = 2 * node
            right_child = 2 * node + 1
            
            # Build left and right subtrees
            self._build(arr, left_child, start, mid)
            self._build(arr, right_child, mid + 1, end)
            
            # Internal node = sum of children
            self.tree[node] = self.tree[left_child] + self.tree[right_child]
    
    def update(self, idx: int, val: int) -> None:
        """Update array[idx] to val."""
        self._update(1, 0, self.n - 1, idx, val)
    
    def _update(self, node: int, start: int, end: int, idx: int, val: int) -> None:
        """Update helper - traverse to leaf, update ancestors on return."""
        if start == end:
            # Leaf node
            self.tree[node] = val
        else:
            mid = (start + end) // 2
            left_child = 2 * node
            right_child = 2 * node + 1
            
            if idx <= mid:
                self._update(left_child, start, mid, idx, val)
            else:
                self._update(right_child, mid + 1, end, idx, val)
            
            # Recalculate after update
            self.tree[node] = self.tree[left_child] + self.tree[right_child]
    
    def query(self, left: int, right: int) -> int:
        """Return sum of arr[left:right+1]."""
        return self._query(1, 0, self.n - 1, left, right)
    
    def _query(self, node: int, start: int, end: int, left: int, right: int) -> int:
        """Query helper - find overlapping segments."""
        # No overlap
        if right < start or end < left:
            return 0  # Identity for sum
        
        # Complete overlap
        if left <= start and end <= right:
            return self.tree[node]
        
        # Partial overlap - query both children
        mid = (start + end) // 2
        left_sum = self._query(2 * node, start, mid, left, right)
        right_sum = self._query(2 * node + 1, mid + 1, end, left, right)
        
        return left_sum + right_sum


# Example
arr = [1, 3, 5, 7, 9, 11]
st = SegmentTree(arr)

print(st.query(1, 3))  # 3 + 5 + 7 = 15
print(st.query(0, 5))  # Sum of all = 36

st.update(2, 10)       # Change arr[2] from 5 to 10
print(st.query(1, 3))  # 3 + 10 + 7 = 20
```

**JavaScript:**
```javascript
class SegmentTree {
    constructor(arr) {
        this.n = arr.length;
        this.tree = new Array(4 * this.n).fill(0);
        if (this.n > 0) {
            this._build(arr, 1, 0, this.n - 1);
        }
    }
    
    _build(arr, node, start, end) {
        if (start === end) {
            this.tree[node] = arr[start];
        } else {
            const mid = Math.floor((start + end) / 2);
            this._build(arr, 2 * node, start, mid);
            this._build(arr, 2 * node + 1, mid + 1, end);
            this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1];
        }
    }
    
    update(idx, val) {
        this._update(1, 0, this.n - 1, idx, val);
    }
    
    _update(node, start, end, idx, val) {
        if (start === end) {
            this.tree[node] = val;
        } else {
            const mid = Math.floor((start + end) / 2);
            if (idx <= mid) {
                this._update(2 * node, start, mid, idx, val);
            } else {
                this._update(2 * node + 1, mid + 1, end, idx, val);
            }
            this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1];
        }
    }
    
    query(left, right) {
        return this._query(1, 0, this.n - 1, left, right);
    }
    
    _query(node, start, end, left, right) {
        if (right < start || end < left) return 0;
        if (left <= start && end <= right) return this.tree[node];
        
        const mid = Math.floor((start + end) / 2);
        return this._query(2 * node, start, mid, left, right) +
               this._query(2 * node + 1, mid + 1, end, left, right);
    }
}

// Example
const arr = [1, 3, 5, 7, 9, 11];
const st = new SegmentTree(arr);
console.log(st.query(1, 3));  // 15
st.update(2, 10);
console.log(st.query(1, 3));  // 20
```

---

## ðŸ” Query Visualization

```
Array: [1, 3, 5, 7, 9, 11]
Query: sum(1, 4) = 3 + 5 + 7 + 9 = 24

                    [0-5]: 36
                   /        \
           [0-2]: 9          [3-5]: 27
           /     \            /      \
      [0-1]: 4  [2-2]: 5  [3-4]: 16  [5-5]: 11

Query process:
1. At root [0-5]: partial overlap â†’ go to both children
2. At [0-2]: partial overlap â†’ go to both children
   - At [0-1]: no overlap with [1,4] â†’ return 0
     Wait, [0-1] does overlap with [1,4]! Partial â†’ go deeper
     - At [0-0]: no overlap â†’ return 0
     - At [1-1]: complete overlap â†’ return 3
   - At [2-2]: complete overlap â†’ return 5
3. At [3-5]: partial overlap â†’ go to both children
   - At [3-4]: complete overlap â†’ return 16
   - At [5-5]: no overlap â†’ return 0

Total: 0 + 3 + 5 + 16 + 0 = 24 âœ“
```

---

## âš¡ Complexity Analysis

| Operation | Time | Space |
|-----------|------|-------|
| Build | O(n) | O(n) |
| Point Update | O(log n) | O(log n) stack |
| Range Query | O(log n) | O(log n) stack |

**Why O(log n) for query/update?**
- Tree height is O(log n)
- Each operation visits at most O(log n) nodes
- At each level, we visit at most 2 nodes that partially overlap

---

## ðŸ“Š Comparison with Other Approaches

| Operation | Array | Prefix Sum | Segment Tree | Fenwick Tree |
|-----------|-------|------------|--------------|--------------|
| Build | O(n) | O(n) | O(n) | O(n) |
| Point Query | O(1) | O(1) | O(log n) | O(log n) |
| Range Sum | O(n) | O(1) | O(log n) | O(log n) |
| Point Update | O(1) | O(n) | O(log n) | O(log n) |
| Range Update | O(n) | O(n) | O(log n)* | O(log n)* |

*With lazy propagation

---

## âš ï¸ Common Mistakes

### 1. Wrong Array Size

```python
# âŒ Wrong: Not enough space
self.tree = [0] * (2 * n)  # May overflow!

# âœ… Correct: Use 4n for safety
self.tree = [0] * (4 * n)  # Always enough for any n
```

### 2. Wrong Base Case Identity

```python
# âŒ Wrong: Using 0 for min query
if right < start or end < left:
    return 0  # Wrong for min!

# âœ… Correct: Use identity element
# For sum: return 0
# For min: return float('inf')
# For max: return float('-inf')
# For product: return 1
```

### 3. Off-by-One in Overlap Check

```python
# âŒ Wrong: Strict inequality
if right <= start or end <= left:  # Misses boundary cases!

# âœ… Correct: Non-strict
if right < start or end < left:  # Correct boundary handling
```

---

## ðŸ”„ Variations

| Query Type | Merge Operation | Identity |
|------------|-----------------|----------|
| Sum | a + b | 0 |
| Min | min(a, b) | âˆž |
| Max | max(a, b) | -âˆž |
| GCD | gcd(a, b) | 0 |
| Product | a * b | 1 |
| XOR | a ^ b | 0 |

**Key requirement:** Operation must be **associative**: (a âŠ• b) âŠ• c = a âŠ• (b âŠ• c)

---

## ðŸ“ Practice Problems

| Problem | Difficulty | Key Concept |
|---------|------------|-------------|
| [Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/) | Medium | Basic segment tree |
| [Range Minimum Query](https://www.spoj.com/problems/RMQSQ/) | Easy | Min variant |
| [Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/) | Hard | Creative use |

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 30 min | Tree structure, operations |
| Implement basic | 30 min | Build, query, update |
| Debug issues | 15 min | Off-by-one, size |
| Lazy propagation | 45 min | Advanced topic |

---

> **ðŸ’¡ Key Insight:** Segment Tree divides the array into O(n) segments of varying sizes. Any range [L, R] can be covered by at most O(log n) of these segments, which is why queries are O(log n).

> **ðŸ”— Related:** [Build, Query, Update â†’](./3.2-Build-Query-Update.md) | [Lazy Propagation](./3.3-Lazy-Propagation.md)

---

**Next:** [Build, Query, Update â†’](./3.2-Build-Query-Update.md)
