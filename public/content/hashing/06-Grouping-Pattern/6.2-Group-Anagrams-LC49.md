# Group Anagrams (LeetCode 49)

> **Medium** | Given an array of strings, group anagrams together. Return the answer in any order.

This is the classic grouping pattern problem - one of the most frequently asked hash map questions in interviews.

---

## üéØ Pattern Recognition

<details>
<summary><strong>Problem Signals</strong></summary>

**Keywords indicating this pattern:**
- "Group" + similarity criterion
- "Anagrams" (rearrangement of characters)
- "Same characters" / "permutations"

**Problem classification:**
```
Category: Grouping Pattern
Subcategory: String grouping by character set
Key type: Sorted string OR character count
```

</details>

---

## üìã Problem Statement

**LeetCode 49:** [Group Anagrams](https://leetcode.com/problems/group-anagrams/)

```
Given an array of strings strs, group the anagrams together.
An Anagram is a word formed by rearranging the letters of another word.

Example 1:
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]

Example 2:
Input: strs = [""]
Output: [[""]]

Example 3:
Input: strs = ["a"]
Output: [["a"]]

Constraints:
- 1 <= strs.length <= 10^4
- 0 <= strs[i].length <= 100
- strs[i] consists of lowercase English letters
```

---

## ‚úÖ When to Use This Approach

- Grouping strings by shared characters
- Finding all anagrams in a list
- Categorizing by equivalence relation

## ‚ùå When NOT to Use

| Scenario | Why Not | Use Instead |
|----------|---------|-------------|
| Find if TWO strings are anagrams | Overkill | Simple comparison |
| Ordered output needed | Hash is unordered | Sort after grouping |
| Memory very limited | Stores all groups | Stream processing |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Related</strong></summary>

**Before this:**
- [Hash Map Operations](../02-Hash-Map-Set/2.1-Hash-Map-Operations.md)
- [Frequency Pattern](../03-Frequency-Pattern/3.1-Frequency-Overview.md)

**Related problems:**
- [Valid Anagram (LC 242)](../03-Frequency-Pattern/3.2-Valid-Anagram-LC242.md)
- [Isomorphic Strings (LC 205)](./6.3-Isomorphic-Strings-LC205.md)
- [Find All Anagrams (LC 438)](../07-Sliding-Window-Hash/7.3-Find-Anagrams-LC438.md)

</details>

---

## üìê Solution Approaches

### Approach 1: Sorted String as Key

**Key Insight:** Two strings are anagrams if and only if their sorted forms are identical.

```
"eat" ‚Üí sorted ‚Üí "aet"
"tea" ‚Üí sorted ‚Üí "aet"  ‚Üê Same!
"ate" ‚Üí sorted ‚Üí "aet"  ‚Üê Same!
"tan" ‚Üí sorted ‚Üí "ant"  ‚Üê Different
```

**Visualization:**
```
Input: ["eat", "tea", "tan", "ate", "nat", "bat"]

Step 1: Create (sorted_key, original) pairs
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Word   ‚îÇ Sorted Key ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ "eat"  ‚îÇ "aet"      ‚îÇ
‚îÇ "tea"  ‚îÇ "aet"      ‚îÇ
‚îÇ "tan"  ‚îÇ "ant"      ‚îÇ
‚îÇ "ate"  ‚îÇ "aet"      ‚îÇ
‚îÇ "nat"  ‚îÇ "ant"      ‚îÇ
‚îÇ "bat"  ‚îÇ "abt"      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Step 2: Group by sorted key
groups = {
    "aet": ["eat", "tea", "ate"],
    "ant": ["tan", "nat"],
    "abt": ["bat"]
}

Step 3: Return values
Output: [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]
```

### Approach 2: Character Count as Key

**Key Insight:** Two anagrams have the same character frequency.

```
"eat" ‚Üí count ‚Üí [1,0,0,0,1,0,...,1,...,0]  (a=1, e=1, t=1)
"tea" ‚Üí count ‚Üí [1,0,0,0,1,0,...,1,...,0]  (a=1, e=1, t=1)
```

This is O(k) per string instead of O(k log k), better for long strings.

---

## üíª Code Implementation

### Python - Approach 1: Sorted Key

```python
from collections import defaultdict
from typing import List

def groupAnagrams(strs: List[str]) -> List[List[str]]:
    """
    Group anagrams using sorted string as key.
    
    Algorithm:
    1. For each string, compute sorted version as key
    2. Add original string to group with that key
    3. Return all groups
    
    Time: O(n * k log k) where n = len(strs), k = max string length
    Space: O(n * k) for storing all strings in groups
    """
    groups = defaultdict(list)
    
    for s in strs:
        # Convert to sorted tuple (hashable)
        key = tuple(sorted(s))
        groups[key].append(s)
    
    return list(groups.values())


# Example trace:
# strs = ["eat", "tea", "ate"]
# 
# s = "eat" ‚Üí key = ('a','e','t') ‚Üí groups[('a','e','t')] = ["eat"]
# s = "tea" ‚Üí key = ('a','e','t') ‚Üí groups[('a','e','t')] = ["eat", "tea"]
# s = "ate" ‚Üí key = ('a','e','t') ‚Üí groups[('a','e','t')] = ["eat", "tea", "ate"]
# 
# Return: [["eat", "tea", "ate"]]
```

### Python - Approach 2: Character Count Key

```python
from collections import defaultdict
from typing import List

def groupAnagrams(strs: List[str]) -> List[List[str]]:
    """
    Group anagrams using character count as key.
    
    More efficient for long strings (O(k) vs O(k log k) per string).
    
    Time: O(n * k) where n = len(strs), k = max string length
    Space: O(n * k) for storing all strings
    """
    groups = defaultdict(list)
    
    for s in strs:
        # Count frequency of each character
        count = [0] * 26
        for c in s:
            count[ord(c) - ord('a')] += 1
        
        # Convert to tuple for use as dictionary key
        key = tuple(count)
        groups[key].append(s)
    
    return list(groups.values())


# Why tuple?
# - Lists are mutable ‚Üí not hashable ‚Üí can't be dict keys
# - Tuples are immutable ‚Üí hashable ‚Üí valid dict keys
#
# count = [1, 0, 0, 0, 1, 0, ..., 1, 0, ...]  ‚Üê list
# key = (1, 0, 0, 0, 1, 0, ..., 1, 0, ...)    ‚Üê tuple (hashable)
```

### Python - Approach 3: Using Counter and frozenset

```python
from collections import Counter, defaultdict
from typing import List

def groupAnagrams(strs: List[str]) -> List[List[str]]:
    """
    Alternative using Counter and frozenset.
    
    Note: frozenset loses character multiplicity, so we use items()
    """
    groups = defaultdict(list)
    
    for s in strs:
        # Counter gives character counts
        # frozenset of items makes it hashable
        key = frozenset(Counter(s).items())
        groups[key].append(s)
    
    return list(groups.values())


# Counter("aab") = {'a': 2, 'b': 1}
# items() = [('a', 2), ('b', 1)]
# frozenset = frozenset({('a', 2), ('b', 1)}) ‚Üê hashable
```

### JavaScript - Approach 1: Sorted Key

```javascript
/**
 * Group anagrams using sorted string as key.
 * 
 * @param {string[]} strs - Array of strings
 * @return {string[][]} - Grouped anagrams
 * 
 * Time: O(n * k log k)
 * Space: O(n * k)
 */
function groupAnagrams(strs) {
    const groups = new Map();
    
    for (const s of strs) {
        // Sort characters and join back to string
        const key = s.split('').sort().join('');
        
        if (!groups.has(key)) {
            groups.set(key, []);
        }
        groups.get(key).push(s);
    }
    
    return [...groups.values()];
}

// Example:
// groupAnagrams(["eat", "tea", "ate"])
// ‚Üí [["eat", "tea", "ate"]]
```

### JavaScript - Approach 2: Character Count Key

```javascript
/**
 * Group anagrams using character count as key.
 * 
 * @param {string[]} strs
 * @return {string[][]}
 * 
 * Time: O(n * k) - faster for long strings
 * Space: O(n * k)
 */
function groupAnagrams(strs) {
    const groups = new Map();
    
    for (const s of strs) {
        // Count each character
        const count = new Array(26).fill(0);
        for (const c of s) {
            count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;
        }
        
        // Convert to string for Map key
        // (JavaScript Maps can use strings as keys efficiently)
        const key = count.join(',');
        
        if (!groups.has(key)) {
            groups.set(key, []);
        }
        groups.get(key).push(s);
    }
    
    return [...groups.values()];
}

// Why join(',')?
// JavaScript Maps can use objects/arrays as keys, BUT
// they compare by reference, not value!
// 
// const map = new Map();
// map.set([1,2], 'a');
// map.get([1,2]); // undefined! Different array object
// 
// String comparison works by value:
// "1,2" === "1,2" // true
```

### JavaScript - ES6 One-Liner (Sorted)

```javascript
const groupAnagrams = (strs) => 
    [...strs.reduce((m, s) => {
        const k = [...s].sort().join('');
        return m.set(k, [...(m.get(k) || []), s]);
    }, new Map()).values()];
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Best For |
|----------|------|-------|----------|
| Sorted key | O(n * k log k) | O(n * k) | Short strings |
| Count key | O(n * k) | O(n * k) | Long strings |
| Counter + frozenset | O(n * k) | O(n * k) | Pythonic code |

**Where:**
- n = number of strings
- k = maximum string length

**Analysis - Sorted Key:**
```
Time: 
  - Iterate n strings: O(n)
  - Sort each string: O(k log k)
  - Total: O(n * k log k)

Space:
  - Store all strings in groups: O(n * k)
  - Keys (sorted strings): O(n * k)
  - Total: O(n * k)
```

**Analysis - Count Key:**
```
Time:
  - Iterate n strings: O(n)
  - Count each string: O(k)
  - Total: O(n * k)

Space:
  - Store all strings: O(n * k)
  - Keys (26-length tuples): O(n * 26) = O(n)
  - Total: O(n * k)
```

---

## üîÑ Variations

| Variation | Difference | Problem |
|-----------|------------|---------|
| Return indices | Track indices instead of strings | Custom |
| Case insensitive | Lowercase before key | Custom |
| Unicode strings | Larger count array | Custom |
| Single anagram check | Compare two strings | LC 242 |
| Find anagrams in string | Sliding window | LC 438 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using List as Dictionary Key

```python
# ‚ùå WRONG: Lists are not hashable
groups = {}
for s in strs:
    key = sorted(s)  # Returns a list!
    groups[key] = groups.get(key, []) + [s]  # TypeError!

# ‚úÖ CORRECT: Use tuple
groups = {}
for s in strs:
    key = tuple(sorted(s))  # Tuple is hashable
    if key not in groups:
        groups[key] = []
    groups[key].append(s)
```

### 2. Not Handling Empty Strings

```python
# ‚ùå WRONG: Skipping empty strings
def groupAnagrams(strs):
    groups = defaultdict(list)
    for s in strs:
        if s:  # Empty string skipped!
            key = tuple(sorted(s))
            groups[key].append(s)
    return list(groups.values())

# Input: ["", ""]
# Wrong output: []
# Correct output: [["", ""]]

# ‚úÖ CORRECT: Handle empty strings
def groupAnagrams(strs):
    groups = defaultdict(list)
    for s in strs:
        key = tuple(sorted(s))  # "" ‚Üí ()
        groups[key].append(s)
    return list(groups.values())
```

### 3. Wrong Key Construction in JavaScript

```javascript
// ‚ùå WRONG: Array reference as key
const groups = new Map();
for (const s of strs) {
    const count = new Array(26).fill(0);
    for (const c of s) count[c.charCodeAt(0) - 97]++;
    groups.set(count, [...(groups.get(count) || []), s]);
}
// Each count array is a NEW object, so keys never match!

// ‚úÖ CORRECT: Convert to string
const groups = new Map();
for (const s of strs) {
    const count = new Array(26).fill(0);
    for (const c of s) count[c.charCodeAt(0) - 97]++;
    const key = count.join(',');  // String comparison works!
    if (!groups.has(key)) groups.set(key, []);
    groups.get(key).push(s);
}
```

### 4. Modifying Returned List

```python
# ‚ùå RISKY: Returning direct reference
def groupAnagrams(strs):
    groups = defaultdict(list)
    for s in strs:
        groups[tuple(sorted(s))].append(s)
    return groups.values()  # Returns view, not copy

# ‚úÖ SAFER: Return list copy
def groupAnagrams(strs):
    groups = defaultdict(list)
    for s in strs:
        groups[tuple(sorted(s))].append(s)
    return list(groups.values())  # Creates new list
```

---

## üìù Practice Problems (Progressive)

| Problem | Difficulty | Key Insight |
|---------|------------|-------------|
| Valid Anagram | üü¢ Easy | Compare two strings |
| Group Anagrams | üü° Medium | This problem |
| Find All Anagrams in String | üü° Medium | Sliding window variant |
| Group Shifted Strings | üü° Medium | Different key (differences) |

**Related LeetCode:**
- [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)
- [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)
- [249. Group Shifted Strings](https://leetcode.com/problems/group-shifted-strings/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement sorted key approach
- **Day 3:** Implement count key approach without looking
- **Day 7:** Solve LC 438 (sliding window variant)
- **Day 14:** Explain trade-offs between approaches
- **Day 30:** < 10 min implementation

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Communication Template</strong></summary>

**1. Clarify (30 sec):**
> "So I need to group strings that are anagrams - same characters, different order. Return groups in any order?"

**2. Approach (1 min):**
> "I'll use a hash map where the key represents the character content. Two approaches: sorted string or character count. I'll use sorted for simplicity - O(n * k log k)."

**3. Walk through example:**
> "For 'eat', sorted is 'aet'. For 'tea', also 'aet'. So they go in the same group."

**4. Code and explain edge cases:**
> "Empty strings will have empty key and group together. Single characters are fine."

**5. Complexity:**
> "Time O(n * k log k), Space O(n * k) where n is number of strings, k is max length."

**Follow-up questions:**
- "Can you do better than O(k log k)?" ‚Üí Character count approach
- "What if strings are very long?" ‚Üí Count is O(k)
- "What about Unicode?" ‚Üí Larger count array or Counter

</details>

**Company Frequency:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Asked frequently |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard question |
| Bloomberg | ‚≠ê‚≠ê‚≠ê‚≠ê | String focus |
| Google | ‚≠ê‚≠ê‚≠ê | May ask variations |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Understand problem | 2 min |
| Plan approach | 2 min |
| Implement (sorted) | 5-8 min |
| Test edge cases | 2 min |
| Complexity analysis | 1 min |
| **Total** | **12-15 min** |

---

> **üí° Key Insight:** Two strings are anagrams if and only if they have the same character counts. We can represent this as a tuple (hashable) and use it as a dictionary key to group all anagrams together in O(n * k) time.

> **üîó Related:** [Grouping Pattern](./6.1-Grouping-Overview.md) | [Valid Anagram](../03-Frequency-Pattern/3.2-Valid-Anagram-LC242.md) | [Find All Anagrams](../07-Sliding-Window-Hash/7.3-Find-Anagrams-LC438.md)
