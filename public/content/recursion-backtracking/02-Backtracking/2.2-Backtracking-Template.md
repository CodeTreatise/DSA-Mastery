# 2.2 The Backtracking Template

> **The Universal Framework for Exploring All Possibilities**  
> **Interview Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - Foundation for ~15% of all coding problems  
> **Grokking Pattern:** #27 Backtracking

---

## Overview

**Backtracking** is a systematic way to explore all possible solutions by building candidates incrementally and abandoning ("backtracking") a candidate as soon as it's determined it cannot lead to a valid solution.

> üí° *Think of backtracking as "trying every path in a maze, but turning back immediately when you hit a dead end."*

The power of backtracking is the **template** - once you understand it, you can solve dozens of problems by recognizing which variation to apply.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Backtracking Problems</strong></summary>

**Look for these signals:**
- "Find **all** possible..." (all solutions, not just one)
- "Generate all..." (permutations, combinations, subsets)
- "Return all valid..." (configurations that satisfy constraints)
- Constraint satisfaction (N-Queens, Sudoku)
- Decision tree exploration

**Keywords in problem statement:**
- "all permutations", "all combinations", "all subsets"
- "generate", "enumerate", "list all"
- "find all paths", "all ways to..."
- "partition into", "split into"

**Problem characteristics:**
- Multiple choices at each step
- Need to explore/generate all possibilities
- Can "undo" choices (no permanent state change)
- Exponential solution space (2^n or n!)

</details>

---

## ‚úÖ When to Use Backtracking

- **Generate all combinations/permutations/subsets**
- **Constraint satisfaction** (Sudoku, N-Queens, graph coloring)
- **Path finding** where you need ALL paths (not just shortest)
- **Partitioning problems** (palindrome partitioning, word break)
- **Decision problems** with multiple valid choices per step
- Problems asking for **"all possible"** solutions

---

## ‚ùå When NOT to Use Backtracking

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Finding ONE optimal solution | Dynamic Programming | DP is more efficient for optimization |
| Shortest path in unweighted graph | BFS | BFS guarantees shortest path |
| Finding ANY valid solution | DFS/Greedy | Don't need to explore all |
| Counting solutions (not listing) | DP or Math | Backtracking is overkill |
| Input size > 20 | Consider pruning or DP | Exponential blowup |
| No "undo" possible | Iterative approach | Can't backtrack without undo |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Recursion Basics](../01-Recursion/1.1-Recursion-Basics.md) - Base case, recursive case
- [Recursion Thinking](../01-Recursion/1.3-Thinking-Process.md) - Trust the recursion

**After mastering this:**
- [Subsets Pattern](./2.3-Core-Patterns/01-Subsets-Pattern.md) - Include/exclude template
- [Permutations Pattern](./2.3-Core-Patterns/02-Permutations-Pattern.md) - Arrangement template
- [Combinations Pattern](./2.3-Core-Patterns/03-Combinations-Pattern.md) - Selection template
- [Grid Backtracking](./2.4-Grid-Backtracking.md) - 2D exploration

**Combines with:**
- **Pruning** - Skip invalid branches early (essential for efficiency)
- **Memoization** - Cache repeated subproblems (becomes DP)
- **Trie** - For word search problems

</details>

---

## üìê How It Works

### The Core Insight

Backtracking builds a **decision tree** where:
- Each **node** represents a partial solution (current state)
- Each **edge** represents a choice (adding an element)
- **Leaves** are complete solutions (or dead ends)

We traverse this tree using DFS, and **prune** branches that can't lead to valid solutions.

### The Universal Template

```
backtrack(current_state):
    if is_complete(current_state):
        record_solution(current_state)
        return
    
    for each choice in available_choices(current_state):
        if is_valid(choice):
            make_choice(choice)           # CHOOSE
            backtrack(updated_state)      # EXPLORE
            undo_choice(choice)           # UNCHOOSE (backtrack!)
```

### Visualization: Subsets of [1, 2, 3]

```
                    []
                   /  \
                [1]    []
               /  \    /  \
           [1,2] [1] [2]  []
           / \   / \  / \  / \
      [1,2,3][1,2][1,3][1][2,3][2][3][]

Decision at each level: Include current element or not?
Leaves = All subsets: [], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]
```

### Visualization: Permutations of [1, 2, 3]

```
                      []
                  /   |   \
               [1]   [2]   [3]
              / \    / \    / \
          [1,2][1,3][2,1][2,3][3,1][3,2]
           |    |    |    |    |    |
        [1,2,3][1,3,2][2,1,3][2,3,1][3,1,2][3,2,1]

Decision at each level: Which unused element to pick?
Leaves = All permutations (6 total = 3!)
```

---

## üíª Code Implementation

### Python - Generic Template

```python
def backtrack(result: list, current: list, choices: list, start: int = 0):
    """
    Generic backtracking template.
    
    Args:
        result: Accumulator for all valid solutions
        current: Current partial solution being built
        choices: Available options to choose from
        start: Starting index (for combinations, to avoid duplicates)
    """
    # Base case: Is current state a complete solution?
    if is_complete(current, choices):
        result.append(current[:])  # Add COPY of current solution
        return  # or don't return if you want to continue exploring
    
    # Explore all valid choices
    for i in range(start, len(choices)):
        # Pruning: Skip invalid choices early
        if not is_valid(choices[i], current):
            continue
        
        # CHOOSE: Add to current solution
        current.append(choices[i])
        
        # EXPLORE: Recurse with updated state
        backtrack(result, current, choices, i + 1)  # i+1 for combinations
        # backtrack(result, current, choices, i)    # i for unlimited reuse
        # backtrack(result, current, choices, 0)    # 0 for permutations
        
        # UNCHOOSE: Remove from current (backtrack!)
        current.pop()
```

### Python - Subsets (Concrete Example)

```python
def subsets(nums: list[int]) -> list[list[int]]:
    """
    Generate all subsets of nums.
    
    Pattern: Include/Exclude at each position
    Time: O(n * 2^n), Space: O(n) for recursion
    """
    result = []
    
    def backtrack(start: int, current: list):
        # Every state is a valid subset - add it!
        result.append(current[:])
        
        # Try including each remaining element
        for i in range(start, len(nums)):
            current.append(nums[i])      # Choose
            backtrack(i + 1, current)    # Explore (i+1 to avoid reuse)
            current.pop()                 # Unchoose
    
    backtrack(0, [])
    return result

# Example
print(subsets([1, 2, 3]))
# Output: [[], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]]
```

### Python - Permutations (Concrete Example)

```python
def permutations(nums: list[int]) -> list[list[int]]:
    """
    Generate all permutations of nums.
    
    Pattern: Use each element exactly once (track with set)
    Time: O(n * n!), Space: O(n)
    """
    result = []
    used = [False] * len(nums)
    
    def backtrack(current: list):
        # Base case: permutation complete
        if len(current) == len(nums):
            result.append(current[:])
            return
        
        # Try each unused element
        for i in range(len(nums)):
            if used[i]:
                continue
            
            used[i] = True               # Choose
            current.append(nums[i])
            backtrack(current)           # Explore
            current.pop()                # Unchoose
            used[i] = False
    
    backtrack([])
    return result

# Example
print(permutations([1, 2, 3]))
# Output: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]
```

### JavaScript - Generic Template

```javascript
function backtrack(result, current, choices, start = 0) {
    // Base case: Is current state complete?
    if (isComplete(current, choices)) {
        result.push([...current]); // Add COPY
        return;
    }
    
    for (let i = start; i < choices.length; i++) {
        // Pruning
        if (!isValid(choices[i], current)) continue;
        
        current.push(choices[i]);        // Choose
        backtrack(result, current, choices, i + 1); // Explore
        current.pop();                    // Unchoose
    }
}
```

### JavaScript - Subsets

```javascript
function subsets(nums) {
    const result = [];
    
    function backtrack(start, current) {
        result.push([...current]); // Every state is valid
        
        for (let i = start; i < nums.length; i++) {
            current.push(nums[i]);
            backtrack(i + 1, current);
            current.pop();
        }
    }
    
    backtrack(0, []);
    return result;
}

// Example
console.log(subsets([1, 2, 3]));
// [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
```

### JavaScript - Permutations

```javascript
function permutations(nums) {
    const result = [];
    const used = new Array(nums.length).fill(false);
    
    function backtrack(current) {
        if (current.length === nums.length) {
            result.push([...current]);
            return;
        }
        
        for (let i = 0; i < nums.length; i++) {
            if (used[i]) continue;
            
            used[i] = true;
            current.push(nums[i]);
            backtrack(current);
            current.pop();
            used[i] = false;
        }
    }
    
    backtrack([]);
    return result;
}
```

---

## ‚ö° Complexity Analysis

| Problem Type | Time | Space | Notes |
|--------------|------|-------|-------|
| Subsets |" O(n * 2‚Åø) "| O(n) |" 2‚Åø subsets, O(n) to copy each "|
| Permutations |" O(n * n!) "| O(n) |" n! permutations, O(n) to copy each "|
| Combinations(n,k) |" O(k * C(n,k)) "| O(k) | C(n,k) combinations |
| With pruning | Varies |" O(n) "| Can be much better in practice |

**Why Exponential?**
- At each step, we make a choice
- Choices multiply: 2 choices * n elements = 2‚Åø
- For permutations: n * (n-1) * (n-2) * ... * 1 = n!

**Space Complexity:**
- O(n) for recursion stack depth
- O(n) for `current` array
- O(2‚Åø * n) or O(n! * n) for storing all results

---

## üîÑ Variations

| Variation | Key Difference | Template Change |
|-----------|----------------|-----------------|
| **Subsets** | Include/exclude each element | `start = i + 1`, add at every node |
| **Permutations** | Use each element once | `used[]` array, no `start` |
| **Combinations** | Select k elements | `start = i + 1`, add only when `len == k` |
| **With duplicates** | Skip consecutive duplicates | Sort first + `if i > start && nums[i] == nums[i-1]: continue` |
| **Unlimited reuse** | Can pick same element multiple times | `start = i` (not `i + 1`) |
| **Grid backtracking** | Move in 4 directions | Mark visited, explore 4 neighbors |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Copy Current Solution

‚ùå **Wrong:**
```python
result.append(current)  # Appends reference, will be modified!
```

‚úÖ **Correct:**
```python
result.append(current[:])  # Python: slice copy
result.append(list(current))  # Python: explicit copy
result.push([...current]);  // JavaScript: spread operator
```

### 2. Forgetting to Backtrack (Undo Choice)

‚ùå **Wrong:**
```python
current.append(nums[i])
backtrack(i + 1, current)
# Missing: current.pop()  ‚Üê Solution keeps growing!
```

‚úÖ **Correct:**
```python
current.append(nums[i])
backtrack(i + 1, current)
current.pop()  # ALWAYS undo the choice!
```

### 3. Wrong Start Index

‚ùå **Wrong (for combinations):**
```python
for i in range(len(nums)):  # Starts from 0 each time ‚Üí duplicates!
```

‚úÖ **Correct:**
```python
for i in range(start, len(nums)):  # Start from current position
```

### 4. Not Handling Duplicates

‚ùå **Wrong (with duplicate elements):**
```python
def subsetsWithDup(nums):
    # [1, 2, 2] gives [[2], [2]] twice!
```

‚úÖ **Correct:**
```python
def subsetsWithDup(nums):
    nums.sort()  # Sort first!
    # ...
    for i in range(start, len(nums)):
        # Skip duplicates at same level
        if i > start and nums[i] == nums[i - 1]:
            continue
```

### 5. Modifying Input Without Restoring

‚ùå **Wrong (grid backtracking):**
```python
grid[r][c] = '#'  # Mark visited
dfs(r + 1, c)
# Forgot to restore!
```

‚úÖ **Correct:**
```python
original = grid[r][c]
grid[r][c] = '#'  # Mark visited
dfs(r + 1, c)
grid[r][c] = original  # Restore!
```

---

## üìù Practice Problems

### Easy (Learn the template)

| Problem | Pattern | LeetCode |
|---------|---------|----------|
| Subsets | Basic backtracking | [LC 78](https://leetcode.com/problems/subsets/) |
| Letter Case Permutation | Include/exclude variant | [LC 784](https://leetcode.com/problems/letter-case-permutation/) |

### Medium (Apply variations)

| Problem | Pattern | LeetCode |
|---------|---------|----------|
| Subsets II | Duplicates handling | [LC 90](https://leetcode.com/problems/subsets-ii/) |
| Permutations | Used array | [LC 46](https://leetcode.com/problems/permutations/) |
| Permutations II | Duplicates + used | [LC 47](https://leetcode.com/problems/permutations-ii/) |
| Combinations | k-selection | [LC 77](https://leetcode.com/problems/combinations/) |
| Combination Sum | Unlimited reuse | [LC 39](https://leetcode.com/problems/combination-sum/) |
| Combination Sum II | No reuse + duplicates | [LC 40](https://leetcode.com/problems/combination-sum-ii/) |
| Generate Parentheses | Constraint tracking | [LC 22](https://leetcode.com/problems/generate-parentheses/) |
| Palindrome Partitioning | Substring validation | [LC 131](https://leetcode.com/problems/palindrome-partitioning/) |

### Hard (Master edge cases)

| Problem | Pattern | LeetCode |
|---------|---------|----------|
| N-Queens | Grid + constraints | [LC 51](https://leetcode.com/problems/n-queens/) |
| Sudoku Solver | Full constraint | [LC 37](https://leetcode.com/problems/sudoku-solver/) |
| Word Search II | Grid + Trie | [LC 212](https://leetcode.com/problems/word-search-ii/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**After solving each problem:**
- **Day 1:** Redo without looking at solution
- **Day 3:** Explain the template variation used
- **Day 7:** Solve a similar problem (e.g., Subsets ‚Üí Subsets II)
- **Day 14:** Teach the pattern to someone
- **Day 30:** Revisit if struggled at Day 14

**Mastery checklist:**
- [ ] Can write template from memory
- [ ] Can identify which variation to use in < 2 min
- [ ] Can handle duplicates without hints
- [ ] Can explain time complexity intuitively

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Step 1: Recognize the pattern (30 sec)**
> "This is asking for all possible [subsets/permutations/combinations], which is a classic backtracking problem."

**Step 2: State the approach (1 min)**
> "I'll use the backtracking template: for each element, I'll make a choice, recursively explore, then undo the choice. This builds a decision tree of all possibilities."

**Step 3: Discuss complexity upfront (30 sec)**
> "Time complexity will be O(n * 2^n) for subsets since there are 2^n possible subsets and we spend O(n) copying each."

**Step 4: Handle edge cases (30 sec)**
> "I'll handle: empty input, single element, and if there are duplicates I'll sort first and skip consecutive duplicates."

**Step 5: Code with explanation**
> "I'm adding a copy of current to avoid reference issues... Now I'll iterate from `start` to avoid reusing earlier elements..."

**Company Focus:**

| Company | Backtracking Focus | Typical Problems |
|---------|-------------------|------------------|
| Google | Complex constraints, pruning | N-Queens, Sudoku |
| Amazon | Classic patterns | Permutations, Combinations |
| Meta | Bug-free implementation | Subsets, Word Search |
| Microsoft | Clear explanation | Generate Parentheses |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn template | 30-45 min | Understand choose/explore/unchoose |
| Subsets (first problem) | 20-30 min | Apply template directly |
| Permutations | 15-20 min | Variation with `used` array |
| Handle duplicates | 20-30 min | Tricky edge case |
| Grid backtracking | 30-45 min | New dimension |
| Master pattern | 10-15 problems | Until automatic |

---

## üí° Key Insight

> **The backtracking template is always the same: CHOOSE ‚Üí EXPLORE ‚Üí UNCHOOSE.** The only differences between problems are:
> 1. **What is a valid choice?** (constraints/pruning)
> 2. **When is a solution complete?** (base case)
> 3. **How to avoid duplicates?** (start index, used array, skip duplicates)

Once you internalize this template, you can solve any backtracking problem by identifying these three things.

---

## üîó Related

- [Subsets Pattern](./2.3-Core-Patterns/01-Subsets-Pattern.md) - Include/exclude variation
- [Permutations Pattern](./2.3-Core-Patterns/02-Permutations-Pattern.md) - Arrangement variation
- [Combinations Pattern](./2.3-Core-Patterns/03-Combinations-Pattern.md) - Selection variation
- [Recursion Basics](../01-Recursion/1.1-Recursion-Basics.md) - Foundation
- [DFS on Graphs](../../10-Graphs.md) - Similar exploration pattern
- [Dynamic Programming](../../11-Dynamic-Programming.md) - When to use DP instead
