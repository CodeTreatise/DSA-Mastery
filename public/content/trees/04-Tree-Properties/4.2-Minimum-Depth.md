# 4.2 - Minimum Depth of Binary Tree (LC 111)

> **Grokking Pattern:** #11 Tree DFS | #10 Tree BFS
>
> **Difficulty:** Easy | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê Common

---

## Problem Statement

Given a binary tree, find its **minimum depth**.

The **minimum depth** is the number of nodes along the shortest path from the root node down to the nearest **leaf node**.

**Note:** A leaf is a node with no children.

```
Input: root = [3,9,20,null,null,15,7]
        3
       / \
      9   20
         /  \
        15   7

Output: 2 (path: 3 ‚Üí 9)
```

**Tricky Case:**
```
Input: root = [2,null,3,null,4]
    2
     \
      3
       \
        4

Output: 4 (NOT 1! The path must go to a LEAF)
```

[LeetCode 111 - Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Minimum depth" or "shortest path"
- "Nearest leaf node"
- Root-to-leaf path

**Key insight:**
Unlike max depth, min depth has a critical edge case: **a null child doesn't count as a leaf**. Only nodes with NO children are leaves.

**BFS is often better** for minimum depth because you find the first leaf immediately.

</details>

---

## ‚úÖ When to Use

- Finding shortest path to any leaf
- Early termination is beneficial
- Level-by-level exploration

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Finding maximum depth | Different problem | Max Depth |
| Path to specific node | Not leaf-specific | Regular BFS |
| All paths needed | Can't early terminate | DFS with tracking |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Maximum Depth](./4.1-Maximum-Depth.md)
- [BFS Concept](../03-Tree-Traversals/3.2-BFS-Traversals/00-BFS-Concept.md)

**After mastering this:**
- [Balanced Binary Tree](./4.4-Balanced-Tree.md)
- [Path Sum](../05-Path-Problems/5.1-Path-Sum.md)

**Related:**
- BFS is optimal for "minimum" problems
- DFS requires checking both subtrees

</details>

---

## üìê How It Works

### The Critical Edge Case

```
Max depth vs Min depth for this tree:

    1
     \
      2

Max depth = 2 (trivial)
Min depth = 2 (NOT 1!)

Why? Node 1 has only one child, so it's NOT a leaf.
The only leaf is node 2, which is at depth 2.
```

### DFS Approach

```
        3
       / \
      9   20
         /  \
        15   7

DFS must handle null children specially:

minDepth(3):
  left = minDepth(9) = 1 (leaf)
  right = minDepth(20) = 2
  return 1 + min(1, 2) = 2 ‚úì
```

### BFS Approach (Optimal)

```
Level 1: [3]      - not a leaf
Level 2: [9, 20]  - 9 is a leaf! Return 2

BFS finds the first leaf immediately.
```

---

## üíª Code Implementation

### Solution 1: BFS (Optimal for Min Depth)

**Python:**
```python
from typing import Optional
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def min_depth_bfs(root: Optional[TreeNode]) -> int:
    """
    Minimum depth using BFS.
    
    BFS finds the first leaf immediately - optimal!
    Time: O(n) worst, but often O(m) where m < n
    Space: O(w) where w = max width
    """
    if not root:
        return 0
    
    queue = deque([root])
    depth = 1
    
    while queue:
        level_size = len(queue)
        for _ in range(level_size):
            node = queue.popleft()
            
            # Check if leaf (no children)
            if not node.left and not node.right:
                return depth  # Found first leaf!
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        depth += 1
    
    return depth
```

**JavaScript:**
```javascript
function minDepthBFS(root) {
    if (!root) return 0;
    
    const queue = [root];
    let depth = 1;
    
    while (queue.length > 0) {
        const levelSize = queue.length;
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            
            // Check if leaf
            if (!node.left && !node.right) {
                return depth;
            }
            
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        depth++;
    }
    
    return depth;
}
```

### Solution 2: DFS (Handle Edge Case Carefully)

**Python:**
```python
def min_depth_dfs(root: Optional[TreeNode]) -> int:
    """
    Minimum depth using DFS.
    
    CRITICAL: Handle the case where one child is null.
    A null child doesn't make the parent a leaf!
    
    Time: O(n), Space: O(h)
    """
    if not root:
        return 0
    
    # If no left child, min depth is on the right
    if not root.left:
        return 1 + min_depth_dfs(root.right)
    
    # If no right child, min depth is on the left
    if not root.right:
        return 1 + min_depth_dfs(root.left)
    
    # Both children exist - take minimum
    return 1 + min(min_depth_dfs(root.left), min_depth_dfs(root.right))
```

**JavaScript:**
```javascript
function minDepthDFS(root) {
    if (!root) return 0;
    
    // Handle one-child cases
    if (!root.left) return 1 + minDepthDFS(root.right);
    if (!root.right) return 1 + minDepthDFS(root.left);
    
    // Both children exist
    return 1 + Math.min(minDepthDFS(root.left), minDepthDFS(root.right));
}
```

### Solution 3: DFS Alternative (Cleaner but More Checks)

**Python:**
```python
def min_depth_dfs_v2(root: Optional[TreeNode]) -> int:
    """
    Alternative DFS with explicit leaf check.
    """
    if not root:
        return 0
    
    left = min_depth_dfs_v2(root.left)
    right = min_depth_dfs_v2(root.right)
    
    # If one subtree is empty, must go through the other
    if left == 0 or right == 0:
        return 1 + left + right  # One of them is 0
    
    return 1 + min(left, right)
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| BFS |" O(n) worst "| O(w) | Early termination often |
| DFS |" O(n) "| O(h) | Must visit all nodes |

**Why BFS is often better:**
- BFS stops at first leaf found
- For balanced trees, may only traverse half
- DFS must check all paths to find minimum

---

## üîÑ Variations

| Variation | Difference | Notes |
|-----------|------------|-------|
| N-ary min depth | Multiple children | Check all children = 0 |
| With path return | Return actual path | Track path during traversal |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Not Handling One-Child Case

```python
# ‚ùå WRONG: Classic bug
def min_depth(root):
    if not root:
        return 0
    return 1 + min(min_depth(root.left), min_depth(root.right))

# For tree [1, null, 2]:
#   min(0, 1) = 0 ‚Üí returns 1 (WRONG!)
#   Actual answer is 2

# ‚úÖ CORRECT: Handle null children specially
def min_depth(root):
    if not root:
        return 0
    if not root.left:
        return 1 + min_depth(root.right)
    if not root.right:
        return 1 + min_depth(root.left)
    return 1 + min(min_depth(root.left), min_depth(root.right))
```

### 2. Starting BFS Depth at 0

```python
# ‚ùå WRONG: Starting at 0
queue = deque([root])
depth = 0  # Should start at 1!

# ‚úÖ CORRECT: Start at 1 (root is depth 1)
queue = deque([root])
depth = 1
```

### 3. Forgetting to Check Leaf Condition in BFS

```python
# ‚ùå WRONG: Checking only one side
if not node.left:  # This doesn't mean it's a leaf!
    return depth

# ‚úÖ CORRECT: Both must be null for leaf
if not node.left and not node.right:
    return depth
```

---

## üìù Practice Problems

### This Problem
- [ ] [Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/) - LC 111

### Related Problems
- [ ] [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) - LC 104
- [ ] [Path Sum](https://leetcode.com/problems/path-sum/) - LC 112
- [ ] [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/) - LC 110

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement both BFS and DFS
**Day 3:** Focus on the one-child edge case
**Day 7:** Explain when BFS is better than DFS
**Day 14:** Solve without looking at notes

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Approach selection:**
> "For minimum depth, BFS is often better because it finds the first leaf immediately and can terminate early. DFS would need to explore all paths."

**Edge case awareness (IMPORTANT):**
> "I need to be careful about the edge case where a node has only one child. That node is NOT a leaf, so I can't treat a null child as having depth 0."

**Follow-up handling:**
- "What if tree is very wide?" ‚Üí DFS uses less space
- "What if tree is very deep?" ‚Üí BFS guaranteed to find min quickly

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê | Often paired with max depth |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Test edge case awareness |
| Google | ‚≠ê‚≠ê‚≠ê | May ask for BFS + DFS |
| Microsoft | ‚≠ê‚≠ê‚≠ê | Focus on edge cases |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| BFS solution | 5-7 min | Straightforward |
| DFS solution | 7-10 min | Edge case is tricky |
| Explain trade-offs | 2-3 min | BFS vs DFS |

---

> **üí° Key Insight:** The critical difference from max depth is handling null children. `min(0, something) = 0` is wrong because a null child doesn't make the parent a leaf. Always ask: "Does this node have ANY children?" If yes, it's not a leaf.

---

## üîó Related

- [Maximum Depth](./4.1-Maximum-Depth.md)
- [Path Sum](../05-Path-Problems/5.1-Path-Sum.md)
- [BFS Concept](../03-Tree-Traversals/3.2-BFS-Traversals/00-BFS-Concept.md)
