# 1.1 What Is a Heap?

## Definition

A **heap** is a specialized **complete binary tree** that satisfies the **heap property**:
- **Max-Heap:** Every parent node is ‚â• its children (root = maximum)
- **Min-Heap:** Every parent node is ‚â§ its children (root = minimum)

```
Max-Heap Example:               Min-Heap Example:
       100                            1
      /    \                        /   \
     19      36                    3     5
    /  \    /  \                  / \   / \
   17   3  25   1                7  10 8   9

Parent ‚â• Children               Parent ‚â§ Children
Root = Maximum (100)            Root = Minimum (1)
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify When to Use Heaps</strong></summary>

**Primary signals:**
- Need the **maximum** or **minimum** element frequently
- Need **Top K** elements (largest or smallest)
- Need to maintain a **priority queue**
- Streaming data with ranking requirements

**Keywords in problem statement:**
- "kth largest/smallest"
- "top k", "k most/least"
- "priority", "schedule"
- "median of stream"
- "merge k sorted"

</details>

---

## ‚úÖ When to Use Heaps

| Use Case | Why Heap? | Time Saved |
|----------|-----------|------------|
| Get min/max repeatedly |" O(1) access "| vs O(n) scan |
| Top K elements |" O(n log k) "| vs O(n log n) sort |
| Priority scheduling |" O(log n) update "| vs O(n) re-sort |
| Merge K sorted lists |" O(n log k) "| vs O(nk) naive |

## ‚ùå When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Need Kth element (k varies) | Heap gives fixed position | Balanced BST, Order Statistic Tree |
| Need all elements sorted | Just sorting |" Sort O(n log n) "|
| Frequent search by value | Heap doesn't support | Hash Set/Map |
| Need both min AND max | Need two heaps | Two heaps or Deque |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Binary Trees](../../06-Trees/01-Tree-Fundamentals/1.1-Tree-Terminology.md)
- Complete Binary Tree concept
- Array indexing

**After mastering this:**
- [Heap Operations](../02-Heap-Operations/2.1-Insert.md)
- [Priority Queue](../03-Priority-Queue/3.1-PQ-Basics.md)
- [Top K Pattern](../04-Top-K-Pattern/4.1-Top-K-Overview.md)

**Related concepts:**
- Binary Search Tree (different ordering)
- Balanced trees (AVL, Red-Black)

</details>

---

## üìê How It Works

### Two Key Properties

```
Property 1: COMPLETE BINARY TREE
- All levels filled except possibly the last
- Last level filled left-to-right
- No gaps!

Valid (Complete):          Invalid (Not Complete):
       A                          A
      / \                        / \
     B   C                      B   C
    / \                            / \
   D   E                          D   E
   
Property 2: HEAP PROPERTY
- Max-heap: parent ‚â• children (always)
- Min-heap: parent ‚â§ children (always)
- Only parent-child, NOT between siblings
```

### Array Representation

The **complete tree** property enables efficient array storage:

```
Heap as tree:           As array (0-indexed):
       100              [100, 19, 36, 17, 3, 25, 1]
      /    \               0   1   2   3  4   5  6
     19      36
    /  \    /  \
   17   3  25   1

Index formulas (0-indexed):
- Parent of i:     (i - 1) // 2
- Left child of i:  2 * i + 1
- Right child of i: 2 * i + 2

Example: node at index 1 (value 19)
- Parent: (1-1)//2 = 0 ‚Üí value 100 ‚úì
- Left child: 2*1+1 = 3 ‚Üí value 17 ‚úì
- Right child: 2*1+2 = 4 ‚Üí value 3 ‚úì
```

### Min-Heap vs Max-Heap

```
Operation           Max-Heap         Min-Heap
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Get extreme         O(1) maximum     O(1) minimum
Use case            "K largest"      "K smallest"
Root value          Largest          Smallest
Python heapq        Negate values    Default behavior
```

---

## üíª Code Implementation

### Basic Heap Structure

**Python:**
```python
import heapq

# Python's heapq is a MIN-HEAP by default
# For MAX-HEAP: negate values

# Min-heap operations
min_heap = []
heapq.heappush(min_heap, 5)
heapq.heappush(min_heap, 3)
heapq.heappush(min_heap, 7)

print(min_heap[0])  # Peek min: 3
print(heapq.heappop(min_heap))  # Pop min: 3

# Max-heap: negate values
max_heap = []
heapq.heappush(max_heap, -5)  # Store -5 for value 5
heapq.heappush(max_heap, -3)
heapq.heappush(max_heap, -7)

print(-max_heap[0])  # Peek max: 7
print(-heapq.heappop(max_heap))  # Pop max: 7

# Heapify an existing list - O(n)
arr = [5, 3, 7, 1, 9, 2]
heapq.heapify(arr)  # Transforms arr into a min-heap in-place
print(arr)  # [1, 3, 2, 5, 9, 7] - heap property maintained
```

**JavaScript:**
```javascript
// JavaScript doesn't have a built-in heap
// Here's a simple MinHeap implementation

class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    // Get parent/child indices
    parent(i) { return Math.floor((i - 1) / 2); }
    leftChild(i) { return 2 * i + 1; }
    rightChild(i) { return 2 * i + 2; }
    
    // Peek at minimum (root)
    peek() {
        return this.heap[0];
    }
    
    size() {
        return this.heap.length;
    }
    
    // Insert element - O(log n)
    push(val) {
        this.heap.push(val);
        this._bubbleUp(this.heap.length - 1);
    }
    
    // Remove and return minimum - O(log n)
    pop() {
        if (this.heap.length === 0) return undefined;
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return min;
    }
    
    _bubbleUp(i) {
        while (i > 0 && this.heap[this.parent(i)] > this.heap[i]) {
            [this.heap[this.parent(i)], this.heap[i]] = 
                [this.heap[i], this.heap[this.parent(i)]];
            i = this.parent(i);
        }
    }
    
    _bubbleDown(i) {
        let minIndex = i;
        const left = this.leftChild(i);
        const right = this.rightChild(i);
        
        if (left < this.heap.length && this.heap[left] < this.heap[minIndex]) {
            minIndex = left;
        }
        if (right < this.heap.length && this.heap[right] < this.heap[minIndex]) {
            minIndex = right;
        }
        
        if (minIndex !== i) {
            [this.heap[i], this.heap[minIndex]] = [this.heap[minIndex], this.heap[i]];
            this._bubbleDown(minIndex);
        }
    }
}

// MaxHeap: same structure but reverse comparisons
class MaxHeap extends MinHeap {
    _bubbleUp(i) {
        while (i > 0 && this.heap[this.parent(i)] < this.heap[i]) {
            [this.heap[this.parent(i)], this.heap[i]] = 
                [this.heap[i], this.heap[this.parent(i)]];
            i = this.parent(i);
        }
    }
    
    _bubbleDown(i) {
        let maxIndex = i;
        const left = this.leftChild(i);
        const right = this.rightChild(i);
        
        if (left < this.heap.length && this.heap[left] > this.heap[maxIndex]) {
            maxIndex = left;
        }
        if (right < this.heap.length && this.heap[right] > this.heap[maxIndex]) {
            maxIndex = right;
        }
        
        if (maxIndex !== i) {
            [this.heap[i], this.heap[maxIndex]] = [this.heap[maxIndex], this.heap[i]];
            this._bubbleDown(maxIndex);
        }
    }
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Peek (get min/max) |" O(1) "| O(1) | Root access |
| Insert (push) |" O(log n) "| O(1) | Bubble up |
| Delete min/max (pop) |" O(log n) "| O(1) | Bubble down |
| Build heap (heapify) |" O(n) "| O(1) | Bottom-up |
| Search |" O(n) "| O(1) | No ordering between siblings |

**Why O(n) heapify (not O(n log n))?**
```
Mathematical proof simplified:
- Leaves (n/2 nodes): 0 swaps each
- Level above leaves (n/4 nodes): 1 swap max each
- Level above that (n/8 nodes): 2 swaps max each
- ...

Total = n/4 * 1 + n/8 * 2 + n/16 * 3 + ...
      = O(n) by geometric series
```

---

## üîÑ Variations

| Variation | Difference | Use Case |
|-----------|------------|----------|
| **Min-Heap** | Root = minimum | Dijkstra's, K smallest |
| **Max-Heap** | Root = maximum | K largest, priority max |
| **Binary Heap** | Standard, degree = 2 | General purpose |
| **D-ary Heap** | Degree = d | Decrease-key heavy |
| **Fibonacci Heap** |" Amortized O(1) decrease-key "| Advanced graph algorithms |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Confusing Min-Heap and Max-Heap

```python
# ‚ùå Wrong: Using min-heap for "K largest"
for num in arr:
    heapq.heappush(heap, num)  # Min-heap, but we need max behavior!
    if len(heap) > k:
        heapq.heappop(heap)  # Removes smallest, keeps K largest ‚úì

# Actually this IS correct for K largest!
# Min-heap of size K ‚Üí K largest elements
# Root = Kth largest (smallest of the K largest)
```

### 2. Forgetting Python heapq is Min-Heap

```python
# ‚ùå Wrong: Expecting max at root
heap = [3, 1, 4, 1, 5]
heapq.heapify(heap)
print(heap[0])  # Expecting 5? NO! It's 1 (min-heap)

# ‚úÖ Correct: Negate for max-heap behavior
heap = [-3, -1, -4, -1, -5]
heapq.heapify(heap)
print(-heap[0])  # Now it's 5 (largest)
```

### 3. Modifying Heap Array Directly

```python
# ‚ùå Wrong: Changing elements breaks heap property
heap = [1, 3, 2]
heapq.heapify(heap)
heap[0] = 100  # Heap property violated!

# ‚úÖ Correct: Use heap operations
heapq.heapreplace(heap, 100)  # Pop min, push 100
# or
heapq.heappop(heap)
heapq.heappush(heap, 100)
```

### 4. Assuming Heap is Fully Sorted

```python
heap = [1, 3, 2, 7, 4]  # Valid min-heap
# Heap only guarantees parent ‚â§ children
# NOT: heap[i] ‚â§ heap[i+1] for all i

# To get sorted order:
sorted_list = []
while heap:
    sorted_list.append(heapq.heappop(heap))  # O(n log n)
```

---

## üìù Practice Problems (Progressive)

### Easy (Foundation)
- [ ] [Last Stone Weight (LC 1046)](https://leetcode.com/problems/last-stone-weight/) - Basic max-heap
- [ ] [Kth Largest Element (LC 703)](https://leetcode.com/problems/kth-largest-element-in-a-stream/) - Min-heap for K largest

### Medium (Apply patterns)
- [ ] [Kth Largest in Array (LC 215)](https://leetcode.com/problems/kth-largest-element-in-an-array/) - Classic Top K
- [ ] [Top K Frequent (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/) - Frequency + heap

### Hard (Master)
- [ ] [Find Median from Stream (LC 295)](https://leetcode.com/problems/find-median-from-data-stream/) - Two heaps
- [ ] [Merge K Sorted Lists (LC 23)](https://leetcode.com/problems/merge-k-sorted-lists/) - K-way merge

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement heap from scratch in JS
- **Day 3:** Use Python heapq for min and max operations
- **Day 7:** Solve LC 1046 and LC 703
- **Day 14:** Explain heap property and operations to someone
- **Day 30:** Implement D-ary heap

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**When to mention heaps:**
"This is a 'find K largest' problem, so I'll use a min-heap of size K. The key insight is that maintaining a min-heap of K elements means the root is the Kth largest, and anything smaller gets rejected."

**Explaining the structure:**
"A heap is a complete binary tree stored as an array. Parent at index i has children at 2i+1 and 2i+2. The heap property ensures the root is always the minimum (or maximum)."

**Complexity explanation:**
"Push and pop are O(log n) because we traverse at most the tree height. Peek is O(1) since the root is always at index 0."

</details>

**Company Focus:**

| Company | Frequency | Common Problem Types |
|---------|-----------|---------------------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Top K, scheduling |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | K-way merge, median |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Priority queue |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Heap fundamentals |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand heap concept | 15-20 min | Draw diagrams |
| Implement from scratch | 25-30 min | Bubble up/down |
| Learn Python heapq | 10-15 min | API familiarity |
| First heap problems | 20-30 min | LC 1046, 703 |

---

## üí° Key Insight

> **A heap gives O(1) access to the extreme element (min or max) with O(log n) updates.** The magic comes from the complete binary tree property (efficient array storage) combined with the heap property (extreme always at root). For Top K problems, remember: **K largest ‚Üí min-heap of size K; K smallest ‚Üí max-heap of size K.**

---

## üîó Related

- **Next:** [Heap Property Explained](./1.2-Heap-Property.md)
- **Operations:** [Insert and Remove](../02-Heap-Operations/2.1-Insert.md)
- **Applications:** [Priority Queue](../03-Priority-Queue/3.1-PQ-Basics.md)
- **Patterns:** [Top K](../04-Top-K-Pattern/4.1-Top-K-Overview.md) | [Two Heaps](../05-Two-Heaps-Pattern/5.1-Two-Heaps-Overview.md)
