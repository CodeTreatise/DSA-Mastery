# 2.3 Edge List

> **Simple list of all edges - used for specific algorithms**
>
> â±ï¸ **Time:** 15-20 min | ğŸ“Š **Difficulty:** Beginner | ğŸ¯ **Interview Frequency:** Low

---

## Overview

An **edge list** is the simplest graph representation - just a list of all edges in the graph. Each edge is typically a tuple of (source, destination) or (source, destination, weight).

```
Graph:                    Edge List:
    [0] â”€5â”€ [1]           [(0, 1, 5),
     â”‚       â”‚             (0, 2, 3),
     3       2             (1, 3, 2),
     â”‚       â”‚             (2, 3, 4)]
    [2] â”€4â”€ [3]
    
Simple: Just list of edges
```

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>When Edge List is Used</strong></summary>

**Use edge list when:**
- Problem gives input as list of edges
- Kruskal's MST algorithm (sort edges by weight)
- Bellman-Ford algorithm (iterate all edges)
- Need to process edges, not vertices
- Graph is extremely sparse

**Keywords in problems:**
- "edges = [[u, v, w], ...]"
- "minimum spanning tree"
- "sort edges by weight"
- "process each edge exactly once"

</details>

---

## âœ… When to Use

| Scenario | Why Edge List is Good |
|----------|----------------------|
| Kruskal's Algorithm | Need to sort edges by weight |
| Bellman-Ford | Iterate through all edges |
| Input already as edges | No conversion needed |
| Extremely sparse graphs | Minimal space usage |
| Edge-centric algorithms | Focus on edges, not vertices |

---

## âŒ When NOT to Use

| Scenario | Why Not | Better Alternative |
|----------|---------|-------------------|
| Finding neighbors | O(E) scan needed | Adjacency List |
| BFS/DFS traversal | Can't efficiently get neighbors | Adjacency List |
| Checking edge exists | O(E) lookup | Adjacency List/Matrix |
| Dense graphs | No benefit | Adjacency Matrix |
| Most interview problems | Inefficient for traversal | Adjacency List |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Graph?](../01-Graph-Fundamentals/1.1-What-Is-Graph.md)
- [Adjacency List](./2.2-Adjacency-List.md)

**After mastering this:**
- [Representation Comparison](./2.4-Representation-Comparison.md)
- [Kruskal's Algorithm](../11-MST/11.2-Kruskal-Algorithm.md) - Uses edge list
- [Bellman-Ford](../08-Shortest-Path/8.3-Bellman-Ford-Algorithm.md) - Iterates edges

**Conversion:**
- Edge list â†’ Adjacency list: O(E)
- Adjacency list â†’ Edge list: O(V + E)

</details>

---

## ğŸ“ How It Works

### Basic Structure

```python
# Unweighted undirected graph
edges = [(0, 1), (0, 2), (1, 3), (2, 3)]

# Weighted directed graph
edges = [(0, 1, 5), (0, 2, 3), (1, 3, 2), (2, 3, 4)]
#        src dst wt  src dst wt  ...

# As 2D list (common LeetCode format)
edges = [[0, 1, 5], [0, 2, 3], [1, 3, 2], [2, 3, 4]]
```

### Visual Representation

```
Edge List: [(A,B,5), (A,C,3), (B,D,2), (C,D,4)]

          5                      Edge   Src  Dst  Weight
    [A] â”€â”€â”€â”€â”€ [B]                 1      A    B     5
     â”‚         â”‚                  2      A    C     3
     3         2                  3      B    D     2
     â”‚         â”‚                  4      C    D     4
    [C] â”€â”€â”€â”€â”€ [D]
          4
```

### Edge List Properties

| Property | Undirected | Directed |
|----------|------------|----------|
| Store edge (u,v) | Once (either direction) | Once (as given) |
| For edge (u,v) | u and v are neighbors | v is neighbor of u only |
| Edge count | E edges in list | E edges in list |
| Reverse lookup | Need separate list | Need separate list |

---

## ğŸ’» Code Implementation

**Python:**
```python
class EdgeList:
    """Graph represented as a list of edges."""
    
    def __init__(self, directed=False, weighted=False):
        self.edges = []
        self.directed = directed
        self.weighted = weighted
        self.vertices = set()
    
    def add_edge(self, u, v, weight=1):
        """Add an edge to the graph."""
        self.vertices.add(u)
        self.vertices.add(v)
        
        if self.weighted:
            self.edges.append((u, v, weight))
        else:
            self.edges.append((u, v))
    
    def remove_edge(self, u, v):
        """Remove edge between u and v."""
        if self.weighted:
            self.edges = [(a, b, w) for a, b, w in self.edges 
                         if not (a == u and b == v)]
            if not self.directed:
                self.edges = [(a, b, w) for a, b, w in self.edges 
                             if not (a == v and b == u)]
        else:
            self.edges = [(a, b) for a, b in self.edges 
                         if not (a == u and b == v)]
            if not self.directed:
                self.edges = [(a, b) for a, b in self.edges 
                             if not (a == v and b == u)]
    
    def has_edge(self, u, v):
        """Check if edge exists. O(E)"""
        if self.weighted:
            if any(a == u and b == v for a, b, w in self.edges):
                return True
            if not self.directed:
                return any(a == v and b == u for a, b, w in self.edges)
        else:
            if (u, v) in self.edges:
                return True
            if not self.directed:
                return (v, u) in self.edges
        return False
    
    def get_neighbors(self, vertex):
        """Get neighbors of vertex. O(E)"""
        neighbors = []
        for edge in self.edges:
            if self.weighted:
                u, v, w = edge
                if u == vertex:
                    neighbors.append((v, w))
                elif not self.directed and v == vertex:
                    neighbors.append((u, w))
            else:
                u, v = edge
                if u == vertex:
                    neighbors.append(v)
                elif not self.directed and v == vertex:
                    neighbors.append(u)
        return neighbors
    
    def get_sorted_edges(self, reverse=False):
        """Get edges sorted by weight (for Kruskal's)."""
        if self.weighted:
            return sorted(self.edges, key=lambda x: x[2], reverse=reverse)
        return self.edges
    
    def to_adjacency_list(self):
        """Convert to adjacency list. O(E)"""
        from collections import defaultdict
        adj = defaultdict(list)
        
        for edge in self.edges:
            if self.weighted:
                u, v, w = edge
                adj[u].append((v, w))
                if not self.directed:
                    adj[v].append((u, w))
            else:
                u, v = edge
                adj[u].append(v)
                if not self.directed:
                    adj[v].append(u)
        
        return dict(adj)
    
    def num_vertices(self):
        """Return number of unique vertices."""
        return len(self.vertices)
    
    def num_edges(self):
        """Return number of edges."""
        return len(self.edges)
    
    def __str__(self):
        return f"Edges: {self.edges}"


# Example usage
print("=== Weighted Undirected Graph ===")
g = EdgeList(directed=False, weighted=True)
g.add_edge('A', 'B', 5)
g.add_edge('A', 'C', 3)
g.add_edge('B', 'D', 2)
g.add_edge('C', 'D', 4)

print(g)
# Edges: [('A', 'B', 5), ('A', 'C', 3), ('B', 'D', 2), ('C', 'D', 4)]

print(f"\nSorted by weight: {g.get_sorted_edges()}")
# [('B', 'D', 2), ('A', 'C', 3), ('C', 'D', 4), ('A', 'B', 5)]

print(f"\nConverted to adjacency list: {g.to_adjacency_list()}")
# {'A': [('B', 5), ('C', 3)], 'B': [('A', 5), ('D', 2)], ...}


# Kruskal's Algorithm pattern
def kruskal_pattern(edges, n):
    """Example of using edge list for MST."""
    # Sort edges by weight
    sorted_edges = sorted(edges, key=lambda x: x[2])
    
    # Process edges in order of weight
    mst = []
    for u, v, w in sorted_edges:
        # If adding edge doesn't create cycle (use Union-Find)
        # Add to MST
        mst.append((u, v, w))
        if len(mst) == n - 1:  # MST has n-1 edges
            break
    
    return mst
```

**JavaScript:**
```javascript
class EdgeList {
    constructor(directed = false, weighted = false) {
        this.edges = [];
        this.directed = directed;
        this.weighted = weighted;
        this.vertices = new Set();
    }
    
    addEdge(u, v, weight = 1) {
        this.vertices.add(u);
        this.vertices.add(v);
        
        if (this.weighted) {
            this.edges.push([u, v, weight]);
        } else {
            this.edges.push([u, v]);
        }
    }
    
    hasEdge(u, v) {
        for (const edge of this.edges) {
            const [a, b] = edge;
            if (a === u && b === v) return true;
            if (!this.directed && a === v && b === u) return true;
        }
        return false;
    }
    
    getNeighbors(vertex) {
        const neighbors = [];
        for (const edge of this.edges) {
            if (this.weighted) {
                const [u, v, w] = edge;
                if (u === vertex) neighbors.push([v, w]);
                else if (!this.directed && v === vertex) neighbors.push([u, w]);
            } else {
                const [u, v] = edge;
                if (u === vertex) neighbors.push(v);
                else if (!this.directed && v === vertex) neighbors.push(u);
            }
        }
        return neighbors;
    }
    
    getSortedEdges(reverse = false) {
        if (this.weighted) {
            return [...this.edges].sort((a, b) => 
                reverse ? b[2] - a[2] : a[2] - b[2]
            );
        }
        return this.edges;
    }
    
    toAdjacencyList() {
        const adj = new Map();
        
        for (const edge of this.edges) {
            if (this.weighted) {
                const [u, v, w] = edge;
                if (!adj.has(u)) adj.set(u, []);
                if (!adj.has(v)) adj.set(v, []);
                adj.get(u).push([v, w]);
                if (!this.directed) adj.get(v).push([u, w]);
            } else {
                const [u, v] = edge;
                if (!adj.has(u)) adj.set(u, []);
                if (!adj.has(v)) adj.set(v, []);
                adj.get(u).push(v);
                if (!this.directed) adj.get(v).push(u);
            }
        }
        
        return adj;
    }
    
    display() {
        console.log(`Edges: ${JSON.stringify(this.edges)}`);
    }
}

// Example
const g = new EdgeList(false, true);
g.addEdge('A', 'B', 5);
g.addEdge('A', 'C', 3);
g.addEdge('B', 'D', 2);
g.addEdge('C', 'D', 4);

console.log('Sorted by weight:', g.getSortedEdges());
// [['B', 'D', 2], ['A', 'C', 3], ['C', 'D', 4], ['A', 'B', 5]]
```

---

## âš¡ Complexity Analysis

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| Add edge | O(1) | Simple append |
| Remove edge | O(E) | Search through all edges |
| Check edge exists | O(E) | Linear search |
| Get neighbors | O(E) | Scan all edges |
| Sort edges | O(E log E) | For Kruskal's |
| Iterate all edges | O(E) | â­ Best feature! |
| **Space** | O(E) | â­ Minimal space |

**Why these complexities:**
- No index structure, so every query requires scanning
- Minimal overhead - just stores the edges
- Sorting is the main operation this is used for

---

## ğŸ”„ Variations

| Variation | Format | Use Case |
|-----------|--------|----------|
| Tuple list | `[(0,1), (1,2)]` | Unweighted |
| Triple list | `[(0,1,5), (1,2,3)]` | Weighted |
| 2D array | `[[0,1,5], [1,2,3]]` | LeetCode format |
| Named tuples | `Edge(src=0, dst=1, wt=5)` | Readable code |

### Common Conversions

```python
# Edge list to Adjacency list
def edges_to_adj_list(edges, directed=False):
    from collections import defaultdict
    adj = defaultdict(list)
    for u, v in edges:
        adj[u].append(v)
        if not directed:
            adj[v].append(u)
    return adj

# Adjacency list to Edge list
def adj_list_to_edges(adj, directed=False):
    edges = []
    seen = set()
    for u in adj:
        for v in adj[u]:
            if directed or (v, u) not in seen:
                edges.append((u, v))
                seen.add((u, v))
    return edges
```

---

## âš ï¸ Common Mistakes

### 1. O(E) Complexity for Simple Queries

```python
# âŒ Wrong: Using edge list when you need fast neighbor lookup
def bfs(edge_list, start):
    queue = [start]
    while queue:
        node = queue.pop(0)
        # This is O(E) per node! Total: O(V * E)
        for u, v in edge_list:
            if u == node:
                queue.append(v)

# âœ… Correct: Convert to adjacency list first
adj = edges_to_adj_list(edge_list)
# Now BFS is O(V + E) as expected
```

### 2. Forgetting Undirected Edges

```python
# âŒ Wrong: Only checking one direction for undirected graph
def get_neighbors_wrong(edges, vertex):
    return [v for u, v in edges if u == vertex]

# âœ… Correct: Check both directions
def get_neighbors_correct(edges, vertex, directed=False):
    neighbors = [v for u, v in edges if u == vertex]
    if not directed:
        neighbors.extend([u for u, v in edges if v == vertex])
    return neighbors
```

---

## ğŸ“ Practice Problems

### Problems Where Edge List is Given
| Problem | Difficulty | Focus |
|---------|------------|-------|
| [Find if Path Exists](https://leetcode.com/problems/find-if-path-exists-in-graph/) | ğŸŸ¢ Easy | Convert to adj list |
| [Redundant Connection](https://leetcode.com/problems/redundant-connection/) | ğŸŸ¡ Medium | Process edges |
| [Min Cost to Connect All Points](https://leetcode.com/problems/min-cost-to-connect-all-points/) | ğŸŸ¡ Medium | Kruskal's MST |

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Convert edge list â†” adjacency list
- **Day 3:** Implement Kruskal's using edge list
- **Day 7:** Recognize when edge list is optimal
- **Day 14:** Compare all three representations

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>When Edge List Matters</strong></summary>

**Mention edge list when:**
> "The input is already in edge list format. For this traversal problem, I'll first convert it to an adjacency list since we need efficient neighbor lookup."

**For MST problems:**
> "I'll keep the edge list format since Kruskal's algorithm needs to sort edges by weight."

**Trade-off discussion:**
> "Edge list is space-efficient O(E) but has O(E) lookup time. For this problem with many neighbor queries, adjacency list is better."

</details>

---

## â±ï¸ Time Estimates

| Activity | Time |
|----------|------|
| Understand concept | 5-10 min |
| Implement class | 10-15 min |
| Conversion functions | 10-15 min |
| **Total to master** | **25-40 min** |

---

> **ğŸ’¡ Key Insight:** Edge list is the simplest representation but least efficient for most operations. Use it when you need to iterate/sort all edges (Kruskal's, Bellman-Ford) or convert it to adjacency list for traversal problems.

> **ğŸ”— Related:** [Adjacency List](./2.2-Adjacency-List.md) | [Kruskal's Algorithm](../11-MST/11.2-Kruskal-Algorithm.md) | [Bellman-Ford](../08-Shortest-Path/8.3-Bellman-Ford-Algorithm.md)

---

**Previous:** [â† 2.2 Adjacency List](./2.2-Adjacency-List.md)  
**Next:** [2.4 Representation Comparison â†’](./2.4-Representation-Comparison.md)
