# Trie Insert Operation

> **Insert adds words to the Trie character by character, creating new nodes as needed and marking word endings.**

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Insert Patterns</strong></summary>

**Look for these signals:**
- "Add word to dictionary"
- "Build a trie from word list"
- "Insert strings for later lookup"
- Building autocomplete/spell-checker systems

**The insert operation is used when:**
- Initial Trie construction
- Dynamic word addition
- Building prefix structures
- Any "add" operation on string sets

</details>

---

## ‚úÖ When to Use

| Scenario | Details |
|----------|---------|
| **Building Trie from list** | Process all words with insert |
| **Dynamic dictionary** | Add words at runtime |
| **Word game setup** | Insert valid words |
| **Autocomplete system** | Build searchable index |

---

## ‚ùå Common Insertion Mistakes

| Mistake | Problem | Solution |
|---------|---------|----------|
| Not marking `is_end` | Words not found on search | Always set `is_end = True` |
| Wrong traversal direction | Corrupted structure | Start from root, go forward |
| Not handling duplicates | Incorrect word count | Use `count` field or check |
| Empty string handling | Unexpected behavior | Mark root or reject |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [What Is a Trie](../01-Trie-Fundamentals/1.1-What-Is-Trie.md) - Basic concept
- [TrieNode Structure](../01-Trie-Fundamentals/2.1-TrieNode-Structure.md) - Node design

**After mastering this:**
- [Search Operation](./3.2-Search-Operation.md) - Find exact words
- [StartsWith Operation](./3.3-StartsWith-Prefix.md) - Prefix queries
- [Delete Operation](./3.4-Delete-Operation.md) - Remove words

**Insert is used by:**
- All Trie problems (must build first!)
- Word Search II (build then search)
- Autocomplete (build then query)

</details>

---

## üìê How It Works

### The Insert Algorithm

```
FUNCTION insert(word):
    1. Start at root node
    2. FOR each character in word:
        a. If child for character doesn't exist:
           ‚Üí Create new TrieNode
        b. Move to child node
    3. Mark current node as end of word
    END
```

### Step-by-Step Visualization

**Insert "apple":**

```
Initial Trie (empty):
    (root)

Step 1: Insert 'a'
    (root)
       ‚îÇ
       a

Step 2: Insert 'p'
    (root)
       ‚îÇ
       a
       ‚îÇ
       p

Step 3: Insert 'p' (second 'p')
    (root)
       ‚îÇ
       a
       ‚îÇ
       p
       ‚îÇ
       p

Step 4: Insert 'l'
    (root)
       ‚îÇ
       a
       ‚îÇ
       p
       ‚îÇ
       p
       ‚îÇ
       l

Step 5: Insert 'e' and mark end
    (root)
       ‚îÇ
       a
       ‚îÇ
       p
       ‚îÇ
       p
       ‚îÇ
       l
       ‚îÇ
       e ‚Üê is_end = True ‚úì
```

### Inserting Multiple Words

**Insert ["app", "apple", "apt"]:**

```
After "app":          After "apple":        After "apt":
    (root)                (root)                (root)
       ‚îÇ                     ‚îÇ                     ‚îÇ
       a                     a                     a
       ‚îÇ                     ‚îÇ                     ‚îÇ
       p                     p                     p
       ‚îÇ                     ‚îÇ                    / \
       p(‚úì)                  p(‚úì)               p(‚úì)  t(‚úì)
                             ‚îÇ
                             l
                             ‚îÇ
                             e(‚úì)

Legend: (‚úì) = is_end = True
```

---

## üíª Code Implementation

### Basic Insert (HashMap)

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        """
        Insert a word into the trie.
        
        Time: O(m) where m = len(word)
        Space: O(m) worst case (all new nodes)
        
        Args:
            word: String to insert
        """
        node = self.root  # Start at root
        
        for char in word:
            # Create node if it doesn't exist
            if char not in node.children:
                node.children[char] = TrieNode()
            
            # Move to child node
            node = node.children[char]
        
        # Mark end of word
        node.is_end = True
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = new Map();
        this.isEnd = false;
    }
}

class Trie {
    constructor() {
        this.root = new TrieNode();
    }
    
    /**
     * Insert a word into the trie.
     * @param {string} word - Word to insert
     * Time: O(m), Space: O(m)
     */
    insert(word) {
        let node = this.root;
        
        for (const char of word) {
            if (!node.children.has(char)) {
                node.children.set(char, new TrieNode());
            }
            node = node.children.get(char);
        }
        
        node.isEnd = true;
    }
}
```

---

### Optimized Insert (Array[26])

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = [None] * 26  # a-z only
        self.is_end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        """
        Insert word (lowercase letters only).
        
        Time: O(m) - guaranteed, no hash overhead
        Space: O(m √ó 26) worst case
        """
        node = self.root
        
        for char in word:
            index = ord(char) - ord('a')  # Convert char to index
            
            if node.children[index] is None:
                node.children[index] = TrieNode()
            
            node = node.children[index]
        
        node.is_end = True
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = new Array(26).fill(null);
        this.isEnd = false;
    }
}

class Trie {
    constructor() {
        this.root = new TrieNode();
    }
    
    insert(word) {
        let node = this.root;
        
        for (const char of word) {
            const index = char.charCodeAt(0) - 'a'.charCodeAt(0);
            
            if (node.children[index] === null) {
                node.children[index] = new TrieNode();
            }
            
            node = node.children[index];
        }
        
        node.isEnd = true;
    }
}
```

---

### Extended Insert (With Metadata)

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False
        self.word = None        # Store complete word
        self.prefix_count = 0   # Words passing through
        self.end_count = 0      # Words ending here

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        """
        Insert with metadata tracking.
        
        Useful for:
        - Word Search II (storing complete word)
        - Counting words with prefix
        - Handling duplicate words
        """
        node = self.root
        
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            
            node = node.children[char]
            node.prefix_count += 1  # Track prefix usage
        
        node.is_end = True
        node.end_count += 1  # Handle duplicates
        node.word = word     # Store complete word
    
    def count_prefix(self, prefix: str) -> int:
        """Count words starting with prefix."""
        node = self._traverse(prefix)
        return node.prefix_count if node else 0
    
    def _traverse(self, s: str) -> TrieNode:
        """Helper to traverse to node for string."""
        node = self.root
        for char in s:
            if char not in node.children:
                return None
            node = node.children[char]
        return node
```

---

### Build Trie from List

**Python:**
```python
def build_trie(words: list[str]) -> Trie:
    """
    Build trie from list of words.
    
    Time: O(n √ó m) where n = num words, m = avg length
    Space: O(n √ó m) worst case (no shared prefixes)
    
    Example:
        trie = build_trie(["apple", "app", "application"])
    """
    trie = Trie()
    for word in words:
        trie.insert(word)
    return trie
```

**JavaScript:**
```javascript
function buildTrie(words) {
    const trie = new Trie();
    for (const word of words) {
        trie.insert(word);
    }
    return trie;
}
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| **Insert one word** | O(m) | O(m) | m = word length, worst case |
| **Build from n words** | O(n √ó m) | O(n √ó m) | Total characters |
| **Per character step** | O(1) | O(1) | Hash lookup or array index |

**Why O(m) per insert:**
- We visit exactly m characters
- Each character: one lookup + possibly one node creation
- Both are O(1) operations

**Space Analysis:**

```
Best case (all shared prefixes):
  Words: ["a", "ab", "abc", "abcd"]
  Nodes: 4 (shared path)
  
Worst case (no shared prefixes):
  Words: ["a", "b", "c", "d"]
  Nodes: 4 (separate paths)
  
Typical case:
  Nodes ‚âà total_unique_characters √ó sharing_factor
```

---

## üîÑ Variations

| Variation | Difference | Use Case |
|-----------|------------|----------|
| **Basic insert** | Just is_end marking | Simple lookup |
| **With count** | Track word frequency | Frequency queries |
| **With prefix_count** | Track prefix usage | Prefix counting |
| **With word storage** | Store complete word | Word Search II |
| **Case-insensitive** | Convert to lowercase | Search engines |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Mark End

**‚ùå Wrong:**
```python
def insert(self, word):
    node = self.root
    for char in word:
        if char not in node.children:
            node.children[char] = TrieNode()
        node = node.children[char]
    # Forgot to mark is_end!
```

**‚úÖ Correct:**
```python
def insert(self, word):
    node = self.root
    for char in word:
        if char not in node.children:
            node.children[char] = TrieNode()
        node = node.children[char]
    node.is_end = True  # Essential!
```

### 2. Modifying Root Reference

**‚ùå Wrong:**
```python
def insert(self, word):
    self.root = self.root  # Reassigning?
    for char in word:
        self.root = self.root.children[char]  # WRONG! Lost root!
```

**‚úÖ Correct:**
```python
def insert(self, word):
    node = self.root  # Use local variable
    for char in word:
        node = node.children[char]
```

### 3. Wrong Array Index for Non-Lowercase

**‚ùå Wrong:**
```python
def insert(self, word):  # word might have uppercase
    for char in word:
        index = ord(char) - ord('a')  # 'A' = -32!
```

**‚úÖ Correct:**
```python
def insert(self, word):
    for char in word.lower():  # Normalize first
        index = ord(char) - ord('a')
```

### 4. Empty String Handling

**‚ùå Ambiguous:**
```python
def insert(self, word):
    if not word:
        return  # Just ignoring empty string?
```

**‚úÖ Explicit:**
```python
def insert(self, word):
    if not word:
        self.root.is_end = True  # Empty string is a word
        return
    # ... rest of logic
```

---

## üìù Practice Problems

### Easy (Master basic insert)
- [ ] [Implement Trie](https://leetcode.com/problems/implement-trie-prefix-tree/) - LC 208 ‚≠ê Core problem

### Medium (Insert with extensions)
- [ ] [Design Add and Search Words](https://leetcode.com/problems/design-add-and-search-words-data-structure/) - LC 211
- [ ] [Replace Words](https://leetcode.com/problems/replace-words/) - LC 648
- [ ] [Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/) - LC 677

### Hard (Insert in complex scenarios)
- [ ] [Word Search II](https://leetcode.com/problems/word-search-ii/) - LC 212

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

For insert operation mastery:
- **Day 1:** Implement insert from scratch (both HashMap and Array)
- **Day 3:** Add metadata fields (count, word)
- **Day 7:** Build trie for Word Search II
- **Day 14:** Implement insert with all extensions
- **Day 30:** Write insert without any reference

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Discuss Insert in Interviews</strong></summary>

**Explaining the approach:**
> "For insert, I'll traverse the trie character by character. For each character, if the child doesn't exist, I create a new node. Then I move to that child. At the end, I mark the node as the end of a word."

**When asked about optimization:**
> "For lowercase-only input, I can use an Array[26] instead of HashMap for guaranteed O(1) lookup without hash overhead. This also improves cache performance."

**When discussing complexity:**
> "Insert is O(m) where m is the word length. In the worst case, we create m new nodes, so space is also O(m) per word. For building from n words, it's O(n √ó m) total."

</details>

**Interview Tips:**

| Situation | Advice |
|-----------|--------|
| Building from list | Mention O(n √ó m) total time |
| Duplicate words | Ask if they should be counted |
| Empty strings | Clarify expected behavior |
| Memory concerns | Discuss shared prefix benefit |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand insert | 10-15 min | This file |
| Implement basic insert | 5-10 min | Simple loop |
| Add metadata | 5-10 min | Extension |
| Debug common issues | 5-10 min | Typical errors |
| Master pattern | 30-45 min | Multiple implementations |

---

> **üí° Key Insight:** Insert is just a path-building operation. For each character, ensure the path exists (create if needed), then walk down. At the end, plant a flag (is_end = True). That's all there is to it.

> **üîó Related:** [TrieNode Structure](../01-Trie-Fundamentals/2.1-TrieNode-Structure.md) | [Search Operation](./3.2-Search-Operation.md) | [Delete Operation](./3.4-Delete-Operation.md)
