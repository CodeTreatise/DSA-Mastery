# 4.1 Memoization

> **The Bridge from Recursion to Dynamic Programming**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - Essential optimization technique  
> **Prerequisites:** [1.1 Recursion Basics](../01-Recursion/1.1-Recursion-Basics.md), [1.4 Basic Problems](../01-Recursion/1.4-Basic-Problems/)

---

## Overview

**Memoization** is caching the results of expensive function calls to avoid redundant computation. It transforms exponential recursive solutions into polynomial time.

```
Without Memo: fib(5) ‚Üí 15 calls, O(2^n)
With Memo:    fib(5) ‚Üí 9 calls,  O(n)
```

The key insight: **If you've solved a subproblem before, don't solve it again‚Äîlook it up!**

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Memoization</strong></summary>

**Look for these signals:**
- Recursive solution has **overlapping subproblems**
- Same function called with **same arguments** multiple times
- Exponential time complexity that seems reducible
- Problem asks for **optimal** value (min/max/count)

**Keywords in problem statement:**
- "minimum/maximum", "count ways", "number of paths"
- "can you reach", "is it possible"
- Problems with choices at each step

**How to identify overlapping subproblems:**
```python
# Add print to see repeated calls
def fib(n):
    print(f"fib({n})")  # You'll see fib(3), fib(2) called multiple times
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)
```

</details>

---

## ‚úÖ When to Use

- **Fibonacci-like** sequences (each state depends on previous states)
- **Grid path** problems (unique paths, minimum cost)
- **String matching** (edit distance, longest common subsequence)
- **Tree/graph** problems with repeated subtrees
- **Combinatorial counting** (number of ways to achieve X)

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| No overlapping subproblems | Plain recursion | Nothing to cache |
| Need all solutions, not count | Backtracking | Memoization doesn't save paths |
| Subproblems don't repeat | Divide & Conquer | No benefit from caching |
| Space is critical | Bottom-up DP |" Can often reduce to O(1) space "|
| Simple iterative solution exists | Loop | Simpler, less overhead |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Recursion Basics](../01-Recursion/1.1-Recursion-Basics.md)
- [Recursion Patterns](../01-Recursion/1.2-Recursion-Patterns.md)
- [Factorial & Fibonacci](../01-Recursion/1.4-Basic-Problems/01-Factorial-Fibonacci.md)

**After mastering this:**
- [Dynamic Programming](../../11-Dynamic-Programming.md) - Bottom-up approach
- [2D DP](../../11-Dynamic-Programming.md) - Grid-based problems
- [State Machine DP](../../11-Dynamic-Programming.md) - Complex state transitions

**Combines with:**
- Recursion (always the foundation)
- Tree/Graph traversal (cache visited states)
- Backtracking (sometimes can memoize partial results)

</details>

---

## üìê How It Works

### The Memoization Pattern

```
1. Check if result is in cache ‚Üí return cached value
2. Compute the result recursively
3. Store result in cache
4. Return result
```

### Visualization: Fibonacci Without vs With Memo

```
WITHOUT MEMOIZATION - fib(5):
                    fib(5)
                   /      \
               fib(4)     fib(3)
              /    \      /    \
          fib(3)  fib(2) fib(2) fib(1)
          /   \    / \    / \
       fib(2) fib(1) ...  ... 
       
15 total calls! fib(2) computed 3 times, fib(3) computed 2 times


WITH MEMOIZATION - fib(5):
                    fib(5)
                   /      \
               fib(4)     fib(3) ‚Üê CACHED!
              /    \      
          fib(3)  fib(2) ‚Üê CACHED!
          /   \    
       fib(2) fib(1)
       
Only 6 unique calls! Each fib(n) computed exactly once
```

### The Three Steps

```python
def memoized_function(args):
    # 1. CHECK CACHE
    if args in memo:
        return memo[args]
    
    # 2. COMPUTE (base case + recursive case)
    if base_condition:
        result = base_value
    else:
        result = recursive_computation
    
    # 3. STORE & RETURN
    memo[args] = result
    return result
```

---

## üíª Code Implementation

### Template: Manual Memoization

**Python:**
```python
def memoized_recursion(n: int, memo: dict = None) -> int:
    """
    Template for memoized recursion.
    
    Pattern: Check ‚Üí Compute ‚Üí Store ‚Üí Return
    """
    if memo is None:
        memo = {}
    
    # 1. Check cache
    if n in memo:
        return memo[n]
    
    # 2. Base case
    if n <= 1:
        return n
    
    # 3. Recursive computation
    result = memoized_recursion(n - 1, memo) + memoized_recursion(n - 2, memo)
    
    # 4. Store and return
    memo[n] = result
    return result


# Example usage
print(memoized_recursion(50))  # Instant! Try without memo = forever
```

**JavaScript:**
```javascript
function memoizedRecursion(n, memo = {}) {
    // 1. Check cache
    if (n in memo) return memo[n];
    
    // 2. Base case
    if (n <= 1) return n;
    
    // 3. Compute and store
    memo[n] = memoizedRecursion(n - 1, memo) + memoizedRecursion(n - 2, memo);
    
    return memo[n];
}

console.log(memoizedRecursion(50)); // 12586269025
```

---

### Using Python's @lru_cache Decorator

```python
from functools import lru_cache

@lru_cache(maxsize=None)  # None = unlimited cache
def fib(n: int) -> int:
    """
    Fibonacci with automatic memoization.
    
    @lru_cache handles all caching automatically!
    Time: O(n), Space: O(n)
    """
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)


# Works instantly for large n
print(fib(100))  # 354224848179261915075
```

---

## üíª Problem 1: Climbing Stairs

### Problem Statement
You can climb 1 or 2 steps. How many distinct ways to reach step n?

```
n = 3 ‚Üí 3 ways: [1,1,1], [1,2], [2,1]
n = 4 ‚Üí 5 ways
```

### Without Memoization (TLE)

```python
def climb_stairs_slow(n: int) -> int:
    """O(2^n) - Too slow for n > 40"""
    if n <= 2:
        return n
    return climb_stairs_slow(n - 1) + climb_stairs_slow(n - 2)
```

### With Memoization

```python
def climb_stairs(n: int, memo: dict = None) -> int:
    """
    Count ways to climb n stairs (1 or 2 steps at a time).
    
    Recurrence: ways(n) = ways(n-1) + ways(n-2)
    Time: O(n), Space: O(n)
    """
    if memo is None:
        memo = {}
    
    if n in memo:
        return memo[n]
    
    if n <= 2:
        return n
    
    memo[n] = climb_stairs(n - 1, memo) + climb_stairs(n - 2, memo)
    return memo[n]


# Or with decorator
from functools import lru_cache

@lru_cache(maxsize=None)
def climb_stairs_cached(n: int) -> int:
    if n <= 2:
        return n
    return climb_stairs_cached(n - 1) + climb_stairs_cached(n - 2)


print(climb_stairs(45))  # 1836311903
```

```javascript
function climbStairs(n, memo = {}) {
    if (n in memo) return memo[n];
    if (n <= 2) return n;
    
    memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);
    return memo[n];
}

console.log(climbStairs(45)); // 1836311903
```

---

## üíª Problem 2: Unique Paths (Grid)

### Problem Statement
Robot at top-left, can only move right or down. How many unique paths to bottom-right?

```
Grid 3x3:
[S][ ][ ]
[ ][ ][ ]
[ ][ ][E]

Answer: 6 paths
```

### Code

```python
from functools import lru_cache

def unique_paths(m: int, n: int) -> int:
    """
    Count unique paths in m*n grid (only right/down moves).
    
    Recurrence: paths(i,j) = paths(i-1,j) + paths(i,j-1)
    Time: O(m*n), Space: O(m*n)
    """
    @lru_cache(maxsize=None)
    def dp(row: int, col: int) -> int:
        # Base: reached destination
        if row == m - 1 and col == n - 1:
            return 1
        
        # Base: out of bounds
        if row >= m or col >= n:
            return 0
        
        # Move right + move down
        return dp(row + 1, col) + dp(row, col + 1)
    
    return dp(0, 0)


print(unique_paths(3, 7))  # 28
print(unique_paths(3, 3))  # 6
```

```javascript
function uniquePaths(m, n) {
    const memo = {};
    
    function dp(row, col) {
        const key = `${row},${col}`;
        if (key in memo) return memo[key];
        
        if (row === m - 1 && col === n - 1) return 1;
        if (row >= m || col >= n) return 0;
        
        memo[key] = dp(row + 1, col) + dp(row, col + 1);
        return memo[key];
    }
    
    return dp(0, 0);
}

console.log(uniquePaths(3, 7)); // 28
```

---

## üíª Problem 3: Minimum Path Sum

### Problem Statement
Find path from top-left to bottom-right with minimum sum.

```
grid = [
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]
Output: 7 (path: 1‚Üí3‚Üí1‚Üí1‚Üí1)
```

### Code

```python
from functools import lru_cache

def min_path_sum(grid: list[list[int]]) -> int:
    """
    Find minimum path sum from top-left to bottom-right.
    
    Recurrence: minSum(i,j) = grid[i][j] + min(minSum(i+1,j), minSum(i,j+1))
    Time: O(m*n), Space: O(m*n)
    """
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    
    @lru_cache(maxsize=None)
    def dp(row: int, col: int) -> int:
        # Base: destination
        if row == m - 1 and col == n - 1:
            return grid[row][col]
        
        # Base: out of bounds
        if row >= m or col >= n:
            return float('inf')
        
        # Current cell + min of two directions
        right = dp(row, col + 1)
        down = dp(row + 1, col)
        
        return grid[row][col] + min(right, down)
    
    return dp(0, 0)


grid = [
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1]
]
print(min_path_sum(grid))  # 7
```

```javascript
function minPathSum(grid) {
    const m = grid.length;
    const n = grid[0].length;
    const memo = {};
    
    function dp(row, col) {
        if (row === m - 1 && col === n - 1) return grid[row][col];
        if (row >= m || col >= n) return Infinity;
        
        const key = `${row},${col}`;
        if (key in memo) return memo[key];
        
        memo[key] = grid[row][col] + Math.min(dp(row + 1, col), dp(row, col + 1));
        return memo[key];
    }
    
    return dp(0, 0);
}
```

---

## ‚ö° Complexity Analysis

| Problem | Without Memo | With Memo | Space |
|---------|--------------|-----------|-------|
| Fibonacci |" O(2^n) "| O(n) |" O(n) "|
| Climbing Stairs |" O(2^n) "| O(n) |" O(n) "|
| Unique Paths |" O(2^(m+n)) "| O(m*n) |" O(m*n) "|
| Min Path Sum |" O(2^(m+n)) "| O(m*n) |" O(m*n) "|

**Why memoization works:**
- **Without memo:** Each subproblem solved multiple times ‚Üí exponential
- **With memo:** Each subproblem solved once ‚Üí polynomial
- **Space trade-off:** We use O(n) or O(m*n) space to store results

---

## üîÑ Variations

| Variation | Key Difference | Example |
|-----------|----------------|---------|
| **Top-down (Memo)** | Start from main problem, cache subproblems | This lesson |
| **Bottom-up (DP)** | Build from base cases up | DP chapter |
| **Space-optimized** | Only keep needed previous states |" O(n) ‚Üí O(1) for Fibonacci "|
| **Multi-dimensional** | Cache with multiple keys | Grid problems |

### Top-Down vs Bottom-Up

```python
# TOP-DOWN (Memoization) - This lesson
@lru_cache
def fib_top_down(n):
    if n <= 1:
        return n
    return fib_top_down(n - 1) + fib_top_down(n - 2)

# BOTTOM-UP (Tabulation) - DP lesson
def fib_bottom_up(n):
    if n <= 1:
        return n
    dp = [0] * (n + 1)
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting to Initialize Memo

‚ùå **Wrong:**
```python
def fib(n, memo):  # memo could be None on first call!
    if n in memo:
        return memo[n]
```

‚úÖ **Correct:**
```python
def fib(n, memo=None):
    if memo is None:
        memo = {}
    if n in memo:
        return memo[n]
```

### 2. Mutable Default Argument Bug

‚ùå **Wrong:**
```python
def fib(n, memo={}):  # Same dict reused across calls!
    ...
```

‚úÖ **Correct:**
```python
def fib(n, memo=None):
    if memo is None:
        memo = {}
    ...
```

### 3. Wrong Cache Key for Multiple Args

‚ùå **Wrong:**
```python
def grid_dp(row, col, memo=None):
    if (row, col) in memo:  # Works
        ...
    
def grid_dp(row, col, memo=None):
    key = row + col  # WRONG! (1,2) and (2,1) have same key
```

‚úÖ **Correct:**
```python
def grid_dp(row, col, memo=None):
    key = (row, col)  # Tuple as key
    # Or
    key = f"{row},{col}"  # String key for JS compatibility
```

### 4. Not Returning Cached Value

‚ùå **Wrong:**
```python
if n in memo:
    memo[n]  # Forgot return!
```

‚úÖ **Correct:**
```python
if n in memo:
    return memo[n]
```

---

## üìù Practice Problems

### Easy (Learn the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Fibonacci Number | Basic memo | [LC 509](https://leetcode.com/problems/fibonacci-number/) |
| Climbing Stairs | 1D memo | [LC 70](https://leetcode.com/problems/climbing-stairs/) |
| Min Cost Climbing Stairs | With cost | [LC 746](https://leetcode.com/problems/min-cost-climbing-stairs/) |

### Medium (Apply variations)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Unique Paths | 2D memo | [LC 62](https://leetcode.com/problems/unique-paths/) |
| Unique Paths II | With obstacles | [LC 63](https://leetcode.com/problems/unique-paths-ii/) |
| Minimum Path Sum | Grid optimization | [LC 64](https://leetcode.com/problems/minimum-path-sum/) |
| House Robber | Non-adjacent selection | [LC 198](https://leetcode.com/problems/house-robber/) |
| Word Break | String partitioning | [LC 139](https://leetcode.com/problems/word-break/) |

### Hard (Master the pattern)

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Longest Palindromic Substring | 2D string DP | [LC 5](https://leetcode.com/problems/longest-palindromic-substring/) |
| Burst Balloons | Interval DP | [LC 312](https://leetcode.com/problems/burst-balloons/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Week 1: Foundation**
- Day 1: Fibonacci + Climbing Stairs
- Day 3: Redo without looking at solution
- Day 5: Unique Paths (2D)

**Week 2: Application**
- Day 8: Minimum Path Sum
- Day 10: House Robber
- Day 14: Review all, identify the pattern

**Week 3+: Mastery**
- Solve 2-3 new problems per week
- Always identify: What are the states? What are the transitions?

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Step 1: Recognize the pattern**
> "I notice this problem has overlapping subproblems‚Äîcomputing the same values multiple times. I'll use memoization to optimize."

**Step 2: Define the state**
> "The state is [what we're computing], and it depends on [parameters]. For example, fib(n) depends on n."

**Step 3: Write recurrence**
> "The recurrence is: result(n) = result(n-1) + result(n-2) for Fibonacci-like problems."

**Step 4: Add memoization**
> "I'll cache results in a dictionary/map to avoid recomputation."

**Step 5: Analyze complexity**
> "Time is O(n) since we compute each state once. Space is O(n) for the cache plus recursion stack."

**Common follow-up questions:**
- "Can you convert this to bottom-up DP?" ‚Üí Yes, iterate from base case
- "Can you optimize space?" ‚Üí Often can reduce to O(1) for linear dependencies

**Company Focus:**

| Company | Memoization Frequency |
|---------|----------------------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Often leads to DP |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê Standard optimization |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê Bug-free implementation |
| Microsoft | ‚≠ê‚≠ê‚≠ê Know the pattern |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 20-30 min | With examples |
| Fibonacci/Stairs | 10-15 min | Easy after understanding |
| Grid problems | 20-30 min | 2D state takes practice |
| Complex DP | 40-60 min | Word Break, Burst Balloons |
| Master pattern | 1-2 weeks | Multiple problems |

---

## üí° Key Insight

> **Memoization = Recursion + Memory**
>
> If you can write a recursive solution, you can memoize it by:
> 1. Adding a cache (dict/map)
> 2. Checking cache before computing
> 3. Storing result before returning
>
> This transforms O(2^n) ‚Üí O(n) with just 3 lines of code!

---

## üîó Related

- [Recursion Basics](../01-Recursion/1.1-Recursion-Basics.md) - Foundation
- [Tail Recursion](./4.2-Tail-Recursion.md) - Another optimization
- [Dynamic Programming](../../11-Dynamic-Programming.md) - Bottom-up approach
- [Tech Interview Handbook - DP](https://www.techinterviewhandbook.org/algorithms/dynamic-programming/) - More patterns
