# 8.1 - Construct Binary Tree from Preorder and Inorder Traversal (LC 105)

> **Grokking Pattern:** #11 Tree DFS (Construction Pattern)
>
> **Difficulty:** Medium | **Frequency:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very Common

---

## Problem Statement

Given two integer arrays `preorder` and `inorder` where:
- `preorder` is the preorder traversal of a binary tree
- `inorder` is the inorder traversal of the same tree

Construct and return the binary tree.

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]

Output:
    3
   / \
  9  20
    /  \
   15   7
```

**Explanation:**
- Preorder: [3, 9, 20, 15, 7] ‚Üí Root first, then left subtree, then right subtree
- Inorder: [9, 3, 15, 20, 7] ‚Üí Left subtree, then root, then right subtree

[LeetCode 105 - Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Construct tree" from traversals
- Given preorder AND inorder
- Need to rebuild original structure

**Key insight:**
- **Preorder first element** = root of current subtree
- **Inorder** = tells us which nodes are left vs right of root

Find root in inorder ‚Üí everything left of it is left subtree, everything right is right subtree.

</details>

---

## ‚úÖ When to Use

- Reconstructing tree from traversals
- Given preorder + inorder
- Need exact tree structure

---

## ‚ùå When NOT to Use

| Situation | Why Not | Use Instead |
|-----------|---------|-------------|
| Only one traversal | Can't determine structure | Need two traversals |
| Preorder + postorder | Different algorithm | LC 889 |
| Serialized format | Different parsing | Deserialize (LC 297) |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Preorder Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/02-Preorder-Traversal.md)
- [Inorder Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/01-Inorder-Traversal.md)

**After mastering this:**
- [Construct from Inorder + Postorder](./8.2-Construct-Inorder-Postorder.md) - LC 106
- [Construct from Preorder + Postorder](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) - LC 889

</details>

---

## üìê How It Works

### The Algorithm

```
Preorder: [3, 9, 20, 15, 7]
           ‚Üë
          root

Inorder:  [9, 3, 15, 20, 7]
           ‚Üë  ‚Üë   ‚Üë
          left root right
          sub      subtree
          tree
```

**Steps:**
1. Take first element of preorder ‚Üí this is the root
2. Find this element in inorder
3. Everything left of it in inorder = left subtree
4. Everything right of it in inorder = right subtree
5. Recursively build left and right subtrees

### Visualization

```
Step 1: preorder[0] = 3 is root
        inorder index of 3 = 1
        
        Left subtree nodes: inorder[0:1] = [9]
        Right subtree nodes: inorder[2:5] = [15, 20, 7]
        
Step 2: Left subtree
        preorder[1:2] = [9]
        inorder[0:1] = [9]
        ‚Üí Node 9 (leaf)
        
Step 3: Right subtree
        preorder[2:5] = [20, 15, 7]
        inorder[2:5] = [15, 20, 7]
        
        preorder[0] = 20 is root of right subtree
        inorder index of 20 = 1 (relative to [15, 20, 7])
        
        Left of 20: [15] ‚Üí Node 15
        Right of 20: [7] ‚Üí Node 7

Final tree:
    3
   / \
  9  20
    /  \
   15   7
```

---

## üíª Code Implementation

### Solution 1: Hash Map for O(1) Lookup (Recommended)

**Python:**
```python
from typing import Optional, List

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def build_tree(preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
    """
    Construct binary tree from preorder and inorder traversals.
    
    Key insight:
    - Preorder first = root
    - Inorder splits into left/right subtrees
    
    Time: O(n), Space: O(n)
    """
    # Map value -> index in inorder for O(1) lookup
    inorder_map = {val: idx for idx, val in enumerate(inorder)}
    
    preorder_idx = [0]  # Use list to allow modification in nested function
    
    def build(left, right):
        """Build subtree from inorder[left:right+1]"""
        if left > right:
            return None
        
        # Root is next element in preorder
        root_val = preorder[preorder_idx[0]]
        preorder_idx[0] += 1
        
        root = TreeNode(root_val)
        
        # Find root position in inorder
        mid = inorder_map[root_val]
        
        # Build left subtree FIRST (matches preorder traversal order)
        root.left = build(left, mid - 1)
        # Then build right subtree
        root.right = build(mid + 1, right)
        
        return root
    
    return build(0, len(inorder) - 1)
```

**JavaScript:**
```javascript
function buildTree(preorder, inorder) {
    // Map value -> index for O(1) lookup
    const inorderMap = new Map();
    inorder.forEach((val, idx) => inorderMap.set(val, idx));
    
    let preorderIdx = 0;
    
    function build(left, right) {
        if (left > right) return null;
        
        // Root is next in preorder
        const rootVal = preorder[preorderIdx++];
        const root = new TreeNode(rootVal);
        
        // Split point in inorder
        const mid = inorderMap.get(rootVal);
        
        // Build left first, then right
        root.left = build(left, mid - 1);
        root.right = build(mid + 1, right);
        
        return root;
    }
    
    return build(0, inorder.length - 1);
}
```

### Solution 2: Slice-Based (Clearer but O(n¬≤))

**Python:**
```python
def build_tree_slices(preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
    """
    Clearer logic using array slices.
    Less efficient due to copying arrays.
    
    Time: O(n¬≤) due to slicing, Space: O(n¬≤)
    """
    if not preorder or not inorder:
        return None
    
    # Root is first element of preorder
    root_val = preorder[0]
    root = TreeNode(root_val)
    
    # Find root in inorder
    mid = inorder.index(root_val)
    
    # Elements left of root in inorder = left subtree
    # Number of left subtree nodes = mid
    root.left = build_tree_slices(
        preorder[1:mid+1],    # Skip root, take 'mid' nodes
        inorder[:mid]          # Everything left of root
    )
    
    # Elements right of root in inorder = right subtree
    root.right = build_tree_slices(
        preorder[mid+1:],      # Remaining preorder
        inorder[mid+1:]        # Everything right of root
    )
    
    return root
```

### Solution 3: Iterative with Stack

**Python:**
```python
def build_tree_iterative(preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
    """
    Iterative approach using stack.
    More complex but avoids recursion.
    """
    if not preorder:
        return None
    
    root = TreeNode(preorder[0])
    stack = [root]
    inorder_idx = 0
    
    for i in range(1, len(preorder)):
        node = TreeNode(preorder[i])
        
        if stack[-1].val != inorder[inorder_idx]:
            # Haven't reached leftmost, keep going left
            stack[-1].left = node
        else:
            # Reached leftmost, need to go right at some ancestor
            parent = None
            while stack and stack[-1].val == inorder[inorder_idx]:
                parent = stack.pop()
                inorder_idx += 1
            parent.right = node
        
        stack.append(node)
    
    return root
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Hash Map (indices) |" O(n) "| O(n) | Best approach |
| Slicing |" O(n¬≤) "| O(n¬≤) | Creates copies |
| Iterative |" O(n) "| O(n) | Complex logic |

**Why hash map approach is O(n):**
- Each node processed once
- O(1) lookup in hash map
- No array copying

---

## üîÑ Variations

| Variation | Difference | LeetCode |
|-----------|------------|----------|
| Inorder + Postorder | Root is last in postorder | LC 106 |
| Preorder + Postorder | Works only for full binary trees | LC 889 |
| From preorder only (BST) | Use BST property | LC 1008 |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Order of Recursive Calls

```python
# ‚ùå WRONG: Building right before left
root.right = build(mid + 1, right)  # Wrong! Consumes wrong preorder elements
root.left = build(left, mid - 1)

# ‚úÖ CORRECT: Left first, then right (matches preorder order)
root.left = build(left, mid - 1)
root.right = build(mid + 1, right)
```

### 2. Off-by-One in Slice Indices

```python
# ‚ùå WRONG: Including root in left subtree
root.left = build_tree(preorder[1:mid+2], inorder[:mid+1])

# ‚úÖ CORRECT: Root is at index mid, exclude it
root.left = build_tree(preorder[1:mid+1], inorder[:mid])
root.right = build_tree(preorder[mid+1:], inorder[mid+1:])
```

### 3. Not Using Hash Map

```python
# ‚ùå SLOW: Linear search each time
mid = inorder.index(root_val)  # O(n) per call ‚Üí O(n¬≤) total

# ‚úÖ FAST: Build hash map once
inorder_map = {val: idx for idx, val in enumerate(inorder)}
mid = inorder_map[root_val]  # O(1) per call ‚Üí O(n) total
```

### 4. Forgetting Edge Cases

```python
# Empty arrays
if not preorder or not inorder:
    return None

# Single element
if len(preorder) == 1:
    return TreeNode(preorder[0])
```

---

## üìù Practice Problems

### This Problem
- [ ] [Construct Binary Tree from Preorder and Inorder](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) - LC 105

### Related Construction Problems
- [ ] [Construct from Inorder and Postorder](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) - LC 106
- [ ] [Construct from Preorder and Postorder](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) - LC 889
- [ ] [Construct BST from Preorder](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/) - LC 1008

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Understand why preorder gives root, inorder gives split
**Day 3:** Implement with hash map
**Day 7:** Solve inorder + postorder version
**Day 14:** Explain the algorithm to someone

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Explaining the insight:**
> "Preorder visits root first, so preorder[0] is always the root. Inorder visits left-root-right, so finding the root in inorder tells us which nodes are in the left vs right subtree."

**The algorithm:**
> "I take the first preorder element as root, find it in inorder to split left/right, then recursively build each subtree. I use a hash map for O(1) lookup in inorder."

**Why left before right:**
> "In preorder, after the root comes the entire left subtree, then the right. So I must build left first to consume preorder elements in the correct order."

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Very common |
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Classic question |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê | Frequently asked |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê | Standard interview |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand traversals | 3-5 min | Key insight |
| Implement with hash map | 12-15 min | Clean solution |
| Handle edge cases | 2-3 min | Empty, single |

---

> **üí° Key Insight:** Preorder gives us the root (first element), while inorder lets us determine which nodes belong to left vs right subtrees. This combination uniquely determines the tree structure. Always build the left subtree first to maintain correct preorder consumption.

---

## üîó Related

- [Preorder Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/02-Preorder-Traversal.md)
- [Inorder Traversal](../03-Tree-Traversals/3.1-DFS-Traversals/01-Inorder-Traversal.md)
- [Construct from Inorder + Postorder](./8.2-Construct-Inorder-Postorder.md)
