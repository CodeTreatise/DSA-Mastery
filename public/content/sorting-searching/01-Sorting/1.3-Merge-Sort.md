# 1.3 - Merge Sort

> **Divide and Conquer Sorting**  
> **Interview Value:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê - Must know for interviews  
> **Characteristics:** Stable, O(n log n) guaranteed, O(n) space

---

## Overview

**Merge Sort** is a divide-and-conquer algorithm that:
1. **Divides** the array into two halves
2. **Recursively sorts** each half
3. **Merges** the sorted halves back together

It's the go-to algorithm when you need:
- Guaranteed O(n log n) performance
- Stability (preserving relative order of equal elements)
- Sorting linked lists (no random access needed)

---

## üéØ Pattern Recognition

<details>
<summary><strong>When to Use Merge Sort</strong></summary>

**Keywords:**
- "Stable sort required"
- "Sort linked list"
- "External sort" (data too large for memory)
- "Count inversions"
- "Merge sorted arrays"

**The pattern:**
```
[38, 27, 43, 3, 9, 82, 10]
       /              \
[38, 27, 43, 3]    [9, 82, 10]
    /    \            /    \
[38, 27] [43, 3]  [9, 82] [10]
  /  \     /  \    /  \     |
[38][27] [43][3] [9][82]  [10]
  \  /     \  /    \  /     |
[27, 38] [3, 43]  [9, 82] [10]
    \    /            \    /
[3, 27, 38, 43]    [9, 10, 82]
       \              /
[3, 9, 10, 27, 38, 43, 82]
```

</details>

---

## ‚úÖ When to Use

- **Need stable sort** - preserves order of equal elements
- **Linked lists** - no random access, easy to merge
- **External sorting** - sorting data too large for memory
- **Counting inversions** - classic application
- **Guaranteed O(n log n)** - no O(n¬≤) worst case

---

## ‚ùå When NOT to Use

| Situation | Use Instead | Why |
|-----------|-------------|-----|
| Space is critical | Quick Sort or Heap Sort |" Merge sort needs O(n) space "|
| Array is small (n < 50) | Insertion Sort | Lower overhead |
| Nearly sorted | Insertion Sort |" O(n) best case "|
| Random access important | Quick Sort | Better cache performance |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this:**
- [Recursion Basics](../../02-Recursion-Backtracking/01-Recursion/1.1-Recursion-Basics.md)
- [Divide and Conquer](../../02-Recursion-Backtracking/03-Divide-Conquer/3.1-DC-Basics.md)

**After mastering this:**
- [Quick Sort](./1.4-Quick-Sort.md) - Compare approaches
- [Counting Inversions](link) - Classic application
- [External Sorting](link) - Large data

**The merge operation is also used in:**
- Merge K Sorted Lists (LC 23)
- Merge Sorted Array (LC 88)
- Sort Linked List (LC 148)

</details>

---

## üìê How It Works

### The Two Key Operations

**1. Divide (Recursive)**
```
Split array at midpoint until single elements
[5, 2, 4, 7, 1, 3]
     /        \
[5, 2, 4]  [7, 1, 3]
  /    \     /    \
[5, 2] [4] [7, 1] [3]
 / \        / \
[5][2]    [7][1]
```

**2. Merge (Combine)**
```
Compare and merge sorted halves:

Left:  [2, 4, 5]    Right: [1, 3, 7]
        ^                   ^
        
Result: []

1 < 2 ‚Üí take 1
Left:  [2, 4, 5]    Right: [3, 7]
        ^                   ^
Result: [1]

2 < 3 ‚Üí take 2
Left:  [4, 5]       Right: [3, 7]
        ^                   ^
Result: [1, 2]

3 < 4 ‚Üí take 3
... and so on

Final: [1, 2, 3, 4, 5, 7]
```

### Visualization

```
Level 0: [38, 27, 43, 3, 9, 82, 10]         Divide ‚Üì
Level 1: [38, 27, 43, 3] | [9, 82, 10]
Level 2: [38, 27] | [43, 3] | [9, 82] | [10]
Level 3: [38] [27] [43] [3] [9] [82] [10]   Merge ‚Üë
Level 2: [27, 38] [3, 43] [9, 82] [10]
Level 1: [3, 27, 38, 43] [9, 10, 82]
Level 0: [3, 9, 10, 27, 38, 43, 82]
```

---

## üíª Code Implementation

### Standard Implementation

**Python:**
```python
def merge_sort(arr: list[int]) -> list[int]:
    """
    Merge Sort - divide and conquer.
    
    Time: O(n log n) always
    Space: O(n) for temporary arrays
    Stable: Yes
    """
    if len(arr) <= 1:
        return arr
    
    # Divide
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    # Conquer (merge)
    return merge(left, right)


def merge(left: list[int], right: list[int]) -> list[int]:
    """Merge two sorted arrays into one sorted array."""
    result = []
    i = j = 0
    
    # Compare and merge
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:  # <= for stability
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # Append remaining elements
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result


# Example
arr = [38, 27, 43, 3, 9, 82, 10]
print(merge_sort(arr))  # [3, 9, 10, 27, 38, 43, 82]
```

**JavaScript:**
```javascript
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result.push(left[i++]);
        } else {
            result.push(right[j++]);
        }
    }
    
    return result.concat(left.slice(i)).concat(right.slice(j));
}

// Example
console.log(mergeSort([38, 27, 43, 3, 9, 82, 10]));
```

---

### In-Place Merge Sort (Space Optimized)

```python
def merge_sort_inplace(arr: list[int], left: int = 0, right: int = None) -> None:
    """
    In-place merge sort using auxiliary array.
    
    Time: O(n log n)
    Space: O(n) - can't truly be O(1) for merge sort
    """
    if right is None:
        right = len(arr) - 1
    
    if left >= right:
        return
    
    mid = (left + right) // 2
    merge_sort_inplace(arr, left, mid)
    merge_sort_inplace(arr, mid + 1, right)
    merge_inplace(arr, left, mid, right)


def merge_inplace(arr: list[int], left: int, mid: int, right: int) -> None:
    """Merge arr[left:mid+1] and arr[mid+1:right+1] in place."""
    # Create temporary arrays
    left_arr = arr[left:mid + 1]
    right_arr = arr[mid + 1:right + 1]
    
    i = j = 0
    k = left
    
    while i < len(left_arr) and j < len(right_arr):
        if left_arr[i] <= right_arr[j]:
            arr[k] = left_arr[i]
            i += 1
        else:
            arr[k] = right_arr[j]
            j += 1
        k += 1
    
    while i < len(left_arr):
        arr[k] = left_arr[i]
        i += 1
        k += 1
    
    while j < len(right_arr):
        arr[k] = right_arr[j]
        j += 1
        k += 1


# Example
arr = [38, 27, 43, 3, 9, 82, 10]
merge_sort_inplace(arr)
print(arr)  # [3, 9, 10, 27, 38, 43, 82]
```

---

### Merge Sort for Linked List (LC 148)

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def sort_list(head: ListNode) -> ListNode:
    """
    Sort linked list using merge sort.
    
    Time: O(n log n)
    Space: O(log n) for recursion stack (O(1) if iterative)
    
    Why merge sort for linked lists?
    - No random access, so Quick Sort is inefficient
    - Merge operation is easy with pointers
    """
    if not head or not head.next:
        return head
    
    # Find middle using slow/fast pointers
    slow, fast = head, head.next
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    # Split the list
    mid = slow.next
    slow.next = None
    
    # Recursively sort both halves
    left = sort_list(head)
    right = sort_list(mid)
    
    # Merge sorted halves
    return merge_lists(left, right)


def merge_lists(l1: ListNode, l2: ListNode) -> ListNode:
    """Merge two sorted linked lists."""
    dummy = ListNode(0)
    curr = dummy
    
    while l1 and l2:
        if l1.val <= l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    
    curr.next = l1 or l2
    return dummy.next
```

---

### Count Inversions (Classic Application)

An inversion is a pair (i, j) where i < j but arr[i] > arr[j].

```python
def count_inversions(arr: list[int]) -> int:
    """
    Count inversions using modified merge sort.
    
    Time: O(n log n)
    Space: O(n)
    """
    def merge_count(arr, temp, left, mid, right):
        i = left      # Left subarray index
        j = mid + 1   # Right subarray index
        k = left      # Merged array index
        inv_count = 0
        
        while i <= mid and j <= right:
            if arr[i] <= arr[j]:
                temp[k] = arr[i]
                i += 1
            else:
                temp[k] = arr[j]
                # All remaining elements in left subarray are inversions
                inv_count += (mid - i + 1)
                j += 1
            k += 1
        
        while i <= mid:
            temp[k] = arr[i]
            i += 1
            k += 1
        
        while j <= right:
            temp[k] = arr[j]
            j += 1
            k += 1
        
        for i in range(left, right + 1):
            arr[i] = temp[i]
        
        return inv_count
    
    def sort_count(arr, temp, left, right):
        inv_count = 0
        if left < right:
            mid = (left + right) // 2
            inv_count += sort_count(arr, temp, left, mid)
            inv_count += sort_count(arr, temp, mid + 1, right)
            inv_count += merge_count(arr, temp, left, mid, right)
        return inv_count
    
    n = len(arr)
    temp = [0] * n
    return sort_count(arr, temp, 0, n - 1)


# Example
arr = [2, 4, 1, 3, 5]
print(count_inversions(arr))  # 3: (2,1), (4,1), (4,3)
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space | Why |
|------|------|-------|-----|
| Best |" O(n log n) "| O(n) | Always divides and merges |
| Average |" O(n log n) "| O(n) | Same as best |
| Worst |" O(n log n) "| O(n) | No degenerate cases |

**Why O(n log n)?**
```
Recursion depth: log n (halving each time)
Work at each level: O(n) (merge operation)
Total: O(n) * O(log n) = O(n log n)

Level 0: merge n elements      ‚Üí O(n)
Level 1: merge n/2 + n/2       ‚Üí O(n)
Level 2: merge n/4 + n/4 + ... ‚Üí O(n)
...
log n levels * O(n) work = O(n log n)
```

**Why O(n) space?**
- Merge operation needs temporary array
- Can't merge in true O(1) space while maintaining O(n log n) time

---

## üîÑ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| Top-Down | Recursive divide | Standard implementation |
| Bottom-Up | Iterative merge | Avoids recursion overhead |
| Natural | Uses existing runs | Nearly sorted data |
| Timsort | Hybrid with insertion | Python/Java built-in |
| External | For disk storage | Large datasets |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Wrong Merge Logic (Stability)

‚ùå **Wrong:**
```python
if left[i] < right[j]:  # Strict less than
    result.append(left[i])
```

‚úÖ **Correct:**
```python
if left[i] <= right[j]:  # <= for stability
    result.append(left[i])
```

### 2. Off-by-One in Indices

‚ùå **Wrong:**
```python
mid = len(arr) // 2
left = merge_sort(arr[:mid-1])  # Missing element!
```

‚úÖ **Correct:**
```python
mid = len(arr) // 2
left = merge_sort(arr[:mid])  # Correct slice
right = merge_sort(arr[mid:])
```

### 3. Forgetting Base Case

‚ùå **Wrong:**
```python
def merge_sort(arr):
    mid = len(arr) // 2  # Crashes for empty array
```

‚úÖ **Correct:**
```python
def merge_sort(arr):
    if len(arr) <= 1:  # Base case
        return arr
```

### 4. Linked List - Not Breaking the List

‚ùå **Wrong:**
```python
# mid is found but list isn't split
left = sort_list(head)
right = sort_list(mid)  # Still connected!
```

‚úÖ **Correct:**
```python
mid = slow.next
slow.next = None  # Break the list!
left = sort_list(head)
right = sort_list(mid)
```

---

## üìù Practice Problems

### Easy

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Merge Sorted Array | Merge operation | [LC 88](https://leetcode.com/problems/merge-sorted-array/) |
| Merge Two Sorted Lists | Linked list merge | [LC 21](https://leetcode.com/problems/merge-two-sorted-lists/) |

### Medium

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Sort an Array | Implement merge sort | [LC 912](https://leetcode.com/problems/sort-an-array/) |
| Sort List | Linked list sort | [LC 148](https://leetcode.com/problems/sort-list/) |
| Sort Colors | Three-way partition | [LC 75](https://leetcode.com/problems/sort-colors/) |

### Hard

| Problem | Focus | LeetCode |
|---------|-------|----------|
| Merge K Sorted Lists | K-way merge | [LC 23](https://leetcode.com/problems/merge-k-sorted-lists/) |
| Count of Smaller Numbers After Self | Merge + count | [LC 315](https://leetcode.com/problems/count-of-smaller-numbers-after-self/) |
| Reverse Pairs | Modified count inversions | [LC 493](https://leetcode.com/problems/reverse-pairs/) |

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Day 1:** Implement merge sort from scratch
- Write both the split and merge functions

**Day 3:** LC 88 Merge Sorted Array
- Master the merge operation

**Day 7:** LC 148 Sort List
- Apply to linked lists

**Day 14:** LC 315 Count of Smaller Numbers
- Understand the counting modification

**Day 21:** Implement bottom-up merge sort

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate in Interviews</strong></summary>

**Choosing merge sort:**
> "I'll use merge sort because it guarantees O(n log n) time and is stable. The trade-off is O(n) extra space."

**Explaining the approach:**
> "The algorithm divides the array in half recursively until we have single elements, then merges them back in sorted order."

**Discussing trade-offs:**
> "Compared to Quick Sort, merge sort is slower in practice due to memory allocation, but it has no O(n¬≤) worst case and is stable. It's preferred for linked lists and external sorting."

**Company Focus:**

| Company | Focus |
|---------|-------|
| Google | Implement from scratch |
| Amazon | Know trade-offs |
| Meta | Linked list applications |
| Microsoft | Basic implementation |

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand algorithm | 20-25 min | Trace through example |
| Implement basic version | 20-30 min | Practice multiple times |
| LC 88 Merge Array | 15-20 min | Master merge |
| LC 148 Sort List | 25-35 min | Linked list variant |
| LC 315 Count Inversions | 40-50 min | Hard application |

---

## üí° Key Insight

> **Merge Sort = Stable O(n log n) with O(n) space**
>
> The power is in the **merge operation**:
> - Linear time O(n) to merge two sorted arrays
> - Preserves stability with `<=` comparison
> - Works naturally with linked lists (no random access needed)
>
> Choose merge sort when:
> - Stability matters
> - Sorting linked lists
> - External sorting (data on disk)
> - Need guaranteed O(n log n)

---

## üîó Related

- [Sorting Basics](./1.1-Sorting-Basics.md) - Algorithm overview
- [Quick Sort](./1.4-Quick-Sort.md) - Compare approaches
- [Divide and Conquer](../02-Recursion-Backtracking/03-Divide-Conquer/3.1-DC-Basics.md) - Pattern
- [Merge K Sorted Lists](link) - Application
