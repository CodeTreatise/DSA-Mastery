# Collect All Words Pattern

> **Use DFS on a Trie to enumerate all words matching a prefix - the foundation for autocomplete, suggestions, and word enumeration.**

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Look for these signals:**
- "Find all words starting with X"
- "Get suggestions for prefix"
- "Enumerate all words in dictionary"
- "Top K words with prefix"
- Autocomplete functionality

**The pattern:**
1. Navigate to prefix node
2. DFS from that node
3. Collect all words found

</details>

---

## ‚úÖ When to Use

| Scenario | Application |
|----------|-------------|
| **Autocomplete** | Show suggestions as user types |
| **Search suggestions** | "Did you mean..." |
| **Word enumeration** | List all dictionary words |
| **Prefix-based filtering** | Filter by starting characters |

---

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|-------------------|
| **Just check prefix exists** | startsWith() |
| **Count only, not list** | Use prefix_count |
| **Top-K by frequency** | Add heap/sorting |
| **Single word search** | Basic search() |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [StartsWith Operation](../02-Trie-Operations/3.3-StartsWith-Prefix.md) - Prefix navigation
- [DFS basics](../../02-Recursion-Backtracking.md) - Tree traversal

**After mastering this:**
- [Autocomplete System](../06-Applications/7.1-Autocomplete-System.md) - Full feature
- Top-K suggestions with ranking

**Combines with:**
- Heap for top-K results
- Frequency counting for ranking
- Lexicographic ordering

</details>

---

## üìê How It Works

### The Algorithm

```
FUNCTION getWordsWithPrefix(prefix):
    1. Navigate to prefix node
    2. If node doesn't exist ‚Üí return []
    3. DFS from node, collecting all words ending below
    4. Return collected words
    END
```

### Visualization

```
Trie contains: ["apple", "app", "application", "apt", "banana"]

         (root)
          / \
         a   b
         |   |
         p   a
        / \   |
       p   t  n
      (‚úì) (‚úì) ...
       |
       l
      / \
     e   i
    (‚úì)   |
          c
          ...

getWordsWithPrefix("app"):
  Step 1: Navigate to "app" node
  Step 2: DFS from that node:
          - "app" node has is_end=True ‚Üí add "app"
          - Go to 'l' ‚Üí 'e' ‚Üí is_end=True ‚Üí add "apple"
          - Go to 'l' ‚Üí 'i' ‚Üí 'c'... ‚Üí add "application"
  Result: ["app", "apple", "application"]
```

---

## üíª Code Implementation

### Basic Collection

**Python:**
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False
        self.word = None  # Optional: store word for easy retrieval


class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        """Insert with word storage."""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
        node.word = word
    
    def get_words_with_prefix(self, prefix: str) -> list[str]:
        """
        Get all words starting with prefix.
        
        Time: O(p + k) where p = prefix length, k = total chars in results
        Space: O(k) for result storage + O(h) for recursion (h = max word length)
        """
        # Navigate to prefix node
        node = self._traverse(prefix)
        if node is None:
            return []
        
        # Collect all words below this node
        results = []
        self._collect_words(node, results)
        return results
    
    def _traverse(self, s: str) -> TrieNode:
        """Navigate to node for string s."""
        node = self.root
        for char in s:
            if char not in node.children:
                return None
            node = node.children[char]
        return node
    
    def _collect_words(self, node: TrieNode, results: list) -> None:
        """DFS to collect all words below node."""
        if node.word is not None:  # Found a word
            results.append(node.word)
        
        for child in node.children.values():
            self._collect_words(child, results)


# Usage:
# trie = Trie()
# for word in ["apple", "app", "application", "apt"]:
#     trie.insert(word)
# print(trie.get_words_with_prefix("app"))  # ["app", "apple", "application"]
# print(trie.get_words_with_prefix("apt"))  # ["apt"]
# print(trie.get_words_with_prefix("xyz"))  # []
```

**JavaScript:**
```javascript
class TrieNode {
    constructor() {
        this.children = new Map();
        this.isEnd = false;
        this.word = null;
    }
}

class Trie {
    constructor() {
        this.root = new TrieNode();
    }
    
    insert(word) {
        let node = this.root;
        for (const char of word) {
            if (!node.children.has(char)) {
                node.children.set(char, new TrieNode());
            }
            node = node.children.get(char);
        }
        node.isEnd = true;
        node.word = word;
    }
    
    getWordsWithPrefix(prefix) {
        const node = this._traverse(prefix);
        if (node === null) {
            return [];
        }
        
        const results = [];
        this._collectWords(node, results);
        return results;
    }
    
    _traverse(s) {
        let node = this.root;
        for (const char of s) {
            if (!node.children.has(char)) {
                return null;
            }
            node = node.children.get(char);
        }
        return node;
    }
    
    _collectWords(node, results) {
        if (node.word !== null) {
            results.push(node.word);
        }
        
        for (const child of node.children.values()) {
            this._collectWords(child, results);
        }
    }
}
```

---

### Without Storing Words (Build Path)

**Python:**
```python
class Trie:
    def get_words_with_prefix(self, prefix: str) -> list[str]:
        """Version that builds words from path."""
        node = self._traverse(prefix)
        if node is None:
            return []
        
        results = []
        self._collect_words_path(node, prefix, results)
        return results
    
    def _collect_words_path(self, node: TrieNode, current: str, results: list) -> None:
        """DFS collecting words by building path string."""
        if node.is_end:
            results.append(current)
        
        for char, child in node.children.items():
            self._collect_words_path(child, current + char, results)
```

---

### Lexicographically Sorted Results

**Python:**
```python
class Trie:
    def get_words_with_prefix_sorted(self, prefix: str) -> list[str]:
        """Get words in lexicographic order."""
        node = self._traverse(prefix)
        if node is None:
            return []
        
        results = []
        self._collect_sorted(node, prefix, results)
        return results
    
    def _collect_sorted(self, node: TrieNode, current: str, results: list) -> None:
        """DFS in sorted order (by character)."""
        if node.is_end:
            results.append(current)
        
        # Sort children keys for lexicographic order
        for char in sorted(node.children.keys()):
            self._collect_sorted(node.children[char], current + char, results)
```

---

### Top-K Results

**Python:**
```python
import heapq

class Trie:
    def get_top_k_with_prefix(self, prefix: str, k: int) -> list[str]:
        """
        Get top K words with prefix.
        
        Requires frequency tracking during insert.
        """
        node = self._traverse(prefix)
        if node is None:
            return []
        
        # Use heap to get top K by frequency
        heap = []  # (-frequency, word) for max-heap behavior
        self._collect_with_freq(node, heap)
        
        # Get top K
        result = []
        while heap and len(result) < k:
            freq, word = heapq.heappop(heap)
            result.append(word)
        
        return result
    
    def _collect_with_freq(self, node: TrieNode, heap: list) -> None:
        """Collect words with frequencies."""
        if node.word is not None:
            heapq.heappush(heap, (-node.frequency, node.word))
        
        for child in node.children.values():
            self._collect_with_freq(child, heap)
```

---

## ‚ö° Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| **Navigate to prefix** | O(p) | O(1) | p = prefix length |
| **Collect all words** | O(k) | O(k + h) | k = result chars, h = max depth |
| **Total** | O(p + k) | O(k + h) | - |

**Why O(p + k)?**
- Navigate: p steps to reach prefix node
- Collect: Visit each character of all result words once
- Much faster than O(n √ó p) hash map approach!

---

## üîÑ Variations

| Variation | Change | Use Case |
|-----------|--------|----------|
| **Lexicographic order** | Sort children | Alphabetical results |
| **Top-K by frequency** | Use heap | Search suggestions |
| **Limited results** | Stop after N | Performance |
| **With scores** | Track relevance | Ranking |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Building String Inefficiently

**‚ùå Wrong:**
```python
def _collect(self, node, current, results):
    if node.is_end:
        results.append(current)
    for char, child in node.children.items():
        # String concatenation creates new string each time!
        self._collect(child, current + char, results)
```

**‚úÖ Better (for very large tries):**
```python
def _collect(self, node, path, results):
    if node.is_end:
        results.append(''.join(path))  # Join once
    for char, child in node.children.items():
        path.append(char)
        self._collect(child, path, results)
        path.pop()  # Backtrack
```

### 2. Forgetting Empty Prefix

**‚úÖ Handle correctly:**
```python
def get_words_with_prefix(self, prefix):
    if not prefix:
        return self.get_all_words()  # Return all words
    # ... rest of logic
```

### 3. Not Handling Word Storage

**‚ùå Wrong:**
```python
# Node only has is_end, no way to know the word!
if node.is_end:
    results.append(???)  # What's the word?
```

**‚úÖ Correct:**
```python
# Either store word in node or build from path
if node.word is not None:
    results.append(node.word)
```

---

## üìù Practice Problems

### Medium (Apply pattern)
- [ ] [Search Suggestions System](https://leetcode.com/problems/search-suggestions-system/) - LC 1268 ‚≠ê
- [ ] [Design Search Autocomplete System](https://leetcode.com/problems/design-search-autocomplete-system/) - LC 642

### Related
- [ ] [Implement Trie](https://leetcode.com/problems/implement-trie-prefix-tree/) - LC 208
- [ ] [Replace Words](https://leetcode.com/problems/replace-words/) - LC 648

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement basic word collection
- **Day 3:** Add lexicographic ordering
- **Day 7:** Solve LC 1268 (Search Suggestions)
- **Day 14:** Implement top-K with frequency
- **Day 30:** Build complete autocomplete system

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Discuss in Interviews</strong></summary>

**Explaining the approach:**
> "To get all words with a prefix, I first navigate to the prefix node in O(p) time. Then I do a DFS from that node, collecting all words I find. This is O(p + k) where k is the total characters in the results."

**Why this is efficient:**
> "Compared to checking every word in a hash set - which would be O(n √ó p) where n is dictionary size - the Trie approach is much faster because we only visit relevant branches."

**For autocomplete:**
> "For real autocomplete, I'd add frequency tracking and return results sorted by frequency. I could use a heap to efficiently get the top K suggestions."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand pattern | 10-15 min | This file |
| Implement basic collection | 15-20 min | With trie |
| Add sorting/top-K | 10-15 min | Extensions |
| Solve LC 1268 | 25-30 min | Full problem |

---

> **üí° Key Insight:** Word collection is just DFS on a sub-trie. Navigate to the prefix node, then explore all paths below it, collecting words along the way. The prefix narrows down the search space dramatically.

> **üîó Related:** [StartsWith](../02-Trie-Operations/3.3-StartsWith-Prefix.md) | [Autocomplete System](../06-Applications/7.1-Autocomplete-System.md) | [Search Suggestions](../07-Practice-Problems/6.4-Search-Suggestions.md)
