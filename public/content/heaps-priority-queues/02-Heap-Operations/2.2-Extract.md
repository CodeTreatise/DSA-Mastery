# 2.2 Extract (Pop) Operation

## Definition

**Extract (Pop)** removes and returns the **root element** (min or max) while maintaining the heap property. This is the primary operation that makes heaps useful.

```
Algorithm:
1. Save root value (to return)
2. Move LAST element to root (maintains completeness)
3. BUBBLE DOWN: Compare with children, swap with smaller/larger child
4. Repeat until property restored or reach leaf
5. Return saved root value

Extract from Min-Heap:

Before:          After move last:    After bubble down:
    1                 6                    2
   / \               / \                  / \
  2   3      ‚Üí      2   3        ‚Üí       5   3
 / \               / \                  /
5   6             5                    6

Remove 1        Move 6 to root     6>2, swap; 6>5, swap
Return 1        (now violates)     Property restored!
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>When Extract Is Used</strong></summary>

**Common scenarios:**
- Get next item from priority queue
- Pop minimum/maximum
- Heap sort (extract all elements)
- Top K problems (extract K times)

**Key insight:**
```
Extract always removes the ROOT (extreme element)
Root access: O(1)
Restoration: O(log n)
Total: O(log n)
```

</details>

---

## ‚úÖ When to Use

| Scenario | Why Extract? |
|----------|--------------|
| Get min/max from heap | Primary use case |
| Priority queue dequeue | Standard operation |
| Heap sort | Extract n times |
| Kth element | Extract k times |

## ‚ùå When NOT to Use

| Scenario | Better Alternative |
|----------|---------------------|
| Just need to peek |" Use peek() O(1) "|
| Remove arbitrary element | Need decrease-key approach |
| Empty heap | Check size first |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Insert Operation](./2.1-Insert.md)
- [Heap Property](../01-Heap-Fundamentals/1.2-Heap-Property.md)
- Parent/child index formulas

**After mastering this:**
- [Peek Operation](./2.3-Peek.md)
- [Heapify](./2.4-Heapify.md)
- [Heap Sort](../08-Heap-Sort/8.1-Heap-Sort-Algorithm.md)

**Related:**
- Bubble down (sift down, percolate down)
- Priority queue dequeue

</details>

---

## üìê How It Works

### Step-by-Step Algorithm

```
EXTRACT(heap):
    If heap is empty: return None
    
    1. root = heap[0]  // Save return value
    2. heap[0] = heap.pop()  // Move last to root
    3. BUBBLE_DOWN(heap, 0)
    4. Return root

BUBBLE_DOWN(heap, i):
    While i has at least one child:
        // Find the child to potentially swap with
        smallest = i  // For min-heap (largest for max-heap)
        left = 2*i + 1
        right = 2*i + 2
        
        If left < len(heap) and heap[left] < heap[smallest]:
            smallest = left
        If right < len(heap) and heap[right] < heap[smallest]:
            smallest = right
        
        If smallest == i:
            Break  // Property satisfied
        
        Swap heap[i] and heap[smallest]
        i = smallest
```

### Visual Example: Extract from Min-Heap

```
Extract min from [1, 3, 2, 7, 4, 5]:

Tree view:          Step 1: Save & remove root
    1                   _
   / \                 / \
  3   2       ‚Üí       3   2
 /\  /               /\  /
7 4 5               7 4 5

                    Step 2: Move last (5) to root
                        5
                       / \
                      3   2
                     /\
                    7 4

                    Step 3: Bubble down
                    5 vs children (3, 2): 2 < 3 < 5 ‚Üí swap with 2
                        2
                       / \
                      3   5
                     /\
                    7 4

                    5 has no children, done!
                    
Final: [2, 3, 5, 7, 4]
Return: 1
```

### Why Move Last to Root?

```
Why not just remove root directly?

Option A (Wrong): Remove root, shift everything
  [1, 3, 2, 7, 4, 5] ‚Üí [3, 2, 7, 4, 5]
  Problem: O(n) shift AND breaks tree structure!

Option B (Correct): Move last to root
  [1, 3, 2, 7, 4, 5] ‚Üí [5, 3, 2, 7, 4]
  Then bubble down: O(log n)
  Maintains complete tree structure ‚úì
```

---

## üíª Code Implementation

### Min-Heap Extract

**Python:**
```python
import heapq

def extract_min(heap: list[int]) -> int | None:
    """
    Extract minimum from min-heap.
    Uses Python's heapq.
    
    Time: O(log n)
    Space: O(1)
    """
    if not heap:
        return None
    return heapq.heappop(heap)


# Manual implementation:
def extract_min_manual(heap: list[int]) -> int | None:
    """Manual extract with bubble down."""
    if not heap:
        return None
    
    # Step 1: Save root
    min_val = heap[0]
    
    # Step 2: Move last element to root
    last = heap.pop()
    if heap:  # If heap not empty after pop
        heap[0] = last
        # Step 3: Bubble down
        bubble_down(heap, 0)
    
    return min_val


def bubble_down(heap: list[int], i: int) -> None:
    """Bubble down for min-heap."""
    n = len(heap)
    
    while True:
        smallest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        # Find smallest among node and its children
        if left < n and heap[left] < heap[smallest]:
            smallest = left
        if right < n and heap[right] < heap[smallest]:
            smallest = right
        
        # If node is smallest, property satisfied
        if smallest == i:
            break
        
        # Swap and continue
        heap[i], heap[smallest] = heap[smallest], heap[i]
        i = smallest


# Example:
heap = [1, 3, 2, 7, 4, 5]
print(extract_min_manual(heap))  # 1
print(heap)  # [2, 3, 5, 7, 4]
print(extract_min_manual(heap))  # 2
print(heap)  # [3, 4, 5, 7]
```

**JavaScript:**
```javascript
function extractMin(heap) {
    if (heap.length === 0) return undefined;
    
    // Save root
    const min = heap[0];
    
    // Move last to root
    const last = heap.pop();
    if (heap.length > 0) {
        heap[0] = last;
        bubbleDown(heap, 0);
    }
    
    return min;
}

function bubbleDown(heap, i) {
    const n = heap.length;
    
    while (true) {
        let smallest = i;
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        
        if (left < n && heap[left] < heap[smallest]) smallest = left;
        if (right < n && heap[right] < heap[smallest]) smallest = right;
        
        if (smallest === i) break;
        
        [heap[i], heap[smallest]] = [heap[smallest], heap[i]];
        i = smallest;
    }
}

// Example:
const heap = [1, 3, 2, 7, 4, 5];
console.log(extractMin(heap));  // 1
console.log(heap);  // [2, 3, 5, 7, 4]
```

### Max-Heap Extract

**Python:**
```python
def extract_max(heap: list[int]) -> int | None:
    """
    Extract maximum from max-heap.
    For Python heapq, values are negated.
    
    Time: O(log n)
    """
    if not heap:
        return None
    return -heapq.heappop(heap)  # Negate back


def extract_max_manual(heap: list[int]) -> int | None:
    """Manual max-heap extract."""
    if not heap:
        return None
    
    max_val = heap[0]
    last = heap.pop()
    
    if heap:
        heap[0] = last
        bubble_down_max(heap, 0)
    
    return max_val


def bubble_down_max(heap: list[int], i: int) -> None:
    """Bubble down for max-heap."""
    n = len(heap)
    
    while True:
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        # Find largest among node and its children
        if left < n and heap[left] > heap[largest]:
            largest = left
        if right < n and heap[right] > heap[largest]:
            largest = right
        
        if largest == i:
            break
        
        heap[i], heap[largest] = heap[largest], heap[i]
        i = largest


# Example:
heap = [10, 7, 8, 3, 5, 2]
print(extract_max_manual(heap))  # 10
print(heap)  # [8, 7, 2, 3, 5]
```

### heapreplace: Pop then Push (Optimized)

**Python:**
```python
import heapq

def replace_example():
    """
    heapreplace: Pop min, then push new value.
    More efficient than pop() + push() separately.
    
    Time: O(log n) - single bubble down
    """
    heap = [1, 3, 2, 7, 4]
    
    # Pop 1, push 6 (in one operation)
    old_min = heapq.heapreplace(heap, 6)
    
    print(f"Removed: {old_min}")  # 1
    print(f"Heap: {heap}")        # [2, 3, 6, 7, 4]
    
    
def heappushpop_example():
    """
    heappushpop: Push first, then pop min.
    Returns smaller of (new value, current min).
    
    Useful for maintaining bounded heap.
    """
    heap = [1, 3, 2, 7, 4]
    
    # Push 0, then pop min (0)
    result = heapq.heappushpop(heap, 0)
    print(f"Returned: {result}")  # 0 (was pushed then immediately popped)
    print(f"Heap: {heap}")        # [1, 3, 2, 7, 4] (unchanged)
    
    # Push 5, then pop min (1)
    result = heapq.heappushpop(heap, 5)
    print(f"Returned: {result}")  # 1
    print(f"Heap: {heap}")        # [2, 3, 5, 7, 4]
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Best |" O(1) "| O(1) | Last element is new root (rare) |
| Average |" O(log n) "| O(1) | Half-height typically |
| Worst |" O(log n) "| O(1) | Bubbles to leaf |

**Why O(log n)?**
```
Bubble down path = root to some leaf
Maximum path length = height of tree = ‚åälog‚ÇÇ(n)‚åã

At each level: O(1) comparisons and swaps
Total: O(log n)
```

---

## üîÑ Variations

| Variation | Description | Use Case |
|-----------|-------------|----------|
| **heappop** | Extract min | Standard |
| **heapreplace** | Pop then push | Replace root |
| **heappushpop** | Push then pop | Bounded heap |
| **nsmallest** | Extract k smallest | Top K |

---

## ‚ö†Ô∏è Common Mistakes

### 1. Extracting from Empty Heap

```python
# ‚ùå Wrong: No check for empty
def bad_extract(heap):
    root = heap[0]  # IndexError!
    heap[0] = heap.pop()

# ‚úÖ Correct: Check first
def good_extract(heap):
    if not heap:
        return None
    root = heap[0]
    ...
```

### 2. Wrong Child Selection for Max-Heap

```python
# ‚ùå Wrong: Using min comparison for max-heap
if heap[left] < heap[largest]:  # Should be >
    largest = left

# ‚úÖ Correct: Max-heap uses > comparison
if heap[left] > heap[largest]:
    largest = left
```

### 3. Forgetting Edge Case: Heap of Size 1

```python
# ‚ùå Wrong: Assumes heap has more than 1 element
def bad_extract(heap):
    root = heap[0]
    heap[0] = heap.pop()  # If heap was size 1, now empty!
    bubble_down(heap, 0)  # Operating on empty heap!
    return root

# ‚úÖ Correct: Handle size 1 case
def good_extract(heap):
    if not heap:
        return None
    root = heap[0]
    last = heap.pop()
    if heap:  # Only set and bubble if still has elements
        heap[0] = last
        bubble_down(heap, 0)
    return root
```

### 4. Not Breaking When Property Satisfied

```python
# ‚ùå Wrong: Always goes to leaf (wastes time)
while left < n:
    if heap[left] < heap[i]:
        heap[i], heap[left] = heap[left], heap[i]
    i = left
    left = 2 * i + 1

# ‚úÖ Correct: Break when property satisfied
while True:
    smallest = i
    if left < n and heap[left] < heap[smallest]:
        smallest = left
    if right < n and heap[right] < heap[smallest]:
        smallest = right
    if smallest == i:
        break  # No violation, stop
    heap[i], heap[smallest] = heap[smallest], heap[i]
    i = smallest
```

---

## üìù Practice Problems (Progressive)

### Easy (Understand extract)
- [ ] Implement extract for min-heap
- [ ] Implement extract for max-heap
- [ ] [Last Stone Weight (LC 1046)](https://leetcode.com/problems/last-stone-weight/)

### Medium (Apply extract)
- [ ] [Kth Largest Element (LC 215)](https://leetcode.com/problems/kth-largest-element-in-an-array/)
- [ ] [Top K Frequent Elements (LC 347)](https://leetcode.com/problems/top-k-frequent-elements/)

### Hard (Master extract)
- [ ] [Merge K Sorted Lists (LC 23)](https://leetcode.com/problems/merge-k-sorted-lists/)
- [ ] [Sliding Window Median (LC 480)](https://leetcode.com/problems/sliding-window-median/)

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement extract for min-heap
- **Day 3:** Implement extract for max-heap
- **Day 7:** Trace through extract with example
- **Day 14:** Use heapreplace and heappushpop
- **Day 30:** Implement heap sort using extract

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Explain This in Interviews</strong></summary>

**Describing the operation:**
"Extract saves the root, moves the last element to the root position to maintain the complete tree, then bubbles down by comparing with children and swapping with the smaller (for min-heap) or larger (for max-heap) child until the property is restored."

**Why move last to root:**
"Moving the last element to root is key - it maintains the complete tree structure in O(1). We only need to fix the heap property, which takes O(log n) as we traverse from root to at most a leaf."

**Common follow-up:**
"What if we need to remove an arbitrary element?"
‚Üí "That's more complex - we'd need to find it O(n), move last to that position, then either bubble up or down depending on the replacement value."

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand concept | 10-15 min | Draw examples |
| Implement from scratch | 15-20 min | Bubble down logic |
| Handle edge cases | 5-10 min | Empty, size 1 |
| Use for heap sort | 20-25 min | Apply repeatedly |

---

## üí° Key Insight

> **Extract swaps root with last (O(1)) then fixes downward (O(log n)).** The trick is that moving the last element to root preserves the complete tree structure. We then only need to restore the heap property along a single path from root to leaf. Since the tree height is log n, this is efficient.

---

## üîó Related

- **Previous:** [Insert Operation](./2.1-Insert.md)
- **Next:** [Peek Operation](./2.3-Peek.md)
- **Related:** [Heapify](./2.4-Heapify.md) | [Heap Sort](../08-Heap-Sort/8.1-Heap-Sort-Algorithm.md)
