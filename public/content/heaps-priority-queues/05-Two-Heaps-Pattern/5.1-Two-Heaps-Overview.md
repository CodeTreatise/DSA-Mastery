# 5.1 Two Heaps Pattern Overview

## Pattern Definition

The **Two Heaps pattern** uses a **max-heap** and a **min-heap** together to efficiently track the median or maintain a balanced partition of elements.

```
Two Heaps = Max-heap (smaller half) + Min-heap (larger half)

            Max-heap              Min-heap
         (smaller half)        (larger half)
              â–²                     â–²
              â”‚                     â”‚
         [1, 2, 3]              [4, 5, 6]
              â”‚                     â”‚
          max = 3              min = 4
              â”‚                     â”‚
              â””â”€â”€â”€â”€â”€â”€â”€ median â”€â”€â”€â”€â”€â”€â”˜
                      = 3.5
```

This is **Grokking Pattern #9** and appears in approximately **~2%** of interview problems.

---

## ğŸ¯ Pattern Recognition

<details>
<summary><strong>How to Identify This Pattern</strong></summary>

**Primary signals:**
- Need to find **median** in a stream
- Need to **partition** elements into two balanced groups
- Need the **largest of small half** AND **smallest of large half**
- Sliding window median problems

**Keywords in problem statement:**
- "find the median"
- "streaming data"
- "balance", "partition"
- "middle element"

**The core insight:**
```
If we keep elements partitioned:
- Smaller half in MAX-heap â†’ get maximum in O(1)
- Larger half in MIN-heap â†’ get minimum in O(1)
- Median = function of these two roots
```

</details>

---

## âœ… When to Use

- Finding median in a data stream
- Sliding window median
- Maintaining balanced partitions
- Need both "max of smaller half" and "min of larger half"

## âŒ When NOT to Use

| Scenario | Why Not | Alternative |
|----------|---------|-------------|
| Static array median | One-time query |" Sort or QuickSelect O(n) "|
| Need Kth element (k varies) | Two heaps fixed at middle | Single heap or order statistics |
| Need mode, not median | Different statistic | Hash map |
| Very small dataset | Overhead not worth it | Sort each time |

---

## ğŸ”— Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Heap Basics](../01-Heap-Fundamentals/1.1-What-Is-Heap.md)
- [Heap Operations](../02-Heap-Operations/2.1-Insert.md)
- Min-heap vs Max-heap

**After mastering this:**
- Sliding Window Median (LC 480)
- IPO problem (LC 502)
- Custom partitioning problems

**Combines with:**
- Sliding Window pattern
- Stream processing

</details>

---

## ğŸ“ How It Works

### Core Idea: Balanced Partitioning

```
Stream: 1, 5, 3, 8, 2, 9

Goal: Always know the median efficiently

Strategy:
1. Keep smaller half in MAX-heap (get max in O(1))
2. Keep larger half in MIN-heap (get min in O(1))
3. Balance sizes: |max_heap| - |min_heap| â‰¤ 1

After processing all elements:
    MAX-heap (smaller)    MIN-heap (larger)
         [3]                  [5]
        / \                  / \
       1   2                8   9

    max of smaller = 3    min of larger = 5
    
    Median = (3 + 5) / 2 = 4.0
```

### The Balancing Rules

```
Rule 1: Sizes differ by at most 1
        len(max_heap) - len(min_heap) âˆˆ {0, 1}
        
Rule 2: All elements in max_heap â‰¤ all elements in min_heap
        max(max_heap) â‰¤ min(min_heap)
        
To maintain these invariants:
1. Add new element to appropriate heap
2. Rebalance if sizes differ by more than 1
3. If Rule 2 violated, swap roots
```

### Step-by-Step Algorithm

```
addNum(num):
    1. If num â‰¤ max of smaller half (or smaller half empty):
         Push to max_heap (smaller half)
       Else:
         Push to min_heap (larger half)
         
    2. Rebalance:
       If len(max_heap) > len(min_heap) + 1:
         Move root of max_heap to min_heap
       If len(min_heap) > len(max_heap):
         Move root of min_heap to max_heap
         
findMedian():
    If len(max_heap) > len(min_heap):
        return max_heap.peek()  // Odd count
    Else:
        return (max_heap.peek() + min_heap.peek()) / 2
```

### Visual Trace

```
Stream: 2, 3, 4

Add 2:
  max_heap: [2]    min_heap: []
  median = 2

Add 3:
  max_heap: [2]    min_heap: [3]  (3 > 2, goes to min_heap)
  median = (2 + 3) / 2 = 2.5

Add 4:
  max_heap: [2]    min_heap: [3, 4]  (4 > 2, goes to min_heap)
  Rebalance! min_heap too big
  Move 3 from min_heap to max_heap
  max_heap: [3, 2]    min_heap: [4]
  median = 3

Final state:
      MAX-heap          MIN-heap
        [3]               [4]
       /
     [2]

median = 3 (odd count, max_heap is larger)
```

---

## ğŸ’» Code Implementation

### Template: Find Median from Data Stream

**Python:**
```python
import heapq

class MedianFinder:
    """
    Two Heaps pattern for finding median in O(1).
    
    - max_heap: stores SMALLER half (negate for max-heap behavior)
    - min_heap: stores LARGER half
    
    Invariant: 0 â‰¤ len(max_heap) - len(min_heap) â‰¤ 1
    """
    
    def __init__(self):
        self.max_heap = []  # Smaller half (negated for max-heap)
        self.min_heap = []  # Larger half
    
    def addNum(self, num: int) -> None:
        """Add number maintaining balanced heaps. O(log n)"""
        # Step 1: Add to appropriate heap
        if not self.max_heap or num <= -self.max_heap[0]:
            heapq.heappush(self.max_heap, -num)
        else:
            heapq.heappush(self.min_heap, num)
        
        # Step 2: Rebalance
        # max_heap can have at most 1 more element than min_heap
        if len(self.max_heap) > len(self.min_heap) + 1:
            val = -heapq.heappop(self.max_heap)
            heapq.heappush(self.min_heap, val)
        elif len(self.min_heap) > len(self.max_heap):
            val = heapq.heappop(self.min_heap)
            heapq.heappush(self.max_heap, -val)
    
    def findMedian(self) -> float:
        """Return median in O(1)"""
        if len(self.max_heap) > len(self.min_heap):
            return -self.max_heap[0]
        return (-self.max_heap[0] + self.min_heap[0]) / 2


# Usage:
# mf = MedianFinder()
# mf.addNum(1)
# mf.addNum(2)
# mf.findMedian()  # â†’ 1.5
# mf.addNum(3)
# mf.findMedian()  # â†’ 2.0
```

**JavaScript:**
```javascript
class MedianFinder {
    constructor() {
        this.maxHeap = new MaxHeap();  // Smaller half
        this.minHeap = new MinHeap();  // Larger half
    }
    
    addNum(num) {
        // Add to appropriate heap
        if (this.maxHeap.size() === 0 || num <= this.maxHeap.peek()) {
            this.maxHeap.push(num);
        } else {
            this.minHeap.push(num);
        }
        
        // Rebalance
        if (this.maxHeap.size() > this.minHeap.size() + 1) {
            this.minHeap.push(this.maxHeap.pop());
        } else if (this.minHeap.size() > this.maxHeap.size()) {
            this.maxHeap.push(this.minHeap.pop());
        }
    }
    
    findMedian() {
        if (this.maxHeap.size() > this.minHeap.size()) {
            return this.maxHeap.peek();
        }
        return (this.maxHeap.peek() + this.minHeap.peek()) / 2;
    }
}

// MinHeap and MaxHeap implementations needed (see heap fundamentals)
```

### Alternative: Always Add to Max-Heap First

```python
class MedianFinder:
    """
    Simplified: Always add to max_heap first, then balance.
    """
    
    def __init__(self):
        self.small = []  # max-heap (negated)
        self.large = []  # min-heap
    
    def addNum(self, num: int) -> None:
        # Always add to max-heap first
        heapq.heappush(self.small, -num)
        
        # Ensure max(small) â‰¤ min(large)
        if self.large and -self.small[0] > self.large[0]:
            val = -heapq.heappop(self.small)
            heapq.heappush(self.large, val)
        
        # Balance sizes
        if len(self.small) > len(self.large) + 1:
            val = -heapq.heappop(self.small)
            heapq.heappush(self.large, val)
        elif len(self.large) > len(self.small):
            val = heapq.heappop(self.large)
            heapq.heappush(self.small, -val)
    
    def findMedian(self) -> float:
        if len(self.small) > len(self.large):
            return -self.small[0]
        return (-self.small[0] + self.large[0]) / 2
```

---

## âš¡ Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| addNum |" O(log n) "| - | Heap push + potential rebalance |
| findMedian |" O(1) "| - | Just peek at roots |
| Total space | - |" O(n) "| Store all elements |

**Why O(log n) for add:**
- Push to heap: O(log n)
- Pop from heap: O(log n)
- At most 3 heap operations per add

---

## ğŸ”„ Variations

| Variation | Modification | Problem |
|-----------|--------------|---------|
| **Sliding Window Median** | Add lazy deletion | [LC 480](https://leetcode.com/problems/sliding-window-median/) |
| **Maximize Capital** | Two heaps for profit/capital | [LC 502 - IPO](https://leetcode.com/problems/ipo/) |
| **Kth Element (fixed k)** | Adjust balance to k vs n-k | Custom |
| **Remove median** | Need to track median element | Extension |

---

## âš ï¸ Common Mistakes

### 1. Forgetting to Negate for Max-Heap

```python
# âŒ Wrong: Treating small as min-heap
heapq.heappush(self.small, num)

# âœ… Correct: Negate for max-heap behavior in Python
heapq.heappush(self.small, -num)
# And remember to negate when retrieving!
return -self.small[0]
```

### 2. Wrong Balance Direction

```python
# âŒ Wrong: max_heap can be smaller than min_heap
# This breaks the convention for odd counts

# âœ… Correct: max_heap should have the extra element
# len(max_heap) âˆˆ {len(min_heap), len(min_heap) + 1}
```

### 3. Not Handling Empty Heaps

```python
# âŒ Wrong: Accessing empty heap
def findMedian(self):
    return (-self.small[0] + self.large[0]) / 2  # Crashes if one is empty

# âœ… Correct: Check sizes first
def findMedian(self):
    if len(self.small) > len(self.large):
        return -self.small[0]
    return (-self.small[0] + self.large[0]) / 2
```

### 4. Incorrect Comparison for First Element

```python
# âŒ Wrong: Comparing with empty max-heap
if num <= -self.max_heap[0]:  # IndexError!

# âœ… Correct: Check if heap is empty first
if not self.max_heap or num <= -self.max_heap[0]:
    heapq.heappush(self.max_heap, -num)
```

---

## ğŸ“ Practice Problems (Progressive)

### Easy (Build intuition)
- [ ] [Last Stone Weight (LC 1046)](https://leetcode.com/problems/last-stone-weight/) - Single heap warm-up

### Medium (Core Two Heaps)
- [ ] [Find Median from Data Stream (LC 295)](https://leetcode.com/problems/find-median-from-data-stream/) - **Classic problem**
- [ ] [IPO (LC 502)](https://leetcode.com/problems/ipo/) - Two heaps for profit/capital

### Hard (Advanced applications)
- [ ] [Sliding Window Median (LC 480)](https://leetcode.com/problems/sliding-window-median/) - Lazy deletion
- [ ] [Find Right Interval (LC 436)](https://leetcode.com/problems/find-right-interval/) - Sorted endpoints

<details>
<summary><strong>ğŸ§  Spaced Repetition Schedule</strong></summary>

- **Day 1:** Implement MedianFinder from scratch
- **Day 3:** Trace through with example [2, 3, 4]
- **Day 7:** Implement with "always add to max-heap first" variant
- **Day 14:** Solve IPO (different two heaps application)
- **Day 30:** Attempt Sliding Window Median

</details>

---

## ğŸ¤ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening statement:**
"For streaming median, I'll use the Two Heaps pattern. I'll maintain a max-heap for the smaller half and a min-heap for the larger half. The key insight is that the median is always at or between the roots of these two heaps."

**Drawing the structure:**
```
"I'll draw this as:
    Smaller half (max-heap)  |  Larger half (min-heap)
          [3]                |       [5]
         / \                 |      / \
        1   2                |     7   8
        
Median = (3 + 5) / 2 = 4"
```

**Explaining invariants:**
"I maintain two invariants:
1. Size difference is at most 1
2. All elements in small â‰¤ all elements in large"

**Follow-up questions:**
- *"What if we need to remove elements?"* â†’ Lazy deletion with hash map
- *"What about sliding window?"* â†’ Track invalid elements, clean during rebalance

</details>

**Company Focus:**

| Company | Frequency | Notes |
|---------|-----------|-------|
| Amazon | â­â­â­â­ | LC 295 commonly asked |
| Google | â­â­â­â­ | May ask follow-ups |
| Microsoft | â­â­â­ | Standard median problem |
| Apple | â­â­â­ | Data stream questions |

---

## â±ï¸ Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Understand pattern | 10-15 min | Draw diagrams |
| Implement MedianFinder | 15-20 min | Watch for negation |
| Handle edge cases | 5-10 min | Empty heaps, odd/even |
| Master variations | 1-2 hours | Multiple problems |

---

## ğŸ’¡ Key Insight

> **Two Heaps let us efficiently access the middle of a dynamic stream.** By partitioning into smaller half (max-heap) and larger half (min-heap), the median is always at or between the two roots. The magic is that heap operations are O(log n) while median access is O(1).

---

## ğŸ”— Related

- **Prerequisites:** [Heap Basics](../01-Heap-Fundamentals/1.1-What-Is-Heap.md)
- **Core Problem:** [Find Median from Data Stream (LC 295)](./5.2-Median-Stream-LC295.md)
- **Related Pattern:** [Top K Elements](../04-Top-K-Pattern/4.1-Top-K-Overview.md)
- **Advanced:** [Sliding Window Median](./5.3-Sliding-Window-Median-LC480.md)
