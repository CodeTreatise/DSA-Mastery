# Greedy Patterns Cheat Sheet

> **Quick reference for all greedy patterns in one place**

---

## ðŸŽ¯ Pattern Recognition Decision Tree

```
Is it about intervals?
â”œâ”€â”€ Yes â†’ 
â”‚   â”œâ”€â”€ Counting non-overlapping? â†’ Sort by END
â”‚   â”œâ”€â”€ Merging overlapping? â†’ Sort by START
â”‚   â””â”€â”€ Meeting rooms/resources? â†’ Sort by START + Heap
â”‚
â”œâ”€â”€ Is it about reaching/jumping?
â”‚   â”œâ”€â”€ Can you reach end? â†’ Track max_reach
â”‚   â”œâ”€â”€ Minimum jumps? â†’ Track current_end, next_end
â”‚   â””â”€â”€ Circular (gas station)? â†’ Track running surplus
â”‚
â”œâ”€â”€ Is it about scheduling?
â”‚   â”œâ”€â”€ Meet deadlines? â†’ Sort by DEADLINE
â”‚   â”œâ”€â”€ Maximize profit? â†’ Sort by PROFIT desc + Heap
â”‚   â””â”€â”€ With cooldowns? â†’ Use heap + waiting queue
â”‚
â”œâ”€â”€ Is it a matching problem?
â”‚   â”œâ”€â”€ Two sets to match? â†’ Sort BOTH
â”‚   â””â”€â”€ Binary choice (A or B)? â†’ Sort by DIFFERENCE
â”‚
â””â”€â”€ Other patterns
    â”œâ”€â”€ Both directions matter? â†’ Two-pass (Lâ†’R, Râ†’L)
    â”œâ”€â”€ Track last occurrence? â†’ Hash map + expand
    â””â”€â”€ Fractional allowed? â†’ Sort by RATIO
```

---

## ðŸ“Š Sorting Strategies

| Problem Type | Sort By | Order | Key |
|--------------|---------|-------|-----|
| Activity Selection | End | â†‘ Asc | `intervals.sort(key=lambda x: x[1])` |
| Merge Intervals | Start | â†‘ Asc | `intervals.sort(key=lambda x: x[0])` |
| Meet Deadlines | Deadline | â†‘ Asc | `tasks.sort(key=lambda x: x[1])` |
| Job Sequencing | Profit | â†“ Desc | `jobs.sort(key=lambda x: -x.profit)` |
| Fractional Knapsack | Ratio | â†“ Desc | `items.sort(key=lambda x: x.val/x.wt, reverse=True)` |
| Two City | Difference | â†‘ Asc | `costs.sort(key=lambda x: x[0]-x[1])` |
| Matching | Both | â†‘ Asc | `a.sort(); b.sort()` |

---

## ðŸ’» Code Templates

### Interval - Activity Selection (Max Non-Overlapping)

```python
def maxNonOverlapping(intervals):
    intervals.sort(key=lambda x: x[1])  # Sort by END
    count = 0
    last_end = float('-inf')
    
    for start, end in intervals:
        if start >= last_end:
            count += 1
            last_end = end
    
    return count
```

### Interval - Merge

```python
def merge(intervals):
    intervals.sort(key=lambda x: x[0])  # Sort by START
    merged = [intervals[0]]
    
    for start, end in intervals[1:]:
        if start <= merged[-1][1]:
            merged[-1][1] = max(merged[-1][1], end)
        else:
            merged.append([start, end])
    
    return merged
```

### Interval - Meeting Rooms (Min Resources)

```python
import heapq

def minRooms(intervals):
    intervals.sort(key=lambda x: x[0])
    heap = []  # End times
    
    for start, end in intervals:
        if heap and heap[0] <= start:
            heapq.heappop(heap)
        heapq.heappush(heap, end)
    
    return len(heap)
```

### Jump - Reachability

```python
def canJump(nums):
    max_reach = 0
    
    for i in range(len(nums)):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + nums[i])
    
    return True
```

### Jump - Minimum Jumps

```python
def minJumps(nums):
    if len(nums) <= 1:
        return 0
    
    jumps = 0
    current_end = 0
    next_end = 0
    
    for i in range(len(nums) - 1):
        next_end = max(next_end, i + nums[i])
        
        if i == current_end:
            jumps += 1
            current_end = next_end
    
    return jumps
```

### Circular - Gas Station

```python
def gasStation(gas, cost):
    if sum(gas) < sum(cost):
        return -1
    
    start = 0
    tank = 0
    
    for i in range(len(gas)):
        tank += gas[i] - cost[i]
        if tank < 0:
            start = i + 1
            tank = 0
    
    return start
```

### Two-Pass

```python
def twoPass(arr):
    n = len(arr)
    result = [initial] * n
    
    # Left to right
    for i in range(1, n):
        if condition(arr[i], arr[i-1]):
            result[i] = update_left(result[i-1])
    
    # Right to left
    for i in range(n-2, -1, -1):
        if condition(arr[i], arr[i+1]):
            result[i] = max(result[i], update_right(result[i+1]))
    
    return result
```

### Matching - Two Pointer

```python
def match(a, b):
    a.sort()
    b.sort()
    i = j = 0
    count = 0
    
    while i < len(a) and j < len(b):
        if condition(a[i], b[j]):
            count += 1
            i += 1
        j += 1
    
    return count
```

---

## âš¡ Complexity Reference

| Pattern | Time | Space |
|---------|------|-------|
| Most greedy | O(n log n) | O(1) - O(n) |
| With heap | O(n log k) | O(k) |
| Two-pass | O(n) | O(n) |
| Jump games | O(n) | O(1) |

---

## âš ï¸ Common Mistakes Quick Fix

| Mistake | Fix |
|---------|-----|
| Wrong sort key | Activity=END, Merge=START |
| Forgot to sort | Always sort first for intervals |
| Off-by-one in loops | `while left <= right` for single element |
| Not tracking start in two-pass | Track `start = i + 1` after partition |
| Max-heap in Python | Negate values: `heappush(h, -val)` |

---

## ðŸŽ¤ Interview Quick Phrases

**Opening:**
> "This looks like a greedy problem because [local optimal â†’ global]"

**Sorting:**
> "I'll sort by [X] because it lets me [reason]"

**Proof:**
> "Greedy works because any swap with a different choice wouldn't improve the result"

**Complexity:**
> "Time is O(n log n) for sort, O(n) for greedy. Space is O(1) / O(n)."

---

## ðŸ“ Top 10 Problems to Know

| # | Problem | Pattern | Must Know |
|---|---------|---------|-----------|
| 1 | Merge Intervals | Sort by start | â­â­â­â­â­ |
| 2 | Jump Game | Max reach | â­â­â­â­â­ |
| 3 | Meeting Rooms II | Sort + heap | â­â­â­â­â­ |
| 4 | Task Scheduler | Frequency | â­â­â­â­ |
| 5 | Gas Station | Circular | â­â­â­â­ |
| 6 | Jump Game II | BFS levels | â­â­â­â­ |
| 7 | Candy | Two-pass | â­â­â­ |
| 8 | Partition Labels | Last occur | â­â­â­ |
| 9 | Two City Scheduling | Difference | â­â­â­ |
| 10 | Assign Cookies | Match | â­â­â­ |

---

## ðŸ”— When Greedy â‰  Optimal

| Problem | Why Greedy Fails | Use Instead |
|---------|------------------|-------------|
| 0/1 Knapsack | Can't take fractions | DP |
| Coin Change (general) | Non-canonical systems | DP |
| Longest Increasing Subsequence | Choices affect future | DP |
| All Paths in Graph | Need all options | DFS/BFS |
| Partition Equal Subset | Combination problem | DP |

---

> **ðŸ’¡ Remember:** Sort â†’ Greedy Loop â†’ Done. Most greedy problems are O(n log n) due to sorting.
