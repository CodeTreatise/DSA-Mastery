# 8.2 Dijkstra's Algorithm

> **The gold standard for shortest paths in non-negative weighted graphs**
>
> ‚è±Ô∏è **Study Time:** 45 min | üìä **Priority:** Critical | üéØ **Pattern:** Greedy + Priority Queue

---

## Overview

**Dijkstra's Algorithm** finds the shortest path from a source node to all other nodes in a graph with **non-negative edge weights**. It's a greedy algorithm that always processes the nearest unvisited node.

**Named after:** Edsger W. Dijkstra (1959) - Conceived in 20 minutes at a caf√©!

```
Core Idea:
1. Start with source at distance 0, all others at ‚àû
2. Always process the closest unvisited node
3. Update neighbors if we found a shorter path
4. Repeat until all nodes processed
```

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Dijkstra Problems</strong></summary>

**Look for these signals:**
- Finding shortest/minimum cost path
- Weighted graph (not all edges equal)
- Single source, possibly single destination
- **All weights are non-negative**

**Keywords in problem statement:**
- "minimum cost", "shortest path", "cheapest"
- "network delay", "travel time"
- "least effort", "minimum number of operations"

**NOT Dijkstra if:**
- Negative edge weights (use Bellman-Ford)
- Need all-pairs shortest path (use Floyd-Warshall)
- Unweighted graph (use BFS)

</details>

---

## ‚úÖ When to Use

- Weighted graphs with **non-negative** weights
- Finding shortest path from single source
- GPS/navigation systems
- Network routing protocols
- Any "minimum cost to reach" problem

## ‚ùå When NOT to Use

| Scenario | Better Choice | Why |
|----------|--------------|-----|
| Negative weights | Bellman-Ford | Dijkstra gives wrong answer |
| Unweighted graph | BFS | Simpler, same result |
| All pairs needed | Floyd-Warshall | One run vs V runs |
| Dense graph, all pairs | Floyd-Warshall | O(V¬≥) vs O(V √ó E log V) |

---

## üîó Concept Map

<details>
<summary><strong>Prerequisites & Next Steps</strong></summary>

**Before this, you should know:**
- [Graph Representation](../02-Graph-Representation/2.1-Adjacency-List.md)
- [BFS Pattern](../03-BFS-Traversal/3.1-BFS-Fundamentals.md)
- [Priority Queue/Heap](../../08-Heaps-Priority-Queues.md)

**After mastering this:**
- [Bellman-Ford](./8.3-Bellman-Ford.md) - Handle negatives
- [A* Algorithm](../12-Advanced/12.1-Advanced-Overview.md) - With heuristics
- [Prim's MST](../11-MST/11.2-Prims-Algorithm.md) - Similar technique

**Combines with:**
- State-space modeling (track additional state in tuple)
- Binary search for optimization problems
- Dynamic programming perspective

</details>

---

## üìê How It Works

**The Greedy Insight:**
> If we always process the node with smallest known distance, and all edges are non-negative, we can never find a shorter path to that node later.

### Step-by-Step Visualization

```
Graph:          Step 1: Start at A
    2                dist[A] = 0
A ‚îÄ‚îÄ‚îÄ‚Üí B            Process A, update neighbors
‚îÇ       ‚îÇ   
1       3           dist = {A:0, B:2, C:1, D:‚àû}
‚Üì       ‚Üì           heap = [(1,C), (2,B)]
C ‚îÄ‚îÄ‚îÄ‚Üí D
    4

Step 2: Process C (smallest dist=1)
  dist[D] = min(‚àû, 1+4) = 5
  heap = [(2,B), (5,D)]

Step 3: Process B (dist=2)
  dist[D] = min(5, 2+3) = 5 (no change)
  heap = [(5,D)]

Step 4: Process D (dist=5)
  No neighbors to update

Final: dist = {A:0, B:2, C:1, D:5}
```

---

## üíª Code Implementation

**Python (Production-Ready):**
```python
import heapq
from typing import Dict, List, Tuple, Optional
from collections import defaultdict

def dijkstra(
    graph: Dict[int, List[Tuple[int, int]]], 
    start: int, 
    n: int
) -> List[int]:
    """
    Dijkstra's shortest path algorithm.
    
    Args:
        graph: Adjacency list where graph[u] = [(v, weight), ...]
        start: Source node
        n: Number of nodes (0 to n-1)
    
    Returns:
        List of distances from start to each node
    
    Time: O(E log V)
    Space: O(V)
    """
    dist = [float('inf')] * n
    dist[start] = 0
    heap = [(0, start)]  # (distance, node)
    
    while heap:
        d, u = heapq.heappop(heap)
        
        # Skip if we've already found a better path
        if d > dist[u]:
            continue
        
        # Relax all neighbors
        for v, weight in graph[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(heap, (dist[v], v))
    
    return dist


def dijkstra_with_path(
    graph: Dict[int, List[Tuple[int, int]]], 
    start: int, 
    end: int,
    n: int
) -> Tuple[int, List[int]]:
    """
    Dijkstra with path reconstruction.
    
    Returns: (distance, path) or (-1, []) if unreachable
    """
    dist = [float('inf')] * n
    dist[start] = 0
    parent = [-1] * n
    heap = [(0, start)]
    
    while heap:
        d, u = heapq.heappop(heap)
        
        if d > dist[u]:
            continue
        
        # Early termination if only need path to end
        if u == end:
            break
        
        for v, weight in graph[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                parent[v] = u
                heapq.heappush(heap, (dist[v], v))
    
    # Reconstruct path
    if dist[end] == float('inf'):
        return -1, []
    
    path = []
    current = end
    while current != -1:
        path.append(current)
        current = parent[current]
    
    return dist[end], path[::-1]


# Example usage
graph = {
    0: [(1, 2), (2, 1)],
    1: [(3, 3)],
    2: [(3, 4)],
    3: []
}
print(dijkstra(graph, 0, 4))  # [0, 2, 1, 5]
print(dijkstra_with_path(graph, 0, 3, 4))  # (5, [0, 1, 3])
```

**JavaScript:**
```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    push(item) {
        this.heap.push(item);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        if (this.heap.length === 0) return null;
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
        }
        return min;
    }
    
    isEmpty() {
        return this.heap.length === 0;
    }
    
    _bubbleUp(index) {
        while (index > 0) {
            const parent = Math.floor((index - 1) / 2);
            if (this.heap[parent][0] <= this.heap[index][0]) break;
            [this.heap[parent], this.heap[index]] = 
                [this.heap[index], this.heap[parent]];
            index = parent;
        }
    }
    
    _bubbleDown(index) {
        const n = this.heap.length;
        while (true) {
            let smallest = index;
            const left = 2 * index + 1;
            const right = 2 * index + 2;
            
            if (left < n && this.heap[left][0] < this.heap[smallest][0]) {
                smallest = left;
            }
            if (right < n && this.heap[right][0] < this.heap[smallest][0]) {
                smallest = right;
            }
            if (smallest === index) break;
            
            [this.heap[smallest], this.heap[index]] = 
                [this.heap[index], this.heap[smallest]];
            index = smallest;
        }
    }
}

function dijkstra(graph, start, n) {
    const dist = new Array(n).fill(Infinity);
    dist[start] = 0;
    const heap = new MinHeap();
    heap.push([0, start]);
    
    while (!heap.isEmpty()) {
        const [d, u] = heap.pop();
        
        if (d > dist[u]) continue;
        
        for (const [v, weight] of (graph[u] || [])) {
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                heap.push([dist[v], v]);
            }
        }
    }
    
    return dist;
}

// Example usage
const graph = {
    0: [[1, 2], [2, 1]],
    1: [[3, 3]],
    2: [[3, 4]],
    3: []
};
console.log(dijkstra(graph, 0, 4)); // [0, 2, 1, 5]
```

---

## ‚ö° Complexity Analysis

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Standard | O(E log V) | O(V) | With binary heap |
| Dense (E ‚âà V¬≤) | O(V¬≤ log V) | O(V) | Consider Floyd-Warshall |
| Sparse (E ‚âà V) | O(V log V) | O(V) | Very efficient |
| Fibonacci Heap | O(E + V log V) | O(V) | Theoretical best |

**Why O(E log V):**
- Each edge is relaxed at most once: O(E) relaxations
- Each relaxation may push to heap: O(log V) per push
- Total: O(E log V)

**Why we skip outdated entries:**
```python
if d > dist[u]:
    continue
```
Without this check, same node can be processed multiple times. While the asymptotic complexity remains O(E log V), skipping stale entries significantly improves practical performance by avoiding redundant work.

---

## üîÑ Variations

### 1. State-Space Dijkstra

Track additional state beyond just the node:

```python
def cheapest_flights_k_stops(n, flights, src, dst, k):
    """
    State: (cost, node, stops_remaining)
    LC 787: Cheapest Flights Within K Stops
    """
    graph = defaultdict(list)
    for u, v, price in flights:
        graph[u].append((v, price))
    
    # (cost, node, stops_remaining)
    heap = [(0, src, k + 1)]
    best = {}  # (node, stops) -> best cost
    
    while heap:
        cost, node, stops = heapq.heappop(heap)
        
        if node == dst:
            return cost
        
        if stops == 0:
            continue
        
        # Check if we've seen this state with better cost
        if (node, stops) in best:
            continue
        best[(node, stops)] = cost
        
        for neighbor, price in graph[node]:
            heapq.heappush(heap, (cost + price, neighbor, stops - 1))
    
    return -1
```

### 2. Modified Edge Weights

Sometimes the "weight" is computed differently:

```python
def min_effort_path(heights):
    """
    Edge weight = abs(height difference)
    Path cost = MAX edge weight (not sum!)
    LC 1631: Path With Minimum Effort
    """
    rows, cols = len(heights), len(heights[0])
    dist = [[float('inf')] * cols for _ in range(rows)]
    dist[0][0] = 0
    heap = [(0, 0, 0)]  # (effort, row, col)
    
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    while heap:
        effort, r, c = heapq.heappop(heap)
        
        if r == rows - 1 and c == cols - 1:
            return effort
        
        if effort > dist[r][c]:
            continue
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                # Edge weight = height difference
                edge_effort = abs(heights[nr][nc] - heights[r][c])
                # Path cost = MAX of edges (not sum!)
                new_effort = max(effort, edge_effort)
                
                if new_effort < dist[nr][nc]:
                    dist[nr][nc] = new_effort
                    heapq.heappush(heap, (new_effort, nr, nc))
    
    return dist[rows-1][cols-1]
```

### 3. Multi-Source Dijkstra

Start from multiple sources simultaneously:

```python
def walls_and_gates(rooms):
    """
    LC 286: Distance to nearest gate
    Start Dijkstra from all gates at once
    """
    if not rooms:
        return
    
    INF = 2147483647
    GATE = 0
    rows, cols = len(rooms), len(rooms[0])
    
    # Initialize heap with all gates
    heap = []
    for r in range(rows):
        for c in range(cols):
            if rooms[r][c] == GATE:
                heapq.heappush(heap, (0, r, c))
    
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    while heap:
        dist, r, c = heapq.heappop(heap)
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if (0 <= nr < rows and 0 <= nc < cols 
                and rooms[nr][nc] == INF):
                rooms[nr][nc] = dist + 1
                heapq.heappush(heap, (dist + 1, nr, nc))
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Using Dijkstra with Negative Weights

```python
# ‚ùå WRONG: Dijkstra fails with negative edges
graph = {
    0: [(1, 4), (2, 1)],
    1: [(2, -3)],  # Negative edge!
    2: []
}
# Dijkstra says dist[2] = 1 (via 0‚Üí2)
# But 0‚Üí1‚Üí2 = 4 + (-3) = 1 would be found later!

# ‚úÖ CORRECT: Use Bellman-Ford for negative weights
```

### 2. Not Skipping Outdated Heap Entries

```python
# ‚ùå WRONG: Process every heap entry
while heap:
    d, u = heapq.heappop(heap)
    for v, w in graph[u]:
        # May process same node many times!

# ‚úÖ CORRECT: Skip outdated entries
while heap:
    d, u = heapq.heappop(heap)
    if d > dist[u]:
        continue  # Already found better
    for v, w in graph[u]:
        # ...
```

### 3. Initializing Distance Wrong

```python
# ‚ùå WRONG: Using 0 as default
dist = [0] * n  # Now we can't distinguish visited!

# ‚úÖ CORRECT: Use infinity
dist = [float('inf')] * n
dist[start] = 0
```

### 4. Forgetting Self-Loops or Parallel Edges

```python
# ‚ùå WRONG: Assuming no parallel edges
graph[u] = (v, weight)  # Overwrites previous edge!

# ‚úÖ CORRECT: Handle multiple edges
graph[u].append((v, weight))  # Keep all edges
```

---

## üìù Practice Problems (Progressive)

### Easy (Learn basic Dijkstra)
- [ ] [Network Delay Time](https://leetcode.com/problems/network-delay-time/) - Classic implementation
- [ ] [Path with Maximum Probability](https://leetcode.com/problems/path-with-maximum-probability/) - Max instead of min

### Medium (Apply variations)
- [ ] [Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/) - Max edge in path
- [ ] [Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/) - State with stops
- [ ] [Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/) - Binary search + Dijkstra

### Hard (Master edge cases)
- [ ] [Shortest Path to Get All Keys](https://leetcode.com/problems/shortest-path-to-get-all-keys/) - State with bitmask
- [ ] [Minimum Cost to Make at Least One Valid Path](https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/) - 0-1 BFS variant

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

| Day | Activity |
|-----|----------|
| 1 | Implement basic Dijkstra from scratch |
| 3 | Solve Network Delay Time without hints |
| 7 | Implement with path reconstruction |
| 14 | Solve state-space problem (K stops) |
| 30 | Solve a hard variant |

</details>

---

## üé§ Interview Context

<details>
<summary><strong>How to Communicate This in Interviews</strong></summary>

**Opening:**
> "This is a shortest path problem with non-negative weights. I'll use Dijkstra's algorithm, which greedily processes the closest unvisited node."

**Explain the intuition:**
> "Since weights are non-negative, when we pop a node from the min-heap, we've found the shortest path to it. We can't find a shorter path by going through other nodes because they're all equally far or farther."

**Complexity discussion:**
> "With a binary heap, this runs in O(E log V) time. Each edge is relaxed at most once, and each relaxation involves a heap push."

**Edge cases to mention:**
- Disconnected nodes (return -1 or infinity)
- Self-loops (generally skip)
- Parallel edges (take minimum)

</details>

**Company Focus:**
| Company | Frequency | Notes |
|---------|-----------|-------|
| **Google** | High | Complex state-space variants |
| **Meta** | High | Standard implementation |
| **Amazon** | High | Path optimization |
| **Uber/Lyft** | Very High | Real routing use case |
| **Microsoft** | Medium | Standard implementation |

---

## ‚è±Ô∏è Time Estimates

| Activity | Time | Notes |
|----------|------|-------|
| Learn algorithm | 30 min | Core concept |
| Implement from scratch | 15 min | Interview standard |
| Solve basic problem | 20 min | Network Delay Time |
| State-space variant | 30-40 min | K Stops problem |
| Master variations | 3-4 hours | Multiple problems |

---

> **üí° Key Insight:** Dijkstra works because of the **greedy property** - once we've settled the shortest distance to a node (popped from heap), we can never improve it. This only holds when all weights are non-negative!

---

> **üîó Related:** [BFS Pattern](../03-BFS-Traversal/3.1-BFS-Fundamentals.md) | [Bellman-Ford](./8.3-Bellman-Ford.md) | [Prim's MST](../11-MST/11.2-Prims-Algorithm.md)

---

**Back:** [‚Üê Shortest Path Overview](./8.1-Shortest-Path-Overview.md) | **Next:** [Bellman-Ford ‚Üí](./8.3-Bellman-Ford.md)
