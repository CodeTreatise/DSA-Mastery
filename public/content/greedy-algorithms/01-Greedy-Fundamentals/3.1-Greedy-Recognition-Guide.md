# 3.1 Greedy Recognition Guide

> **Definition:** A systematic method to identify whether a problem can be solved with a greedy approach, based on problem patterns, keywords, and structural analysis.

---

## üéØ Pattern Recognition

<details>
<summary><strong>How to Identify Greedy Problems</strong></summary>

**Primary Signals (if 2+ present, try greedy):**

1. **Optimization goal** - maximize or minimize something
2. **Sequential decisions** - process items one at a time
3. **Local choice = global optimal** - best local choice leads to best overall
4. **Sorting helps** - answer becomes obvious after sorting
5. **No backtracking needed** - never need to undo a decision

**Secondary Signals:**

6. Intervals, scheduling, or assignment
7. "Earliest", "latest", "most", "least", "first"
8. Matching/pairing problems
9. Coverage problems (cover all with minimum)

</details>

---

## ‚úÖ When Greedy Applies

| Problem Type | Example | Greedy Criterion |
|--------------|---------|------------------|
| **Interval scheduling** | Activity Selection | End time |
| **Interval merging** | Merge Intervals | Start time |
| **Min intervals to cover** | Min Arrows | End time |
| **Jump/traversal** | Jump Game | Max reach |
| **Assignment/matching** | Assign Cookies | Sort both |
| **Fractional items** | Fractional Knapsack | Value/weight |
| **Huffman-style** | Encoding | Frequency |

---

## ‚ùå When Greedy FAILS

| Problem Type | Why Greedy Fails | Use Instead |
|--------------|------------------|-------------|
| **0/1 Knapsack** | Can't take fractions | DP |
| **Coin Change (arbitrary)** | Some coins may trap | DP |
| **Longest Path in Graph** | Local max ‚â† global max | DP/Backtracking |
| **All subsets/permutations** | Need to explore all | Backtracking |
| **Optimal BST** | Depends on frequency distribution | DP |

### The Counterexample Test

```python
def test_greedy_fails():
    """
    Classic counterexamples where greedy fails.
    """
    
    # 0/1 Knapsack - greedy fails
    items = [(10, 60), (20, 100), (30, 120)]  # (weight, value)
    capacity = 50
    # Greedy by value/weight: take (10,60), (20,100) = 160
    # Optimal: take (20,100), (30,120) = 220 ‚ùå
    
    # Coin Change - greedy fails
    coins = [1, 3, 4]
    target = 6
    # Greedy: 4+1+1 = 3 coins
    # Optimal: 3+3 = 2 coins ‚ùå
    
    # Longest Increasing Subsequence
    arr = [3, 1, 2, 10, 4, 5, 6]
    # Greedy: always take increasing = [3, 10] = 2
    # Optimal: [1, 2, 4, 5, 6] = 5 ‚ùå
```

---

## üîó Recognition Decision Tree

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            Does problem ask to OPTIMIZE?          ‚îÇ
‚îÇ          (maximize/minimize something)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚ñº                         ‚ñº
          YES                        NO
           ‚îÇ                         ‚îÇ
           ‚îÇ                    Not greedy
           ‚ñº                   (likely search/
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      enumeration)
    ‚îÇ Can you ORDER    ‚îÇ
    ‚îÇ elements to make ‚îÇ
    ‚îÇ solution obvious?‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚ñº           ‚ñº
    YES          NO
     ‚îÇ           ‚îÇ
     ‚îÇ      May need DP
     ‚ñº      or backtracking
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Does local best  ‚îÇ
‚îÇ choice lead to   ‚îÇ
‚îÇ global best?     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
  ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îê
  ‚ñº     ‚ñº
 YES    NO
  ‚îÇ     ‚îÇ
  ‚îÇ   Use DP
  ‚ñº
‚úÖ USE GREEDY!
```

---

## üìê Recognition by Problem Category

### Category 1: Interval Problems

**Signals:**
- Array of `[start, end]` pairs
- "Non-overlapping", "merge", "cover", "minimum meetings"

**Decision Guide:**

| Goal | Sort By | Pattern |
|------|---------|---------|
| Max non-overlapping | END time | Activity Selection |
| Merge overlapping | START time | Merge Intervals |
| Min to cover | END time | Min Arrows |
| Min meeting rooms | START + END | Two pointers/heap |

```python
def recognize_interval_type(problem_text):
    """Recognize interval problem type."""
    
    if "non-overlapping" in problem_text or "maximum activities" in problem_text:
        return "Sort by END time, keep non-overlapping"
    
    if "merge" in problem_text:
        return "Sort by START time, extend end"
    
    if "minimum" in problem_text and ("arrows" in problem_text or "cover" in problem_text):
        return "Sort by END time, count groups"
    
    if "meeting rooms" in problem_text and "minimum" in problem_text:
        return "Use min-heap for overlapping count"
    
    return "Unknown interval pattern"
```

---

### Category 2: Jump/Traversal Problems

**Signals:**
- Array where each element represents how far you can go
- "Can reach", "minimum jumps", "farthest"

**Decision Guide:**

| Goal | Strategy | Track |
|------|----------|-------|
| Can reach end? | Track max reachable | `max_reach` |
| Min jumps? | Track current range | `current_end`, `next_end` |
| Gas station? | Track running surplus | `tank`, `start` |

```python
def recognize_jump_type(problem_text):
    """Recognize jump problem type."""
    
    if "can reach" in problem_text or "possible" in problem_text:
        return "Track max_reachable >= target index"
    
    if "minimum jumps" in problem_text:
        return "BFS-style levels with greedy range extension"
    
    if "gas station" in problem_text or "circular" in problem_text:
        return "Track running surplus, reset when negative"
    
    return "Unknown jump pattern"
```

---

### Category 3: Assignment/Matching Problems

**Signals:**
- Two arrays to match
- "Assign", "match", "satisfy", "distribute"

**Decision Guide:**

| Goal | Strategy |
|------|----------|
| Max satisfied | Sort both, match greedily |
| Min cost assignment | Sort both, pair smallest-to-smallest |
| Pairs with constraint | Sort by constraint, two pointers |

```python
def recognize_assignment_type(problem_text):
    """Recognize assignment problem type."""
    
    if "assign" in problem_text and ("children" in problem_text or "cookies" in problem_text):
        return "Sort both arrays, two pointers"
    
    if "pair" in problem_text:
        return "Sort and match greedily"
    
    if "distribute" in problem_text:
        return "Sort by need, assign in order"
    
    return "Unknown assignment pattern"
```

---

### Category 4: Scheduling Problems

**Signals:**
- Jobs with deadlines, profits, or durations
- "Schedule", "deadline", "maximum profit"

**Decision Guide:**

| Goal | Strategy |
|------|----------|
| Max profit with deadlines | Sort by profit desc, place in latest slot |
| Min total wait time | Sort by duration (SJF) |
| Max jobs completed | Sort by deadline |

---

### Category 5: Coverage/Selection Problems

**Signals:**
- "Minimum to cover", "fewest moves", "distribute"

**Decision Guide:**

| Goal | Strategy |
|------|----------|
| Cover range with min intervals | Sort by start, extend greedily |
| Min cameras to cover tree | Post-order DFS, greedy placement |
| Min candies to distribute | Two-pass (L‚ÜíR, R‚ÜíL) |

---

## üíª Recognition Code Template

```python
def classify_greedy_problem(problem):
    """
    Attempt to classify a problem and suggest greedy approach.
    
    Returns: (is_greedy, pattern, criterion)
    """
    keywords = problem.lower()
    
    # === INTERVAL PATTERNS ===
    if any(word in keywords for word in ['interval', 'meeting', 'schedule']):
        if 'non-overlapping' in keywords or 'maximum' in keywords:
            return (True, "Interval Selection", "Sort by end time")
        if 'merge' in keywords:
            return (True, "Interval Merging", "Sort by start time")
        if 'minimum' in keywords and 'room' in keywords:
            return (True, "Meeting Rooms", "Use min-heap")
    
    # === JUMP PATTERNS ===
    if 'jump' in keywords or 'reach' in keywords:
        if 'can reach' in keywords:
            return (True, "Reachability", "Track max_reachable")
        if 'minimum' in keywords:
            return (True, "Min Jumps", "Track range boundaries")
    
    # === ASSIGNMENT PATTERNS ===
    if any(word in keywords for word in ['assign', 'match', 'pair', 'satisfy']):
        return (True, "Assignment", "Sort both, two pointers")
    
    # === KNAPSACK CHECK ===
    if 'knapsack' in keywords:
        if 'fractional' in keywords:
            return (True, "Fractional Knapsack", "Sort by value/weight")
        else:
            return (False, "0/1 Knapsack", "Use DP")
    
    # === COIN CHANGE CHECK ===
    if 'coin' in keywords and 'change' in keywords:
        return (False, "Coin Change", "Use DP (greedy only for canonical)")
    
    return (None, "Unknown", "Need more analysis")
```

```javascript
function classifyGreedyProblem(problem) {
    const keywords = problem.toLowerCase();
    
    // Interval patterns
    if (keywords.includes('interval') || keywords.includes('meeting')) {
        if (keywords.includes('non-overlapping') || keywords.includes('maximum')) {
            return { isGreedy: true, pattern: 'Interval Selection', criterion: 'Sort by end' };
        }
        if (keywords.includes('merge')) {
            return { isGreedy: true, pattern: 'Interval Merging', criterion: 'Sort by start' };
        }
    }
    
    // Jump patterns
    if (keywords.includes('jump') || keywords.includes('reach')) {
        return { isGreedy: true, pattern: 'Jump/Reach', criterion: 'Track max reachable' };
    }
    
    // Assignment patterns
    if (keywords.includes('assign') || keywords.includes('match')) {
        return { isGreedy: true, pattern: 'Assignment', criterion: 'Sort both arrays' };
    }
    
    // Traps
    if (keywords.includes('knapsack') && !keywords.includes('fractional')) {
        return { isGreedy: false, pattern: '0/1 Knapsack', criterion: 'Use DP' };
    }
    
    return { isGreedy: null, pattern: 'Unknown', criterion: 'Analyze further' };
}
```

---

## ‚ö° Quick Reference: Keyword ‚Üí Pattern

| Keywords | Pattern | Greedy? |
|----------|---------|---------|
| "intervals", "non-overlapping" | Activity Selection | ‚úÖ |
| "merge intervals" | Merge Intervals | ‚úÖ |
| "meeting rooms", "minimum rooms" | Meeting Rooms II | ‚úÖ |
| "jump", "can reach" | Jump Game | ‚úÖ |
| "minimum jumps" | Jump Game II | ‚úÖ |
| "gas station", "circular" | Gas Station | ‚úÖ |
| "assign", "satisfy children" | Assign Cookies | ‚úÖ |
| "candy", "rating" | Candy | ‚úÖ (two-pass) |
| "knapsack", "0/1" | 0/1 Knapsack | ‚ùå (DP) |
| "coin change", "minimum coins" | Coin Change | ‚ùå (DP) |
| "longest path" | Longest Path | ‚ùå (DP/DFS) |
| "all subsets" | Subsets | ‚ùå (Backtrack) |

---

## üîÑ Variations and Edge Cases

### When the Same Problem Can Be Greedy OR DP

| Variant | Greedy? | DP? |
|---------|---------|-----|
| Fractional Knapsack | ‚úÖ | Overkill |
| 0/1 Knapsack | ‚ùå | ‚úÖ |
| Unbounded Knapsack | ‚ùå | ‚úÖ |
| Coin Change (canonical coins) | ‚úÖ | Works too |
| Coin Change (arbitrary coins) | ‚ùå | ‚úÖ |

### The "Canonical" Exception

Some problems are greedy with specific input properties:

```python
# Coin change is greedy ONLY with canonical coin systems
# US coins: [25, 10, 5, 1] - greedy works!
# Random coins: [1, 3, 4] - greedy fails for target 6
```

---

## ‚ö†Ô∏è Common Recognition Mistakes

1. **Assuming optimization = greedy**
   - ‚ùå "Minimize coins" ‚Üí must be greedy
   - ‚úÖ Check if greedy choice property holds

2. **Ignoring constraints**
   - ‚ùå "0/1" constraint means whole items only ‚Üí DP
   - ‚úÖ "Fractional" means can split ‚Üí greedy

3. **Not testing counterexamples**
   - ‚ùå Assume greedy works
   - ‚úÖ Test with 2-3 small examples

4. **Wrong sorting criterion**
   - ‚ùå Always sort by first element
   - ‚úÖ Think about what property to prioritize

---

## üìù Practice Problems (by Recognition Category)

### Interval (Easy to spot)
- [ ] [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)
- [ ] [Merge Intervals](https://leetcode.com/problems/merge-intervals/)
- [ ] [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)

### Jump/Traversal (Medium to spot)
- [ ] [Jump Game](https://leetcode.com/problems/jump-game/)
- [ ] [Jump Game II](https://leetcode.com/problems/jump-game-ii/)
- [ ] [Gas Station](https://leetcode.com/problems/gas-station/)

### Assignment (Clear pattern)
- [ ] [Assign Cookies](https://leetcode.com/problems/assign-cookies/)
- [ ] [Two City Scheduling](https://leetcode.com/problems/two-city-scheduling/)

### Two-Pass (Special technique)
- [ ] [Candy](https://leetcode.com/problems/candy/)
- [ ] [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/) (can be greedy)

### NOT Greedy (Learn to avoid)
- [ ] [Coin Change](https://leetcode.com/problems/coin-change/) - Use DP
- [ ] [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/) - Use DP

<details>
<summary><strong>üß† Spaced Repetition Schedule</strong></summary>

**Interval recognition:**
- Day 1: Solve 2 interval problems
- Day 3: Without looking, classify 5 problem descriptions
- Day 7: Solve unfamiliar interval problem

**Jump recognition:**
- Day 1: Solve Jump Game I and II
- Day 3: Explain difference to someone
- Day 7: Solve Gas Station

**Assignment recognition:**
- Day 1: Solve Assign Cookies
- Day 3: Solve Two City Scheduling
- Day 7: Find and solve similar problem

</details>

---

## üé§ Interview Context

<details>
<summary><strong>Recognition Communication Strategy</strong></summary>

**When unsure if problem is greedy:**

```
"Looking at this problem, I see a few signals:
1. We're trying to maximize/minimize something
2. It involves intervals/sequential choices
3. After sorting, the solution might be straightforward

Let me verify with a small example... [traces through]

Yes, the greedy choice seems to work. If I found a 
counterexample, I'd switch to DP, but this looks good."
```

**When problem is NOT greedy:**

```
"This looks like it might be greedy at first because 
we're minimizing coins. But let me test with [1,3,4], 
target 6...

Greedy gives 4+1+1=3 coins, but 3+3=2 coins is better.

So greedy doesn't work here. I'll use DP instead."
```

</details>

---

## ‚è±Ô∏è Time Estimates

| Activity | Time |
|----------|------|
| Read problem and identify keywords | 30 sec |
| Classify problem type | 30 sec |
| Verify with small example | 1-2 min |
| Decide greedy vs DP | 30 sec |
| **Total recognition** | **2-3 min** |

---

> **üí° Key Insight:** Recognition is about pattern matching. Train on enough problems, and you'll "see" greedy problems instantly. The more problems you solve, the faster recognition becomes.

> **üîó Related:** [Problem-Solving Framework](./3.0-Greedy-Problem-Solving-Framework.md) | [Greedy vs DP](./1.3-Greedy-vs-DP.md) | [When Greedy Works](./1.2-When-Greedy-Works.md)
